<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: Numerical Algorithms</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__NumericalAlgorithmsGroup.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Numerical Algorithms</div></div>
</div><!--header-->
<div class="contents">

<p>Generic numerical algorithms.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceintegration"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceintegration.html">integration</a></td></tr>
<tr class="memdesc:namespaceintegration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerical integration algorithms. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceOdeIntegration"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOdeIntegration.html">OdeIntegration</a></td></tr>
<tr class="memdesc:namespaceOdeIntegration"><td class="mdescLeft">&#160;</td><td class="mdescRight">For ODE integration, we suggest using the boost libraries whenever possible. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRootFinder_1_1StoppingConditions"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRootFinder_1_1StoppingConditions.html">RootFinder::StoppingConditions</a></td></tr>
<tr class="memdesc:namespaceRootFinder_1_1StoppingConditions"><td class="mdescLeft">&#160;</td><td class="mdescRight">The different options for the convergence criterion of gsl_multiroot. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceintrp"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceintrp.html">intrp</a></td></tr>
<tr class="memdesc:namespaceintrp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains classes and functions for interpolation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceintrp_1_1callbacks"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceintrp_1_1callbacks.html">intrp::callbacks</a></td></tr>
<tr class="memdesc:namespaceintrp_1_1callbacks"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains callback functions called by <code><a class="el" href="structintrp_1_1InterpolationTarget.html" title="ParallelComponent representing a set of points to be interpolated to and a function to call upon inte...">InterpolationTarget</a></code>s. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintrp_1_1BarycentricRational.html">intrp::BarycentricRational</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A barycentric rational interpolation class.  <a href="classintrp_1_1BarycentricRational.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintrp_1_1CubicSpline.html">intrp::CubicSpline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A natural cubic spline interpolation class.  <a href="classintrp_1_1CubicSpline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintrp_1_1Irregular.html">intrp::Irregular&lt; Dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates a <code>Variables</code> onto an arbitrary set of points.  <a href="classintrp_1_1Irregular.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintrp_1_1LinearLeastSquares.html">intrp::LinearLeastSquares&lt; Order &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear least squares solver class.  <a href="classintrp_1_1LinearLeastSquares.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintrp_1_1RegularGrid.html">intrp::RegularGrid&lt; Dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate data from a <a class="el" href="classMesh.html" title="Holds the number of grid points, basis, and quadrature in each direction of the computational grid.">Mesh</a> onto a regular grid of points.  <a href="classintrp_1_1RegularGrid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintrp_1_1ZeroCrossingPredictor.html">intrp::ZeroCrossingPredictor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that predicts when a function crosses zero.  <a href="classintrp_1_1ZeroCrossingPredictor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga2bdd099599c989714bd6497401452624"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga2bdd099599c989714bd6497401452624">RootFinder::Method</a> { <a class="el" href="group__NumericalAlgorithmsGroup.html#gga2bdd099599c989714bd6497401452624aa3b07eb68ca39eb0b75ca59169f650d7">Method::Hybrids</a>
, <a class="el" href="group__NumericalAlgorithmsGroup.html#gga2bdd099599c989714bd6497401452624afb1b6e23a3767d2a31ef7899e6dd3f1e">Method::Hybrid</a>
, <a class="el" href="group__NumericalAlgorithmsGroup.html#gga2bdd099599c989714bd6497401452624a1c8b97c83b0726216cd5dbc88a64b0ed">Method::Newton</a>
 }</td></tr>
<tr class="memdesc:ga2bdd099599c989714bd6497401452624"><td class="mdescLeft">&#160;</td><td class="mdescRight">The different options for the rootfinding method of gsl_multiroot.  <a href="group__NumericalAlgorithmsGroup.html#ga2bdd099599c989714bd6497401452624">More...</a><br /></td></tr>
<tr class="separator:ga2bdd099599c989714bd6497401452624"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab165e76ec8f9e5927349a12c8fc8607a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab165e76ec8f9e5927349a12c8fc8607a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#gab165e76ec8f9e5927349a12c8fc8607a">raw_transpose</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; T * &gt; result, const T *const data, const size_t chunk_size, const size_t number_of_chunks)</td></tr>
<tr class="memdesc:gab165e76ec8f9e5927349a12c8fc8607a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute transposed data.  <a href="group__NumericalAlgorithmsGroup.html#gab165e76ec8f9e5927349a12c8fc8607a">More...</a><br /></td></tr>
<tr class="separator:gab165e76ec8f9e5927349a12c8fc8607a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa09845b42e4ab196189f52146264d102"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa09845b42e4ab196189f52146264d102"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structintrp_1_1LinearRegressionResult.html">LinearRegressionResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#gaa09845b42e4ab196189f52146264d102">intrp::linear_regression</a> (const T &amp;x_values, const T &amp;y_values)</td></tr>
<tr class="memdesc:gaa09845b42e4ab196189f52146264d102"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear regression function.  <a href="group__NumericalAlgorithmsGroup.html#gaa09845b42e4ab196189f52146264d102">More...</a><br /></td></tr>
<tr class="separator:gaa09845b42e4ab196189f52146264d102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga317c58dd34eb1a1a8d53153cea6741d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga317c58dd34eb1a1a8d53153cea6741d9">find_generalized_eigenvalues</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt; eigenvalues_real_part, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt; eigenvalues_imaginary_part, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classMatrix.html">Matrix</a> * &gt; eigenvectors, <a class="el" href="classMatrix.html">Matrix</a> matrix_a, <a class="el" href="classMatrix.html">Matrix</a> matrix_b)</td></tr>
<tr class="memdesc:ga317c58dd34eb1a1a8d53153cea6741d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the generalized eigenvalue problem for two matrices.  <a href="group__NumericalAlgorithmsGroup.html#ga317c58dd34eb1a1a8d53153cea6741d9">More...</a><br /></td></tr>
<tr class="separator:ga317c58dd34eb1a1a8d53153cea6741d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31da225dde202f8e08b7106ebadc2170"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ga31da225dde202f8e08b7106ebadc2170"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga31da225dde202f8e08b7106ebadc2170">definite_integral</a> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;integrand, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga31da225dde202f8e08b7106ebadc2170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the definite integral of a function over a manifold.  <a href="group__NumericalAlgorithmsGroup.html#ga31da225dde202f8e08b7106ebadc2170">More...</a><br /></td></tr>
<tr class="separator:ga31da225dde202f8e08b7106ebadc2170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c26f2543e383e45bd418d8f82917879"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ga5c26f2543e383e45bd418d8f82917879"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga5c26f2543e383e45bd418d8f82917879">mean_value</a> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;f, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga5c26f2543e383e45bd418d8f82917879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the mean value of a function over a manifold.  <a href="group__NumericalAlgorithmsGroup.html#ga5c26f2543e383e45bd418d8f82917879">More...</a><br /></td></tr>
<tr class="separator:ga5c26f2543e383e45bd418d8f82917879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0fb506cacdbda9491794de0060a61f0"><td class="memTemplParams" colspan="2">template&lt;typename... FluxTags, size_t Dim&gt; </td></tr>
<tr class="memitem:gae0fb506cacdbda9491794de0060a61f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#gae0fb506cacdbda9491794de0060a61f0">weak_divergence</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; tmpl::list&lt; <a class="el" href="structTags_1_1div.html">Tags::div</a>&lt; FluxTags &gt;... &gt; &gt; * &gt; divergence_of_fluxes, const Variables&lt; tmpl::list&lt; FluxTags... &gt; &gt; &amp;fluxes, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh, const InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &amp;det_jac_times_inverse_jacobian)</td></tr>
<tr class="memdesc:gae0fb506cacdbda9491794de0060a61f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the weak form divergence of fluxes.  <a href="group__NumericalAlgorithmsGroup.html#gae0fb506cacdbda9491794de0060a61f0">More...</a><br /></td></tr>
<tr class="separator:gae0fb506cacdbda9491794de0060a61f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8421b9149d2a3dac8a3d90b28ae2a569"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga8421b9149d2a3dac8a3d90b28ae2a569">RootFinder::newton_raphson</a> ()=delete</td></tr>
<tr class="separator:ga8421b9149d2a3dac8a3d90b28ae2a569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga198dcd46579bcb2545eb2861c0b97ab0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga198dcd46579bcb2545eb2861c0b97ab0">positive_root</a> (double a, double b, double c)</td></tr>
<tr class="memdesc:ga198dcd46579bcb2545eb2861c0b97ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the positive root of a quadratic equation \(ax^2 + bx + c = 0\).  <a href="group__NumericalAlgorithmsGroup.html#ga198dcd46579bcb2545eb2861c0b97ab0">More...</a><br /></td></tr>
<tr class="separator:ga198dcd46579bcb2545eb2861c0b97ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85e08ea84b3af6cc66afd2333b940ea3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga85e08ea84b3af6cc66afd2333b940ea3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga85e08ea84b3af6cc66afd2333b940ea3">smallest_root_greater_than_value_within_roundoff</a> (const T &amp;a, const T &amp;b, const T &amp;c, double <a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">value</a>)</td></tr>
<tr class="memdesc:ga85e08ea84b3af6cc66afd2333b940ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest root of a quadratic equation \(ax^2 + bx + c = 0\) that is greater than the given value, within roundoff.  <a href="group__NumericalAlgorithmsGroup.html#ga85e08ea84b3af6cc66afd2333b940ea3">More...</a><br /></td></tr>
<tr class="separator:ga85e08ea84b3af6cc66afd2333b940ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee3c1f31ffa436392b62d55e2b9d4f7c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaee3c1f31ffa436392b62d55e2b9d4f7c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#gaee3c1f31ffa436392b62d55e2b9d4f7c">largest_root_between_values_within_roundoff</a> (const T &amp;a, const T &amp;b, const T &amp;c, double min_value, double max_value)</td></tr>
<tr class="memdesc:gaee3c1f31ffa436392b62d55e2b9d4f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest root of a quadratic equation \(ax^2 + bx + c = 0\) that is between min_value and max_value, within roundoff.  <a href="group__NumericalAlgorithmsGroup.html#gaee3c1f31ffa436392b62d55e2b9d4f7c">More...</a><br /></td></tr>
<tr class="separator:gaee3c1f31ffa436392b62d55e2b9d4f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb295cc397c661be55b52d2cd023b3a4"><td class="memItemLeft" align="right" valign="top"><a id="gafb295cc397c661be55b52d2cd023b3a4" name="gafb295cc397c661be55b52d2cd023b3a4"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>real_roots</b> (double a, double b, double c)</td></tr>
<tr class="memdesc:gafb295cc397c661be55b52d2cd023b3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the two real roots of a quadratic equation \(ax^2 + bx + c = 0\) with the root closer to \(-\infty\) first, or an empty optional if there are no real roots. <br /></td></tr>
<tr class="separator:gafb295cc397c661be55b52d2cd023b3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f255af75bf51be43bc50fac2ef94764"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:ga4f255af75bf51be43bc50fac2ef94764"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga4f255af75bf51be43bc50fac2ef94764">RootFinder::bracket_possibly_undefined_function_in_interval</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; double * &gt; lower_bound, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; double * &gt; upper_bound, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; double * &gt; f_at_lower_bound, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; double * &gt; f_at_upper_bound, const Functor &amp;f, const double guess)</td></tr>
<tr class="memdesc:ga4f255af75bf51be43bc50fac2ef94764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Brackets the root of the function <code>f</code>, assuming a single root in a given interval \(f[x_\mathrm{lo},x_\mathrm{up}]\) and assuming that <code>f</code> is defined only in an unknown smaller interval \(f[x_a,x_b]\) where \(x_\mathrm{lo} \leq x_a \leq x_b \leq x_\mathrm{hi}\).  <a href="group__NumericalAlgorithmsGroup.html#ga4f255af75bf51be43bc50fac2ef94764">More...</a><br /></td></tr>
<tr class="separator:ga4f255af75bf51be43bc50fac2ef94764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72a74d62622a851dfb580f81a84a09aa"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:ga72a74d62622a851dfb580f81a84a09aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga72a74d62622a851dfb580f81a84a09aa">RootFinder::bracket_possibly_undefined_function_in_interval</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt; lower_bound, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt; upper_bound, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt; f_at_lower_bound, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt; f_at_upper_bound, const Functor &amp;f, const <a class="el" href="classDataVector.html">DataVector</a> &amp;guess)</td></tr>
<tr class="memdesc:ga72a74d62622a851dfb580f81a84a09aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Brackets the single root of the function <code>f</code> for each element in a <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code>, assuming the root lies in the given interval and that <code>f</code> may be undefined at some points in the interval.  <a href="group__NumericalAlgorithmsGroup.html#ga72a74d62622a851dfb580f81a84a09aa">More...</a><br /></td></tr>
<tr class="separator:ga72a74d62622a851dfb580f81a84a09aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad0c6223fdc3a8a5f4501c88d9a74abc"><td class="memTemplParams" colspan="2">template&lt;typename Function &gt; </td></tr>
<tr class="memitem:gaad0c6223fdc3a8a5f4501c88d9a74abc"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#gaad0c6223fdc3a8a5f4501c88d9a74abc">RootFinder::toms748</a> (const Function &amp;f, const double lower_bound, const double upper_bound, const double f_at_lower_bound, const double f_at_upper_bound, const double absolute_tolerance, const double relative_tolerance, const size_t max_iterations=100)</td></tr>
<tr class="memdesc:gaad0c6223fdc3a8a5f4501c88d9a74abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the root of the function <code>f</code> with the TOMS_748 method.  <a href="group__NumericalAlgorithmsGroup.html#gaad0c6223fdc3a8a5f4501c88d9a74abc">More...</a><br /></td></tr>
<tr class="separator:gaad0c6223fdc3a8a5f4501c88d9a74abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf05de5dac1ec3c418a1aa0809a8c58a"><td class="memTemplParams" colspan="2"><a id="gabf05de5dac1ec3c418a1aa0809a8c58a" name="gabf05de5dac1ec3c418a1aa0809a8c58a"></a>
template&lt;typename Function &gt; </td></tr>
<tr class="memitem:gabf05de5dac1ec3c418a1aa0809a8c58a"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RootFinder::toms748</b> (const Function &amp;f, const double lower_bound, const double upper_bound, const double absolute_tolerance, const double relative_tolerance, const size_t max_iterations=100)</td></tr>
<tr class="memdesc:gabf05de5dac1ec3c418a1aa0809a8c58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the root of the function <code>f</code> with the TOMS_748 method, where function values are not supplied at the lower and upper bounds. <br /></td></tr>
<tr class="separator:gabf05de5dac1ec3c418a1aa0809a8c58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e775caa5df400a744eb77c8c6e82a41"><td class="memTemplParams" colspan="2">template&lt;typename Function &gt; </td></tr>
<tr class="memitem:ga0e775caa5df400a744eb77c8c6e82a41"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDataVector.html">DataVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga0e775caa5df400a744eb77c8c6e82a41">RootFinder::toms748</a> (const Function &amp;f, const <a class="el" href="classDataVector.html">DataVector</a> &amp;lower_bound, const <a class="el" href="classDataVector.html">DataVector</a> &amp;upper_bound, const double absolute_tolerance, const double relative_tolerance, const size_t max_iterations=100)</td></tr>
<tr class="memdesc:ga0e775caa5df400a744eb77c8c6e82a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the root of the function <code>f</code> with the TOMS_748 method on each element in a <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code>.  <a href="group__NumericalAlgorithmsGroup.html#ga0e775caa5df400a744eb77c8c6e82a41">More...</a><br /></td></tr>
<tr class="separator:ga0e775caa5df400a744eb77c8c6e82a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cc85680ebf5d265cc65994dcf6365ee"><td class="memTemplParams" colspan="2">template&lt;typename Function &gt; </td></tr>
<tr class="memitem:ga2cc85680ebf5d265cc65994dcf6365ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDataVector.html">DataVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga2cc85680ebf5d265cc65994dcf6365ee">RootFinder::toms748</a> (const Function &amp;f, const <a class="el" href="classDataVector.html">DataVector</a> &amp;lower_bound, const <a class="el" href="classDataVector.html">DataVector</a> &amp;upper_bound, const <a class="el" href="classDataVector.html">DataVector</a> &amp;f_at_lower_bound, const <a class="el" href="classDataVector.html">DataVector</a> &amp;f_at_upper_bound, const double absolute_tolerance, const double relative_tolerance, const size_t max_iterations=100)</td></tr>
<tr class="memdesc:ga2cc85680ebf5d265cc65994dcf6365ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the root of the function <code>f</code> with the TOMS_748 method on each element in a <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code>, where function values are supplied at the lower and upper bounds.  <a href="group__NumericalAlgorithmsGroup.html#ga2cc85680ebf5d265cc65994dcf6365ee">More...</a><br /></td></tr>
<tr class="separator:ga2cc85680ebf5d265cc65994dcf6365ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c5b59cfd5032328d5d029f34778b10a"><td class="memTemplParams" colspan="2">template&lt;typename VariableTags , typename MatrixType , size_t Dim&gt; </td></tr>
<tr class="memitem:ga4c5b59cfd5032328d5d029f34778b10a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga4c5b59cfd5032328d5d029f34778b10a">apply_matrices</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; VariableTags &gt; * &gt; result, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; MatrixType, Dim &gt; &amp;matrices, const Variables&lt; VariableTags &gt; &amp;u, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;extents)</td></tr>
<tr class="memdesc:ga4c5b59cfd5032328d5d029f34778b10a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply by matrices in each dimension.  <a href="group__NumericalAlgorithmsGroup.html#ga4c5b59cfd5032328d5d029f34778b10a">More...</a><br /></td></tr>
<tr class="separator:ga4c5b59cfd5032328d5d029f34778b10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb2b8becf12ac9d423f82a2f1863191e"><td class="memTemplParams" colspan="2">template&lt;typename VariableTags , typename MatrixType , size_t Dim&gt; </td></tr>
<tr class="memitem:gadb2b8becf12ac9d423f82a2f1863191e"><td class="memTemplItemLeft" align="right" valign="top">Variables&lt; VariableTags &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#gadb2b8becf12ac9d423f82a2f1863191e">apply_matrices</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; MatrixType, Dim &gt; &amp;matrices, const Variables&lt; VariableTags &gt; &amp;u, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;extents)</td></tr>
<tr class="memdesc:gadb2b8becf12ac9d423f82a2f1863191e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply by matrices in each dimension.  <a href="group__NumericalAlgorithmsGroup.html#gadb2b8becf12ac9d423f82a2f1863191e">More...</a><br /></td></tr>
<tr class="separator:gadb2b8becf12ac9d423f82a2f1863191e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga845359e41677da4ae67558beb5cd1388"><td class="memTemplParams" colspan="2">template&lt;typename ResultType , typename MatrixType , typename VectorType , size_t Dim&gt; </td></tr>
<tr class="memitem:ga845359e41677da4ae67558beb5cd1388"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga845359e41677da4ae67558beb5cd1388">apply_matrices</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; ResultType * &gt; result, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; MatrixType, Dim &gt; &amp;matrices, const VectorType &amp;u, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;extents)</td></tr>
<tr class="memdesc:ga845359e41677da4ae67558beb5cd1388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply by matrices in each dimension.  <a href="group__NumericalAlgorithmsGroup.html#ga845359e41677da4ae67558beb5cd1388">More...</a><br /></td></tr>
<tr class="separator:ga845359e41677da4ae67558beb5cd1388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3098b0daf1550ed5a14b051ac15d506"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType , size_t Dim&gt; </td></tr>
<tr class="memitem:gad3098b0daf1550ed5a14b051ac15d506"><td class="memTemplItemLeft" align="right" valign="top">VectorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#gad3098b0daf1550ed5a14b051ac15d506">apply_matrices</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; MatrixType, Dim &gt; &amp;matrices, const VectorType &amp;u, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;extents)</td></tr>
<tr class="memdesc:gad3098b0daf1550ed5a14b051ac15d506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply by matrices in each dimension.  <a href="group__NumericalAlgorithmsGroup.html#gad3098b0daf1550ed5a14b051ac15d506">More...</a><br /></td></tr>
<tr class="separator:gad3098b0daf1550ed5a14b051ac15d506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa00d597fd99adcab5ef893992c24c007"><td class="memTemplParams" colspan="2">template&lt;typename ResultType , typename MatrixType , typename VectorType , size_t Dim&gt; </td></tr>
<tr class="memitem:gaa00d597fd99adcab5ef893992c24c007"><td class="memTemplItemLeft" align="right" valign="top">ResultType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#gaa00d597fd99adcab5ef893992c24c007">apply_matrices</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; MatrixType, Dim &gt; &amp;matrices, const VectorType &amp;u, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;extents)</td></tr>
<tr class="memdesc:gaa00d597fd99adcab5ef893992c24c007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply by matrices in each dimension.  <a href="group__NumericalAlgorithmsGroup.html#gaa00d597fd99adcab5ef893992c24c007">More...</a><br /></td></tr>
<tr class="separator:gaa00d597fd99adcab5ef893992c24c007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d755157e0d42f3fdae8dace311c1588"><td class="memTemplParams" colspan="2">template&lt;typename U , typename T &gt; </td></tr>
<tr class="memitem:ga9d755157e0d42f3fdae8dace311c1588"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga9d755157e0d42f3fdae8dace311c1588">transpose</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; T * &gt; result, const U &amp;u, const size_t chunk_size, const size_t number_of_chunks)</td></tr>
<tr class="memdesc:ga9d755157e0d42f3fdae8dace311c1588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute transposed data.  <a href="group__NumericalAlgorithmsGroup.html#ga9d755157e0d42f3fdae8dace311c1588">More...</a><br /></td></tr>
<tr class="separator:ga9d755157e0d42f3fdae8dace311c1588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab66a7469bcf39a26f2c69a3689c0c46f"><td class="memTemplParams" colspan="2">template&lt;typename U , typename T  = U&gt; </td></tr>
<tr class="memitem:gab66a7469bcf39a26f2c69a3689c0c46f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#gab66a7469bcf39a26f2c69a3689c0c46f">transpose</a> (const U &amp;u, const size_t chunk_size, const size_t number_of_chunks)</td></tr>
<tr class="memdesc:gab66a7469bcf39a26f2c69a3689c0c46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute transposed data.  <a href="group__NumericalAlgorithmsGroup.html#gab66a7469bcf39a26f2c69a3689c0c46f">More...</a><br /></td></tr>
<tr class="separator:gab66a7469bcf39a26f2c69a3689c0c46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f1c6629c05b797ff57caba93777e223"><td class="memTemplParams" colspan="2"><a id="ga8f1c6629c05b797ff57caba93777e223" name="ga8f1c6629c05b797ff57caba93777e223"></a>
template&lt;typename FluxTags , size_t Dim, typename DerivativeFrame &gt; </td></tr>
<tr class="memitem:ga8f1c6629c05b797ff57caba93777e223"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>divergence</b> (const Variables&lt; FluxTags &gt; &amp;F, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh, const InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, DerivativeFrame &gt; &amp;inverse_jacobian) -&gt; Variables&lt; <a class="el" href="group__DataBoxTagsGroup.html#ga3dda5a16c7f6baccd115de2c8f12394e">db::wrap_tags_in</a>&lt; <a class="el" href="structTags_1_1div.html">Tags::div</a>, FluxTags &gt; &gt;</td></tr>
<tr class="memdesc:ga8f1c6629c05b797ff57caba93777e223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the (Euclidean) divergence of fluxes. <br /></td></tr>
<tr class="separator:ga8f1c6629c05b797ff57caba93777e223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc87dc0d22e6bdb9cb1b82186af3a76b"><td class="memTemplParams" colspan="2"><a id="gacc87dc0d22e6bdb9cb1b82186af3a76b" name="gacc87dc0d22e6bdb9cb1b82186af3a76b"></a>
template&lt;typename... DivTags, typename... FluxTags, size_t Dim, typename DerivativeFrame &gt; </td></tr>
<tr class="memitem:gacc87dc0d22e6bdb9cb1b82186af3a76b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>divergence</b> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; tmpl::list&lt; DivTags... &gt; &gt; * &gt; divergence_of_F, const Variables&lt; tmpl::list&lt; FluxTags... &gt; &gt; &amp;F, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh, const InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, DerivativeFrame &gt; &amp;inverse_jacobian)</td></tr>
<tr class="memdesc:gacc87dc0d22e6bdb9cb1b82186af3a76b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the (Euclidean) divergence of fluxes. <br /></td></tr>
<tr class="separator:gacc87dc0d22e6bdb9cb1b82186af3a76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0fa62b90b4136c8b533b7e569fe187b"><td class="memTemplParams" colspan="2"><a id="gab0fa62b90b4136c8b533b7e569fe187b" name="gab0fa62b90b4136c8b533b7e569fe187b"></a>
template&lt;size_t Dim, typename DerivativeFrame &gt; </td></tr>
<tr class="memitem:gab0fa62b90b4136c8b533b7e569fe187b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>divergence</b> (const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, DerivativeFrame &gt; &amp;input, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh, const InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, DerivativeFrame &gt; &amp;inverse_jacobian)</td></tr>
<tr class="memdesc:gab0fa62b90b4136c8b533b7e569fe187b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the divergence of the vector <code>input</code> <br /></td></tr>
<tr class="separator:gab0fa62b90b4136c8b533b7e569fe187b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e9c62f904f39f5ffcb188574322e585"><td class="memTemplParams" colspan="2"><a id="ga7e9c62f904f39f5ffcb188574322e585" name="ga7e9c62f904f39f5ffcb188574322e585"></a>
template&lt;size_t Dim, typename DerivativeFrame &gt; </td></tr>
<tr class="memitem:ga7e9c62f904f39f5ffcb188574322e585"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>divergence</b> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt; div_input, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, DerivativeFrame &gt; &amp;input, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh, const InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, DerivativeFrame &gt; &amp;inverse_jacobian)</td></tr>
<tr class="memdesc:ga7e9c62f904f39f5ffcb188574322e585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the divergence of the vector <code>input</code> <br /></td></tr>
<tr class="separator:ga7e9c62f904f39f5ffcb188574322e585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f00d2ce9b2e232d6bad87dd6c4d7c85"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename VectorType &gt; </td></tr>
<tr class="memitem:ga9f00d2ce9b2e232d6bad87dd6c4d7c85"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga9f00d2ce9b2e232d6bad87dd6c4d7c85">indefinite_integral</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; VectorType * &gt; integral, const VectorType &amp;integrand, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh, size_t dim_to_integrate)</td></tr>
<tr class="memdesc:ga9f00d2ce9b2e232d6bad87dd6c4d7c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the indefinite integral of a function in the <code>dim_to_integrate</code>, applying a zero boundary condition on each stripe.  <a href="group__NumericalAlgorithmsGroup.html#ga9f00d2ce9b2e232d6bad87dd6c4d7c85">More...</a><br /></td></tr>
<tr class="separator:ga9f00d2ce9b2e232d6bad87dd6c4d7c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0decf26e777ccc2299de0f563e7e0dbc"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename VectorType &gt; </td></tr>
<tr class="memitem:ga0decf26e777ccc2299de0f563e7e0dbc"><td class="memTemplItemLeft" align="right" valign="top">VectorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga0decf26e777ccc2299de0f563e7e0dbc">indefinite_integral</a> (const VectorType &amp;integrand, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh, size_t dim_to_integrate)</td></tr>
<tr class="memdesc:ga0decf26e777ccc2299de0f563e7e0dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the indefinite integral of a function in the <code>dim_to_integrate</code>, applying a zero boundary condition on each stripe.  <a href="group__NumericalAlgorithmsGroup.html#ga0decf26e777ccc2299de0f563e7e0dbc">More...</a><br /></td></tr>
<tr class="separator:ga0decf26e777ccc2299de0f563e7e0dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b54b59f18279d4a062dc4abb1feb2cd"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ga2b54b59f18279d4a062dc4abb1feb2cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga2b54b59f18279d4a062dc4abb1feb2cd">linearize</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt; result, const <a class="el" href="classDataVector.html">DataVector</a> &amp;u, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga2b54b59f18279d4a062dc4abb1feb2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate u to a linear function in each dimension.  <a href="group__NumericalAlgorithmsGroup.html#ga2b54b59f18279d4a062dc4abb1feb2cd">More...</a><br /></td></tr>
<tr class="separator:ga2b54b59f18279d4a062dc4abb1feb2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21beb26abe3c25180788b2c8ce939b39"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ga21beb26abe3c25180788b2c8ce939b39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDataVector.html">DataVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga21beb26abe3c25180788b2c8ce939b39">linearize</a> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;u, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga21beb26abe3c25180788b2c8ce939b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate u to a linear function in each dimension.  <a href="group__NumericalAlgorithmsGroup.html#ga21beb26abe3c25180788b2c8ce939b39">More...</a><br /></td></tr>
<tr class="separator:ga21beb26abe3c25180788b2c8ce939b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04ba0a473561e003758f2a6036339e5e"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ga04ba0a473561e003758f2a6036339e5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga04ba0a473561e003758f2a6036339e5e">linearize</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt; result, const <a class="el" href="classDataVector.html">DataVector</a> &amp;u, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh, size_t d)</td></tr>
<tr class="memdesc:ga04ba0a473561e003758f2a6036339e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate u to a linear function in the given dimension.  <a href="group__NumericalAlgorithmsGroup.html#ga04ba0a473561e003758f2a6036339e5e">More...</a><br /></td></tr>
<tr class="separator:ga04ba0a473561e003758f2a6036339e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4519e09fd8a878ff52edad38439b5f44"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ga4519e09fd8a878ff52edad38439b5f44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDataVector.html">DataVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga4519e09fd8a878ff52edad38439b5f44">linearize</a> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;u, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh, size_t d)</td></tr>
<tr class="memdesc:ga4519e09fd8a878ff52edad38439b5f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate u to a linear function in the given dimension.  <a href="group__NumericalAlgorithmsGroup.html#ga4519e09fd8a878ff52edad38439b5f44">More...</a><br /></td></tr>
<tr class="separator:ga4519e09fd8a878ff52edad38439b5f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6d6f1876cc09fac52091acb154f752a"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:gad6d6f1876cc09fac52091acb154f752a"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#gad6d6f1876cc09fac52091acb154f752a">mean_value_on_boundary</a> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;f, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh, size_t d, <a class="el" href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">Side</a> side)</td></tr>
<tr class="memdesc:gad6d6f1876cc09fac52091acb154f752a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the mean value of a function over a boundary of a manifold.  <a href="group__NumericalAlgorithmsGroup.html#gad6d6f1876cc09fac52091acb154f752a">More...</a><br /></td></tr>
<tr class="separator:gad6d6f1876cc09fac52091acb154f752a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87663e8ca1d53121aefa98077cd8f34e"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ga87663e8ca1d53121aefa98077cd8f34e"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga87663e8ca1d53121aefa98077cd8f34e">mean_value_on_boundary</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt; boundary_buffer, const <a class="el" href="classDataVector.html">DataVector</a> &amp;f, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh, size_t d, <a class="el" href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">Side</a> side)</td></tr>
<tr class="memdesc:ga87663e8ca1d53121aefa98077cd8f34e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the mean value of a function over a boundary of a manifold.  <a href="group__NumericalAlgorithmsGroup.html#ga87663e8ca1d53121aefa98077cd8f34e">More...</a><br /></td></tr>
<tr class="separator:ga87663e8ca1d53121aefa98077cd8f34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0825cdf0fc3ea76e32d7936d45af36a8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga0825cdf0fc3ea76e32d7936d45af36a8">mean_value_on_boundary</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt;, const <a class="el" href="classDataVector.html">DataVector</a> &amp;f, const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;mesh, size_t d, <a class="el" href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">Side</a> side)</td></tr>
<tr class="memdesc:ga0825cdf0fc3ea76e32d7936d45af36a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the mean value of a function over a boundary of a manifold.  <a href="group__NumericalAlgorithmsGroup.html#ga0825cdf0fc3ea76e32d7936d45af36a8">More...</a><br /></td></tr>
<tr class="separator:ga0825cdf0fc3ea76e32d7936d45af36a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88a958a9671db67b85f2388f4aef8eed"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ga88a958a9671db67b85f2388f4aef8eed"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga88a958a9671db67b85f2388f4aef8eed">mean_value_on_boundary</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt; boundary_buffer, <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; size_t, size_t &gt; &gt; <a class="el" href="group__DataStructuresGroup.html#ga5a7368947aff1d98ab0d939e3f80129c">volume_and_slice_indices</a>, const <a class="el" href="classDataVector.html">DataVector</a> &amp;f, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh, size_t d, <a class="el" href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">Side</a>)</td></tr>
<tr class="memdesc:ga88a958a9671db67b85f2388f4aef8eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the mean value of a function over a boundary of a manifold.  <a href="group__NumericalAlgorithmsGroup.html#ga88a958a9671db67b85f2388f4aef8eed">More...</a><br /></td></tr>
<tr class="separator:ga88a958a9671db67b85f2388f4aef8eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c6b26ca3290c3a3cbb231428fc33026"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga3c6b26ca3290c3a3cbb231428fc33026">mean_value_on_boundary</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt;, <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; size_t, size_t &gt; &gt;, const <a class="el" href="classDataVector.html">DataVector</a> &amp;f, const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;mesh, size_t d, <a class="el" href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">Side</a> side)</td></tr>
<tr class="memdesc:ga3c6b26ca3290c3a3cbb231428fc33026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the mean value of a function over a boundary of a manifold.  <a href="group__NumericalAlgorithmsGroup.html#ga3c6b26ca3290c3a3cbb231428fc33026">More...</a><br /></td></tr>
<tr class="separator:ga3c6b26ca3290c3a3cbb231428fc33026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaac1df3dc75d7963dd5f135a189b47b"><td class="memTemplParams" colspan="2">template&lt;typename DerivativeTags , typename VariableTags , size_t Dim&gt; </td></tr>
<tr class="memitem:gabaac1df3dc75d7963dd5f135a189b47b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#gabaac1df3dc75d7963dd5f135a189b47b">logical_partial_derivatives</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; Variables&lt; DerivativeTags &gt;, Dim &gt; * &gt; logical_partial_derivatives_of_u, const Variables&lt; VariableTags &gt; &amp;u, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh)</td></tr>
<tr class="memdesc:gabaac1df3dc75d7963dd5f135a189b47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the partial derivatives of each variable with respect to the element logical coordinate.  <a href="group__NumericalAlgorithmsGroup.html#gabaac1df3dc75d7963dd5f135a189b47b">More...</a><br /></td></tr>
<tr class="separator:gabaac1df3dc75d7963dd5f135a189b47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3151762c10e3202bb3f7d38e92e16cc9"><td class="memTemplParams" colspan="2">template&lt;typename DerivativeTags , typename VariableTags , size_t Dim&gt; </td></tr>
<tr class="memitem:ga3151762c10e3202bb3f7d38e92e16cc9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga3151762c10e3202bb3f7d38e92e16cc9">logical_partial_derivatives</a> (const Variables&lt; VariableTags &gt; &amp;u, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; Variables&lt; DerivativeTags &gt;, Dim &gt;</td></tr>
<tr class="memdesc:ga3151762c10e3202bb3f7d38e92e16cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the partial derivatives of each variable with respect to the element logical coordinate.  <a href="group__NumericalAlgorithmsGroup.html#ga3151762c10e3202bb3f7d38e92e16cc9">More...</a><br /></td></tr>
<tr class="separator:ga3151762c10e3202bb3f7d38e92e16cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac665845d5ed95426a3c45292300d2263"><td class="memTemplParams" colspan="2">template&lt;typename SymmList , typename IndexList , size_t Dim&gt; </td></tr>
<tr class="memitem:gac665845d5ed95426a3c45292300d2263"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#gac665845d5ed95426a3c45292300d2263">logical_partial_derivative</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga5e4aece332518b3a95c2a73557aaa596">TensorMetafunctions::prepend_spatial_index</a>&lt; Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, SymmList, IndexList &gt;, Dim, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; * &gt; logical_derivative_of_u, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt; * &gt; buffer, const Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, SymmList, IndexList &gt; &amp;u, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh)</td></tr>
<tr class="memdesc:gac665845d5ed95426a3c45292300d2263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the logical partial derivative of a tensor, prepending the spatial derivative index, e.g. for \(\partial_i T_{a}{}^{b}\) the C++ call is <code>get(i, a, b)</code>.  <a href="group__NumericalAlgorithmsGroup.html#gac665845d5ed95426a3c45292300d2263">More...</a><br /></td></tr>
<tr class="separator:gac665845d5ed95426a3c45292300d2263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b8251bd89867d734f756ce22af46eba"><td class="memTemplParams" colspan="2">template&lt;typename SymmList , typename IndexList , size_t Dim&gt; </td></tr>
<tr class="memitem:ga3b8251bd89867d734f756ce22af46eba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga3b8251bd89867d734f756ce22af46eba">logical_partial_derivative</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga5e4aece332518b3a95c2a73557aaa596">TensorMetafunctions::prepend_spatial_index</a>&lt; Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, SymmList, IndexList &gt;, Dim, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; * &gt; logical_derivative_of_u, const Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, SymmList, IndexList &gt; &amp;u, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga3b8251bd89867d734f756ce22af46eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the logical partial derivative of a tensor, prepending the spatial derivative index, e.g. for \(\partial_i T_{a}{}^{b}\) the C++ call is <code>get(i, a, b)</code>.  <a href="group__NumericalAlgorithmsGroup.html#ga3b8251bd89867d734f756ce22af46eba">More...</a><br /></td></tr>
<tr class="separator:ga3b8251bd89867d734f756ce22af46eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14eca4d56fb41f09ab3d9a0487f72eab"><td class="memTemplParams" colspan="2">template&lt;typename SymmList , typename IndexList , size_t Dim&gt; </td></tr>
<tr class="memitem:ga14eca4d56fb41f09ab3d9a0487f72eab"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga14eca4d56fb41f09ab3d9a0487f72eab">logical_partial_derivative</a> (const Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, SymmList, IndexList &gt; &amp;u, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh) -&gt; <a class="el" href="group__TensorGroup.html#ga5e4aece332518b3a95c2a73557aaa596">TensorMetafunctions::prepend_spatial_index</a>&lt; Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, SymmList, IndexList &gt;, Dim, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt;</td></tr>
<tr class="memdesc:ga14eca4d56fb41f09ab3d9a0487f72eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the logical partial derivative of a tensor, prepending the spatial derivative index, e.g. for \(\partial_i T_{a}{}^{b}\) the C++ call is <code>get(i, a, b)</code>.  <a href="group__NumericalAlgorithmsGroup.html#ga14eca4d56fb41f09ab3d9a0487f72eab">More...</a><br /></td></tr>
<tr class="separator:ga14eca4d56fb41f09ab3d9a0487f72eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80e0ee64b5928fa1f01993cfdf43f19b"><td class="memTemplParams" colspan="2">template&lt;typename DerivativeTags , size_t Dim, typename DerivativeFrame &gt; </td></tr>
<tr class="memitem:ga80e0ee64b5928fa1f01993cfdf43f19b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga80e0ee64b5928fa1f01993cfdf43f19b">partial_derivatives</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; <a class="el" href="group__DataBoxTagsGroup.html#ga3dda5a16c7f6baccd115de2c8f12394e">db::wrap_tags_in</a>&lt; <a class="el" href="structTags_1_1deriv.html">Tags::deriv</a>, DerivativeTags, tmpl::size_t&lt; Dim &gt;, DerivativeFrame &gt; &gt; * &gt; du, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; Variables&lt; DerivativeTags &gt;, Dim &gt; &amp;logical_partial_derivatives_of_u, const InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, DerivativeFrame &gt; &amp;inverse_jacobian)</td></tr>
<tr class="memdesc:ga80e0ee64b5928fa1f01993cfdf43f19b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the partial derivatives of each variable with respect to the coordinates of <code>DerivativeFrame</code>.  <a href="group__NumericalAlgorithmsGroup.html#ga80e0ee64b5928fa1f01993cfdf43f19b">More...</a><br /></td></tr>
<tr class="separator:ga80e0ee64b5928fa1f01993cfdf43f19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0854f07e422bb5bd3eae1896c3a152b"><td class="memTemplParams" colspan="2">template&lt;typename DerivativeTags , typename VariableTags , size_t Dim, typename DerivativeFrame &gt; </td></tr>
<tr class="memitem:gac0854f07e422bb5bd3eae1896c3a152b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#gac0854f07e422bb5bd3eae1896c3a152b">partial_derivatives</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; <a class="el" href="group__DataBoxTagsGroup.html#ga3dda5a16c7f6baccd115de2c8f12394e">db::wrap_tags_in</a>&lt; <a class="el" href="structTags_1_1deriv.html">Tags::deriv</a>, DerivativeTags, tmpl::size_t&lt; Dim &gt;, DerivativeFrame &gt; &gt; * &gt; du, const Variables&lt; VariableTags &gt; &amp;u, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh, const InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, DerivativeFrame &gt; &amp;inverse_jacobian)</td></tr>
<tr class="memdesc:gac0854f07e422bb5bd3eae1896c3a152b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the partial derivatives of each variable with respect to the coordinates of <code>DerivativeFrame</code>.  <a href="group__NumericalAlgorithmsGroup.html#gac0854f07e422bb5bd3eae1896c3a152b">More...</a><br /></td></tr>
<tr class="separator:gac0854f07e422bb5bd3eae1896c3a152b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad82f8581712392748d19da8737ecd576"><td class="memTemplParams" colspan="2">template&lt;typename DerivativeTags , typename VariableTags , size_t Dim, typename DerivativeFrame &gt; </td></tr>
<tr class="memitem:gad82f8581712392748d19da8737ecd576"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#gad82f8581712392748d19da8737ecd576">partial_derivatives</a> (const Variables&lt; VariableTags &gt; &amp;u, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh, const InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, DerivativeFrame &gt; &amp;inverse_jacobian) -&gt; Variables&lt; <a class="el" href="group__DataBoxTagsGroup.html#ga3dda5a16c7f6baccd115de2c8f12394e">db::wrap_tags_in</a>&lt; <a class="el" href="structTags_1_1deriv.html">Tags::deriv</a>, DerivativeTags, tmpl::size_t&lt; Dim &gt;, DerivativeFrame &gt; &gt;</td></tr>
<tr class="memdesc:gad82f8581712392748d19da8737ecd576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the partial derivatives of each variable with respect to the coordinates of <code>DerivativeFrame</code>.  <a href="group__NumericalAlgorithmsGroup.html#gad82f8581712392748d19da8737ecd576">More...</a><br /></td></tr>
<tr class="separator:gad82f8581712392748d19da8737ecd576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga325028716dca1a0ab2749abc4cd9132e"><td class="memTemplParams" colspan="2">template&lt;typename SymmList , typename IndexList , size_t Dim, typename DerivativeFrame &gt; </td></tr>
<tr class="memitem:ga325028716dca1a0ab2749abc4cd9132e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga325028716dca1a0ab2749abc4cd9132e">partial_derivative</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga5e4aece332518b3a95c2a73557aaa596">TensorMetafunctions::prepend_spatial_index</a>&lt; Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, SymmList, IndexList &gt;, Dim, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, DerivativeFrame &gt; * &gt; du, const <a class="el" href="group__TensorGroup.html#ga5e4aece332518b3a95c2a73557aaa596">TensorMetafunctions::prepend_spatial_index</a>&lt; Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, SymmList, IndexList &gt;, Dim, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; &amp;logical_partial_derivative_of_u, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh, const InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, DerivativeFrame &gt; &amp;inverse_jacobian)</td></tr>
<tr class="memdesc:ga325028716dca1a0ab2749abc4cd9132e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the partial derivative of a <code>Tensor</code> with respect to the coordinates of <code>DerivativeFrame</code>.  <a href="group__NumericalAlgorithmsGroup.html#ga325028716dca1a0ab2749abc4cd9132e">More...</a><br /></td></tr>
<tr class="separator:ga325028716dca1a0ab2749abc4cd9132e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ae152e90a5c97980839b0efd83d793b"><td class="memTemplParams" colspan="2">template&lt;typename SymmList , typename IndexList , size_t Dim, typename DerivativeFrame &gt; </td></tr>
<tr class="memitem:ga8ae152e90a5c97980839b0efd83d793b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga8ae152e90a5c97980839b0efd83d793b">partial_derivative</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga5e4aece332518b3a95c2a73557aaa596">TensorMetafunctions::prepend_spatial_index</a>&lt; Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, SymmList, IndexList &gt;, Dim, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, DerivativeFrame &gt; * &gt; du, const Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, SymmList, IndexList &gt; &amp;u, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh, const InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, DerivativeFrame &gt; &amp;inverse_jacobian)</td></tr>
<tr class="memdesc:ga8ae152e90a5c97980839b0efd83d793b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the partial derivative of a <code>Tensor</code> with respect to the coordinates of <code>DerivativeFrame</code>.  <a href="group__NumericalAlgorithmsGroup.html#ga8ae152e90a5c97980839b0efd83d793b">More...</a><br /></td></tr>
<tr class="separator:ga8ae152e90a5c97980839b0efd83d793b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2896a931cb783ddc738e13f1cd37d9d7"><td class="memTemplParams" colspan="2">template&lt;typename SymmList , typename IndexList , size_t Dim, typename DerivativeFrame &gt; </td></tr>
<tr class="memitem:ga2896a931cb783ddc738e13f1cd37d9d7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#ga2896a931cb783ddc738e13f1cd37d9d7">partial_derivative</a> (const Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, SymmList, IndexList &gt; &amp;u, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh, const InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, DerivativeFrame &gt; &amp;inverse_jacobian) -&gt; <a class="el" href="group__TensorGroup.html#ga5e4aece332518b3a95c2a73557aaa596">TensorMetafunctions::prepend_spatial_index</a>&lt; Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, SymmList, IndexList &gt;, Dim, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, DerivativeFrame &gt;</td></tr>
<tr class="memdesc:ga2896a931cb783ddc738e13f1cd37d9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the partial derivative of a <code>Tensor</code> with respect to the coordinates of <code>DerivativeFrame</code>.  <a href="group__NumericalAlgorithmsGroup.html#ga2896a931cb783ddc738e13f1cd37d9d7">More...</a><br /></td></tr>
<tr class="separator:ga2896a931cb783ddc738e13f1cd37d9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1898874039a432852e9e8bfdbbcea5d"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename Function , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; gsl_multiroot_detail::is_jacobian_callable_v&lt; Function, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, Dim &gt; &gt; &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:gac1898874039a432852e9e8bfdbbcea5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, Dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#gac1898874039a432852e9e8bfdbbcea5d">RootFinder::gsl_multiroot</a> (const Function &amp;func, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, Dim &gt; &amp;initial_guess, const <a class="el" href="structRootFinder_1_1StoppingCondition.html">StoppingCondition</a> &amp;condition, const size_t maximum_iterations, const <a class="el" href="group__LoggingGroup.html#gabf3be10d03894afb391f3a2935e3b313">Verbosity</a> verbosity=Verbosity::Silent, const double maximum_absolute_tolerance=0.0, const <a class="el" href="group__NumericalAlgorithmsGroup.html#ga2bdd099599c989714bd6497401452624">Method</a> method=<a class="el" href="group__NumericalAlgorithmsGroup.html#gga2bdd099599c989714bd6497401452624a1c8b97c83b0726216cd5dbc88a64b0ed">Method::Newton</a>)</td></tr>
<tr class="memdesc:gac1898874039a432852e9e8bfdbbcea5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multidimensional root finder supporting Newton and Hybrid methods, as well as modified methods based on these.  <a href="group__NumericalAlgorithmsGroup.html#gac1898874039a432852e9e8bfdbbcea5d">More...</a><br /></td></tr>
<tr class="separator:gac1898874039a432852e9e8bfdbbcea5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Generic numerical algorithms. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga2bdd099599c989714bd6497401452624" name="ga2bdd099599c989714bd6497401452624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bdd099599c989714bd6497401452624">&#9670;&nbsp;</a></span>Method</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="group__NumericalAlgorithmsGroup.html#ga2bdd099599c989714bd6497401452624">RootFinder::Method</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The different options for the rootfinding method of gsl_multiroot. </p>
<p >This enum is for setting the method used the rootfinder. The precise method used by the gsl rootfinder depends on whether or not the function passed to it has a callable <code>jacobian</code> member function. In the case where it doesn't, the jacobian is approximated with a finite difference. For example, if the Method specified is Hybrid, gsl will use the gsl_multiroot_fdfsolver_hybridj method in the case where a <code>jacobian</code> is provided, and gsl_multiroot_fsolver_hybrid in the case where one isn't. See <a href="https://www.gnu.org/software/gsl/manual/html_node/Multidimensional-Root_002dFinding.html">GSL's documentation for multidimensional rootfinding</a> for information on the different methods. </p><dl class="section note"><dt>Note</dt><dd>gsl does not provide a finite difference version for the modified Newton method (gsl_multiroot_fdfsolver_gnewton). In the case where a jacobian is not provided the method used will be a non-modified Newton method. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2bdd099599c989714bd6497401452624aa3b07eb68ca39eb0b75ca59169f650d7" name="gga2bdd099599c989714bd6497401452624aa3b07eb68ca39eb0b75ca59169f650d7"></a>Hybrids&#160;</td><td class="fielddoc"><p >Hybrid of Newton's method along with following the gradient direction. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2bdd099599c989714bd6497401452624afb1b6e23a3767d2a31ef7899e6dd3f1e" name="gga2bdd099599c989714bd6497401452624afb1b6e23a3767d2a31ef7899e6dd3f1e"></a>Hybrid&#160;</td><td class="fielddoc"><p >"Unscaled version of Hybrids that uses a spherical trust region," see GSL documentation for more details. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2bdd099599c989714bd6497401452624a1c8b97c83b0726216cd5dbc88a64b0ed" name="gga2bdd099599c989714bd6497401452624a1c8b97c83b0726216cd5dbc88a64b0ed"></a>Newton&#160;</td><td class="fielddoc"><p >If an analytic jacobian is provided, gsl uses a modification of Newton's method to improve global convergence. Uses vanilla Newton's method if no jacobian is provided. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga845359e41677da4ae67558beb5cd1388" name="ga845359e41677da4ae67558beb5cd1388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga845359e41677da4ae67558beb5cd1388">&#9670;&nbsp;</a></span>apply_matrices() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultType , typename MatrixType , typename VectorType , size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void apply_matrices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; ResultType * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; MatrixType, Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>extents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply by matrices in each dimension. </p>
<p >Multiplies each stripe in the first dimension of <code>u</code> by <code>matrices[0]</code>, each stripe in the second dimension of <code>u</code> by <code>matrices[1]</code>, and so on. If any of the matrices are empty they will be treated as the identity, but the matrix multiplications will be skipped for increased efficiency.</p>
<dl class="section note"><dt>Note</dt><dd>The element type stored in the vectors to be transformed may be either <code>double</code> or <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>&lt;double&gt;</code>. The matrix, however, must be real. In the case of acting on a vector of complex values, the matrix is treated as having zero imaginary part. This is chosen for efficiency in all use-cases for spectral matrix arithmetic so far encountered. </dd></dl>

</div>
</div>
<a id="ga4c5b59cfd5032328d5d029f34778b10a" name="ga4c5b59cfd5032328d5d029f34778b10a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c5b59cfd5032328d5d029f34778b10a">&#9670;&nbsp;</a></span>apply_matrices() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VariableTags , typename MatrixType , size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void apply_matrices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; VariableTags &gt; * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; MatrixType, Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Variables&lt; VariableTags &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>extents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply by matrices in each dimension. </p>
<p >Multiplies each stripe in the first dimension of <code>u</code> by <code>matrices[0]</code>, each stripe in the second dimension of <code>u</code> by <code>matrices[1]</code>, and so on. If any of the matrices are empty they will be treated as the identity, but the matrix multiplications will be skipped for increased efficiency.</p>
<dl class="section note"><dt>Note</dt><dd>The element type stored in the vectors to be transformed may be either <code>double</code> or <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>&lt;double&gt;</code>. The matrix, however, must be real. In the case of acting on a vector of complex values, the matrix is treated as having zero imaginary part. This is chosen for efficiency in all use-cases for spectral matrix arithmetic so far encountered. </dd></dl>

</div>
</div>
<a id="gadb2b8becf12ac9d423f82a2f1863191e" name="gadb2b8becf12ac9d423f82a2f1863191e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb2b8becf12ac9d423f82a2f1863191e">&#9670;&nbsp;</a></span>apply_matrices() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VariableTags , typename MatrixType , size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Variables&lt; VariableTags &gt; apply_matrices </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; MatrixType, Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Variables&lt; VariableTags &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>extents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply by matrices in each dimension. </p>
<p >Multiplies each stripe in the first dimension of <code>u</code> by <code>matrices[0]</code>, each stripe in the second dimension of <code>u</code> by <code>matrices[1]</code>, and so on. If any of the matrices are empty they will be treated as the identity, but the matrix multiplications will be skipped for increased efficiency.</p>
<dl class="section note"><dt>Note</dt><dd>The element type stored in the vectors to be transformed may be either <code>double</code> or <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>&lt;double&gt;</code>. The matrix, however, must be real. In the case of acting on a vector of complex values, the matrix is treated as having zero imaginary part. This is chosen for efficiency in all use-cases for spectral matrix arithmetic so far encountered. </dd></dl>

</div>
</div>
<a id="gad3098b0daf1550ed5a14b051ac15d506" name="gad3098b0daf1550ed5a14b051ac15d506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3098b0daf1550ed5a14b051ac15d506">&#9670;&nbsp;</a></span>apply_matrices() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename VectorType , size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorType apply_matrices </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; MatrixType, Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>extents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply by matrices in each dimension. </p>
<p >Multiplies each stripe in the first dimension of <code>u</code> by <code>matrices[0]</code>, each stripe in the second dimension of <code>u</code> by <code>matrices[1]</code>, and so on. If any of the matrices are empty they will be treated as the identity, but the matrix multiplications will be skipped for increased efficiency.</p>
<dl class="section note"><dt>Note</dt><dd>The element type stored in the vectors to be transformed may be either <code>double</code> or <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>&lt;double&gt;</code>. The matrix, however, must be real. In the case of acting on a vector of complex values, the matrix is treated as having zero imaginary part. This is chosen for efficiency in all use-cases for spectral matrix arithmetic so far encountered. </dd></dl>

</div>
</div>
<a id="gaa00d597fd99adcab5ef893992c24c007" name="gaa00d597fd99adcab5ef893992c24c007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa00d597fd99adcab5ef893992c24c007">&#9670;&nbsp;</a></span>apply_matrices() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultType , typename MatrixType , typename VectorType , size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ResultType apply_matrices </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; MatrixType, Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>extents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply by matrices in each dimension. </p>
<p >Multiplies each stripe in the first dimension of <code>u</code> by <code>matrices[0]</code>, each stripe in the second dimension of <code>u</code> by <code>matrices[1]</code>, and so on. If any of the matrices are empty they will be treated as the identity, but the matrix multiplications will be skipped for increased efficiency.</p>
<dl class="section note"><dt>Note</dt><dd>The element type stored in the vectors to be transformed may be either <code>double</code> or <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>&lt;double&gt;</code>. The matrix, however, must be real. In the case of acting on a vector of complex values, the matrix is treated as having zero imaginary part. This is chosen for efficiency in all use-cases for spectral matrix arithmetic so far encountered. </dd></dl>

</div>
</div>
<a id="ga72a74d62622a851dfb580f81a84a09aa" name="ga72a74d62622a851dfb580f81a84a09aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72a74d62622a851dfb580f81a84a09aa">&#9670;&nbsp;</a></span>bracket_possibly_undefined_function_in_interval() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RootFinder::bracket_possibly_undefined_function_in_interval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt;&#160;</td>
          <td class="paramname"><em>upper_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt;&#160;</td>
          <td class="paramname"><em>f_at_lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt;&#160;</td>
          <td class="paramname"><em>f_at_upper_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Functor &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>guess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Brackets the single root of the function <code>f</code> for each element in a <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code>, assuming the root lies in the given interval and that <code>f</code> may be undefined at some points in the interval. </p>
<p ><code>f</code> is a binary invokable that takes a <code>double</code> and a <code>size_t</code> as arguments. The <code>double</code> is the current value at which to evaluate <code>f</code>, and the <code>size_t</code> is the index into the <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code>s. <code>f</code> returns a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt;double&gt;</code> which evaluates to false if the function is undefined at the supplied point.</p>
<p >Assumes that there is only one root in the interval.</p>
<p >Assumes that if \(f(x_1)\) and \(f(x_2)\) are both defined for some \((x_1,x_2)\), then \(f(x)\) is defined for all \(x\) between \(x_1\) and \(x_2\).</p>
<p >On input, assumes that the root lies in the interval [<code>lower_bound</code>,<code>upper_bound</code>]. Optionally takes a <code>guess</code> for the location of the root.</p>
<p >On return, <code>lower_bound</code> and <code>upper_bound</code> are replaced with values that bracket the root and for which the function is defined, and <code>f_at_lower_bound</code> and <code>f_at_upper_bound</code> are replaced with <code>f</code> evaluated at those bracketing points. </p>

</div>
</div>
<a id="ga4f255af75bf51be43bc50fac2ef94764" name="ga4f255af75bf51be43bc50fac2ef94764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f255af75bf51be43bc50fac2ef94764">&#9670;&nbsp;</a></span>bracket_possibly_undefined_function_in_interval() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RootFinder::bracket_possibly_undefined_function_in_interval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; double * &gt;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; double * &gt;&#160;</td>
          <td class="paramname"><em>upper_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; double * &gt;&#160;</td>
          <td class="paramname"><em>f_at_lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; double * &gt;&#160;</td>
          <td class="paramname"><em>f_at_upper_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Functor &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>guess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Brackets the root of the function <code>f</code>, assuming a single root in a given interval \(f[x_\mathrm{lo},x_\mathrm{up}]\) and assuming that <code>f</code> is defined only in an unknown smaller interval \(f[x_a,x_b]\) where \(x_\mathrm{lo} \leq x_a \leq x_b \leq x_\mathrm{hi}\). </p>
<p ><code>f</code> is a unary invokable that takes a <code>double</code> which is the current value at which to evaluate <code>f</code>. <code>f</code> returns a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt;double&gt;</code> which evaluates to false if the function is undefined at the supplied point.</p>
<p >Assumes that there is only one root in the interval.</p>
<p >Assumes that if \(f(x_1)\) and \(f(x_2)\) are both defined for some \((x_1,x_2)\), then \(f(x)\) is defined for all \(x\) between \(x_1\) and \(x_2\).</p>
<p >On input, assumes that the root lies in the interval [<code>lower_bound</code>,<code>upper_bound</code>]. Optionally takes a <code>guess</code> for the location of the root. If <code>guess</code> is supplied, then evaluates the function first at <code>guess</code> and <code>upper_bound</code> before trying <code>lower_bound</code>: this means that it would be optimal if <code>guess</code> underestimates the actual root and if <code>upper_bound</code> was less likely to be undefined than <code>lower_bound</code>.</p>
<p >On return, <code>lower_bound</code> and <code>upper_bound</code> are replaced with values that bracket the root and for which the function is defined, and <code>f_at_lower_bound</code> and <code>f_at_upper_bound</code> are replaced with <code>f</code> evaluated at those bracketing points.</p>
<p ><code>bracket_possibly_undefined_function_in_interval</code> throws an error if all points are valid but of the same sign (because that would indicate multiple roots but we assume only one root), if no root exists, or if the range of a sign change is sufficently small relative to the given interval that the number of iterations to find the root is exceeded. </p>

</div>
</div>
<a id="ga31da225dde202f8e08b7106ebadc2170" name="ga31da225dde202f8e08b7106ebadc2170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31da225dde202f8e08b7106ebadc2170">&#9670;&nbsp;</a></span>definite_integral()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double definite_integral </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>integrand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the definite integral of a function over a manifold. </p>
<p >Given a function \(f\), compute its integral \(I\) with respect to the logical coordinates \(\boldsymbol{\xi} = (\xi, \eta, \zeta)\). E.g., in 1 dimension, \(I = \int_{-1}^1 f d\xi\).</p>
<p >The integral w.r.t. a different set of coordinates \(\boldsymbol{x} = \boldsymbol{x}(\boldsymbol{\xi})\) can be computed by pre-multiplying \(f\) by the Jacobian determinant \(J = \det d\boldsymbol{x}/d\boldsymbol{\xi}\) of the mapping \(\boldsymbol{x}(\boldsymbol{\xi})\). Note that, in the \(\boldsymbol{x}\) coordinates, the domain of integration is the image of the logical cube (square in 2D, interval in 1D) under the mapping.</p>
<p >The integral is computed by quadrature, using the quadrature rule for the basis associated with the collocation points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">integrand</td><td>the function to integrate. </td></tr>
    <tr><td class="paramname">mesh</td><td>the <a class="el" href="classMesh.html" title="Holds the number of grid points, basis, and quadrature in each direction of the computational grid.">Mesh</a> defining the grid points on the manifold. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga317c58dd34eb1a1a8d53153cea6741d9" name="ga317c58dd34eb1a1a8d53153cea6741d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga317c58dd34eb1a1a8d53153cea6741d9">&#9670;&nbsp;</a></span>find_generalized_eigenvalues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void find_generalized_eigenvalues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt;&#160;</td>
          <td class="paramname"><em>eigenvalues_real_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt;&#160;</td>
          <td class="paramname"><em>eigenvalues_imaginary_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classMatrix.html">Matrix</a> * &gt;&#160;</td>
          <td class="paramname"><em>eigenvectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a>&#160;</td>
          <td class="paramname"><em>matrix_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a>&#160;</td>
          <td class="paramname"><em>matrix_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve the generalized eigenvalue problem for two matrices. </p>
<p >This function uses the lapack routine dggev (<a href="http://www.netlib.org/lapack/explore-3.1.1-html/dggev.f.html">http://www.netlib.org/lapack/explore-3.1.1-html/dggev.f.html</a>) to solve the generalized eigenvalue problem \(A v_a =\lambda_a B v_a \) for the generalized eigenvalues \(\lambda_a\) and corresponding eigenvectors \(v_a\). <code>matrix_a</code> and <code>matrix_b</code> are each a <code><a class="el" href="classMatrix.html" title="A dynamically sized matrix of doubles with column-major storage.">Matrix</a></code>; they correspond to square matrices \(A\) and \(B\) that are the same dimension \(N\). <code>eigenvalues_real_part</code> is a <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code> of size \(N\) that will store the real parts of the eigenvalues, <code>eigenvalues_imaginary_part</code> is a <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code> of size \(N\) that will store the imaginary parts of the eigenvalues. Complex eigenvalues always form complex conjugate pairs, and the \(j\) and \(j+1\) eigenvalues will have the forms \(a+ib\) and \(a-ib\), respectively. The eigenvectors are returned as the columns of a square <code><a class="el" href="classMatrix.html" title="A dynamically sized matrix of doubles with column-major storage.">Matrix</a></code> of dimension \(N\) called <code>eigenvectors</code>. If eigenvalue \(j\) is real, then column \(j\) of <code>eigenvectors</code> is the corresponding eigenvector. If eigenvalue \(j\) and \(j+1\) are complex-conjugate pairs, then the eigenvector for eigenvalue \(j\) is (column j) + \(i\) (column j+1), and the eigenvector for eigenvalue \(j+1\) is (column j) - \(i\) (column j+1). </p>

</div>
</div>
<a id="gac1898874039a432852e9e8bfdbbcea5d" name="gac1898874039a432852e9e8bfdbbcea5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1898874039a432852e9e8bfdbbcea5d">&#9670;&nbsp;</a></span>gsl_multiroot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename Function , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; gsl_multiroot_detail::is_jacobian_callable_v&lt; Function, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, Dim &gt; &gt; &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, Dim &gt; RootFinder::gsl_multiroot </td>
          <td>(</td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>initial_guess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structRootFinder_1_1StoppingCondition.html">StoppingCondition</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maximum_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__LoggingGroup.html#gabf3be10d03894afb391f3a2935e3b313">Verbosity</a>&#160;</td>
          <td class="paramname"><em>verbosity</em> = <code>Verbosity::Silent</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>maximum_absolute_tolerance</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__NumericalAlgorithmsGroup.html#ga2bdd099599c989714bd6497401452624">Method</a>&#160;</td>
          <td class="paramname"><em>method</em> = <code><a class="el" href="group__NumericalAlgorithmsGroup.html#gga2bdd099599c989714bd6497401452624a1c8b97c83b0726216cd5dbc88a64b0ed">Method::Newton</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A multidimensional root finder supporting Newton and Hybrid methods, as well as modified methods based on these. </p>
<p >This root finder accepts function objects with and without a callable <code>jacobian</code> member function. The call operator both accepts and returns a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;double, Dim&gt;</code>, of the appropriate dimension for the domain and range the function the root find is being performed on.</p>
<p >If a <code>jacobian</code> function is provided, it must accept a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;double, Dim&gt;</code> and return a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;double, Dim&gt;, Dim&gt;</code> representing the derivative of the call operator, with </p><p class="formulaDsp">
\begin{equation} \text{jacobian[i][j]} = \frac{\partial f_i}{x_j}. \end{equation}
</p>
<p >Whether the jacobian is provided determines the details of the implementation of the root-finding method that is selected by the user using the Method enum. That is, whether the jacobian is computed analytically via the <code>jacobian</code> member function, or whether the jacobian is computed numerically via a finite difference approximation.</p>
<dl class="section note"><dt>Note</dt><dd>GSL does not provide a finite difference version of its modified Newton method, so the unmodified one is used instead when the user uses the <a class="el" href="group__NumericalAlgorithmsGroup.html#gga2bdd099599c989714bd6497401452624a1c8b97c83b0726216cd5dbc88a64b0ed" title="If an analytic jacobian is provided, gsl uses a modification of Newton&#39;s method to improve global con...">Method::Newton</a> method.</dd></dl>
<p>The user can select one of two possible criteria for convergence, StoppingCondition::Residual, where the sum of the absolute values of the components of the residual vector f are compared against the value provided to <code>absolute_tolerance</code>, and StoppingCondition::Convergence, where the size of the most recent step taken in the root-finding iteration is compared against <code>absolute_tolerance</code> + <code>relative_tolerance</code> * |x_i|, for each component. In either case, a <code>maximum_absolute_tolerance</code> may be specified if the user anticipates that the convergence criterion specified with <a class="el" href="structRootFinder_1_1StoppingCondition.html">StoppingCondition</a> will be too strict for a few points out of a population of points found with a sequence of root finds.</p>
<p >See <a href="https://www.gnu.org/software/gsl/manual/html_node/Multidimensional-Root_002dFinding.html">GSL's documentation for multidimensional rootfinding</a> for reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function whose root is to be found. </td></tr>
    <tr><td class="paramname">initial_guess</td><td>Contains initial guess. </td></tr>
    <tr><td class="paramname">maximum_iterations</td><td>The maximum number of iterations. </td></tr>
    <tr><td class="paramname">verbosity</td><td>Whether to print diagnostic messages. </td></tr>
    <tr><td class="paramname">maximum_absolute_tolerance</td><td>Acceptable absolute tolerance when root finder doesn't converge. You may wish to use this if there are only a few "problematic" points where it is difficult to do a precise root find. </td></tr>
    <tr><td class="paramname">method</td><td>The method to use. See the documentation for the Method enum. </td></tr>
    <tr><td class="paramname">condition</td><td>The convergence condition to use. See the documentation for the <a class="el" href="structRootFinder_1_1StoppingCondition.html">StoppingCondition</a> enum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0decf26e777ccc2299de0f563e7e0dbc" name="ga0decf26e777ccc2299de0f563e7e0dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0decf26e777ccc2299de0f563e7e0dbc">&#9670;&nbsp;</a></span>indefinite_integral() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorType indefinite_integral </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>integrand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dim_to_integrate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the indefinite integral of a function in the <code>dim_to_integrate</code>, applying a zero boundary condition on each stripe. </p>
<p >Integrates with respect to one of the logical coordinates \(\boldsymbol{\xi} = (\xi, \eta, \zeta)\).</p>
<p >The integral w.r.t. a different set of coordinates \(\boldsymbol{x} = \boldsymbol{x}(\boldsymbol{\xi})\) can be computed by pre-multiplying <code>integrand</code> by the Jacobian determinant \(J = \det d\boldsymbol{x}/d\boldsymbol{\xi}\) of the mapping \(\boldsymbol{x}(\boldsymbol{\xi})\). The integration is still performed along one logical-coordinate direction, indicated by <code>dim_to_integrate</code>.</p>
<p ><em>Requires:</em> number of points in <code>integrand</code> and <code>mesh</code> are equal. </p>

</div>
</div>
<a id="ga9f00d2ce9b2e232d6bad87dd6c4d7c85" name="ga9f00d2ce9b2e232d6bad87dd6c4d7c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f00d2ce9b2e232d6bad87dd6c4d7c85">&#9670;&nbsp;</a></span>indefinite_integral() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void indefinite_integral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; VectorType * &gt;&#160;</td>
          <td class="paramname"><em>integral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>integrand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dim_to_integrate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the indefinite integral of a function in the <code>dim_to_integrate</code>, applying a zero boundary condition on each stripe. </p>
<p >Integrates with respect to one of the logical coordinates \(\boldsymbol{\xi} = (\xi, \eta, \zeta)\).</p>
<p >The integral w.r.t. a different set of coordinates \(\boldsymbol{x} = \boldsymbol{x}(\boldsymbol{\xi})\) can be computed by pre-multiplying <code>integrand</code> by the Jacobian determinant \(J = \det d\boldsymbol{x}/d\boldsymbol{\xi}\) of the mapping \(\boldsymbol{x}(\boldsymbol{\xi})\). The integration is still performed along one logical-coordinate direction, indicated by <code>dim_to_integrate</code>.</p>
<p ><em>Requires:</em> number of points in <code>integrand</code> and <code>mesh</code> are equal. </p>

</div>
</div>
<a id="gaee3c1f31ffa436392b62d55e2b9d4f7c" name="gaee3c1f31ffa436392b62d55e2b9d4f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee3c1f31ffa436392b62d55e2b9d4f7c">&#9670;&nbsp;</a></span>largest_root_between_values_within_roundoff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T largest_root_between_values_within_roundoff </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the largest root of a quadratic equation \(ax^2 + bx + c = 0\) that is between min_value and max_value, within roundoff. </p>
<p ><em>Returns:</em> A root of a quadratic equation. </p>
<p ><em>Requires:</em> That there are two real roots. </p>
<p ><em>Requires:</em> At least one root is between min_value and max_value, to roundoff. </p>

</div>
</div>
<a id="gaa09845b42e4ab196189f52146264d102" name="gaa09845b42e4ab196189f52146264d102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa09845b42e4ab196189f52146264d102">&#9670;&nbsp;</a></span>linear_regression()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structintrp_1_1LinearRegressionResult.html">LinearRegressionResult</a> intrp::linear_regression </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A linear regression function. </p>
<p >A wrapper for gsl linear regression. Fits the data to \(y = m x + b\). Returns a struct containing \((b, m, \delta b, \delta m)\), where \(\delta b\) and \(\delta m\) are the error bars in \(b\) and \(m\). The error bars are computed assuming unknown errors in \(y\).</p>
<p >linear_regression could be implemented by calling <a class="el" href="classintrp_1_1LinearLeastSquares.html" title="A linear least squares solver class.">LinearLeastSquares</a> using Order=1, but we choose instead to implement linear_regression in a simpler way, by calling a simpler gsl function that involves no memory allocations, no copying, and no <code>pow</code> functions. </p>

</div>
</div>
<a id="ga21beb26abe3c25180788b2c8ce939b39" name="ga21beb26abe3c25180788b2c8ce939b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21beb26abe3c25180788b2c8ce939b39">&#9670;&nbsp;</a></span>linearize() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataVector.html">DataVector</a> linearize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncate u to a linear function in each dimension. </p>
<p >Ex in 2D: \(u^{Lin} = U_0 + U_x x + U_y y + U_{xy} xy\)</p>
<dl class="section warning"><dt>Warning</dt><dd>the <code><a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a></code> variant assumes <code>*result</code> is of the correct size. </dd></dl>

</div>
</div>
<a id="ga4519e09fd8a878ff52edad38439b5f44" name="ga4519e09fd8a878ff52edad38439b5f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4519e09fd8a878ff52edad38439b5f44">&#9670;&nbsp;</a></span>linearize() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataVector.html">DataVector</a> linearize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncate u to a linear function in the given dimension. </p>
<p ><b>Parameters</b></p><ul>
<li><code>u</code> the function to linearize.</li>
<li><code>mesh</code> the <a class="el" href="classMesh.html" title="Holds the number of grid points, basis, and quadrature in each direction of the computational grid.">Mesh</a> of the grid on the manifold on which <code>u</code> is located.</li>
<li><code>d</code> the dimension that is to be linearized.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>the <code><a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a></code> variant assumes <code>*result</code> is of the correct size. </dd></dl>

</div>
</div>
<a id="ga2b54b59f18279d4a062dc4abb1feb2cd" name="ga2b54b59f18279d4a062dc4abb1feb2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b54b59f18279d4a062dc4abb1feb2cd">&#9670;&nbsp;</a></span>linearize() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linearize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncate u to a linear function in each dimension. </p>
<p >Ex in 2D: \(u^{Lin} = U_0 + U_x x + U_y y + U_{xy} xy\)</p>
<dl class="section warning"><dt>Warning</dt><dd>the <code><a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a></code> variant assumes <code>*result</code> is of the correct size. </dd></dl>

</div>
</div>
<a id="ga04ba0a473561e003758f2a6036339e5e" name="ga04ba0a473561e003758f2a6036339e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04ba0a473561e003758f2a6036339e5e">&#9670;&nbsp;</a></span>linearize() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void linearize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncate u to a linear function in the given dimension. </p>
<p ><b>Parameters</b></p><ul>
<li><code>u</code> the function to linearize.</li>
<li><code>mesh</code> the <a class="el" href="classMesh.html" title="Holds the number of grid points, basis, and quadrature in each direction of the computational grid.">Mesh</a> of the grid on the manifold on which <code>u</code> is located.</li>
<li><code>d</code> the dimension that is to be linearized.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>the <code><a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a></code> variant assumes <code>*result</code> is of the correct size. </dd></dl>

</div>
</div>
<a id="ga14eca4d56fb41f09ab3d9a0487f72eab" name="ga14eca4d56fb41f09ab3d9a0487f72eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14eca4d56fb41f09ab3d9a0487f72eab">&#9670;&nbsp;</a></span>logical_partial_derivative() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SymmList , typename IndexList , size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto logical_partial_derivative </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, SymmList, IndexList &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="group__TensorGroup.html#ga5e4aece332518b3a95c2a73557aaa596">TensorMetafunctions::prepend_spatial_index</a>&lt; Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, SymmList, IndexList &gt;, Dim, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the logical partial derivative of a tensor, prepending the spatial derivative index, e.g. for \(\partial_i T_{a}{}^{b}\) the C++ call is <code>get(i, a, b)</code>. </p>
<p >There is an overload that accepts a <code>buffer</code> of size <code>mesh.number_of_grid_points()</code> or larger. When passed this function performs no memory allocations, which helps improve performance.</p>
<p >If you have a <code>Variables</code> with several tensors you need to differentiate you should use the <code>logical_partial_derivatives</code> function that operates on <code>Variables</code> since that'll be more efficient. </p>

</div>
</div>
<a id="ga3b8251bd89867d734f756ce22af46eba" name="ga3b8251bd89867d734f756ce22af46eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b8251bd89867d734f756ce22af46eba">&#9670;&nbsp;</a></span>logical_partial_derivative() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SymmList , typename IndexList , size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void logical_partial_derivative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga5e4aece332518b3a95c2a73557aaa596">TensorMetafunctions::prepend_spatial_index</a>&lt; Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, SymmList, IndexList &gt;, Dim, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>logical_derivative_of_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, SymmList, IndexList &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the logical partial derivative of a tensor, prepending the spatial derivative index, e.g. for \(\partial_i T_{a}{}^{b}\) the C++ call is <code>get(i, a, b)</code>. </p>
<p >There is an overload that accepts a <code>buffer</code> of size <code>mesh.number_of_grid_points()</code> or larger. When passed this function performs no memory allocations, which helps improve performance.</p>
<p >If you have a <code>Variables</code> with several tensors you need to differentiate you should use the <code>logical_partial_derivatives</code> function that operates on <code>Variables</code> since that'll be more efficient. </p>

</div>
</div>
<a id="gac665845d5ed95426a3c45292300d2263" name="gac665845d5ed95426a3c45292300d2263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac665845d5ed95426a3c45292300d2263">&#9670;&nbsp;</a></span>logical_partial_derivative() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SymmList , typename IndexList , size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void logical_partial_derivative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga5e4aece332518b3a95c2a73557aaa596">TensorMetafunctions::prepend_spatial_index</a>&lt; Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, SymmList, IndexList &gt;, Dim, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>logical_derivative_of_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt; * &gt;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, SymmList, IndexList &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the logical partial derivative of a tensor, prepending the spatial derivative index, e.g. for \(\partial_i T_{a}{}^{b}\) the C++ call is <code>get(i, a, b)</code>. </p>
<p >There is an overload that accepts a <code>buffer</code> of size <code>mesh.number_of_grid_points()</code> or larger. When passed this function performs no memory allocations, which helps improve performance.</p>
<p >If you have a <code>Variables</code> with several tensors you need to differentiate you should use the <code>logical_partial_derivatives</code> function that operates on <code>Variables</code> since that'll be more efficient. </p>

</div>
</div>
<a id="ga3151762c10e3202bb3f7d38e92e16cc9" name="ga3151762c10e3202bb3f7d38e92e16cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3151762c10e3202bb3f7d38e92e16cc9">&#9670;&nbsp;</a></span>logical_partial_derivatives() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivativeTags , typename VariableTags , size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto logical_partial_derivatives </td>
          <td>(</td>
          <td class="paramtype">const Variables&lt; VariableTags &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; Variables&lt; DerivativeTags &gt;, Dim &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the partial derivatives of each variable with respect to the element logical coordinate. </p>
<p ><em>Requires:</em> <code>DerivativeTags</code> to be the head of <code>VariableTags</code></p>
<p >Returns a <code>Variables</code> with a spatial tensor index appended to the front of each tensor within <code>u</code> and each <code>Tag</code> wrapped with a <code><a class="el" href="structTags_1_1deriv.html" title="Prefix indicating spatial derivatives.">Tags::deriv</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivativeTags</td><td>the subset of <code>VariableTags</code> for which derivatives are computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabaac1df3dc75d7963dd5f135a189b47b" name="gabaac1df3dc75d7963dd5f135a189b47b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaac1df3dc75d7963dd5f135a189b47b">&#9670;&nbsp;</a></span>logical_partial_derivatives() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivativeTags , typename VariableTags , size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void logical_partial_derivatives </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; Variables&lt; DerivativeTags &gt;, Dim &gt; * &gt;&#160;</td>
          <td class="paramname"><em>logical_partial_derivatives_of_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Variables&lt; VariableTags &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the partial derivatives of each variable with respect to the element logical coordinate. </p>
<p ><em>Requires:</em> <code>DerivativeTags</code> to be the head of <code>VariableTags</code></p>
<p >Returns a <code>Variables</code> with a spatial tensor index appended to the front of each tensor within <code>u</code> and each <code>Tag</code> wrapped with a <code><a class="el" href="structTags_1_1deriv.html" title="Prefix indicating spatial derivatives.">Tags::deriv</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivativeTags</td><td>the subset of <code>VariableTags</code> for which derivatives are computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5c26f2543e383e45bd418d8f82917879" name="ga5c26f2543e383e45bd418d8f82917879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c26f2543e383e45bd418d8f82917879">&#9670;&nbsp;</a></span>mean_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double mean_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the mean value of a function over a manifold. </p>
<p >Given a function \(f\), compute its mean value \(\bar{f}\) with respect to the logical coordinates \(\boldsymbol{\xi} = (\xi, \eta, \zeta)\). E.g., in 1 dimension, \(\bar{f} = \int_{-1}^1 f d\xi \Big/ \int_{-1}^1 d\xi\).</p>
<dl class="section note"><dt>Note</dt><dd>The mean w.r.t. a different set of coordinates \(\boldsymbol{x} = \boldsymbol{x}(\boldsymbol{\xi})\) can't be directly computed using this function. Before calling <code>mean_value</code>, \(f\) must be pre-multiplied by the Jacobian determinant \(J = \det d\boldsymbol{x}/d\boldsymbol{\xi}\) of the mapping \(\boldsymbol{x}(\boldsymbol{\xi})\). Additionally, the output of <code>mean_value</code> must be multiplied by a factor \(2^{\text{d}} / \int J d^{\text{d}}\xi\) (in \(d\) dimensions), to account for the different volume of the manifold in the \(\boldsymbol{x}\) coordinates.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the function to average. </td></tr>
    <tr><td class="paramname">mesh</td><td>the <a class="el" href="classMesh.html" title="Holds the number of grid points, basis, and quadrature in each direction of the computational grid.">Mesh</a> defining the grid points on the manifold. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad6d6f1876cc09fac52091acb154f752a" name="gad6d6f1876cc09fac52091acb154f752a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6d6f1876cc09fac52091acb154f752a">&#9670;&nbsp;</a></span>mean_value_on_boundary() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double mean_value_on_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">Side</a>&#160;</td>
          <td class="paramname"><em>side</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the mean value of a function over a boundary of a manifold. </p>
<p >Given a function \(f\), compute its mean value \(\bar{f}\), over a boundary, with respect to the logical coordinates \(\boldsymbol{\xi} = (\xi, \eta, \zeta)\).</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__NumericalAlgorithmsGroup.html#ga5c26f2543e383e45bd418d8f82917879" title="Compute the mean value of a function over a manifold.">mean_value</a></code> for notes about means w.r.t. other coordinates.</dd></dl>
<ul>
<li><code>f</code> the function to average.</li>
<li><code>mesh</code> the <a class="el" href="classMesh.html" title="Holds the number of grid points, basis, and quadrature in each direction of the computational grid.">Mesh</a> defining the grid points on the manifold.</li>
<li><code>d</code> the dimension which is sliced away to get the boundary.</li>
<li><code>side</code> whether it is the lower or upper boundary in the d-th dimension.</li>
<li><code>boundary_buffer</code> is a pointer to a <a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a> of size <code>mesh.slice_away(d).number_of_grid_points()</code> used as a temporary buffer when slicing the data to the boundary.</li>
<li><code>volume_and_slice_indices</code> a pair of <code>(volume_index_for_point, slice_index_for_point)</code> computed using the <code><a class="el" href="classSliceIterator.html" title="Iterate over a (dim-1)-dimensional slice.">SliceIterator</a></code>. Because <code><a class="el" href="classSliceIterator.html" title="Iterate over a (dim-1)-dimensional slice.">SliceIterator</a></code> is somewhat expensive, if computing the mean value on the same boundary for many different tensor components, prefer computing the slice indices once. </li>
</ul>

</div>
</div>
<a id="ga87663e8ca1d53121aefa98077cd8f34e" name="ga87663e8ca1d53121aefa98077cd8f34e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87663e8ca1d53121aefa98077cd8f34e">&#9670;&nbsp;</a></span>mean_value_on_boundary() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double mean_value_on_boundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt;&#160;</td>
          <td class="paramname"><em>boundary_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">Side</a>&#160;</td>
          <td class="paramname"><em>side</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the mean value of a function over a boundary of a manifold. </p>
<p >Given a function \(f\), compute its mean value \(\bar{f}\), over a boundary, with respect to the logical coordinates \(\boldsymbol{\xi} = (\xi, \eta, \zeta)\).</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__NumericalAlgorithmsGroup.html#ga5c26f2543e383e45bd418d8f82917879" title="Compute the mean value of a function over a manifold.">mean_value</a></code> for notes about means w.r.t. other coordinates.</dd></dl>
<ul>
<li><code>f</code> the function to average.</li>
<li><code>mesh</code> the <a class="el" href="classMesh.html" title="Holds the number of grid points, basis, and quadrature in each direction of the computational grid.">Mesh</a> defining the grid points on the manifold.</li>
<li><code>d</code> the dimension which is sliced away to get the boundary.</li>
<li><code>side</code> whether it is the lower or upper boundary in the d-th dimension.</li>
<li><code>boundary_buffer</code> is a pointer to a <a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a> of size <code>mesh.slice_away(d).number_of_grid_points()</code> used as a temporary buffer when slicing the data to the boundary.</li>
<li><code>volume_and_slice_indices</code> a pair of <code>(volume_index_for_point, slice_index_for_point)</code> computed using the <code><a class="el" href="classSliceIterator.html" title="Iterate over a (dim-1)-dimensional slice.">SliceIterator</a></code>. Because <code><a class="el" href="classSliceIterator.html" title="Iterate over a (dim-1)-dimensional slice.">SliceIterator</a></code> is somewhat expensive, if computing the mean value on the same boundary for many different tensor components, prefer computing the slice indices once. </li>
</ul>

</div>
</div>
<a id="ga88a958a9671db67b85f2388f4aef8eed" name="ga88a958a9671db67b85f2388f4aef8eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88a958a9671db67b85f2388f4aef8eed">&#9670;&nbsp;</a></span>mean_value_on_boundary() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double mean_value_on_boundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt;&#160;</td>
          <td class="paramname"><em>boundary_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; size_t, size_t &gt; &gt;&#160;</td>
          <td class="paramname"><em>volume_and_slice_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">Side</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the mean value of a function over a boundary of a manifold. </p>
<p >Given a function \(f\), compute its mean value \(\bar{f}\), over a boundary, with respect to the logical coordinates \(\boldsymbol{\xi} = (\xi, \eta, \zeta)\).</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__NumericalAlgorithmsGroup.html#ga5c26f2543e383e45bd418d8f82917879" title="Compute the mean value of a function over a manifold.">mean_value</a></code> for notes about means w.r.t. other coordinates.</dd></dl>
<ul>
<li><code>f</code> the function to average.</li>
<li><code>mesh</code> the <a class="el" href="classMesh.html" title="Holds the number of grid points, basis, and quadrature in each direction of the computational grid.">Mesh</a> defining the grid points on the manifold.</li>
<li><code>d</code> the dimension which is sliced away to get the boundary.</li>
<li><code>side</code> whether it is the lower or upper boundary in the d-th dimension.</li>
<li><code>boundary_buffer</code> is a pointer to a <a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a> of size <code>mesh.slice_away(d).number_of_grid_points()</code> used as a temporary buffer when slicing the data to the boundary.</li>
<li><code>volume_and_slice_indices</code> a pair of <code>(volume_index_for_point, slice_index_for_point)</code> computed using the <code><a class="el" href="classSliceIterator.html" title="Iterate over a (dim-1)-dimensional slice.">SliceIterator</a></code>. Because <code><a class="el" href="classSliceIterator.html" title="Iterate over a (dim-1)-dimensional slice.">SliceIterator</a></code> is somewhat expensive, if computing the mean value on the same boundary for many different tensor components, prefer computing the slice indices once. </li>
</ul>

</div>
</div>
<a id="ga0825cdf0fc3ea76e32d7936d45af36a8" name="ga0825cdf0fc3ea76e32d7936d45af36a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0825cdf0fc3ea76e32d7936d45af36a8">&#9670;&nbsp;</a></span>mean_value_on_boundary() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mean_value_on_boundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">Side</a>&#160;</td>
          <td class="paramname"><em>side</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the mean value of a function over a boundary of a manifold. </p>
<p >Given a function \(f\), compute its mean value \(\bar{f}\), over a boundary, with respect to the logical coordinates \(\boldsymbol{\xi} = (\xi, \eta, \zeta)\).</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__NumericalAlgorithmsGroup.html#ga5c26f2543e383e45bd418d8f82917879" title="Compute the mean value of a function over a manifold.">mean_value</a></code> for notes about means w.r.t. other coordinates.</dd></dl>
<ul>
<li><code>f</code> the function to average.</li>
<li><code>mesh</code> the <a class="el" href="classMesh.html" title="Holds the number of grid points, basis, and quadrature in each direction of the computational grid.">Mesh</a> defining the grid points on the manifold.</li>
<li><code>d</code> the dimension which is sliced away to get the boundary.</li>
<li><code>side</code> whether it is the lower or upper boundary in the d-th dimension.</li>
<li><code>boundary_buffer</code> is a pointer to a <a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a> of size <code>mesh.slice_away(d).number_of_grid_points()</code> used as a temporary buffer when slicing the data to the boundary.</li>
<li><code>volume_and_slice_indices</code> a pair of <code>(volume_index_for_point, slice_index_for_point)</code> computed using the <code><a class="el" href="classSliceIterator.html" title="Iterate over a (dim-1)-dimensional slice.">SliceIterator</a></code>. Because <code><a class="el" href="classSliceIterator.html" title="Iterate over a (dim-1)-dimensional slice.">SliceIterator</a></code> is somewhat expensive, if computing the mean value on the same boundary for many different tensor components, prefer computing the slice indices once. </li>
</ul>

</div>
</div>
<a id="ga3c6b26ca3290c3a3cbb231428fc33026" name="ga3c6b26ca3290c3a3cbb231428fc33026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c6b26ca3290c3a3cbb231428fc33026">&#9670;&nbsp;</a></span>mean_value_on_boundary() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mean_value_on_boundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; size_t, size_t &gt; &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">Side</a>&#160;</td>
          <td class="paramname"><em>side</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the mean value of a function over a boundary of a manifold. </p>
<p >Given a function \(f\), compute its mean value \(\bar{f}\), over a boundary, with respect to the logical coordinates \(\boldsymbol{\xi} = (\xi, \eta, \zeta)\).</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__NumericalAlgorithmsGroup.html#ga5c26f2543e383e45bd418d8f82917879" title="Compute the mean value of a function over a manifold.">mean_value</a></code> for notes about means w.r.t. other coordinates.</dd></dl>
<ul>
<li><code>f</code> the function to average.</li>
<li><code>mesh</code> the <a class="el" href="classMesh.html" title="Holds the number of grid points, basis, and quadrature in each direction of the computational grid.">Mesh</a> defining the grid points on the manifold.</li>
<li><code>d</code> the dimension which is sliced away to get the boundary.</li>
<li><code>side</code> whether it is the lower or upper boundary in the d-th dimension.</li>
<li><code>boundary_buffer</code> is a pointer to a <a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a> of size <code>mesh.slice_away(d).number_of_grid_points()</code> used as a temporary buffer when slicing the data to the boundary.</li>
<li><code>volume_and_slice_indices</code> a pair of <code>(volume_index_for_point, slice_index_for_point)</code> computed using the <code><a class="el" href="classSliceIterator.html" title="Iterate over a (dim-1)-dimensional slice.">SliceIterator</a></code>. Because <code><a class="el" href="classSliceIterator.html" title="Iterate over a (dim-1)-dimensional slice.">SliceIterator</a></code> is somewhat expensive, if computing the mean value on the same boundary for many different tensor components, prefer computing the slice indices once. </li>
</ul>

</div>
</div>
<a id="ga8421b9149d2a3dac8a3d90b28ae2a569" name="ga8421b9149d2a3dac8a3d90b28ae2a569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8421b9149d2a3dac8a3d90b28ae2a569">&#9670;&nbsp;</a></span>newton_raphson()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RootFinder::newton_raphson </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >For the nonlinear solver, see <a class="el" href="namespaceNonlinearSolver_1_1newton__raphson.html" title="Items related to the NewtonRaphson nonlinear solver.">NonlinearSolver::newton_raphson</a>. We do not provide a Newton-Raphson root finder. The Boost implementation is buggy and can return the wrong answer, and it is not clear that performance would be better than RootFinder::toms748 in practice.</p>
<p >Newton-Raphson is asymptotically faster than TOMS748 in the ideal case, but that assumes that function evaluations take the same amount of time for both solvers, while in reality the derivatives are often as or even more expensive than the values. Additionally, for realistic problems, convergence is usually fast enough that neither solver reaches the asymptotic regime. Newton-Raphson also has the advantage of requiring less work internally in the solver implementation, but, again, for realistic problems solver overhead is usually dwarfed by the function evaluations. </p>

</div>
</div>
<a id="ga8ae152e90a5c97980839b0efd83d793b" name="ga8ae152e90a5c97980839b0efd83d793b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ae152e90a5c97980839b0efd83d793b">&#9670;&nbsp;</a></span>partial_derivative() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SymmList , typename IndexList , size_t Dim, typename DerivativeFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void partial_derivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga5e4aece332518b3a95c2a73557aaa596">TensorMetafunctions::prepend_spatial_index</a>&lt; Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, SymmList, IndexList &gt;, Dim, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, DerivativeFrame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>du</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, SymmList, IndexList &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, DerivativeFrame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_jacobian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the partial derivative of a <code>Tensor</code> with respect to the coordinates of <code>DerivativeFrame</code>. </p>
<p >Returns a <code>Tensor</code> with a spatial tensor index appended to the front of the input <code>Tensor</code>.</p>
<p >If you have a <code>Variables</code> with several tensors you need to differentiate, you should use the <code>partial_derivatives</code> function that operates on <code>Variables</code> since that'll be more efficient. </p>

</div>
</div>
<a id="ga325028716dca1a0ab2749abc4cd9132e" name="ga325028716dca1a0ab2749abc4cd9132e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga325028716dca1a0ab2749abc4cd9132e">&#9670;&nbsp;</a></span>partial_derivative() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SymmList , typename IndexList , size_t Dim, typename DerivativeFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void partial_derivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga5e4aece332518b3a95c2a73557aaa596">TensorMetafunctions::prepend_spatial_index</a>&lt; Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, SymmList, IndexList &gt;, Dim, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, DerivativeFrame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>du</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga5e4aece332518b3a95c2a73557aaa596">TensorMetafunctions::prepend_spatial_index</a>&lt; Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, SymmList, IndexList &gt;, Dim, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>logical_partial_derivative_of_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, DerivativeFrame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_jacobian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the partial derivative of a <code>Tensor</code> with respect to the coordinates of <code>DerivativeFrame</code>. </p>
<p >Returns a <code>Tensor</code> with a spatial tensor index appended to the front of the input <code>Tensor</code>.</p>
<p >If you have a <code>Variables</code> with several tensors you need to differentiate, you should use the <code>partial_derivatives</code> function that operates on <code>Variables</code> since that'll be more efficient. </p>

</div>
</div>
<a id="ga2896a931cb783ddc738e13f1cd37d9d7" name="ga2896a931cb783ddc738e13f1cd37d9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2896a931cb783ddc738e13f1cd37d9d7">&#9670;&nbsp;</a></span>partial_derivative() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SymmList , typename IndexList , size_t Dim, typename DerivativeFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto partial_derivative </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, SymmList, IndexList &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, DerivativeFrame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_jacobian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="group__TensorGroup.html#ga5e4aece332518b3a95c2a73557aaa596">TensorMetafunctions::prepend_spatial_index</a>&lt; Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, SymmList, IndexList &gt;, Dim, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, DerivativeFrame &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the partial derivative of a <code>Tensor</code> with respect to the coordinates of <code>DerivativeFrame</code>. </p>
<p >Returns a <code>Tensor</code> with a spatial tensor index appended to the front of the input <code>Tensor</code>.</p>
<p >If you have a <code>Variables</code> with several tensors you need to differentiate, you should use the <code>partial_derivatives</code> function that operates on <code>Variables</code> since that'll be more efficient. </p>

</div>
</div>
<a id="gad82f8581712392748d19da8737ecd576" name="gad82f8581712392748d19da8737ecd576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad82f8581712392748d19da8737ecd576">&#9670;&nbsp;</a></span>partial_derivatives() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivativeTags , typename VariableTags , size_t Dim, typename DerivativeFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto partial_derivatives </td>
          <td>(</td>
          <td class="paramtype">const Variables&lt; VariableTags &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, DerivativeFrame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_jacobian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  Variables&lt; <a class="el" href="group__DataBoxTagsGroup.html#ga3dda5a16c7f6baccd115de2c8f12394e">db::wrap_tags_in</a>&lt; <a class="el" href="structTags_1_1deriv.html">Tags::deriv</a>, DerivativeTags, tmpl::size_t&lt; Dim &gt;, DerivativeFrame &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the partial derivatives of each variable with respect to the coordinates of <code>DerivativeFrame</code>. </p>
<p ><em>Requires:</em> <code>DerivativeTags</code> to be the head of <code>VariableTags</code></p>
<p >Returns a <code>Variables</code> with a spatial tensor index appended to the front of each tensor within <code>u</code> and each <code>Tag</code> wrapped with a <code><a class="el" href="structTags_1_1deriv.html" title="Prefix indicating spatial derivatives.">Tags::deriv</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivativeTags</td><td>the subset of <code>VariableTags</code> for which derivatives are computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga80e0ee64b5928fa1f01993cfdf43f19b" name="ga80e0ee64b5928fa1f01993cfdf43f19b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80e0ee64b5928fa1f01993cfdf43f19b">&#9670;&nbsp;</a></span>partial_derivatives() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivativeTags , size_t Dim, typename DerivativeFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void partial_derivatives </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; <a class="el" href="group__DataBoxTagsGroup.html#ga3dda5a16c7f6baccd115de2c8f12394e">db::wrap_tags_in</a>&lt; <a class="el" href="structTags_1_1deriv.html">Tags::deriv</a>, DerivativeTags, tmpl::size_t&lt; Dim &gt;, DerivativeFrame &gt; &gt; * &gt;&#160;</td>
          <td class="paramname"><em>du</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; Variables&lt; DerivativeTags &gt;, Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>logical_partial_derivatives_of_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, DerivativeFrame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_jacobian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the partial derivatives of each variable with respect to the coordinates of <code>DerivativeFrame</code>. </p>
<p ><em>Requires:</em> <code>DerivativeTags</code> to be the head of <code>VariableTags</code></p>
<p >Returns a <code>Variables</code> with a spatial tensor index appended to the front of each tensor within <code>u</code> and each <code>Tag</code> wrapped with a <code><a class="el" href="structTags_1_1deriv.html" title="Prefix indicating spatial derivatives.">Tags::deriv</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivativeTags</td><td>the subset of <code>VariableTags</code> for which derivatives are computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac0854f07e422bb5bd3eae1896c3a152b" name="gac0854f07e422bb5bd3eae1896c3a152b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0854f07e422bb5bd3eae1896c3a152b">&#9670;&nbsp;</a></span>partial_derivatives() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivativeTags , typename VariableTags , size_t Dim, typename DerivativeFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void partial_derivatives </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; <a class="el" href="group__DataBoxTagsGroup.html#ga3dda5a16c7f6baccd115de2c8f12394e">db::wrap_tags_in</a>&lt; <a class="el" href="structTags_1_1deriv.html">Tags::deriv</a>, DerivativeTags, tmpl::size_t&lt; Dim &gt;, DerivativeFrame &gt; &gt; * &gt;&#160;</td>
          <td class="paramname"><em>du</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Variables&lt; VariableTags &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, DerivativeFrame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_jacobian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the partial derivatives of each variable with respect to the coordinates of <code>DerivativeFrame</code>. </p>
<p ><em>Requires:</em> <code>DerivativeTags</code> to be the head of <code>VariableTags</code></p>
<p >Returns a <code>Variables</code> with a spatial tensor index appended to the front of each tensor within <code>u</code> and each <code>Tag</code> wrapped with a <code><a class="el" href="structTags_1_1deriv.html" title="Prefix indicating spatial derivatives.">Tags::deriv</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivativeTags</td><td>the subset of <code>VariableTags</code> for which derivatives are computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga198dcd46579bcb2545eb2861c0b97ab0" name="ga198dcd46579bcb2545eb2861c0b97ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga198dcd46579bcb2545eb2861c0b97ab0">&#9670;&nbsp;</a></span>positive_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double positive_root </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the positive root of a quadratic equation \(ax^2 + bx + c = 0\). </p>
<p ><em>Returns:</em> The positive root of a quadratic equation. </p>
<p ><em>Requires:</em> That there are two real roots, of which only one is positive. </p>

</div>
</div>
<a id="gab165e76ec8f9e5927349a12c8fc8607a" name="gab165e76ec8f9e5927349a12c8fc8607a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab165e76ec8f9e5927349a12c8fc8607a">&#9670;&nbsp;</a></span>raw_transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void raw_transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; T * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>chunk_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>number_of_chunks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute transposed data. </p>
<p >Transpose the data pointed to by <code>data</code>, writing the result to the location pointed to by <code>result</code>. See the <a class="el" href="group__NumericalAlgorithmsGroup.html#ga9d755157e0d42f3fdae8dace311c1588" title="Function to compute transposed data.">transpose</a> function for a safer interface and for the meaning of the other arguments. </p>

</div>
</div>
<a id="ga85e08ea84b3af6cc66afd2333b940ea3" name="ga85e08ea84b3af6cc66afd2333b940ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85e08ea84b3af6cc66afd2333b940ea3">&#9670;&nbsp;</a></span>smallest_root_greater_than_value_within_roundoff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T smallest_root_greater_than_value_within_roundoff </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the smallest root of a quadratic equation \(ax^2 + bx + c = 0\) that is greater than the given value, within roundoff. </p>
<p ><em>Returns:</em> A root of a quadratic equation. </p>
<p ><em>Requires:</em> That there are two real roots. </p>
<p ><em>Requires:</em> At least one root is greater than the given value, to roundoff. </p>

</div>
</div>
<a id="ga2cc85680ebf5d265cc65994dcf6365ee" name="ga2cc85680ebf5d265cc65994dcf6365ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cc85680ebf5d265cc65994dcf6365ee">&#9670;&nbsp;</a></span>toms748() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataVector.html">DataVector</a> RootFinder::toms748 </td>
          <td>(</td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>f_at_lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>f_at_upper_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>absolute_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>relative_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>max_iterations</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the root of the function <code>f</code> with the TOMS_748 method on each element in a <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code>, where function values are supplied at the lower and upper bounds. </p>
<p >Supplying function values is an optimization that saves two function calls per point. The function values are often available because one often checks if the root is bracketed before calling <code>toms748</code>. </p>

</div>
</div>
<a id="ga0e775caa5df400a744eb77c8c6e82a41" name="ga0e775caa5df400a744eb77c8c6e82a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e775caa5df400a744eb77c8c6e82a41">&#9670;&nbsp;</a></span>toms748() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataVector.html">DataVector</a> RootFinder::toms748 </td>
          <td>(</td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>absolute_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>relative_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>max_iterations</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the root of the function <code>f</code> with the TOMS_748 method on each element in a <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code>. </p>
<p ><code>f</code> is a binary invokable that takes a <code>double</code> as its first argument and a <code>size_t</code> as its second. The <code>double</code> is the current value at which to evaluate <code>f</code>, and the <code>size_t</code> is the current index into the <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code>s. Below is an example of how to root find different functions by indexing into a lambda-captured <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code> using the <code>size_t</code> passed to <code>f</code>.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> abs_tol = 1e-15;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> rel_tol = 1e-15;</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classDataVector.html">DataVector</a> upper{2.0, 3.0, -<a class="code hl_function" href="group__TensorExpressionsGroup.html#ga68e742f6a0919a54715253d91318d7bb">sqrt</a>(2.0) + abs_tol, -<a class="code hl_function" href="group__TensorExpressionsGroup.html#ga68e742f6a0919a54715253d91318d7bb">sqrt</a>(2.0)};</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classDataVector.html">DataVector</a> lower{<a class="code hl_function" href="group__TensorExpressionsGroup.html#ga68e742f6a0919a54715253d91318d7bb">sqrt</a>(2.0) - abs_tol, <a class="code hl_function" href="group__TensorExpressionsGroup.html#ga68e742f6a0919a54715253d91318d7bb">sqrt</a>(2.0), -2.0, -3.0};</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classDataVector.html">DataVector</a> constant{2.0, 4.0, 2.0, 4.0};</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> f_lambda = [&amp;constant](<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">size_t</span> i) {</div>
<div class="line">    <span class="keywordflow">return</span> constant[i] - <a class="code hl_function" href="group__ConstantExpressionsGroup.html#gaef1fe82faee8c46e9706f252a5a00937">square</a>(x);</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> root_no_function_values =</div>
<div class="line">      <a class="code hl_function" href="group__NumericalAlgorithmsGroup.html#gaad0c6223fdc3a8a5f4501c88d9a74abc">RootFinder::toms748</a>(f_lambda, lower, upper, abs_tol, rel_tol);</div>
<div class="ttc" id="aclassDataVector_html"><div class="ttname"><a href="classDataVector.html">DataVector</a></div><div class="ttdoc">Stores a collection of function values.</div><div class="ttdef"><b>Definition:</b> DataVector.hpp:48</div></div>
<div class="ttc" id="agroup__ConstantExpressionsGroup_html_gaef1fe82faee8c46e9706f252a5a00937"><div class="ttname"><a href="group__ConstantExpressionsGroup.html#gaef1fe82faee8c46e9706f252a5a00937">square</a></div><div class="ttdeci">constexpr decltype(auto) square(const T &amp;x)</div><div class="ttdoc">Compute the square of x</div><div class="ttdef"><b>Definition:</b> ConstantExpressions.hpp:55</div></div>
<div class="ttc" id="agroup__NumericalAlgorithmsGroup_html_gaad0c6223fdc3a8a5f4501c88d9a74abc"><div class="ttname"><a href="group__NumericalAlgorithmsGroup.html#gaad0c6223fdc3a8a5f4501c88d9a74abc">RootFinder::toms748</a></div><div class="ttdeci">double toms748(const Function &amp;f, const double lower_bound, const double upper_bound, const double f_at_lower_bound, const double f_at_upper_bound, const double absolute_tolerance, const double relative_tolerance, const size_t max_iterations=100)</div><div class="ttdoc">Finds the root of the function f with the TOMS_748 method.</div><div class="ttdef"><b>Definition:</b> TOMS748.hpp:46</div></div>
<div class="ttc" id="agroup__TensorExpressionsGroup_html_ga68e742f6a0919a54715253d91318d7bb"><div class="ttname"><a href="group__TensorExpressionsGroup.html#ga68e742f6a0919a54715253d91318d7bb">sqrt</a></div><div class="ttdeci">auto sqrt(const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;t)</div><div class="ttdoc">Returns the tensor expression representing the square root of a tensor expression that evaluates to a...</div><div class="ttdef"><b>Definition:</b> SquareRoot.hpp:253</div></div>
</div><!-- fragment --><p >For each index <code>i</code> into the <a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a>, the TOMS_748 algorithm searches for a root in the interval [<code>lower_bound[i]</code>, <code>upper_bound[i]</code>], and will throw if this interval does not bracket a root, i.e. if <code>f(lower_bound[i], i) * f(upper_bound[i], i) &gt; 0</code>.</p>
<p >See the <a href="http://www.boost.org/">Boost</a> documentation for more details.</p>
<p ><em>Requires:</em> Function <code>f</code> be callable with a <code>double</code> and a <code>size_t</code></p>
<p ><em>Throws:</em> <code><a class="el" href="classconvergence__error.html" title="Exception indicating convergence failure.">convergence_error</a></code> if, for any index, the requested tolerance is not met after <code>max_iterations</code> iterations. </p>

</div>
</div>
<a id="gaad0c6223fdc3a8a5f4501c88d9a74abc" name="gaad0c6223fdc3a8a5f4501c88d9a74abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad0c6223fdc3a8a5f4501c88d9a74abc">&#9670;&nbsp;</a></span>toms748() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double RootFinder::toms748 </td>
          <td>(</td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>upper_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>f_at_lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>f_at_upper_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>absolute_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>relative_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>max_iterations</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the root of the function <code>f</code> with the TOMS_748 method. </p>
<p ><code>f</code> is a unary invokable that takes a <code>double</code> which is the current value at which to evaluate <code>f</code>. An example is below.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> abs_tol = 1e-15;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> rel_tol = 1e-15;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> upper = 2.0;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> lower = <a class="code hl_function" href="group__TensorExpressionsGroup.html#ga68e742f6a0919a54715253d91318d7bb">sqrt</a>(2.0) - abs_tol;  <span class="comment">// bracket surrounds root</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> f_lambda = [](<span class="keywordtype">double</span> x) { <span class="keywordflow">return</span> 2.0 - <a class="code hl_function" href="group__ConstantExpressionsGroup.html#gaef1fe82faee8c46e9706f252a5a00937">square</a>(x); };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> root = <a class="code hl_function" href="group__NumericalAlgorithmsGroup.html#gaad0c6223fdc3a8a5f4501c88d9a74abc">RootFinder::toms748</a>(f_lambda, lower, upper, abs_tol, rel_tol);</div>
</div><!-- fragment --><p >The TOMS_748 algorithm searches for a root in the interval [<code>lower_bound</code>, <code>upper_bound</code>], and will throw if this interval does not bracket a root, i.e. if <code>f(lower_bound) * f(upper_bound) &gt; 0</code>.</p>
<p >The arguments <code>f_at_lower_bound</code> and <code>f_at_upper_bound</code> are optional, and are the function values at <code>lower_bound</code> and <code>upper_bound</code>. These function values are often known because the user typically checks if a root is bracketed before calling <code>toms748</code>; passing the function values here saves two function evaluations.</p>
<p >See the <a href="http://www.boost.org/">Boost</a> documentation for more details.</p>
<p ><em>Requires:</em> Function <code>f</code> is invokable with a <code>double</code></p>
<p ><em>Throws:</em> <code><a class="el" href="classconvergence__error.html" title="Exception indicating convergence failure.">convergence_error</a></code> if the requested tolerance is not met after <code>max_iterations</code> iterations. </p>

</div>
</div>
<a id="ga9d755157e0d42f3fdae8dace311c1588" name="ga9d755157e0d42f3fdae8dace311c1588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d755157e0d42f3fdae8dace311c1588">&#9670;&nbsp;</a></span>transpose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; T * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>chunk_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>number_of_chunks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute transposed data. </p>
<p >The primary use of this function is to rearrange the memory layout so that another function can operate on contiguous chunks of memory.</p>
<p ><em>Requires:</em> <code>result.size()</code> to be the product of <code>number_of_chunks</code> and <code>chunk_size</code>, <code>u.size()</code> to be equal or greater than <code>result.size()</code>, and that both <code>result</code> and <code>u</code> have a <code>data()</code> member function.</p>
<h3>Details</h3>
<p >The container <code>u</code> holds a contiguous array of data, treated as a sequence of <code>number_of_chunks</code> contiguous sets of entries of size <code>chunk_size</code>. The output <code>result</code> has its data arranged such that the first <code>number_of_chunks</code> elements in <code>result</code> will be the first element of each chunk of <code>u</code>. The last <code>number_of_chunks</code> elements in <code>result</code> will be the last (i.e. <code>chunk_size</code>-th) element of each chunk of <code>u</code>. If <code>u.size()</code> is greater than <code>result.size()</code> the extra elements of <code>u</code> are ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This is equivalent to treating the first part of <code>u</code> as a matrix and filling <code>result</code> (or the returned object) with the transpose of that matrix.</dd></dl>
<p>If <code>u</code> represents a block of data indexed by \((x, y, z, \ldots)\) with the first index varying fastest, transpose serves to rotate the indices. If the extents are \((X, Y, Z, \ldots)\), with product \(N\), <code>transpose(u, X, N/X)</code> reorders the data to be indexed \((y, z, \ldots, x)\), <code>transpose(u, X*Y, N/X/Y)</code> reorders the data to be indexed \((z, \ldots, x, y)\), etc.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classDataVector.html">DataVector</a> matrix{ 1.,  2.,  3.,</div>
<div class="line">                           4.,  5.,  6.,</div>
<div class="line">                           7.,  8.,  9.,</div>
<div class="line">                          10., 11., 12.};</div>
<div class="line">  CHECK(<a class="code hl_function" href="group__NumericalAlgorithmsGroup.html#ga9d755157e0d42f3fdae8dace311c1588">transpose</a>(matrix, 3, 4) == <a class="code hl_class" href="classDataVector.html">DataVector</a>{1.,  4.,  7., 10.,</div>
<div class="line">                                              2.,  5.,  8., 11.,</div>
<div class="line">                                              3.,  6.,  9., 12.});</div>
<div class="ttc" id="agroup__NumericalAlgorithmsGroup_html_ga9d755157e0d42f3fdae8dace311c1588"><div class="ttname"><a href="group__NumericalAlgorithmsGroup.html#ga9d755157e0d42f3fdae8dace311c1588">transpose</a></div><div class="ttdeci">void transpose(const gsl::not_null&lt; T * &gt; result, const U &amp;u, const size_t chunk_size, const size_t number_of_chunks)</div><div class="ttdoc">Function to compute transposed data.</div><div class="ttdef"><b>Definition:</b> Transpose.hpp:81</div></div>
</div><!-- fragment --> <div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> chunk_size_vars = 8;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> n_grid_pts = 2 * chunk_size_vars;</div>
<div class="line">  Variables&lt;two_vars&lt;2&gt;&gt; variables(n_grid_pts, 0.);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; variables.size(); ++i) {</div>
<div class="line">    <span class="comment">// clang-tidy: pointer arithmetic</span></div>
<div class="line">    variables.data()[i] = i * i;  <span class="comment">// NOLINT</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> number_of_chunks_vars = variables.size() / chunk_size_vars;</div>
<div class="line">  <span class="keyword">auto</span> transposed_vars = variables;</div>
<div class="line">  <a class="code hl_function" href="group__NumericalAlgorithmsGroup.html#ga9d755157e0d42f3fdae8dace311c1588">transpose</a>(make_not_null(&amp;transposed_vars), variables, chunk_size_vars,</div>
<div class="line">            number_of_chunks_vars);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; chunk_size_vars; ++i) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; number_of_chunks_vars; ++j) {</div>
<div class="line">      <span class="comment">// clang-tidy: pointer arithmetic</span></div>
<div class="line">      CHECK(variables.data()[i + chunk_size_vars * j] ==             <span class="comment">// NOLINT</span></div>
<div class="line">            transposed_vars.data()[j + number_of_chunks_vars * i]);  <span class="comment">// NOLINT</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
</div><!-- fragment --> <div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> chunk_size = 8;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> number_of_chunks = 2;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> n_pts = chunk_size * number_of_chunks;</div>
<div class="line">  <a class="code hl_class" href="classDataVector.html">DataVector</a> <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/iterator/data.html">data</a>(n_pts);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/iterator/data.html">data</a>.size(); ++i) {</div>
<div class="line">    <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/iterator/data.html">data</a>[i] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(i * i);</div>
<div class="line">  }</div>
<div class="line">  <a class="code hl_class" href="classDataVector.html">DataVector</a> transposed_data(n_pts, 0.);</div>
<div class="line">  transposed_data = <a class="code hl_function" href="group__NumericalAlgorithmsGroup.html#ga9d755157e0d42f3fdae8dace311c1588">transpose</a>(data, chunk_size, number_of_chunks);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; chunk_size; ++i) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; number_of_chunks; ++j) {</div>
<div class="line">      CHECK(data[i + chunk_size * j] ==</div>
<div class="line">            transposed_data[j + number_of_chunks * i]);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="ttc" id="adata_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/iterator/data.html">std::data</a></div><div class="ttdeci">T data(T... args)</div></div>
</div><!-- fragment --> <div class="fragment"><div class="line">  Variables&lt;one_var&lt;2&gt;&gt; partial_vars(n_grid_pts, 0.);</div>
<div class="line">  get&lt;Var1&lt;2&gt;&gt;(partial_vars) = <a class="code hl_function" href="group__DataBoxGroup.html#gaa36fa9cf94ab1cb05c5a6e23d56f79ae">get</a>&lt;Var1&lt;2&gt;&gt;(variables);</div>
<div class="line">  Variables&lt;one_var&lt;2&gt;&gt; partial_transpose(n_grid_pts, 0.);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> partial_number_of_chunks = 2 * number_of_chunks_vars / 3;</div>
<div class="line">  <a class="code hl_function" href="group__NumericalAlgorithmsGroup.html#ga9d755157e0d42f3fdae8dace311c1588">transpose</a>(make_not_null(&amp;partial_transpose), variables, chunk_size_vars,</div>
<div class="line">            partial_number_of_chunks);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; chunk_size_vars; ++i) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; partial_number_of_chunks; ++j) {</div>
<div class="line">      <span class="comment">// clang-tidy: pointer arithmetic</span></div>
<div class="line">      CHECK(partial_transpose</div>
<div class="line">                .<a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/iterator/data.html">data</a>()[j + partial_number_of_chunks * i] ==  <span class="comment">// NOLINT</span></div>
<div class="line">            variables.data()[i + chunk_size_vars * j]);       <span class="comment">// NOLINT</span></div>
<div class="line">      CHECK(partial_transpose</div>
<div class="line">                .<a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/iterator/data.html">data</a>()[j + partial_number_of_chunks * i] ==  <span class="comment">// NOLINT</span></div>
<div class="line">            partial_vars.data()[i + chunk_size_vars * j]);    <span class="comment">// NOLINT</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="ttc" id="agroup__DataBoxGroup_html_gaa36fa9cf94ab1cb05c5a6e23d56f79ae"><div class="ttname"><a href="group__DataBoxGroup.html#gaa36fa9cf94ab1cb05c5a6e23d56f79ae">db::get</a></div><div class="ttdeci">const auto &amp; get(const DataBox&lt; TagList &gt; &amp;box)</div><div class="ttdoc">Retrieve the item with tag Tag from the DataBox.</div><div class="ttdef"><b>Definition:</b> DataBox.hpp:850</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>the type of data to be transposed </td></tr>
    <tr><td class="paramname">T</td><td>the type of the transposed data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab66a7469bcf39a26f2c69a3689c0c46f" name="gab66a7469bcf39a26f2c69a3689c0c46f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab66a7469bcf39a26f2c69a3689c0c46f">&#9670;&nbsp;</a></span>transpose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename T  = U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T transpose </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>chunk_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>number_of_chunks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute transposed data. </p>
<p >The primary use of this function is to rearrange the memory layout so that another function can operate on contiguous chunks of memory.</p>
<p ><em>Requires:</em> <code>result.size()</code> to be the product of <code>number_of_chunks</code> and <code>chunk_size</code>, <code>u.size()</code> to be equal or greater than <code>result.size()</code>, and that both <code>result</code> and <code>u</code> have a <code>data()</code> member function.</p>
<h3>Details</h3>
<p >The container <code>u</code> holds a contiguous array of data, treated as a sequence of <code>number_of_chunks</code> contiguous sets of entries of size <code>chunk_size</code>. The output <code>result</code> has its data arranged such that the first <code>number_of_chunks</code> elements in <code>result</code> will be the first element of each chunk of <code>u</code>. The last <code>number_of_chunks</code> elements in <code>result</code> will be the last (i.e. <code>chunk_size</code>-th) element of each chunk of <code>u</code>. If <code>u.size()</code> is greater than <code>result.size()</code> the extra elements of <code>u</code> are ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This is equivalent to treating the first part of <code>u</code> as a matrix and filling <code>result</code> (or the returned object) with the transpose of that matrix.</dd></dl>
<p>If <code>u</code> represents a block of data indexed by \((x, y, z, \ldots)\) with the first index varying fastest, transpose serves to rotate the indices. If the extents are \((X, Y, Z, \ldots)\), with product \(N\), <code>transpose(u, X, N/X)</code> reorders the data to be indexed \((y, z, \ldots, x)\), <code>transpose(u, X*Y, N/X/Y)</code> reorders the data to be indexed \((z, \ldots, x, y)\), etc.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classDataVector.html">DataVector</a> matrix{ 1.,  2.,  3.,</div>
<div class="line">                           4.,  5.,  6.,</div>
<div class="line">                           7.,  8.,  9.,</div>
<div class="line">                          10., 11., 12.};</div>
<div class="line">  CHECK(<a class="code hl_function" href="group__NumericalAlgorithmsGroup.html#ga9d755157e0d42f3fdae8dace311c1588">transpose</a>(matrix, 3, 4) == <a class="code hl_class" href="classDataVector.html">DataVector</a>{1.,  4.,  7., 10.,</div>
<div class="line">                                              2.,  5.,  8., 11.,</div>
<div class="line">                                              3.,  6.,  9., 12.});</div>
</div><!-- fragment --> <div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> chunk_size_vars = 8;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> n_grid_pts = 2 * chunk_size_vars;</div>
<div class="line">  Variables&lt;two_vars&lt;2&gt;&gt; variables(n_grid_pts, 0.);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; variables.size(); ++i) {</div>
<div class="line">    <span class="comment">// clang-tidy: pointer arithmetic</span></div>
<div class="line">    variables.data()[i] = i * i;  <span class="comment">// NOLINT</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> number_of_chunks_vars = variables.size() / chunk_size_vars;</div>
<div class="line">  <span class="keyword">auto</span> transposed_vars = variables;</div>
<div class="line">  <a class="code hl_function" href="group__NumericalAlgorithmsGroup.html#ga9d755157e0d42f3fdae8dace311c1588">transpose</a>(make_not_null(&amp;transposed_vars), variables, chunk_size_vars,</div>
<div class="line">            number_of_chunks_vars);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; chunk_size_vars; ++i) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; number_of_chunks_vars; ++j) {</div>
<div class="line">      <span class="comment">// clang-tidy: pointer arithmetic</span></div>
<div class="line">      CHECK(variables.data()[i + chunk_size_vars * j] ==             <span class="comment">// NOLINT</span></div>
<div class="line">            transposed_vars.data()[j + number_of_chunks_vars * i]);  <span class="comment">// NOLINT</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
</div><!-- fragment --> <div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> chunk_size = 8;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> number_of_chunks = 2;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> n_pts = chunk_size * number_of_chunks;</div>
<div class="line">  <a class="code hl_class" href="classDataVector.html">DataVector</a> <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/iterator/data.html">data</a>(n_pts);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/iterator/data.html">data</a>.size(); ++i) {</div>
<div class="line">    <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/iterator/data.html">data</a>[i] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(i * i);</div>
<div class="line">  }</div>
<div class="line">  <a class="code hl_class" href="classDataVector.html">DataVector</a> transposed_data(n_pts, 0.);</div>
<div class="line">  transposed_data = <a class="code hl_function" href="group__NumericalAlgorithmsGroup.html#ga9d755157e0d42f3fdae8dace311c1588">transpose</a>(data, chunk_size, number_of_chunks);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; chunk_size; ++i) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; number_of_chunks; ++j) {</div>
<div class="line">      CHECK(data[i + chunk_size * j] ==</div>
<div class="line">            transposed_data[j + number_of_chunks * i]);</div>
<div class="line">    }</div>
<div class="line">  }</div>
</div><!-- fragment --> <div class="fragment"><div class="line">  Variables&lt;one_var&lt;2&gt;&gt; partial_vars(n_grid_pts, 0.);</div>
<div class="line">  get&lt;Var1&lt;2&gt;&gt;(partial_vars) = <a class="code hl_function" href="group__DataBoxGroup.html#gaa36fa9cf94ab1cb05c5a6e23d56f79ae">get</a>&lt;Var1&lt;2&gt;&gt;(variables);</div>
<div class="line">  Variables&lt;one_var&lt;2&gt;&gt; partial_transpose(n_grid_pts, 0.);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> partial_number_of_chunks = 2 * number_of_chunks_vars / 3;</div>
<div class="line">  <a class="code hl_function" href="group__NumericalAlgorithmsGroup.html#ga9d755157e0d42f3fdae8dace311c1588">transpose</a>(make_not_null(&amp;partial_transpose), variables, chunk_size_vars,</div>
<div class="line">            partial_number_of_chunks);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; chunk_size_vars; ++i) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; partial_number_of_chunks; ++j) {</div>
<div class="line">      <span class="comment">// clang-tidy: pointer arithmetic</span></div>
<div class="line">      CHECK(partial_transpose</div>
<div class="line">                .<a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/iterator/data.html">data</a>()[j + partial_number_of_chunks * i] ==  <span class="comment">// NOLINT</span></div>
<div class="line">            variables.data()[i + chunk_size_vars * j]);       <span class="comment">// NOLINT</span></div>
<div class="line">      CHECK(partial_transpose</div>
<div class="line">                .<a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/iterator/data.html">data</a>()[j + partial_number_of_chunks * i] ==  <span class="comment">// NOLINT</span></div>
<div class="line">            partial_vars.data()[i + chunk_size_vars * j]);    <span class="comment">// NOLINT</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>the type of data to be transposed </td></tr>
    <tr><td class="paramname">T</td><td>the type of the transposed data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae0fb506cacdbda9491794de0060a61f0" name="gae0fb506cacdbda9491794de0060a61f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0fb506cacdbda9491794de0060a61f0">&#9670;&nbsp;</a></span>weak_divergence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... FluxTags, size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void weak_divergence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; tmpl::list&lt; <a class="el" href="structTags_1_1div.html">Tags::div</a>&lt; FluxTags &gt;... &gt; &gt; * &gt;&#160;</td>
          <td class="paramname"><em>divergence_of_fluxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Variables&lt; tmpl::list&lt; FluxTags... &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>fluxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>det_jac_times_inverse_jacobian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the weak form divergence of fluxes. </p>
<p >In a discontinuous Galerkin scheme we integrate the equations against the basis functions over the element. For the flux divergence term this gives:</p>
<p class="formulaDsp">
\begin{align*} \int_{\Omega}d^n x \phi_{\breve{\imath}}\partial_i F^i, \end{align*}
</p>
<p >where the basis functions are denoted by \(\phi_{\breve{\imath}}\).</p>
<p >Integrating by parts we get</p>
<p class="formulaDsp">
\begin{align*} \int_{\Omega}d^n x\, \phi_{\breve{\imath}}\partial_i F^i = -\int_{\Omega}d^n x\, F^i \partial_i \phi_{\breve{\imath}} + \int_{\partial\Omega} d^{(n-1)}\Sigma\, n_i F^i \phi_{\breve{\imath}} \end{align*}
</p>
<p >Next we expand the flux \(F^i\) in terms of the basis functions, yielding</p>
<p class="formulaDsp">
\begin{align*} - \int_{\Omega}d^n x\,F^i_{\breve{\jmath}} \phi_{\breve{\jmath}} \partial_i \phi_{\breve{\imath}} + \int_{\partial\Omega} d^{(n-1)}\Sigma\, n_i F^i_{\breve{\jmath}} \phi_{\breve{\jmath}} \phi_{\breve{\imath}} \end{align*}
</p>
<p >This function computes the volume term:</p>
<p class="formulaDsp">
\begin{align*} \int_{\Omega}d^n x\,F^i_{\breve{\jmath}} \phi_{\breve{\jmath}} \partial_i \phi_{\breve{\imath}} \end{align*}
</p>
<dl class="section note"><dt>Note</dt><dd>When using Gauss-Lobatto points the numerical values of the divergence are the same for the strong and weak divergence at the interior points. When using Gauss points they are only the same at the central grid point and only when an odd number of grid points is used. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
