<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: TensorExpression&lt; Derived, DataType, Symm, tmpl::list&lt; Indices... &gt;, ArgsList&lt; Args... &gt; &gt; Struct Template Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structTensorExpression_3_01Derived_00_01DataType_00_01Symm_00_01tmpl_1_1list_3_01Indices_8_8_8_0325e1bafc70f036ee2f18c4f6a988515.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="structTensorExpression_3_01Derived_00_01DataType_00_01Symm_00_01tmpl_1_1list_3_01Indices_8_8_8_0ccad0197582a1440fe1509185c0d0773.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TensorExpression&lt; Derived, DataType, Symm, tmpl::list&lt; Indices... &gt;, ArgsList&lt; Args... &gt; &gt; Struct Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__TensorExpressionsGroup.html">Tensor Expressions</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>The base class all tensor expression implementations derive from.  
 <a href="structTensorExpression_3_01Derived_00_01DataType_00_01Symm_00_01tmpl_1_1list_3_01Indices_8_8_8_0325e1bafc70f036ee2f18c4f6a988515.html#details">More...</a></p>

<p><code>#include &lt;TensorExpression.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6f86f36b39f0e1afb5f8279d26065201"><td class="memItemLeft" align="right" valign="top"><a id="a6f86f36b39f0e1afb5f8279d26065201" name="a6f86f36b39f0e1afb5f8279d26065201"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>type</b> = DataType</td></tr>
<tr class="memdesc:a6f86f36b39f0e1afb5f8279d26065201"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the data being stored in the <code>Tensor</code>s. <br /></td></tr>
<tr class="separator:a6f86f36b39f0e1afb5f8279d26065201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08bd1509fd7c09b53353a8dfd821a13c"><td class="memItemLeft" align="right" valign="top"><a id="a08bd1509fd7c09b53353a8dfd821a13c" name="a08bd1509fd7c09b53353a8dfd821a13c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>symmetry</b> = Symm</td></tr>
<tr class="memdesc:a08bd1509fd7c09b53353a8dfd821a13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9" title="Computes the canonical symmetry from the integers T">Symmetry</a> of the <code>Derived</code> class. <br /></td></tr>
<tr class="separator:a08bd1509fd7c09b53353a8dfd821a13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43e0e7396096f1b3e431e1fb388502a"><td class="memItemLeft" align="right" valign="top"><a id="ab43e0e7396096f1b3e431e1fb388502a" name="ab43e0e7396096f1b3e431e1fb388502a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>index_list</b> = tmpl::list&lt; Indices... &gt;</td></tr>
<tr class="memdesc:ab43e0e7396096f1b3e431e1fb388502a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a>s. <br /></td></tr>
<tr class="separator:ab43e0e7396096f1b3e431e1fb388502a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810c46bb774bb3832bcd50ff4f744a6d"><td class="memItemLeft" align="right" valign="top"><a id="a810c46bb774bb3832bcd50ff4f744a6d" name="a810c46bb774bb3832bcd50ff4f744a6d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>args_list</b> = ArgsList&lt; Args... &gt;</td></tr>
<tr class="memdesc:a810c46bb774bb3832bcd50ff4f744a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typelist of the tensor indices, e.g. types of <code>ti_a</code> and <code>ti_b</code> in <code>F(ti_a, ti_b)</code> <br /></td></tr>
<tr class="separator:a810c46bb774bb3832bcd50ff4f744a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adee8354856d909bb929f9df3c9ea6d22"><td class="memItemLeft" align="right" valign="top">const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorExpression_3_01Derived_00_01DataType_00_01Symm_00_01tmpl_1_1list_3_01Indices_8_8_8_0325e1bafc70f036ee2f18c4f6a988515.html#adee8354856d909bb929f9df3c9ea6d22">operator~</a> () const</td></tr>
<tr class="memdesc:adee8354856d909bb929f9df3c9ea6d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived is casted down to the derived class. This is enabled by the <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP</a>  <a href="structTensorExpression_3_01Derived_00_01DataType_00_01Symm_00_01tmpl_1_1list_3_01Indices_8_8_8_0325e1bafc70f036ee2f18c4f6a988515.html#adee8354856d909bb929f9df3c9ea6d22">More...</a><br /></td></tr>
<tr class="separator:adee8354856d909bb929f9df3c9ea6d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a02528b68c4dd7e1be08dcd6bc3221a43"><td class="memItemLeft" align="right" valign="top"><a id="a02528b68c4dd7e1be08dcd6bc3221a43" name="a02528b68c4dd7e1be08dcd6bc3221a43"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>num_tensor_indices</b> = tmpl::size&lt;<a class="el" href="structTensorExpression_3_01Derived_00_01DataType_00_01Symm_00_01tmpl_1_1list_3_01Indices_8_8_8_0325e1bafc70f036ee2f18c4f6a988515.html#ab43e0e7396096f1b3e431e1fb388502a">index_list</a>&gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a></td></tr>
<tr class="memdesc:a02528b68c4dd7e1be08dcd6bc3221a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of tensor indices of the <code>Derived</code> class. <br /></td></tr>
<tr class="separator:a02528b68c4dd7e1be08dcd6bc3221a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Derived, typename DataType, typename Symm, typename... Indices, template&lt; typename... &gt; class ArgsList, typename... Args&gt;<br />
struct TensorExpression&lt; Derived, DataType, Symm, tmpl::list&lt; Indices... &gt;, ArgsList&lt; Args... &gt; &gt;</div><p >The base class all tensor expression implementations derive from. </p>
<h3>Details</h3>
<h2><a class="anchor" id="autotoc_md214"></a>
Tensor equation construction</h2>
<p >Each derived <code>TensorExpression</code> class should be thought of as an expression tree that represents some operation done on or between tensor expressions. Arithmetic operators and other mathematical functions of interest (e.g. <code>sqrt</code>) have overloads defined that accept <code>TensorExpression</code>s and return a new <code>TensorExpression</code> representing the result tensor of such an operation. In this way, an equation written with <code>TensorExpression</code>s will generate an expression tree where the internal and leaf nodes are instances of the derived <code>TensorExpression</code> classes. For example, <code><a class="el" href="structtenex_1_1AddSub.html" title="Defines the tensor expression representing the addition or subtraction of two tensor expressions.">tenex::AddSub</a></code> defines an internal node for handling the addition and subtraction operations between tensors expressions, while <code><a class="el" href="structtenex_1_1TensorAsExpression.html" title="Defines an expression representing a Tensor.">tenex::TensorAsExpression</a></code> defines a leaf node that represents a single <code>Tensor</code> that appears in the equation.</p>
<h2><a class="anchor" id="autotoc_md215"></a>
Tensor equation evaluation</h2>
<p >The overall tree for an equation and the order in which we traverse the tree define the order of operations done to compute the resulting LHS <code>Tensor</code>. The evaluation is done by <code><a class="el" href="group__TensorExpressionsGroup.html#ga44bc58678768c8978ac7f6d47b2f7d17" title="Assign the result of a RHS tensor expression to a tensor with the LHS index order set in the template...">tenex::evaluate</a></code>, which traverses the whole tree once for each unique LHS component in order to evaluate the full LHS <code>Tensor</code>. There are two different traversals currently implemented that are chosen from, depending on the tensor equation being evaluated:</p><ol type="1">
<li><b>Evaluate the whole tree as one expression</b> using in-order traversal. This is like generating and solving a one-liner of the whole equation.</li>
<li><b>Split up the tree into subexpressions</b> that are each evaluated with in-order traversal to successively "accumulate" a LHS result component of the equation. This is like splitting the equation up and solving pieces of it at a time with multiple lines of assignments/updates (see details below).</li>
</ol>
<h2><a class="anchor" id="autotoc_md216"></a>
Equation splitting details</h2>
<p >Splitting up the tree and evaluating subexpressions is beneficial when we believe it to lead to a better runtime than if we were to compute the whole expression as a one-liner. One important use case is when the <code>Tensor</code>s in the equation hold components whose data type is <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code>. From benchmarking, it was found that the runtime of <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code> expressions scales poorly as we increase the number of operations. For example, for an inner product with 256 sums of products, instead of adding 256 <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code> products in one line (e.g. <code>result = A*B + C*D + E*F + ...;</code>), it's much faster to, say, set the result to be the sum of the first 8 products, then <code>+=</code> the next 8, and so forth. This is what is meant by "accumulating" the LHS result tensor, and what the <code>TensorExpression</code> splitting emulates. Note that while 8 is the number used in this example, the exact optimal number of operations will be hardware-dependent, but probably not something we need to really worry about fine-tuning. However, a ballpark estimate for a "good" number of operations may vary greatly depending on the data type of the components (e.g. <code>double</code> vs. <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code>), which is something important to at least coarsely tune.</p>
<h3><a class="anchor" id="autotoc_md217"></a>
How the tree is split up</h3>
<p >Let's define the <b>primary path</b> to be the path in the tree going from the root node to the leftmost leaf. The overall tree contains subtrees represented by different <code>TensorExpression</code>s in the equation. Certain subtrees are marked as the starting and/or ending points of these "pieces" of the equation. Let's define a <b>leg</b> to be a "segment" along the primary path delineated by a starting and ending expression subtree. These delineations are made where we decide there are enough operations in a subtree that it would be wise to split at that point. What is considered to be "enough" operations is specialized based on the data type held by the <code>Tensor</code>s in the expression (see <code>tenex::max_num_ops_in_sub_expression</code>).</p>
<h3><a class="anchor" id="autotoc_md218"></a>
How a split tree is traversed and evaluated</h3>
<p >We recurse down the primary path, visiting each expression subtree until we reach the start of the lowest leg, then initialize the LHS result component we're wanting to compute to be the result of this lowest expression. Then, we recurse back up to the expression subtree that is starting point of the leg "above" it and compute that subtree. This time, however, when recursively evaluating this higher subtree, we substitute in the current LHS result for that lower subtree that we have already computed. This is repeated as we "climb up" the primary path to successively accumulate the result component.</p>
<p ><b>Note:</b> The primary path is currently implemented as the path specified above, but there's no reason it couldn't be reimplemented to be a different path. The idea with the current implementation is to select a path from root to leaf that is long so we have more flexibility in splitting, should we want to. When evaluating, we <em>could</em> implement the traversal to take a different path, but currently, derived <code>TensorExpression</code>s that represent commutative binary operations are instantiated with the larger subtree being the left child and the smaller subtree being the right child. By constructing it this way, we elongate the leftmost path, which will allow for increased splitting.</p>
<h2><a class="anchor" id="autotoc_md219"></a>
Requirements for derived &lt;tt&gt;TensorExpression&lt;/tt&gt; classes</h2>
<p >Each derived <code>TensorExpression</code> class must define the following aliases and members:</p><ul>
<li><code>private</code> variables that store its operands' derived <code>TensorExpression</code>s. We make these non-<code>const</code> to allow for move construction.</li>
<li>Constructor that initializes the above <code>private</code> operand members</li>
<li>alias <code>type</code>: The data type of the data being stored in the result of the expression, e.g. <code>double</code>, <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code></li>
<li>alias <code>symmetry</code>: The <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9" title="Computes the canonical symmetry from the integers T">Symmetry</a> of the result of the expression</li>
<li>alias <code>index_list</code>: The list of <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a>s of the result of the expression</li>
<li>alias <code>args_list</code>: The list of generic <code><a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a></code>s of the result of the expression</li>
<li>variable <code>static constexpr size_t num_tensor_indices</code>: The number of tensor indices in the result of the expression</li>
<li>variable <code>static constexpr size_t num_ops_left_child</code>: The number of arithmetic tensor operations done in the subtree for the expression's left operand. If the expression represents a unary operation, their only child is considered the left child. If the expression is a leaf node, then this value should be set to 0 since retrieving a value at the leaf involves 0 arithmetic tensor operations.</li>
<li>variable <code>static constexpr size_t num_ops_right_child</code>: The number of arithmetic tensor operations done in the expression's right operand. If the expression represents a unary operation or is leaf node, this should be set to 0 because there is no right child.</li>
<li>variable <code>static constexpr size_t num_ops_subtree</code>: The number of arithmetic tensor operations done in the subtree represented by the expression. For <code>AddSub</code>, for example, this is <code>num_ops_left_child + num_ops_right_child + 1</code>, the sum of the number of operations in each operand's subtrees plus one for the operation done for the expression, itself.</li>
<li>variable <code>static constexpr size_t height_relative_to_closest_tensor_leaf_in_subtree</code> : The height of an expression's node in the overall expression tree relative to the closest <code>TensorAsExpression</code> leaf in its subtree. This is stored so that we can traverse from the root along the shortest path to a <code>Tensor</code> when retrieving the size of a component from the RHS expression (see <code>get_rhs_tensor_component_size()</code> below). Non-<code>Tensor</code> leaves (e.g. <code>NumberAsExpression</code>) are defined to have maximum height <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits</a>&lt;size_t&gt;::max()</code> to encode that they are maximally far away from their nearest <code>Tensor</code> descendant, since the expression's subtree (a leaf) can never have a <code>TensorAsExpression</code> descedant from it. This maximal height is leveraged by <code>get_rhs_tensor_component_size()</code> so that in traversing the expression tree to find a <code>Tensor</code>, it will never take the path that ends in a non-<code>Tensor</code> leaf because it is the worst path option.</li>
<li>function <code>decltype(auto) get(const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;size_t, num_tensor_indices&gt;&amp; result_multi_index) const</code>: Accepts a multi-index for the result tensor represented by the expression and returns the computed result of the expression at that multi-index. This should call the operands' <code>get</code> functions in order to recursively compute the result of the expression.</li>
<li>function template <code>template &lt;typename LhsTensor&gt; void assert_lhs_tensor_not_in_rhs_expression( const <a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a>&lt;LhsTensor*&gt; lhs_tensor) const</code>: Asserts that the LHS <code>Tensor</code> we're computing does not also appear in the RHS <code>TensorExpression</code>. We define this because if a tree is split up, then the LHS <code>Tensor</code> will generally not be computed correctly because the LHS components will be updated as we traverse the split tree.</li>
<li>function template <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> LhsTensorIndices, <span class="keyword">typename</span> LhsTensor&gt;</div>
<div class="line"><span class="keywordtype">void</span> assert_lhs_tensorindices_same_in_rhs(</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="classgsl_1_1not__null.html">gsl::not_null&lt;LhsTensor*&gt;</a> lhs_tensor) <span class="keyword">const</span>;</div>
<div class="ttc" id="aclassgsl_1_1not__null_html"><div class="ttname"><a href="classgsl_1_1not__null.html">gsl::not_null</a></div><div class="ttdoc">Require a pointer to not be a nullptr</div><div class="ttdef"><b>Definition:</b> Gsl.hpp:183</div></div>
</div><!-- fragment --> Asserts that any instance of the LHS <code>Tensor</code> in the RHS <code>TensorExpression</code> uses the same generic index order that the LHS uses. We define this because if a tree is not split up, it's safe to use the LHS <code>Tensor</code> on the RHS if the generic index order is the same. In these cases, <code><a class="el" href="group__TensorExpressionsGroup.html#ga387632ac6d9e87f550a1cc678d1f6f76" title="If the LHS tensor is used in the RHS expression, this should be used to assign a LHS tensor to the re...">tenex::update</a></code> should be used instead of <code><a class="el" href="group__TensorExpressionsGroup.html#ga44bc58678768c8978ac7f6d47b2f7d17" title="Assign the result of a RHS tensor expression to a tensor with the LHS index order set in the template...">tenex::evaluate</a></code>. See the documentation for <code><a class="el" href="group__TensorExpressionsGroup.html#ga387632ac6d9e87f550a1cc678d1f6f76" title="If the LHS tensor is used in the RHS expression, this should be used to assign a LHS tensor to the re...">tenex::update</a></code> for more details and <code>tenex::detail::evaluate_impl</code> for why this is safe to do.</li>
<li>function <code>size_t get_rhs_tensor_component_size() const</code>: Gets the size of a component from a <code>Tensor</code> in an expression's subtree of the RHS expression. This is used to size LHS components, if needed. Utilizes <code>height_relative_to_closest_tensor_leaf_in_subtree</code> to recursively find the nearest <code>TensorAsExpression</code> descendant leaf.</li>
</ul>
<p >Each derived <code>TensorExpression</code> class must also define the following members, which have real meaning for the expression <em>only</em> if it ends up belonging to the primary path of the tree that is traversed:</p><ul>
<li>variable <code>static constexpr bool is_primary_start</code>: If on the primary path, whether or not the expression is a starting point of a leg. This is true when there are enough operations to warrant splitting (see <code>tenex::max_num_ops_in_sub_expression</code>).</li>
<li>variable <code>static constexpr bool is_primary_end</code>: If on the primary path, whether or not the expression is an ending point of a leg. This is true when the expression's child along the primary path is a starting point of a leg.</li>
<li>variable <code>static constexpr size_t num_ops_to_evaluate_primary_left_child</code>: If on the primary path, this is the remaining number of arithmetic tensor operations that need to be done in the subtree of the child along the primary path, given that we will have already computed the whole subtree at the next lowest leg's starting point.</li>
<li>variable <code>static constexpr size_t num_ops_to_evaluate_primary_right_child</code>: If on the primary path, this is the remaining number of arithmetic tensor operations that need to be done in the right operand's subtree. Because the branches off of the primary path currently are not split up in any way, this currently should simply be equal to <code>num_ops_right_child</code>. If logic is added to split up these branches, logic will need to be added to compute this remaining number of operations in the right subtree.</li>
<li>variable <code>static constexpr size_t num_ops_to_evaluate_primary_subtree</code>: If on the primary path, this is the remaining number of arithmetic tensor operations that need to be done for this expression's subtree, given that we will have already computed the subtree at the next lowest leg's starting point. For example, for <code><a class="el" href="structtenex_1_1AddSub.html" title="Defines the tensor expression representing the addition or subtraction of two tensor expressions.">tenex::AddSub</a></code>, this is just <code>num_ops_to_evaluate_primary_left_child + num_ops_to_evaluate_primary_right_child + 1</code> (the extra 1 for the <code>+</code> or <code>-</code> operation itself).</li>
<li>variable <code>static constexpr bool primary_child_subtree_contains_primary_start</code>: If on the primary path, whether or not the expression's child along the primary path is a subtree that contains a starting point of a leg along the primary path. In other words, whether or not there is a split on the primary path lower than this expression. When evaluating a split tree, this is useful because it tells us we need to keep recursing down to a lower leg and evaluate that lower subtree first before evaluating the current subtree.</li>
<li>variable <code>static constexpr bool primary_subtree_contains_primary_start</code>: If on the primary path, whether or not this subtree contains a starting point of a leg along the primary path. In other words, whether or not there is a split on the primary path at this expression or beneath it.</li>
<li>function template <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ResultType&gt;</div>
<div class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) get_primary(</div>
<div class="line">    ResultType&amp; result_component,</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;size_t, num_tensor_indices&gt;</a>&amp; result_multi_index) <span class="keyword">const</span></div>
<div class="ttc" id="aarray_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a></div></div>
</div><!-- fragment --> This is similar to the required <code>get</code> function described above, but this should be used when the tree is split up. The main difference with this function is that it takes the current result component (that we're computing) as an argument, and when we hit the starting point of the next lowest leg on the primary path when recursively evaluating the current leg, we substitute in the current LHS result for the subtree that we have already computed. This function should call <code>get_primary</code> on the child on the primary path and <code>get</code> on the other child, if one exists.</li>
<li>function template <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ResultType&gt;</div>
<div class="line"><span class="keywordtype">void</span> evaluate_primary_subtree(</div>
<div class="line">    ResultType&amp; result_component,</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;size_t, num_tensor_indices&gt;</a>&amp; result_multi_index) <span class="keyword">const</span></div>
</div><!-- fragment --> This should first recursively evaluate the legs beneath it on the primary path, then if the expression itself is the start of a leg, it should evaluate this leg by calling the expression's own <code>get_primary</code> to compute it and update the result component being accumulated. <code><a class="el" href="group__TensorExpressionsGroup.html#ga44bc58678768c8978ac7f6d47b2f7d17" title="Assign the result of a RHS tensor expression to a tensor with the LHS index order set in the template...">tenex::evaluate</a></code> should call this function on the root node for the whole tree if there is determined to be any splits in the tree.</li>
</ul>
<h2><a class="anchor" id="autotoc_md220"></a>
Data type support</h2>
<p >Which types can be used, which operations with which types can be performed, and other type-specific support and configuration can be found in <code>DataStructures/Tensor/Expressions/DataTypeSupport.hpp</code>. To add support for equation terms with a certain type or to modify the configuration for a type that is already supported, see the contents of that file and modify settings as necessary.</p>
<h2><a class="anchor" id="autotoc_md221"></a>
Current advice for improving and extending &lt;tt&gt;TensorExpression&lt;/tt&gt;s</h2>
<ul>
<li>Derived <code>TensorExpression</code> classes (or the overloads that produce them) should include <code>static_assert</code>s for ensuring mathematical correctness wherever reasonable</li>
<li>Minimize breadth in the tree where possible because benchmarking inner products has shown that increased tree breadth can cause slower runtimes. In addition, more breadth means a decreased ability to split up the tree along the primary path.</li>
<li>Minimize the number of multi-index transformations that need to be done when evaluating the tree. For some operations like addition, the associated multi-indices of the two operands needs to be computed from the multi-index of the result, which may involve reordering and/or shifting the values of the result index. It's good to minimize the number of these kinds of transformations from result to operand multi-index where we can.</li>
<li>Unless the implementation of Tensor_detail::Structure changes, it's not advised for the derived <code>TensorExpression</code> classes to have anything that would instantiate the Tensor_detail::Structure of the tensor that would result from the expression. This is really only a problem when the result of the expression would be a tensor with many components, because the compile time of the mapping between storage indices and multi-indices within Tensor_detail::Structure scales very poorly with the number of components. It's important to keep in mind that while SpECTRE currently only supports creating <code>Tensor</code>s up to rank 4, there is nothing preventing the represented result tensor of a expression being higher rank, e.g. <code>R(ti_j, ti_b, ti_A) * (S(ti_d, ti_a, ti_B, ti_C) * T(ti_J, ti_k, ti_l))</code> contains an intermediate outer product expression <code>S(ti_d, ti_a, ti_B, ti_C) * T(ti_J, ti_k, ti_l)</code> that represents a rank 7 tensor, even though a rank 7 <code>Tensor</code> is never instantiated. Having the outer product expression instantiate the Tensor_detail::Structure of this intermediate result currently leads to an unreasonable compile time.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>the derived class needed for <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP</a> </td></tr>
    <tr><td class="paramname">DataType</td><td>the type of the data being stored in the <code>Tensor</code>s </td></tr>
    <tr><td class="paramname">Symm</td><td>the <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9" title="Computes the canonical symmetry from the integers T">Symmetry</a> of the Derived class </td></tr>
    <tr><td class="paramname">IndexList</td><td>the list of <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a>s </td></tr>
    <tr><td class="paramname">Args</td><td>typelist of the tensor indices, e.g. types of <code>ti::a</code> and <code>ti::b</code> in <code>F(ti::a, ti::b)</code> </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="adee8354856d909bb929f9df3c9ea6d22" name="adee8354856d909bb929f9df3c9ea6d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee8354856d909bb929f9df3c9ea6d22">&#9670;&nbsp;</a></span>operator~()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename DataType , typename Symm , typename... Indices, template&lt; typename... &gt; class ArgsList, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto &amp; TensorExpression&lt; Derived, DataType, Symm, tmpl::list&lt; Indices... &gt;, ArgsList&lt; Args... &gt; &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived is casted down to the derived class. This is enabled by the <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP</a> </p>
<p ><em>Returns:</em> const TensorExpression&lt;Derived, DataType, Symm, IndexList, ArgsList&lt;Args...&gt;&gt;&amp; </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>src/DataStructures/Tensor/Expressions/TensorExpression.hpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structTensorExpression_3_01Derived_00_01DataType_00_01Symm_00_01tmpl_1_1list_3_01Indices_8_8_8_0325e1bafc70f036ee2f18c4f6a988515.html">TensorExpression&lt; Derived, DataType, Symm, tmpl::list&lt; Indices... &gt;, ArgsList&lt; Args... &gt; &gt;</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
