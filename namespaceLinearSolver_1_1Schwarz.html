<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: LinearSolver::Schwarz Namespace Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceLinearSolver_1_1Schwarz.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">LinearSolver::Schwarz Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Items related to the Schwarz linear solver.  
<a href="namespaceLinearSolver_1_1Schwarz.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceLinearSolver_1_1Schwarz_1_1Actions"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLinearSolver_1_1Schwarz_1_1Actions.html">Actions</a></td></tr>
<tr class="memdesc:namespaceLinearSolver_1_1Schwarz_1_1Actions"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceLinearSolver_1_1Schwarz_1_1Actions.html" title="Actions related to the Schwarz solver.">Actions</a> related to the <a class="el" href="structLinearSolver_1_1Schwarz_1_1Schwarz.html" title="An additive Schwarz subdomain solver for linear systems of equations .">Schwarz</a> solver. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceLinearSolver_1_1Schwarz_1_1OptionTags"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLinearSolver_1_1Schwarz_1_1OptionTags.html">OptionTags</a></td></tr>
<tr class="memdesc:namespaceLinearSolver_1_1Schwarz_1_1OptionTags"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option tags related to the <a class="el" href="structLinearSolver_1_1Schwarz_1_1Schwarz.html" title="An additive Schwarz subdomain solver for linear systems of equations .">Schwarz</a> solver. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceLinearSolver_1_1Schwarz_1_1Tags"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLinearSolver_1_1Schwarz_1_1Tags.html">Tags</a></td></tr>
<tr class="memdesc:namespaceLinearSolver_1_1Schwarz_1_1Tags"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceLinearSolver_1_1Schwarz_1_1Tags.html" title="Tags related to the Schwarz solver.">Tags</a> related to the <a class="el" href="structLinearSolver_1_1Schwarz_1_1Schwarz.html" title="An additive Schwarz subdomain solver for linear systems of equations .">Schwarz</a> solver. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinearSolver_1_1Schwarz_1_1ElementCenteredSubdomainData.html">ElementCenteredSubdomainData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data on an element-centered subdomain.  <a href="structLinearSolver_1_1Schwarz_1_1ElementCenteredSubdomainData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinearSolver_1_1Schwarz_1_1ElementCenteredSubdomainDataIterator.html">ElementCenteredSubdomainDataIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over <code><a class="el" href="structLinearSolver_1_1Schwarz_1_1ElementCenteredSubdomainData.html" title="Data on an element-centered subdomain.">LinearSolver::Schwarz::ElementCenteredSubdomainData</a></code>  <a href="structLinearSolver_1_1Schwarz_1_1ElementCenteredSubdomainDataIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearSolver_1_1Schwarz_1_1OverlapIterator.html">OverlapIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over grid points in a region that extends partially into the volume.  <a href="classLinearSolver_1_1Schwarz_1_1OverlapIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinearSolver_1_1Schwarz_1_1Schwarz.html">Schwarz</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An additive <a class="el" href="structLinearSolver_1_1Schwarz_1_1Schwarz.html" title="An additive Schwarz subdomain solver for linear systems of equations .">Schwarz</a> subdomain solver for linear systems of equations \(Ax=b\).  <a href="structLinearSolver_1_1Schwarz_1_1Schwarz.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearSolver_1_1Schwarz_1_1SubdomainOperator.html">SubdomainOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for the subdomain operator, i.e. the linear operator restricted to an element-centered <a class="el" href="structLinearSolver_1_1Schwarz_1_1Schwarz.html" title="An additive Schwarz subdomain solver for linear systems of equations .">Schwarz</a> subdomain.  <a href="classLinearSolver_1_1Schwarz_1_1SubdomainOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2d76a9985279a866886fb074484d5e2d"><td class="memTemplParams" colspan="2"><a id="a2d76a9985279a866886fb074484d5e2d" name="a2d76a9985279a866886fb074484d5e2d"></a>
template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:a2d76a9985279a866886fb074484d5e2d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>OverlapId</b> = <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt;</td></tr>
<tr class="memdesc:a2d76a9985279a866886fb074484d5e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies a subdomain region that overlaps with another element. <br /></td></tr>
<tr class="separator:a2d76a9985279a866886fb074484d5e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f93b06273400d7ac4150c064502a047"><td class="memTemplParams" colspan="2"><a id="a2f93b06273400d7ac4150c064502a047" name="a2f93b06273400d7ac4150c064502a047"></a>
template&lt;size_t Dim, typename ValueType &gt; </td></tr>
<tr class="memitem:a2f93b06273400d7ac4150c064502a047"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>OverlapMap</b> = <a class="el" href="classFixedHashMap.html">FixedHashMap</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#gafa8cb44daebc8f9e080718961530be89">maximum_number_of_neighbors</a>(Dim), <a class="el" href="namespaceLinearSolver_1_1Schwarz.html#a2d76a9985279a866886fb074484d5e2d">OverlapId</a>&lt; Dim &gt;, ValueType, boost::hash&lt; <a class="el" href="namespaceLinearSolver_1_1Schwarz.html#a2d76a9985279a866886fb074484d5e2d">OverlapId</a>&lt; Dim &gt; &gt; &gt;</td></tr>
<tr class="memdesc:a2f93b06273400d7ac4150c064502a047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure that can store the <code>ValueType</code> on each possible overlap of an element-centered subdomain with its neighbors. Overlaps are identified by their <code>OverlapId</code>. <br /></td></tr>
<tr class="separator:a2f93b06273400d7ac4150c064502a047"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac473761c3b125e9325d6e24e2441f675"><td class="memTemplParams" colspan="2"><a id="ac473761c3b125e9325d6e24e2441f675" name="ac473761c3b125e9325d6e24e2441f675"></a>
template&lt;size_t Dim, typename LhsTagsList , typename RhsTagsList &gt; </td></tr>
<tr class="memitem:ac473761c3b125e9325d6e24e2441f675"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (<a class="el" href="structLinearSolver_1_1Schwarz_1_1ElementCenteredSubdomainData.html">ElementCenteredSubdomainData</a>&lt; Dim, LhsTagsList &gt; lhs, const <a class="el" href="structLinearSolver_1_1Schwarz_1_1ElementCenteredSubdomainData.html">ElementCenteredSubdomainData</a>&lt; Dim, RhsTagsList &gt; &amp;rhs)</td></tr>
<tr class="separator:ac473761c3b125e9325d6e24e2441f675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adf03e72d58267b7183f579090bfd51"><td class="memTemplParams" colspan="2"><a id="a4adf03e72d58267b7183f579090bfd51" name="a4adf03e72d58267b7183f579090bfd51"></a>
template&lt;size_t Dim, typename LhsTagsList , typename RhsTagsList &gt; </td></tr>
<tr class="memitem:a4adf03e72d58267b7183f579090bfd51"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (<a class="el" href="structLinearSolver_1_1Schwarz_1_1ElementCenteredSubdomainData.html">ElementCenteredSubdomainData</a>&lt; Dim, LhsTagsList &gt; lhs, const <a class="el" href="structLinearSolver_1_1Schwarz_1_1ElementCenteredSubdomainData.html">ElementCenteredSubdomainData</a>&lt; Dim, RhsTagsList &gt; &amp;rhs)</td></tr>
<tr class="separator:a4adf03e72d58267b7183f579090bfd51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e273aae30064f74f1cdb51ed40cc473"><td class="memTemplParams" colspan="2"><a id="a3e273aae30064f74f1cdb51ed40cc473" name="a3e273aae30064f74f1cdb51ed40cc473"></a>
template&lt;size_t Dim, typename TagsList &gt; </td></tr>
<tr class="memitem:a3e273aae30064f74f1cdb51ed40cc473"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const double scalar, <a class="el" href="structLinearSolver_1_1Schwarz_1_1ElementCenteredSubdomainData.html">ElementCenteredSubdomainData</a>&lt; Dim, TagsList &gt; data)</td></tr>
<tr class="separator:a3e273aae30064f74f1cdb51ed40cc473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8799afb5ad609d9804de49fcd6e70b51"><td class="memTemplParams" colspan="2"><a id="a8799afb5ad609d9804de49fcd6e70b51" name="a8799afb5ad609d9804de49fcd6e70b51"></a>
template&lt;size_t Dim, typename TagsList &gt; </td></tr>
<tr class="memitem:a8799afb5ad609d9804de49fcd6e70b51"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (<a class="el" href="structLinearSolver_1_1Schwarz_1_1ElementCenteredSubdomainData.html">ElementCenteredSubdomainData</a>&lt; Dim, TagsList &gt; data, const double scalar)</td></tr>
<tr class="separator:a8799afb5ad609d9804de49fcd6e70b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa468aa2997b5d99900edfca957323be1"><td class="memTemplParams" colspan="2"><a id="aa468aa2997b5d99900edfca957323be1" name="aa468aa2997b5d99900edfca957323be1"></a>
template&lt;size_t Dim, typename TagsList &gt; </td></tr>
<tr class="memitem:aa468aa2997b5d99900edfca957323be1"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (<a class="el" href="structLinearSolver_1_1Schwarz_1_1ElementCenteredSubdomainData.html">ElementCenteredSubdomainData</a>&lt; Dim, TagsList &gt; data, const double scalar)</td></tr>
<tr class="separator:aa468aa2997b5d99900edfca957323be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5093234c05613b3dec2ecaa0a8c61001"><td class="memTemplParams" colspan="2"><a id="a5093234c05613b3dec2ecaa0a8c61001" name="a5093234c05613b3dec2ecaa0a8c61001"></a>
template&lt;size_t Dim, typename TagsList &gt; </td></tr>
<tr class="memitem:a5093234c05613b3dec2ecaa0a8c61001"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="el" href="structLinearSolver_1_1Schwarz_1_1ElementCenteredSubdomainData.html">ElementCenteredSubdomainData</a>&lt; Dim, TagsList &gt; &amp;subdomain_data)</td></tr>
<tr class="separator:a5093234c05613b3dec2ecaa0a8c61001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a7e6a9001ee9f009098aba75e54f48"><td class="memTemplParams" colspan="2"><a id="ae9a7e6a9001ee9f009098aba75e54f48" name="ae9a7e6a9001ee9f009098aba75e54f48"></a>
template&lt;size_t Dim, typename TagsList &gt; </td></tr>
<tr class="memitem:ae9a7e6a9001ee9f009098aba75e54f48"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structLinearSolver_1_1Schwarz_1_1ElementCenteredSubdomainData.html">ElementCenteredSubdomainData</a>&lt; Dim, TagsList &gt; &amp;lhs, const <a class="el" href="structLinearSolver_1_1Schwarz_1_1ElementCenteredSubdomainData.html">ElementCenteredSubdomainData</a>&lt; Dim, TagsList &gt; &amp;rhs)</td></tr>
<tr class="separator:ae9a7e6a9001ee9f009098aba75e54f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fc60c55cabb248e67898c1d9b9bda1"><td class="memTemplParams" colspan="2"><a id="ad6fc60c55cabb248e67898c1d9b9bda1" name="ad6fc60c55cabb248e67898c1d9b9bda1"></a>
template&lt;size_t Dim, typename TagsList &gt; </td></tr>
<tr class="memitem:ad6fc60c55cabb248e67898c1d9b9bda1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structLinearSolver_1_1Schwarz_1_1ElementCenteredSubdomainData.html">ElementCenteredSubdomainData</a>&lt; Dim, TagsList &gt; &amp;lhs, const <a class="el" href="structLinearSolver_1_1Schwarz_1_1ElementCenteredSubdomainData.html">ElementCenteredSubdomainData</a>&lt; Dim, TagsList &gt; &amp;rhs)</td></tr>
<tr class="separator:ad6fc60c55cabb248e67898c1d9b9bda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08103589b643b96a11c73d5d69de5adf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLinearSolver_1_1Schwarz.html#a08103589b643b96a11c73d5d69de5adf">overlap_extent</a> (size_t volume_extent, size_t max_overlap)</td></tr>
<tr class="memdesc:a08103589b643b96a11c73d5d69de5adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of points that an overlap extends into the <code>volume_extent</code>  <a href="namespaceLinearSolver_1_1Schwarz.html#a08103589b643b96a11c73d5d69de5adf">More...</a><br /></td></tr>
<tr class="separator:a08103589b643b96a11c73d5d69de5adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27de269b628e31db1b66be340ac5ee94"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:a27de269b628e31db1b66be340ac5ee94"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLinearSolver_1_1Schwarz.html#a27de269b628e31db1b66be340ac5ee94">overlap_num_points</a> (const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;volume_extents, size_t <a class="el" href="namespaceLinearSolver_1_1Schwarz.html#a08103589b643b96a11c73d5d69de5adf">overlap_extent</a>, size_t overlap_dimension)</td></tr>
<tr class="memdesc:a27de269b628e31db1b66be340ac5ee94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of grid points in an overlap region that extends <code>overlap_extent</code> points into the <code>volume_extents</code> from either side in the <code>overlap_dimension</code>  <a href="namespaceLinearSolver_1_1Schwarz.html#a27de269b628e31db1b66be340ac5ee94">More...</a><br /></td></tr>
<tr class="separator:a27de269b628e31db1b66be340ac5ee94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3461c9a919a0ebf2fcb5818af92bbd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLinearSolver_1_1Schwarz.html#aff3461c9a919a0ebf2fcb5818af92bbd">overlap_width</a> (size_t <a class="el" href="namespaceLinearSolver_1_1Schwarz.html#a08103589b643b96a11c73d5d69de5adf">overlap_extent</a>, const <a class="el" href="classDataVector.html">DataVector</a> &amp;collocation_points)</td></tr>
<tr class="memdesc:aff3461c9a919a0ebf2fcb5818af92bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Width of an overlap extending <code>overlap_extent</code> points into the <code>collocation_points</code> from either side.  <a href="namespaceLinearSolver_1_1Schwarz.html#aff3461c9a919a0ebf2fcb5818af92bbd">More...</a><br /></td></tr>
<tr class="separator:aff3461c9a919a0ebf2fcb5818af92bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608e68dcaf8cb4f60d61fe29a950daf5"><td class="memTemplParams" colspan="2"><a id="a608e68dcaf8cb4f60d61fe29a950daf5" name="a608e68dcaf8cb4f60d61fe29a950daf5"></a>
template&lt;size_t Dim, typename VolumeTagsList , typename OverlapTagsList &gt; </td></tr>
<tr class="memitem:a608e68dcaf8cb4f60d61fe29a950daf5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>add_overlap_data</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; VolumeTagsList &gt; * &gt; volume_data, const Variables&lt; OverlapTagsList &gt; &amp;overlap_data, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;volume_extents, const size_t <a class="el" href="namespaceLinearSolver_1_1Schwarz.html#a08103589b643b96a11c73d5d69de5adf">overlap_extent</a>, const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;direction)</td></tr>
<tr class="memdesc:a608e68dcaf8cb4f60d61fe29a950daf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the <code>overlap_data</code> to the <code>volume_data</code> <br /></td></tr>
<tr class="separator:a608e68dcaf8cb4f60d61fe29a950daf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30a8d15d025586fb54344a27e58cb4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDataVector.html">DataVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLinearSolver_1_1Schwarz.html#ad30a8d15d025586fb54344a27e58cb4c">extruding_weight</a> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;logical_coords, double width, const <a class="el" href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">Side</a> &amp;side)</td></tr>
<tr class="memdesc:ad30a8d15d025586fb54344a27e58cb4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights for the solution on an element-centered subdomain, decreasing from 1 to 0.5 towards the <code>side</code> over the logical distance <code>width</code>, and further to 0 over the same distance outside the element.  <a href="namespaceLinearSolver_1_1Schwarz.html#ad30a8d15d025586fb54344a27e58cb4c">More...</a><br /></td></tr>
<tr class="separator:ad30a8d15d025586fb54344a27e58cb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fca2fb34a1e059b87a06d0a27cd7498"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDataVector.html">DataVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLinearSolver_1_1Schwarz.html#a1fca2fb34a1e059b87a06d0a27cd7498">intruding_weight</a> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;logical_coords, double width, const <a class="el" href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">Side</a> &amp;side)</td></tr>
<tr class="memdesc:a1fca2fb34a1e059b87a06d0a27cd7498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights for the intruding solution of a neighboring element-centered subdomain, increasing from 0 to 0.5 towards the <code>side</code> over the logical distance <code>width</code>, and further to 1 over the same distance outside the element.  <a href="namespaceLinearSolver_1_1Schwarz.html#a1fca2fb34a1e059b87a06d0a27cd7498">More...</a><br /></td></tr>
<tr class="separator:a1fca2fb34a1e059b87a06d0a27cd7498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a007882c5ec941061350b9e292406d640"><td class="memTemplParams" colspan="2"><a id="a007882c5ec941061350b9e292406d640" name="a007882c5ec941061350b9e292406d640"></a>
template&lt;size_t Dim, typename DataType , typename... TensorStructure&gt; </td></tr>
<tr class="memitem:a007882c5ec941061350b9e292406d640"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>data_on_overlap</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Tensor&lt; DataType, TensorStructure... &gt; * &gt; restricted_tensor, const Tensor&lt; DataType, TensorStructure... &gt; &amp;tensor, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;volume_extents, const size_t <a class="el" href="namespaceLinearSolver_1_1Schwarz.html#a08103589b643b96a11c73d5d69de5adf">overlap_extent</a>, const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;direction)</td></tr>
<tr class="memdesc:a007882c5ec941061350b9e292406d640"><td class="mdescLeft">&#160;</td><td class="mdescRight">The part of the tensor data that lies within the overlap region. <br /></td></tr>
<tr class="separator:a007882c5ec941061350b9e292406d640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563e8c704422f146d5b244936b105cc2"><td class="memTemplParams" colspan="2"><a id="a563e8c704422f146d5b244936b105cc2" name="a563e8c704422f146d5b244936b105cc2"></a>
template&lt;size_t Dim, typename DataType , typename... TensorStructure&gt; </td></tr>
<tr class="memitem:a563e8c704422f146d5b244936b105cc2"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; DataType, TensorStructure... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>data_on_overlap</b> (const Tensor&lt; DataType, TensorStructure... &gt; &amp;tensor, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;volume_extents, const size_t <a class="el" href="namespaceLinearSolver_1_1Schwarz.html#a08103589b643b96a11c73d5d69de5adf">overlap_extent</a>, const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;direction)</td></tr>
<tr class="memdesc:a563e8c704422f146d5b244936b105cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The part of the tensor data that lies within the overlap region. <br /></td></tr>
<tr class="separator:a563e8c704422f146d5b244936b105cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b50441eaa9f2765907f14d40f08bd46"><td class="memTemplParams" colspan="2"><a id="a2b50441eaa9f2765907f14d40f08bd46" name="a2b50441eaa9f2765907f14d40f08bd46"></a>
template&lt;size_t Dim, typename OverlapTagsList , typename VolumeTagsList &gt; </td></tr>
<tr class="memitem:a2b50441eaa9f2765907f14d40f08bd46"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>data_on_overlap</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; OverlapTagsList &gt; * &gt; overlap_data, const Variables&lt; VolumeTagsList &gt; &amp;volume_data, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;volume_extents, const size_t <a class="el" href="namespaceLinearSolver_1_1Schwarz.html#a08103589b643b96a11c73d5d69de5adf">overlap_extent</a>, const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;direction)</td></tr>
<tr class="memdesc:a2b50441eaa9f2765907f14d40f08bd46"><td class="mdescLeft">&#160;</td><td class="mdescRight">The part of the tensor data that lies within the overlap region. <br /></td></tr>
<tr class="separator:a2b50441eaa9f2765907f14d40f08bd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e3fa598ae43f2cd4a69d20b9cc5703"><td class="memTemplParams" colspan="2"><a id="a02e3fa598ae43f2cd4a69d20b9cc5703" name="a02e3fa598ae43f2cd4a69d20b9cc5703"></a>
template&lt;size_t Dim, typename TagsList &gt; </td></tr>
<tr class="memitem:a02e3fa598ae43f2cd4a69d20b9cc5703"><td class="memTemplItemLeft" align="right" valign="top">Variables&lt; TagsList &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>data_on_overlap</b> (const Variables&lt; TagsList &gt; &amp;volume_data, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;volume_extents, const size_t <a class="el" href="namespaceLinearSolver_1_1Schwarz.html#a08103589b643b96a11c73d5d69de5adf">overlap_extent</a>, const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;direction)</td></tr>
<tr class="memdesc:a02e3fa598ae43f2cd4a69d20b9cc5703"><td class="mdescLeft">&#160;</td><td class="mdescRight">The part of the tensor data that lies within the overlap region. <br /></td></tr>
<tr class="separator:a02e3fa598ae43f2cd4a69d20b9cc5703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af571586edaeee5a5498ecc0629e7266e"><td class="memTemplParams" colspan="2"><a id="af571586edaeee5a5498ecc0629e7266e" name="af571586edaeee5a5498ecc0629e7266e"></a>
template&lt;size_t Dim, typename ExtendedTagsList , typename OverlapTagsList &gt; </td></tr>
<tr class="memitem:af571586edaeee5a5498ecc0629e7266e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>extended_overlap_data</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; ExtendedTagsList &gt; * &gt; extended_data, const Variables&lt; OverlapTagsList &gt; &amp;overlap_data, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;volume_extents, const size_t <a class="el" href="namespaceLinearSolver_1_1Schwarz.html#a08103589b643b96a11c73d5d69de5adf">overlap_extent</a>, const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;direction)</td></tr>
<tr class="memdesc:af571586edaeee5a5498ecc0629e7266e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend the overlap data to the full mesh by filling it with zeros outside the overlap region. <br /></td></tr>
<tr class="separator:af571586edaeee5a5498ecc0629e7266e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92ba4e2716b792fcc62146cb6da9eb6"><td class="memTemplParams" colspan="2"><a id="ae92ba4e2716b792fcc62146cb6da9eb6" name="ae92ba4e2716b792fcc62146cb6da9eb6"></a>
template&lt;size_t Dim, typename TagsList &gt; </td></tr>
<tr class="memitem:ae92ba4e2716b792fcc62146cb6da9eb6"><td class="memTemplItemLeft" align="right" valign="top">Variables&lt; TagsList &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>extended_overlap_data</b> (const Variables&lt; TagsList &gt; &amp;overlap_data, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;volume_extents, const size_t <a class="el" href="namespaceLinearSolver_1_1Schwarz.html#a08103589b643b96a11c73d5d69de5adf">overlap_extent</a>, const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;direction)</td></tr>
<tr class="memdesc:ae92ba4e2716b792fcc62146cb6da9eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend the overlap data to the full mesh by filling it with zeros outside the overlap region. <br /></td></tr>
<tr class="separator:ae92ba4e2716b792fcc62146cb6da9eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4c718e2581160b9e9dae02835a89b651"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:a4c718e2581160b9e9dae02835a89b651"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLinearSolver_1_1Schwarz.html#a4c718e2581160b9e9dae02835a89b651">element_weight</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt; element_weight, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; &amp;logical_coords, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, Dim &gt; &amp;overlap_widths, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &gt; &amp;external_boundaries)</td></tr>
<tr class="memdesc:a4c718e2581160b9e9dae02835a89b651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights for data on the central element of an element-centered subdomain.  <a href="namespaceLinearSolver_1_1Schwarz.html#a4c718e2581160b9e9dae02835a89b651">More...</a><br /></td></tr>
<tr class="separator:a4c718e2581160b9e9dae02835a89b651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd62fd6fe2a98e3b88a68a57d863e7c"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:aacd62fd6fe2a98e3b88a68a57d863e7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLinearSolver_1_1Schwarz.html#aacd62fd6fe2a98e3b88a68a57d863e7c">element_weight</a> (const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; &amp;logical_coords, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, Dim &gt; &amp;overlap_widths, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &gt; &amp;external_boundaries)</td></tr>
<tr class="memdesc:aacd62fd6fe2a98e3b88a68a57d863e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights for data on the central element of an element-centered subdomain.  <a href="namespaceLinearSolver_1_1Schwarz.html#aacd62fd6fe2a98e3b88a68a57d863e7c">More...</a><br /></td></tr>
<tr class="separator:aacd62fd6fe2a98e3b88a68a57d863e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad3cb69a238232f585990c2a71c9859c0"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ad3cb69a238232f585990c2a71c9859c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLinearSolver_1_1Schwarz.html#ad3cb69a238232f585990c2a71c9859c0">intruding_weight</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt; weight, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; &amp;logical_coords, const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;direction, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, Dim &gt; &amp;overlap_widths, size_t num_intruding_overlaps, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &gt; &amp;external_boundaries)</td></tr>
<tr class="memdesc:ad3cb69a238232f585990c2a71c9859c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights for data on overlap regions intruding into an element-centered subdomain.  <a href="namespaceLinearSolver_1_1Schwarz.html#ad3cb69a238232f585990c2a71c9859c0">More...</a><br /></td></tr>
<tr class="separator:ad3cb69a238232f585990c2a71c9859c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1afbedf47ce3a07bcd31736ebc946027"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:a1afbedf47ce3a07bcd31736ebc946027"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLinearSolver_1_1Schwarz.html#a1afbedf47ce3a07bcd31736ebc946027">intruding_weight</a> (const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; &amp;logical_coords, const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;direction, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, Dim &gt; &amp;overlap_widths, size_t num_intruding_overlaps, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &gt; &amp;external_boundaries)</td></tr>
<tr class="memdesc:a1afbedf47ce3a07bcd31736ebc946027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights for data on overlap regions intruding into an element-centered subdomain.  <a href="namespaceLinearSolver_1_1Schwarz.html#a1afbedf47ce3a07bcd31736ebc946027">More...</a><br /></td></tr>
<tr class="separator:a1afbedf47ce3a07bcd31736ebc946027"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Items related to the Schwarz linear solver. </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structLinearSolver_1_1Schwarz_1_1Schwarz.html" title="An additive Schwarz subdomain solver for linear systems of equations .">LinearSolver::Schwarz::Schwarz</a></code> </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aacd62fd6fe2a98e3b88a68a57d863e7c" name="aacd62fd6fe2a98e3b88a68a57d863e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd62fd6fe2a98e3b88a68a57d863e7c">&#9670;&nbsp;</a></span>element_weight() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; LinearSolver::Schwarz::element_weight </td>
          <td>(</td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>logical_coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>overlap_widths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>external_boundaries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weights for data on the central element of an element-centered subdomain. </p>
<p >Constructs the weighting field</p>
<p class="formulaDsp">
\begin{equation} W(\boldsymbol{\xi}) = \prod^d_{i=0} w(\xi^i) \end{equation}
</p>
<p >where \(w(\xi^i)\) is the one-dimensional weighting function described in <code><a class="el" href="namespaceLinearSolver_1_1Schwarz.html#ad30a8d15d025586fb54344a27e58cb4c" title="Weights for the solution on an element-centered subdomain, decreasing from 1 to 0....">LinearSolver::Schwarz::extruding_weight</a></code> and \(\xi^i\) are the element-logical coordinates (see Eq. (41) in <a class="el" href="citelist.html#CITEREF_Vincent2019qpd">[166]</a>). </p>

</div>
</div>
<a id="a4c718e2581160b9e9dae02835a89b651" name="a4c718e2581160b9e9dae02835a89b651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c718e2581160b9e9dae02835a89b651">&#9670;&nbsp;</a></span>element_weight() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LinearSolver::Schwarz::element_weight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>element_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>logical_coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>overlap_widths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>external_boundaries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weights for data on the central element of an element-centered subdomain. </p>
<p >Constructs the weighting field</p>
<p class="formulaDsp">
\begin{equation} W(\boldsymbol{\xi}) = \prod^d_{i=0} w(\xi^i) \end{equation}
</p>
<p >where \(w(\xi^i)\) is the one-dimensional weighting function described in <code><a class="el" href="namespaceLinearSolver_1_1Schwarz.html#ad30a8d15d025586fb54344a27e58cb4c" title="Weights for the solution on an element-centered subdomain, decreasing from 1 to 0....">LinearSolver::Schwarz::extruding_weight</a></code> and \(\xi^i\) are the element-logical coordinates (see Eq. (41) in <a class="el" href="citelist.html#CITEREF_Vincent2019qpd">[166]</a>). </p>

</div>
</div>
<a id="ad30a8d15d025586fb54344a27e58cb4c" name="ad30a8d15d025586fb54344a27e58cb4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30a8d15d025586fb54344a27e58cb4c">&#9670;&nbsp;</a></span>extruding_weight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataVector.html">DataVector</a> LinearSolver::Schwarz::extruding_weight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>logical_coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">Side</a> &amp;&#160;</td>
          <td class="paramname"><em>side</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weights for the solution on an element-centered subdomain, decreasing from 1 to 0.5 towards the <code>side</code> over the logical distance <code>width</code>, and further to 0 over the same distance outside the element. </p>
<p >The weighting function over a full element-centered subdomain is</p>
<p class="formulaDsp">
\begin{equation} w(\xi) = \frac{1}{2}\left( \phi\left( \frac{\xi + 1}{\delta} \right) - \phi\left( \frac{\xi - 1}{\delta} \right) \right) \end{equation}
</p>
<p >where \(\phi(\xi)\) is a second-order <code><a class="el" href="group__UtilitiesGroup.html#gafce557042e1335e19b1bf3dbb7a75d79" title="Smoothly interpolates from 0 to 1 between lower_edge and upper_edge with a Hermite polynomial of degr...">smoothstep</a></code>, i.e. the quintic polynomial</p>
<p class="formulaDsp">
\begin{align*} \phi(\xi) = \begin{cases} \mathrm{sign}(\xi) \quad \text{for} \quad |\xi| &gt; 1 \\ \frac{1}{8}\left(15\xi - 10\xi^3 + 3\xi^5\right) \end{cases} \end{align*}
</p>
<p >(see Eq. (39) in <a class="el" href="citelist.html#CITEREF_Vincent2019qpd">[166]</a>).</p>
<p >The <code><a class="el" href="namespaceLinearSolver_1_1Schwarz.html#ad30a8d15d025586fb54344a27e58cb4c" title="Weights for the solution on an element-centered subdomain, decreasing from 1 to 0....">LinearSolver::Schwarz::extruding_weight</a></code> and <code><a class="el" href="namespaceLinearSolver_1_1Schwarz.html#a1fca2fb34a1e059b87a06d0a27cd7498" title="Weights for the intruding solution of a neighboring element-centered subdomain, increasing from 0 to ...">LinearSolver::Schwarz::intruding_weight</a></code> functions each compute one of the two terms in \(w(\xi)\). For example, consider an element-centered subdomain <code>A</code> that overlaps with a neighboring element-centered subdomain <code>B</code>. To combine solutions on <code>A</code> and <code>B</code> to a weighted solution on <code>A</code>, multiply the solution on <code>A</code> with the <code>extruding_weight</code> and the solution on <code>B</code> with the <code>intruding_weight</code>, both evaluated at the logical coordinates in <code>A</code> and at the <code>side</code> of <code>A</code> that faces <code>B</code>. </p>

</div>
</div>
<a id="a1fca2fb34a1e059b87a06d0a27cd7498" name="a1fca2fb34a1e059b87a06d0a27cd7498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fca2fb34a1e059b87a06d0a27cd7498">&#9670;&nbsp;</a></span>intruding_weight() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataVector.html">DataVector</a> LinearSolver::Schwarz::intruding_weight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>logical_coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">Side</a> &amp;&#160;</td>
          <td class="paramname"><em>side</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weights for the intruding solution of a neighboring element-centered subdomain, increasing from 0 to 0.5 towards the <code>side</code> over the logical distance <code>width</code>, and further to 1 over the same distance outside the element. </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="namespaceLinearSolver_1_1Schwarz.html#ad30a8d15d025586fb54344a27e58cb4c" title="Weights for the solution on an element-centered subdomain, decreasing from 1 to 0....">LinearSolver::Schwarz::extruding_weight</a></code> </dd></dl>

</div>
</div>
<a id="a1afbedf47ce3a07bcd31736ebc946027" name="a1afbedf47ce3a07bcd31736ebc946027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1afbedf47ce3a07bcd31736ebc946027">&#9670;&nbsp;</a></span>intruding_weight() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; LinearSolver::Schwarz::intruding_weight </td>
          <td>(</td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>logical_coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>overlap_widths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_intruding_overlaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>external_boundaries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weights for data on overlap regions intruding into an element-centered subdomain. </p>
<p >Constructs the weighting field \(W(\xi)\) as described in <code><a class="el" href="namespaceLinearSolver_1_1Schwarz.html#a4c718e2581160b9e9dae02835a89b651" title="Weights for data on the central element of an element-centered subdomain.">LinearSolver::Schwarz::element_weight</a></code> for the data that overlaps with the central element of an element-centered subdomain. The weights are constructed in such a way that all weights at a grid point sum to one, i.e. the weight is conserved. The <code>logical_coords</code> are the element-logical coordinates of the central element.</p>
<p >This function assumes that corner- and edge-neighbors of the central element are not part of the subdomain, which means that no contributions from those neighbors are expected although the weighting field is non-zero in overlap regions with those neighbors. Therefore, to retain conservation we must account for this missing weight by adding it to the central element, to the intruding overlaps from face-neighbors, or split it between the two. We choose to add the weight to the intruding overlaps, since that's where information from the corner- and edge-regions propagates through in a DG context. </p>

</div>
</div>
<a id="ad3cb69a238232f585990c2a71c9859c0" name="ad3cb69a238232f585990c2a71c9859c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3cb69a238232f585990c2a71c9859c0">&#9670;&nbsp;</a></span>intruding_weight() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LinearSolver::Schwarz::intruding_weight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>logical_coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>overlap_widths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_intruding_overlaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>external_boundaries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weights for data on overlap regions intruding into an element-centered subdomain. </p>
<p >Constructs the weighting field \(W(\xi)\) as described in <code><a class="el" href="namespaceLinearSolver_1_1Schwarz.html#a4c718e2581160b9e9dae02835a89b651" title="Weights for data on the central element of an element-centered subdomain.">LinearSolver::Schwarz::element_weight</a></code> for the data that overlaps with the central element of an element-centered subdomain. The weights are constructed in such a way that all weights at a grid point sum to one, i.e. the weight is conserved. The <code>logical_coords</code> are the element-logical coordinates of the central element.</p>
<p >This function assumes that corner- and edge-neighbors of the central element are not part of the subdomain, which means that no contributions from those neighbors are expected although the weighting field is non-zero in overlap regions with those neighbors. Therefore, to retain conservation we must account for this missing weight by adding it to the central element, to the intruding overlaps from face-neighbors, or split it between the two. We choose to add the weight to the intruding overlaps, since that's where information from the corner- and edge-regions propagates through in a DG context. </p>

</div>
</div>
<a id="a08103589b643b96a11c73d5d69de5adf" name="a08103589b643b96a11c73d5d69de5adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08103589b643b96a11c73d5d69de5adf">&#9670;&nbsp;</a></span>overlap_extent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t LinearSolver::Schwarz::overlap_extent </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>volume_extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_overlap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of points that an overlap extends into the <code>volume_extent</code> </p>
<p >In a dimension where an element has <code>volume_extent</code> points, the overlap extent is the largest number under these constraints:</p>
<ul>
<li>It is at most <code>max_overlap</code>.</li>
<li>It is smaller than the <code>volume_extent</code>.</li>
</ul>
<p >This means the overlap extent is always smaller than the <code>volume_extent</code>. The reason for this constraint is that we define the <em>width</em> of the overlap as the element-logical coordinate distance from the face of the element to the first collocation point <em>outside</em> the overlap extent. Therefore, even an overlap region that covers the full element in width does not include the collocation point on the opposite side of the element.</p>
<p >Here's a few notes on the definition of the overlap extent and width:</p>
<ul>
<li>A typical smooth weighting function goes to zero at the overlap width, so if the grid points located at the overlap width were included in the subdomain, their solutions would not contribute to the weighted sum of subdomain solutions.</li>
<li>Defining the overlap width as the distance to the first point <em>outside</em> the overlap extent makes it non-zero even for a single point of overlap into a Gauss-Lobatto grid (which has points located at the element face).</li>
<li>Boundary contributions for many (but not all) discontinuous Galerkin schemes on Gauss-Lobatto grids are limited to the grid points on the element face, e.g. for a DG operator that is pre-multiplied by the mass matrix, or one where boundary contributions are lifted using the diagonal mass-matrix approximation. Not including the grid points facing away from the subdomain in the overlap allows to ignore that face altogether in the subdomain operator. </li>
</ul>

</div>
</div>
<a id="a27de269b628e31db1b66be340ac5ee94" name="a27de269b628e31db1b66be340ac5ee94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27de269b628e31db1b66be340ac5ee94">&#9670;&nbsp;</a></span>overlap_num_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t LinearSolver::Schwarz::overlap_num_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>overlap_extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>overlap_dimension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total number of grid points in an overlap region that extends <code>overlap_extent</code> points into the <code>volume_extents</code> from either side in the <code>overlap_dimension</code> </p>
<p >The overlap region has <code>overlap_extent</code> points in the <code>overlap_dimension</code>, and <code>volume_extents</code> points in the other dimensions. The number of grid points returned by this function is the product of these extents. </p>

</div>
</div>
<a id="aff3461c9a919a0ebf2fcb5818af92bbd" name="aff3461c9a919a0ebf2fcb5818af92bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3461c9a919a0ebf2fcb5818af92bbd">&#9670;&nbsp;</a></span>overlap_width()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LinearSolver::Schwarz::overlap_width </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>overlap_extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>collocation_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Width of an overlap extending <code>overlap_extent</code> points into the <code>collocation_points</code> from either side. </p>
<p >The "width" of an overlap is the element-logical coordinate distance from the element boundary to the first collocation point outside the overlap region in the overlap dimension, i.e. the dimension perpendicular to the element face. See <code><a class="el" href="namespaceLinearSolver_1_1Schwarz.html#a08103589b643b96a11c73d5d69de5adf" title="The number of points that an overlap extends into the volume_extent">LinearSolver::Schwarz::overlap_extent</a></code> for details.</p>
<p >This function assumes the <code>collocation_points</code> are mirrored around 0. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceLinearSolver.html">LinearSolver</a></li><li class="navelem"><a class="el" href="namespaceLinearSolver_1_1Schwarz.html">Schwarz</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
