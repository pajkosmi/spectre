<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: Protocols</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('protocols.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Protocols </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#protocols_overview">Overview of protocols</a></li>
<li class="level1"><a href="#protocols_conforming">Protocol users: Conforming to a protocol</a></li>
<li class="level1"><a href="#protocols_author">Protocol authors: Writing a protocol</a></li>
<li class="level1"><a href="#protocols_testing">Protocol authors: Testing a protocol</a></li>
<li class="level1"><a href="#protocols_and_constraints">Protocols and C++20 &quot;Constraints and concepts&quot;</a></li>
</ul>
</div>
<div class="textblock"><p ><a class="anchor" id="md_docs_DevGuide_Protocols"></a></p>
<h1><a class="anchor" id="protocols_overview"></a>
Overview of protocols</h1>
<p >Protocols are a concept we use in SpECTRE to define metaprogramming interfaces. A variation of this concept is built into many languages, so this is a quote from the <a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html">Swift documentation</a>:</p>
<blockquote class="doxtable">
<p >&zwj;A protocol defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol can then be adopted by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to conform to that protocol. </p>
</blockquote>
<p>You should define a protocol when you need a template parameter to conform to an interface. Here is an example of a protocol that is adapted from the <a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html">Swift documentation</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>protocols {</div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * \brief Has a name.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Requires the class has these member functions:</span></div>
<div class="line"><span class="comment"> * - `name`: Returns the name of the object as a `std::string`.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">struct </span>Named {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ConformingType&gt;</div>
<div class="line">  <span class="keyword">struct </span>test {</div>
<div class="line">    <span class="comment">// Try calling the `ConformingType::name` member function</span></div>
<div class="line">    <span class="keyword">using</span> name_return_type = <span class="keyword">decltype</span>(std::declval&lt;ConformingType&gt;().name());</div>
<div class="line">    <span class="comment">// Check the return type of the `name` member function</span></div>
<div class="line">    <span class="keyword">static_assert</span>(std::is_same_v&lt;name_return_type, std::string&gt;,</div>
<div class="line">                  <span class="stringliteral">&quot;The &#39;name&#39; function must return a &#39;std::string&#39;.&quot;</span>);</div>
<div class="line">  };</div>
<div class="line">};</div>
<div class="line">}  <span class="comment">// namespace protocols</span></div>
</div><!-- fragment --><p >The protocol defines an interface that any type that adopts it must implement. For example, the following class conforms to the protocol we just defined:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Person : <span class="keyword">public</span> <a class="code hl_struct" href="structtt_1_1ConformsTo.html">tt::ConformsTo</a>&lt;protocols::Named&gt; {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// Function required to conform to the protocol</span></div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> <a class="code hl_function" href="group__PrettyTypeGroup.html#gac698d0d763b59b714fca6ed84376eb92">name</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> first_name_ + <span class="stringliteral">&quot; &quot;</span> + last_name_; }</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">  <span class="comment">// Implementation details of the class that are irrelevant to the protocol</span></div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> first_name_;</div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> last_name_;</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  Person(<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> first_name, <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> last_name)</div>
<div class="line">      : first_name_(std::move(first_name)), last_name_(std::move(last_name)) {}</div>
<div class="line">};</div>
<div class="ttc" id="abasic_string_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a></div></div>
<div class="ttc" id="agroup__PrettyTypeGroup_html_gac698d0d763b59b714fca6ed84376eb92"><div class="ttname"><a href="group__PrettyTypeGroup.html#gac698d0d763b59b714fca6ed84376eb92">pretty_type::name</a></div><div class="ttdeci">std::string name()</div><div class="ttdoc">Return the result of the name() member of a class. If a class doesn't have a name() member,...</div><div class="ttdef"><b>Definition:</b> PrettyType.hpp:733</div></div>
<div class="ttc" id="astructtt_1_1ConformsTo_html"><div class="ttname"><a href="structtt_1_1ConformsTo.html">tt::ConformsTo</a></div><div class="ttdoc">Indicate a class conforms to the Protocol.</div><div class="ttdef"><b>Definition:</b> ProtocolHelpers.hpp:22</div></div>
</div><!-- fragment --><p >The class indicates it conforms to the protocol by (publicly) inheriting from <code><a class="el" href="structtt_1_1ConformsTo.html" title="Indicate a class conforms to the Protocol.">tt::ConformsTo</a>&lt;TheProtocol&gt;</code>.</p>
<p >Once you have defined a protocol, you can check if a class conforms to it using the <code><a class="el" href="structtt_1_1assert__conforms__to.html" title="Assert that the ConformingType conforms to the Protocol.">tt::assert_conforms_to</a></code> or <code><a class="el" href="structtt_1_1conforms__to.html" title="Checks if the ConformingType conforms to the Protocol.">tt::conforms_to</a></code> metafunctions:</p>
<div class="fragment"><div class="line"><span class="comment">// SFINAE-friendly version:</span></div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">bool</span> person_class_is_named =</div>
<div class="line">    tt::conforms_to_v&lt;Person, protocols::Named&gt;;</div>
<div class="line"><span class="comment">// Assert-friendly version with more diagnostics:</span></div>
<div class="line"><span class="keyword">static_assert</span>(tt::assert_conforms_to_v&lt;Person, protocols::Named&gt;);</div>
</div><!-- fragment --><p >Note that checking for protocol conformance is cheap, so you may freely use protocol conformance checks in your code.</p>
<p >This is how you can write code that relies on the interface defined by the protocol:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NamedThing&gt;</div>
<div class="line"><a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> greet(<span class="keyword">const</span> NamedThing&amp; named_thing) {</div>
<div class="line">  <span class="comment">// Make sure the template parameter conforms to the protocol</span></div>
<div class="line">  <span class="keyword">static_assert</span>(tt::assert_conforms_to_v&lt;NamedThing, protocols::Named&gt;);</div>
<div class="line">  <span class="comment">// Now we can rely on the interface that the protocol defines</span></div>
<div class="line">  <span class="keywordflow">return</span> <span class="stringliteral">&quot;Hello, &quot;</span> + named_thing.name() + <span class="stringliteral">&quot;!&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p >Checking for protocol conformance here makes it clear that we are expecting a template parameter that exposes the particular interface we have defined in the protocol. Therefore, the author of the protocol and of the code that uses it has explicitly defined (and documented!) the interface they expect. And the developer who consumes the protocol by writing classes that conform to it knows exactly what needs to be implemented.</p>
<p >Note that the <code><a class="el" href="structtt_1_1conforms__to.html" title="Checks if the ConformingType conforms to the Protocol.">tt::conforms_to</a></code> metafunction is SFINAE-friendly, so you can use it like this:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Thing,</div>
<div class="line">          <a class="code hl_typedef" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires&lt;not tt::conforms_to_v&lt;Thing, protocols::Named&gt;</a>&gt; = <span class="keyword">nullptr</span>&gt;</div>
<div class="line"><a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> greet_anything(<span class="keyword">const</span> Thing&amp; <span class="comment">/*anything*/</span>) {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="stringliteral">&quot;Hello!&quot;</span>;</div>
<div class="line">}</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NamedThing,</div>
<div class="line">          <a class="code hl_typedef" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires&lt;tt::conforms_to_v&lt;NamedThing, protocols::Named&gt;</a>&gt; = <span class="keyword">nullptr</span>&gt;</div>
<div class="line"><a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> greet_anything(<span class="keyword">const</span> NamedThing&amp; named_thing) {</div>
<div class="line">  <span class="keywordflow">return</span> greet(named_thing);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__UtilitiesGroup_html_ga084d535585c18d4e80f8ec6052d341a3"><div class="ttname"><a href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a></div><div class="ttdeci">typename Requires_detail::requires_impl&lt; B &gt;::template_error_type_failed_to_meet_requirements_on_template_parameters Requires</div><div class="ttdoc">Express requirements on the template parameters of a function or class, replaces std::enable_if_t</div><div class="ttdef"><b>Definition:</b> Requires.hpp:67</div></div>
</div><!-- fragment --><p >The <code><a class="el" href="structtt_1_1conforms__to.html" title="Checks if the ConformingType conforms to the Protocol.">tt::conforms_to</a></code> metafunction only checks if the class <em>indicates</em> it conforms to the protocol. Where SFINAE-friendliness is not necessary prefer the <code><a class="el" href="structtt_1_1assert__conforms__to.html" title="Assert that the ConformingType conforms to the Protocol.">tt::assert_conforms_to</a></code> metafunction that triggers static asserts with diagnostic messages to understand why the class does not conform to the protocol.</p>
<p >We typically define protocols in a file named <code>Protocols.hpp</code> and within a <code>protocols</code> namespace, similar to how we write <a class="el" href="group__DataBoxTagsGroup.html">tags</a> in a <code>Tags.hpp</code> file and within a <code>Tags</code> namespace. The file should be placed in the directory associated with the code that depends on classes conforming to the protocols. For example, the protocol <code>Named</code> in the example above would be placed in directory that also has the <code>greet</code> function.</p>
<h1><a class="anchor" id="protocols_conforming"></a>
Protocol users: Conforming to a protocol</h1>
<p >To indicate a class conforms to a protocol it (publicly) inherits from <code><a class="el" href="structtt_1_1ConformsTo.html" title="Indicate a class conforms to the Protocol.">tt::ConformsTo</a>&lt;TheProtocol&gt;</code>. The class must fulfill all requirements defined by the protocol. The requirements are listed in the protocol's documentation.</p>
<p >Any class that indicates it conforms to a protocol must have a unit test to check that it actually does. You can use the <code><a class="el" href="structtt_1_1assert__conforms__to.html" title="Assert that the ConformingType conforms to the Protocol.">tt::assert_conforms_to</a></code> metafunction for the test:</p>
<div class="fragment"><div class="line"><span class="keyword">static_assert</span>(tt::assert_conforms_to_v&lt;Person, protocols::Named&gt;);</div>
</div><!-- fragment --><h1><a class="anchor" id="protocols_author"></a>
Protocol authors: Writing a protocol</h1>
<p >To author a new protocol you implement a class that provides a <code>test</code> metafunction and detailed documentation. The <code>test</code> metafunction takes a single template parameter (typically named <code>ConformingType</code>) and checks that it conforms to the requirements laid out in the protocol's documentation. Its purpose is to provide diagnostic messages as compiler errors to understand why a type fails to conform to the protocol. You can use <code>static_assert</code>s or trigger standard compiler errors where appropriate. See the protocols defined above for examples.</p>
<p >Occasionally, you might be tempted to add template parameters to a protocol. In those situations, add requirements to the protocol instead and retrieve the parameters from the conforming class. The reason for this guideline is that conforming classes will always inherit from <code><a class="el" href="structtt_1_1ConformsTo.html" title="Indicate a class conforms to the Protocol.">tt::ConformsTo</a>&lt;Protocol&gt;</code>. Therefore, any template parameters of the protocol must also be template parameters of their conforming classes, which means the protocol can just require and retrieve them. For example, we could be tempted to follow this antipattern:</p>
<div class="fragment"><div class="line"><span class="comment">// Don&#39;t do this. Protocols should not have template parameters.</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NameType&gt;</div>
<div class="line"><span class="keyword">struct </span>NamedAntipattern {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ConformingType&gt;</div>
<div class="line">  <span class="keyword">struct </span>test {</div>
<div class="line">    <span class="comment">// Check that the `name` function exists _and_ its return type</span></div>
<div class="line">    <span class="keyword">using</span> name_return_type = <span class="keyword">decltype</span>(std::declval&lt;ConformingType&gt;().name());</div>
<div class="line">    <span class="keyword">static_assert</span>(std::is_same_v&lt;name_return_type, NameType&gt;,</div>
<div class="line">                  <span class="stringliteral">&quot;The &#39;name&#39; function must return a &#39;NameType&#39;.&quot;</span>);</div>
<div class="line">  };</div>
<div class="line">};</div>
</div><!-- fragment --><p >However, instead of adding template parameters to the protocol we should add a requirement to it:</p>
<div class="fragment"><div class="line"><span class="comment">// Instead, do this.</span></div>
<div class="line"><span class="keyword">struct </span>NamedWithType {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ConformingType&gt;</div>
<div class="line">  <span class="keyword">struct </span>test {</div>
<div class="line">    <span class="comment">// Use the `ConformingType::NameType` to check the return type of the `name`</span></div>
<div class="line">    <span class="comment">// function.</span></div>
<div class="line">    <span class="keyword">using</span> name_type = <span class="keyword">typename</span> ConformingType::NameType;</div>
<div class="line">    <span class="keyword">using</span> name_return_type = <span class="keyword">decltype</span>(std::declval&lt;ConformingType&gt;().name());</div>
<div class="line">    <span class="keyword">static_assert</span>(std::is_same_v&lt;name_return_type, name_type&gt;,</div>
<div class="line">                  <span class="stringliteral">&quot;The &#39;name&#39; function must return a &#39;NameType&#39;.&quot;</span>);</div>
<div class="line">  };</div>
<div class="line">};</div>
</div><!-- fragment --><p >Classes would need to specify the template parameters for any protocols they conform to anyway, if the protocols had any. So they might as well expose them:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>PersonWithNameType : <a class="code hl_struct" href="structtt_1_1ConformsTo.html">tt::ConformsTo</a>&lt;protocols::NamedWithType&gt; {</div>
<div class="line">  <span class="keyword">using</span> NameType = <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>;</div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> <a class="code hl_function" href="group__PrettyTypeGroup.html#gac698d0d763b59b714fca6ed84376eb92">name</a>() <span class="keyword">const</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><p >This pattern also allows us to check for protocol conformance first and then add further checks about the types if we wanted to:</p>
<div class="fragment"><div class="line"><span class="keyword">static_assert</span>(</div>
<div class="line">    tt::assert_conforms_to_v&lt;PersonWithNameType, protocols::NamedWithType&gt;);</div>
<div class="line"><span class="keyword">static_assert</span>(</div>
<div class="line">    std::is_same_v&lt;typename PersonWithNameType::NameType, std::string&gt;,</div>
<div class="line">    <span class="stringliteral">&quot;The `NameType` isn&#39;t a `std::string`!&quot;</span>);</div>
</div><!-- fragment --><h1><a class="anchor" id="protocols_testing"></a>
Protocol authors: Testing a protocol</h1>
<p >Protocol authors should provide a unit test for their protocol that includes an example implementation of a class that conforms to it. The protocol author should add this example to the documentation of the protocol through a Doxygen snippet. This gives users a convenient way to see how the author intends their interface to be implemented.</p>
<h1><a class="anchor" id="protocols_and_constraints"></a>
Protocols and C++20 "Constraints and concepts"</h1>
<p >A feature related to protocols is in C++20 and goes under the name of <a href="https://en.cppreference.com/w/cpp/language/constraints">constraints and concepts</a>. Every protocol defines a <em>concept</em>, but it defers checking its requirements to the unit tests to save compile time. In other words, protocols provide a way to <em>indicate</em> that a class fulfills a set of requirements, whereas C++20 constraints provide a way to <em>check</em> that a class fulfills a set of requirements. Therefore, the two features complement each other. Once C++20 becomes available in SpECTRE we can either gradually convert our protocols to concepts and use them as constraints directly if we find the impact on compile time negligible, or we can add a concept that checks protocol conformance the same way that <code>tt::conforms_to_v</code> currently does (i.e. by checking inheritance). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dev_guide.html">Developer Guides</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
