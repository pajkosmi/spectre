<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: elliptic::dg Namespace Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceelliptic_1_1dg.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">elliptic::dg Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Functionality related to discontinuous Galerkin discretizations of elliptic equations.  
<a href="namespaceelliptic_1_1dg.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceelliptic_1_1dg_1_1Actions"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelliptic_1_1dg_1_1Actions.html">Actions</a></td></tr>
<tr class="memdesc:namespaceelliptic_1_1dg_1_1Actions"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceelliptic_1_1dg_1_1Actions.html" title="Actions related to elliptic discontinuous Galerkin schemes.">Actions</a> related to elliptic discontinuous Galerkin schemes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceelliptic_1_1dg_1_1OptionTags"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelliptic_1_1dg_1_1OptionTags.html">OptionTags</a></td></tr>
<tr class="memdesc:namespaceelliptic_1_1dg_1_1OptionTags"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option tags related to elliptic discontinuous Galerkin schemes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceelliptic_1_1dg_1_1subdomain__operator"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelliptic_1_1dg_1_1subdomain__operator.html">subdomain_operator</a></td></tr>
<tr class="memdesc:namespaceelliptic_1_1dg_1_1subdomain__operator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Items related to the restriction of the DG operator to an element-centered subdomain. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceelliptic_1_1dg_1_1Tags"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelliptic_1_1dg_1_1Tags.html">Tags</a></td></tr>
<tr class="memdesc:namespaceelliptic_1_1dg_1_1Tags"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataBox tags related to elliptic discontinuous Galerkin schemes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structelliptic_1_1dg_1_1InitializeBackground.html">InitializeBackground</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize background quantities for the elliptic DG operator, possibly including the metric necessary for normalizing face normals.  <a href="structelliptic_1_1dg_1_1InitializeBackground.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structelliptic_1_1dg_1_1InitializeFacesAndMortars.html">InitializeFacesAndMortars</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the geometry on faces and mortars for the elliptic DG operator.  <a href="structelliptic_1_1dg_1_1InitializeFacesAndMortars.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structelliptic_1_1dg_1_1InitializeGeometry.html">InitializeGeometry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the background-independent geometry for the elliptic DG operator.  <a href="structelliptic_1_1dg_1_1InitializeGeometry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structelliptic_1_1dg_1_1MortarData.html">MortarData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boundary data on both sides of a mortar.  <a href="structelliptic_1_1dg_1_1MortarData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac01f468061bf6c950d1fa5105201ed19"><td class="memTemplParams" colspan="2"><a id="ac01f468061bf6c950d1fa5105201ed19" name="ac01f468061bf6c950d1fa5105201ed19"></a>
template&lt;typename PrimalFields , typename PrimalFluxes &gt; </td></tr>
<tr class="memitem:ac01f468061bf6c950d1fa5105201ed19"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BoundaryData</b> = <a class="el" href="structdg_1_1SimpleBoundaryData.html">::dg::SimpleBoundaryData</a>&lt; tmpl::append&lt; <a class="el" href="group__DataBoxTagsGroup.html#ga3dda5a16c7f6baccd115de2c8f12394e">db::wrap_tags_in</a>&lt;<a class="el" href="structTags_1_1NormalDotFlux.html">::Tags::NormalDotFlux</a>, PrimalFields &gt;, <a class="el" href="group__DataBoxTagsGroup.html#ga3dda5a16c7f6baccd115de2c8f12394e">db::wrap_tags_in</a>&lt;<a class="el" href="structTags_1_1NormalDotFlux.html">::Tags::NormalDotFlux</a>, PrimalFluxes &gt;, <a class="el" href="group__DataBoxTagsGroup.html#ga3dda5a16c7f6baccd115de2c8f12394e">db::wrap_tags_in</a>&lt; <a class="el" href="structelliptic_1_1dg_1_1Tags_1_1NormalDotFluxForJump.html">Tags::NormalDotFluxForJump</a>, PrimalFields &gt;, tmpl::list&lt; <a class="el" href="structelliptic_1_1dg_1_1Tags_1_1ElementSize.html">Tags::ElementSize</a> &gt; &gt;, tmpl::list&lt; <a class="el" href="structelliptic_1_1dg_1_1Tags_1_1PerpendicularNumPoints.html">Tags::PerpendicularNumPoints</a> &gt; &gt;</td></tr>
<tr class="memdesc:ac01f468061bf6c950d1fa5105201ed19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data that is projected to mortars and communicated across element boundaries. <br /></td></tr>
<tr class="separator:ac01f468061bf6c950d1fa5105201ed19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4e09a200dbb357f30157bebd8e407a54"><td class="memTemplParams" colspan="2"><a id="a4e09a200dbb357f30157bebd8e407a54" name="a4e09a200dbb357f30157bebd8e407a54"></a>
template&lt;typename PrimalMortarFields , typename PrimalMortarFluxes , size_t Dim&gt; </td></tr>
<tr class="memitem:a4e09a200dbb357f30157bebd8e407a54"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceelliptic_1_1dg.html#ac01f468061bf6c950d1fa5105201ed19">BoundaryData</a>&lt; PrimalMortarFields, PrimalMortarFluxes &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>zero_boundary_data_on_mortar</b> (const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;direction, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;face_normal_magnitude, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim - 1 &gt; &amp;mortar_mesh, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">::dg::MortarSize</a>&lt; Dim - 1 &gt; &amp;mortar_size)</td></tr>
<tr class="memdesc:a4e09a200dbb357f30157bebd8e407a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct <code><a class="el" href="namespaceelliptic_1_1dg.html#ac01f468061bf6c950d1fa5105201ed19" title="Data that is projected to mortars and communicated across element boundaries.">elliptic::dg::BoundaryData</a></code> assuming the variable data on the element is zero, and project it to the mortar. <br /></td></tr>
<tr class="separator:a4e09a200dbb357f30157bebd8e407a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e05ac53b0c5c836331993b9bc17809"><td class="memTemplParams" colspan="2">template&lt;typename System , bool Linearized, typename... Args&gt; </td></tr>
<tr class="memitem:a95e05ac53b0c5c836331993b9bc17809"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceelliptic_1_1dg.html#a95e05ac53b0c5c836331993b9bc17809">prepare_mortar_data</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a95e05ac53b0c5c836331993b9bc17809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare data on mortars so they can be communicated to neighbors.  <a href="namespaceelliptic_1_1dg.html#a95e05ac53b0c5c836331993b9bc17809">More...</a><br /></td></tr>
<tr class="separator:a95e05ac53b0c5c836331993b9bc17809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de74fccb70b7c85eb7cc2d46de74948"><td class="memTemplParams" colspan="2">template&lt;typename System , bool Linearized, typename... Args&gt; </td></tr>
<tr class="memitem:a7de74fccb70b7c85eb7cc2d46de74948"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceelliptic_1_1dg.html#a7de74fccb70b7c85eb7cc2d46de74948">apply_operator</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a7de74fccb70b7c85eb7cc2d46de74948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the elliptic DG operator.  <a href="namespaceelliptic_1_1dg.html#a7de74fccb70b7c85eb7cc2d46de74948">More...</a><br /></td></tr>
<tr class="separator:a7de74fccb70b7c85eb7cc2d46de74948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3372233a900f2013149a4b2693c116"><td class="memTemplParams" colspan="2">template&lt;typename System , typename... Args&gt; </td></tr>
<tr class="memitem:acb3372233a900f2013149a4b2693c116"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceelliptic_1_1dg.html#acb3372233a900f2013149a4b2693c116">impose_inhomogeneous_boundary_conditions_on_source</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:acb3372233a900f2013149a4b2693c116"><td class="mdescLeft">&#160;</td><td class="mdescRight">For linear systems, impose inhomogeneous boundary conditions as contributions to the fixed sources (i.e. the RHS of the equations).  <a href="namespaceelliptic_1_1dg.html#acb3372233a900f2013149a4b2693c116">More...</a><br /></td></tr>
<tr class="separator:acb3372233a900f2013149a4b2693c116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825f4c9c0c4a193b9429560eeaff75f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDataVector.html">DataVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceelliptic_1_1dg.html#a825f4c9c0c4a193b9429560eeaff75f4">penalty</a> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;element_size, size_t num_points, double penalty_parameter)</td></tr>
<tr class="memdesc:a825f4c9c0c4a193b9429560eeaff75f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The penalty factor in internal penalty fluxes.  <a href="namespaceelliptic_1_1dg.html#a825f4c9c0c4a193b9429560eeaff75f4">More...</a><br /></td></tr>
<tr class="separator:a825f4c9c0c4a193b9429560eeaff75f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Functionality related to discontinuous Galerkin discretizations of elliptic equations. </p>
<p >The following is a brief overview of the elliptic DG schemes that are implemented here. A publication that describes the schemes in detail is in preparation and will be referenced here.</p>
<p >The DG schemes apply to any elliptic PDE that can be formulated in first-order flux-form, as detailed by <code><a class="el" href="structelliptic_1_1protocols_1_1FirstOrderSystem.html" title="A system of elliptic equations in first-order &quot;flux&quot; formulation.">elliptic::protocols::FirstOrderSystem</a></code>. The DG discretization of equations in this first-order form amounts to projecting the equations on the set of basis functions that we also use to represent the fields on the computational grid. The currently implemented DG operator uses Lagrange interpolating polynomials w.r.t. Legendre-Gauss-Lobatto collocation points as basis functions. Support for Legendre-Gauss collocation points can be added if needed. Skipping all further details here, the discretization results in a linear equation \(A(u)=b\) over all grid points and primal variables. Solving the elliptic equations amounts to numerically inverting the DG operator \(A\), typically without ever constructing the full matrix but by employing an iterative linear solver that repeatedly applies the DG operator to "test data". Note that the DG operator applies directly to the primal variables. Auxiliary variables are only computed temporarily and don't inflate the size of the operator. This means the DG operator essentially computes second derivatives of the primal variables, modified by the fluxes and sources of the system as well as by DG boundary corrections that couple grid points across element boundaries.</p>
<dl class="section user"><dt>Boundary corrections:</dt><dd>In this implementation we employ the "internal penalty" DG scheme that couples grid points across nearest-neighbor elements through the fluxes:</dd></dl>
<p class="formulaDsp">
\begin{align} (n_i F^i_v)^* &amp;= \frac{1}{2} n_i \left( F^i_v(u^\mathrm{int}) + F^i_v(u^\mathrm{ext})\right) \\ (n_i F^i_u)^* &amp;= \frac{1}{2} n_i \left( F^i_u(\partial_j F^j_v(u^\mathrm{int}) - S_v(u^\mathrm{int})) + F^i_u(\partial_j F^j_v(u^\mathrm{ext}) - S_v(u^\mathrm{ext}))\right) - \sigma n_i \left( F^i_u(n_j F^j_v(u^\mathrm{int})) - F^i_u(n_j F^j_v(u^\mathrm{ext}))\right) \end{align}
</p>
<p >Note that \(n_i\) denotes the face normal on the "interior" side of the element under consideration. We assume \(n^\mathrm{ext}_i=-n_i\) in the implementation, i.e. face normals don't depend on the dynamic variables (which may be discontinuous on element faces). This is the case for the problems we are expecting to solve, because those will be on fixed background metrics (e.g. a conformal metric for the XCTS system). Numerically, the face normals on either side of a mortar may nonetheless be different because the two faces adjacent to the mortar may resolve them at different resolutions.</p>
<p >Also note that the numerical fluxes intentionally don't depend on the auxiliary field values \(v\). This property allows us to communicate data for both the primal and auxiliary boundary corrections together, instead of communicating them in two steps. If we were to resort to a two-step communication we could replace the divergence in \((n_i F^i_u)^*\) with \(v\), which would result in a generalized "stabilized central flux" that is slightly less sparse than the internal penalty flux (see e.g. <a class="el" href="citelist.html#CITEREF_HesthavenWarburton">[80]</a>, section 7.2). We could also choose to ignore the fluxes in the penalty term, but preliminary tests suggest that this may hurt convergence.</p>
<p >For a <a class="el" href="namespacePoisson.html" title="Items related to solving a Poisson equation .">Poisson</a> system (see <code><a class="el" href="structPoisson_1_1FirstOrderSystem.html" title="The Poisson equation formulated as a set of coupled first-order PDEs.">Poisson::FirstOrderSystem</a></code>) this numerical flux reduces to the standard internal penalty flux (see e.g. <a class="el" href="citelist.html#CITEREF_HesthavenWarburton">[80]</a>, section 7.2, or <a class="el" href="citelist.html#CITEREF_Arnold2002">[5]</a>):</p>
<p class="formulaDsp">
\begin{align} (n_i F^i_{v_j})^* &amp;= n_j u^* = \frac{1}{2} n_j \left( u^\mathrm{int} + u^\mathrm{ext}\right) \\ (n_i F^i_u)^* &amp;= n_i v_i^* = \frac{1}{2} n_i \left( \partial_i u^\mathrm{int} + \partial_i u^\mathrm{ext}\right) - \sigma \left(u^\mathrm{int} - u^\mathrm{ext}\right) \end{align}
</p>
<p >where a sum over repeated indices is assumed, since the equation is formulated on a Euclidean geometry.</p>
<p >The penalty factor \(\sigma\) is responsible for removing zero eigenmodes and impacts the conditioning of the linear operator to be solved. See <code><a class="el" href="namespaceelliptic_1_1dg.html#a825f4c9c0c4a193b9429560eeaff75f4" title="The penalty factor in internal penalty fluxes.">elliptic::dg::penalty</a></code> for details. For the element size that goes into computing the penalty we choose \(h=\frac{J_\mathrm{volume}}{J_\mathrm{face}}\), i.e. the ratio of Jacobi determinants from logical to inertial coordinates in the element volume and on the element face, both evaluated on the face (see <a class="el" href="citelist.html#CITEREF_Vincent2019qpd">[166]</a>). Since both \(N_\mathrm{points}\) and \(h\) can be different on either side of the element boundary we take the maximum of \(N_\mathrm{points}\) and the pointwise minimum of \(h\) across the element boundary as is done in <a class="el" href="citelist.html#CITEREF_Vincent2019qpd">[166]</a>. Note that we use the number of points \(N_\mathrm{points}\) where <a class="el" href="citelist.html#CITEREF_Vincent2019qpd">[166]</a> uses the polynomial degree \(N_\mathrm{points} - 1\) because we found unstable configurations on curved meshes when using the polynomial degree. Optimizing the penalty on curved meshes is subject to further investigation. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a7de74fccb70b7c85eb7cc2d46de74948" name="a7de74fccb70b7c85eb7cc2d46de74948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de74fccb70b7c85eb7cc2d46de74948">&#9670;&nbsp;</a></span>apply_operator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename System , bool Linearized, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void elliptic::dg::apply_operator </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the elliptic DG operator. </p>
<p >This function applies the elliptic DG operator on an element, assuming all data on mortars is already available. Use the <code><a class="el" href="namespaceelliptic_1_1dg.html#a95e05ac53b0c5c836331993b9bc17809" title="Prepare data on mortars so they can be communicated to neighbors.">elliptic::dg::prepare_mortar_data</a></code> function to prepare mortar data on neighboring elements, then communicate the data and insert them on the "remote" side of the mortars before calling this function. </p>

</div>
</div>
<a id="acb3372233a900f2013149a4b2693c116" name="acb3372233a900f2013149a4b2693c116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb3372233a900f2013149a4b2693c116">&#9670;&nbsp;</a></span>impose_inhomogeneous_boundary_conditions_on_source()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename System , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void elliptic::dg::impose_inhomogeneous_boundary_conditions_on_source </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For linear systems, impose inhomogeneous boundary conditions as contributions to the fixed sources (i.e. the RHS of the equations). </p>
<p >This function exists because the DG operator must typically be linear, but even for linear elliptic equations we typically apply boundary conditions with a constant, and therefore nonlinear, contribution. Standard examples are inhomogeneous (i.e. non-zero) Dirichlet or Neumann boundary conditions. This nonlinear contribution can be added to the fixed sources, leaving only the linearized boundary conditions in the DG operator. For standard constant Dirichlet or Neumann boundary conditions the linearization is of course just zero.</p>
<p >This function essentially feeds zero variables through the nonlinear operator and subtracts the result from the fixed sources: <code>b -= A(x=0)</code>. </p>

</div>
</div>
<a id="a825f4c9c0c4a193b9429560eeaff75f4" name="a825f4c9c0c4a193b9429560eeaff75f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825f4c9c0c4a193b9429560eeaff75f4">&#9670;&nbsp;</a></span>penalty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataVector.html">DataVector</a> elliptic::dg::penalty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>element_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>penalty_parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The penalty factor in internal penalty fluxes. </p>
<p >The penalty factor is computed as</p>
<p class="formulaDsp">
\begin{equation} \sigma = C \frac{N_\text{points}^2}{h} \end{equation}
</p>
<p >where \(N_\text{points} = 1 + N_p\) is the number of points (or one plus the polynomial degree) and \(h\) is a measure of the element size. Both quantities are taken perpendicular to the face of the DG element that the penalty is being computed on. \(C\) is the "penalty parameter". For details see section 7.2 in <a class="el" href="citelist.html#CITEREF_HesthavenWarburton">[80]</a>. </p>

</div>
</div>
<a id="a95e05ac53b0c5c836331993b9bc17809" name="a95e05ac53b0c5c836331993b9bc17809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e05ac53b0c5c836331993b9bc17809">&#9670;&nbsp;</a></span>prepare_mortar_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename System , bool Linearized, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void elliptic::dg::prepare_mortar_data </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare data on mortars so they can be communicated to neighbors. </p>
<p >Call this function on all elements and communicate the mortar data, then call <code><a class="el" href="namespaceelliptic_1_1dg.html#a7de74fccb70b7c85eb7cc2d46de74948" title="Apply the elliptic DG operator.">elliptic::dg::apply_operator</a></code>. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceelliptic.html">elliptic</a></li><li class="navelem"><a class="el" href="namespaceelliptic_1_1dg.html">dg</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
