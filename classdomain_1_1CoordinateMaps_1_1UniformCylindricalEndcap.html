<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: domain::CoordinateMaps::UniformCylindricalEndcap Class Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classdomain_1_1CoordinateMaps_1_1UniformCylindricalEndcap.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalEndcap-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">domain::CoordinateMaps::UniformCylindricalEndcap Class Reference<div class="ingroups"><a class="el" href="group__CoordinateMapsGroup.html">Coordinate Maps</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Map from 3D unit right cylinder to a volume that connects portions of two spherical surfaces.  
 <a href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalEndcap.html#details">More...</a></p>

<p><code>#include &lt;UniformCylindricalEndcap.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a310ece694deada008d8a836ed2c683eb"><td class="memItemLeft" align="right" valign="top"><a id="a310ece694deada008d8a836ed2c683eb" name="a310ece694deada008d8a836ed2c683eb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UniformCylindricalEndcap</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 3 &gt; &amp;center_one, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 3 &gt; &amp;center_two, double radius_one, double radius_two, double z_plane_one, double z_plane_two)</td></tr>
<tr class="separator:a310ece694deada008d8a836ed2c683eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab244f243af0d1e83863acf78a5d7400b"><td class="memItemLeft" align="right" valign="top"><a id="ab244f243af0d1e83863acf78a5d7400b" name="ab244f243af0d1e83863acf78a5d7400b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UniformCylindricalEndcap</b> (<a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalEndcap.html">UniformCylindricalEndcap</a> &amp;&amp;)=default</td></tr>
<tr class="separator:ab244f243af0d1e83863acf78a5d7400b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb19860ecf9d6d428d4765347230002b"><td class="memItemLeft" align="right" valign="top"><a id="adb19860ecf9d6d428d4765347230002b" name="adb19860ecf9d6d428d4765347230002b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UniformCylindricalEndcap</b> (const <a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalEndcap.html">UniformCylindricalEndcap</a> &amp;)=default</td></tr>
<tr class="separator:adb19860ecf9d6d428d4765347230002b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32f8d1c7c2ed52c6734a06b7fb6d0ea"><td class="memItemLeft" align="right" valign="top"><a id="ab32f8d1c7c2ed52c6734a06b7fb6d0ea" name="ab32f8d1c7c2ed52c6734a06b7fb6d0ea"></a>
<a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalEndcap.html">UniformCylindricalEndcap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalEndcap.html">UniformCylindricalEndcap</a> &amp;)=default</td></tr>
<tr class="separator:ab32f8d1c7c2ed52c6734a06b7fb6d0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab206515f5cf10b91afc462ca05cd3555"><td class="memItemLeft" align="right" valign="top"><a id="ab206515f5cf10b91afc462ca05cd3555" name="ab206515f5cf10b91afc462ca05cd3555"></a>
<a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalEndcap.html">UniformCylindricalEndcap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalEndcap.html">UniformCylindricalEndcap</a> &amp;&amp;)=default</td></tr>
<tr class="separator:ab206515f5cf10b91afc462ca05cd3555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9faa76aee81f587b1f7765c8b97eb1a2"><td class="memTemplParams" colspan="2"><a id="a9faa76aee81f587b1f7765c8b97eb1a2" name="a9faa76aee81f587b1f7765c8b97eb1a2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9faa76aee81f587b1f7765c8b97eb1a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; tt::remove_cvref_wrap_t&lt; T &gt;, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator()</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 3 &gt; &amp;source_coords) const</td></tr>
<tr class="separator:a9faa76aee81f587b1f7765c8b97eb1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad248032fd4c47c268a94c2feba518e3d"><td class="memItemLeft" align="right" valign="top"><a id="ad248032fd4c47c268a94c2feba518e3d" name="ad248032fd4c47c268a94c2feba518e3d"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>inverse</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 3 &gt; &amp;target_coords) const</td></tr>
<tr class="memdesc:ad248032fd4c47c268a94c2feba518e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse function is only callable with doubles because the inverse might fail if called for a point out of range, and it is unclear what should happen if the inverse were to succeed for some points in a <a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a> but fail for other points. <br /></td></tr>
<tr class="separator:ad248032fd4c47c268a94c2feba518e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa7818a5c5a3071b9fc8fd0ae50b21e"><td class="memTemplParams" colspan="2"><a id="a5fa7818a5c5a3071b9fc8fd0ae50b21e" name="a5fa7818a5c5a3071b9fc8fd0ae50b21e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5fa7818a5c5a3071b9fc8fd0ae50b21e"><td class="memTemplItemLeft" align="right" valign="top">tnsr::Ij&lt; tt::remove_cvref_wrap_t&lt; T &gt;, 3, <a class="el" href="structFrame_1_1NoFrame.html">Frame::NoFrame</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>jacobian</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 3 &gt; &amp;source_coords) const</td></tr>
<tr class="separator:a5fa7818a5c5a3071b9fc8fd0ae50b21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc59d1145ac2e8ef94a7366162587c24"><td class="memTemplParams" colspan="2"><a id="acc59d1145ac2e8ef94a7366162587c24" name="acc59d1145ac2e8ef94a7366162587c24"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acc59d1145ac2e8ef94a7366162587c24"><td class="memTemplItemLeft" align="right" valign="top">tnsr::Ij&lt; tt::remove_cvref_wrap_t&lt; T &gt;, 3, <a class="el" href="structFrame_1_1NoFrame.html">Frame::NoFrame</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inv_jacobian</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 3 &gt; &amp;source_coords) const</td></tr>
<tr class="separator:acc59d1145ac2e8ef94a7366162587c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83652155d11fed334819a6c823699992"><td class="memItemLeft" align="right" valign="top"><a id="a83652155d11fed334819a6c823699992" name="a83652155d11fed334819a6c823699992"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pup</b> (PUP::er &amp;p)</td></tr>
<tr class="separator:a83652155d11fed334819a6c823699992"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abe83188df4449c3051b0bad0b7eebe4a"><td class="memItemLeft" align="right" valign="top"><a id="abe83188df4449c3051b0bad0b7eebe4a" name="abe83188df4449c3051b0bad0b7eebe4a"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_identity</b> ()</td></tr>
<tr class="separator:abe83188df4449c3051b0bad0b7eebe4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a30584a951366f2cd94a2ebe509b166be"><td class="memItemLeft" align="right" valign="top"><a id="a30584a951366f2cd94a2ebe509b166be" name="a30584a951366f2cd94a2ebe509b166be"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>dim</b> = 3</td></tr>
<tr class="separator:a30584a951366f2cd94a2ebe509b166be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0577cc8d69229483a258cad2b8c890dc"><td class="memItemLeft" align="right" valign="top"><a id="a0577cc8d69229483a258cad2b8c890dc" name="a0577cc8d69229483a258cad2b8c890dc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalEndcap.html">UniformCylindricalEndcap</a> &amp;lhs, const <a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalEndcap.html">UniformCylindricalEndcap</a> &amp;rhs)</td></tr>
<tr class="separator:a0577cc8d69229483a258cad2b8c890dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Map from 3D unit right cylinder to a volume that connects portions of two spherical surfaces. </p>
<div class="image">
<object type="image/svg+xml" data="UniformCylEndcap.svg" style="pointer-events: none;"></object>
<div class="caption">
A cylinder maps to the shaded region.</div></div>
<h3>Details</h3>
<p >Consider two spheres with centers \(C_1\) and \(C_2\), and radii \(R_1\) and \(R_2\). Let sphere 1 be intersected by a plane normal to the \(z\) axis and located at \(z = z_{\mathrm{P}1}\), and let sphere 2 be intersected by a plane normal to the \(z\) axis and located at \(z = z_{\mathrm{P}2}\).</p>
<p ><a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalEndcap.html" title="Map from 3D unit right cylinder to a volume that connects portions of two spherical surfaces.">UniformCylindricalEndcap</a> maps a 3D unit right cylinder (with coordinates \((\bar{x},\bar{y},\bar{z})\) such that \(-1\leq\bar{z}\leq 1\) and \(\bar{x}^2+\bar{y}^2 \leq 1\)) to the shaded area in the figure above (with coordinates \((x,y,z)\)). The "bottom" of the cylinder \(\bar{z}=-1\) is mapped to the portion of sphere 1 that has \(z \geq z_{\mathrm{P}1}\), and on this portion of the sphere the angular coordinate \(\theta_1 = \acos((z-C_1^2)/R_1)\) is uniform in \(\bar{\rho} = \sqrt{\bar{x}^2+\bar{y}^2}\) and the angular coordinate \(\phi_1 = \atan((y-C_1^1)/(x-C_1^0))\) is the same as \(\phi = \atan(\bar{y}/\bar{x})\). Likewise, the "top" of the cylinder \(\bar{z}=+1\) is mapped to the portion of sphere 2 that has \(z \geq z_{\mathrm{P}2}\), and on this portion of the sphere the angular coordinate \(\theta_2 = \acos((z-C_2^2)/R_2)\) is uniform in \(\bar\rho\) and the angular coordinate \(\phi_2 = \atan((y-C_2^1)/(x-C_2^0))\) is the same as \(\phi\).</p>
<p ><a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalEndcap.html" title="Map from 3D unit right cylinder to a volume that connects portions of two spherical surfaces.">UniformCylindricalEndcap</a> is different from <a class="el" href="classdomain_1_1CoordinateMaps_1_1CylindricalEndcap.html" title="Map from 3D unit right cylinder to a volume that connects portions of two spherical surfaces.">CylindricalEndcap</a> because of the distribution of points on the spheres, and because for <a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalEndcap.html" title="Map from 3D unit right cylinder to a volume that connects portions of two spherical surfaces.">UniformCylindricalEndcap</a> the mapped portion of both Sphere 1 and Sphere 2 are bounded by planes of constant \(z\), whereas for <a class="el" href="classdomain_1_1CoordinateMaps_1_1CylindricalEndcap.html" title="Map from 3D unit right cylinder to a volume that connects portions of two spherical surfaces.">CylindricalEndcap</a> only one of the mapped portions is bounded by a plane (except for specially chosen map parameters). Note that <a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalEndcap.html" title="Map from 3D unit right cylinder to a volume that connects portions of two spherical surfaces.">UniformCylindricalEndcap</a> can be used to construct maps that connect an arbitrary number of nested spheres; this is not possible for <a class="el" href="classdomain_1_1CoordinateMaps_1_1CylindricalEndcap.html" title="Map from 3D unit right cylinder to a volume that connects portions of two spherical surfaces.">CylindricalEndcap</a> for more than 3 nested spheres because of this asymmetry between <a class="el" href="classdomain_1_1CoordinateMaps_1_1CylindricalEndcap.html" title="Map from 3D unit right cylinder to a volume that connects portions of two spherical surfaces.">CylindricalEndcap</a>'s two spherical surfaces.</p>
<p ><a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalEndcap.html" title="Map from 3D unit right cylinder to a volume that connects portions of two spherical surfaces.">UniformCylindricalEndcap</a> is intended to be composed with <code><a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html" title="Map from a square or cube to a wedge.">Wedge</a>&lt;2&gt;</code> maps to construct a portion of a cylindrical domain for a binary system.</p>
<p ><a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalEndcap.html" title="Map from 3D unit right cylinder to a volume that connects portions of two spherical surfaces.">UniformCylindricalEndcap</a> can be used to construct a domain that is similar to, but not identical to, the one described briefly in the Appendix of <a class="el" href="citelist.html#CITEREF_Buchman:2012dw">[30]</a>. <a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalEndcap.html" title="Map from 3D unit right cylinder to a volume that connects portions of two spherical surfaces.">UniformCylindricalEndcap</a> is used to construct the Blocks analogous to those labeled 'CA wedge', 'EA wedge', 'CB wedge', 'EE wedge', and 'EB wedge' in Figure 20 of that paper.</p>
<p ><a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalEndcap.html" title="Map from 3D unit right cylinder to a volume that connects portions of two spherical surfaces.">UniformCylindricalEndcap</a> provides the following functions:</p>
<h3><a class="anchor" id="autotoc_md294"></a>
operator()</h3>
<p ><code>operator()</code> maps \((\bar{x},\bar{y},\bar{z})\) to \((x,y,z)\) according to</p>
<p class="formulaDsp">
\begin{align} x^0 &amp;= C_1^0+\lambda(C_2^0-C_1^0) + \cos\phi\left(R_1\sin\theta_1 + \lambda(R_2\sin\theta_2-R_1\sin\theta_1)\right), \label{eq:x0} \\ x^1 &amp;= C_1^1+\lambda(C_2^1-C_1^1) + \sin\phi\left(R_1\sin\theta_1 + \lambda(R_2\sin\theta_2-R_1\sin\theta_1)\right), \label{eq:x1} \\ x^2 &amp;= C_1^2+\lambda(C_2^2-C_1^2) + R_1\cos\theta_1 + \lambda(R_2\cos\theta_2-R_1\cos\theta_1) \label{eq:x2}. \end{align}
</p>
<p >Here </p><p class="formulaDsp">
\begin{align} \lambda &amp;= \frac{\bar{z}+1}{2},\label{eq:lambdafromzbar}\\ \theta_1 &amp;= \bar{\rho} \theta_{1 \mathrm{max}},\label{eq:deftheta1}\\ \theta_2 &amp;= \bar{\rho} \theta_{2 \mathrm{max}},\label{eq:deftheta2}\\ \phi &amp;= \atan(\bar{y}/\bar{x})\label{eq:defphi}, \end{align}
</p>
<p> where \(\theta_{1 \mathrm{max}}\) and \(\theta_{2 \mathrm{max}}\) are defined by </p><p class="formulaDsp">
\begin{align} \cos(\theta_{1\mathrm{max}}) &amp;= (z_{\mathrm{P}1}-C_1^2)/R_1,\\ \cos(\theta_{2\mathrm{max}}) &amp;= (z_{\mathrm{P}2}-C_2^2)/R_2, \end{align}
</p>
<p> and </p><p class="formulaDsp">
\begin{align} \bar{\rho} &amp;= \sqrt{\bar{x}^2+\bar{y}^2}/\bar{R} \label{eq:defrhobar}, \end{align}
</p>
<p> where \(\bar{R}\) is the radius of the cylinder in barred coordinates, which is always unity.</p>
<h3><a class="anchor" id="autotoc_md295"></a>
inverse</h3>
<p >Given \((x,y,z)\) we want to find \((\bar{x},\bar{y},\bar{z})\). From Eq. ( \(\ref{eq:x2}\)) we can write \(\lambda\) as a function of \(\bar\rho\):</p>
<p class="formulaDsp">
\begin{align} \lambda &amp;= \frac{x^2 - C_1^2 - R_1\cos\theta_1} {C_2^2-C_1^2 + R_2\cos\theta_2-R_1\cos\theta_1} \label{eq:lambda_from_rho}. \end{align}
</p>
<p >Then by eliminating \(\phi\) from Eqs. ( \(\ref{eq:x0}\)) and ( \(\ref{eq:x1}\)) we find that \(\bar{\rho}\) is the solution of \(Q(\bar{\rho})=0\), where</p>
<p class="formulaDsp">
\begin{align} Q(\bar{\rho}) &amp;= \left(x^0-C_1^0-\lambda(C_2^0-C_1^0)\right)^2+ \left(x^1-C_1^1-\lambda(C_2^1-C_1^1)\right)^2- \left((1-\lambda)R_1\sin\theta_1 + \lambda R_2\sin\theta_2\right)^2.\label{eq:defQ} \end{align}
</p>
<p> Here \(\lambda\), \(\theta_1\), and \(\theta_2\) are functions of \(\bar{\rho}\) through Eqs. ( \(\ref{eq:lambda_from_rho}\)), ( \(\ref{eq:deftheta1}\)), and ( \(\ref{eq:deftheta2}\)).</p>
<p >We solve \(Q(\bar{\rho})=0\) numerically; it is a one-dimensional root-finding problem.</p>
<p >Once we have determined \(\bar{\rho}\), we then obtain \(\lambda\) from Eq. ( \(\ref{eq:lambda_from_rho}\)), and we obtain \(\phi\) from</p>
<p class="formulaDsp">
\begin{align} \tan\phi &amp;= \frac{x^1-C_1^1-\lambda(C_2^1-C_1^1)}{x^0-C_1^0-\lambda(C_2^0-C_1^0)}. \end{align}
</p>
<p >Then \(\bar{z}\) is obtained from Eq. ( \(\ref{eq:lambdafromzbar}\)) and \(\bar{x}\) and \(\bar{y}\) are obtained from</p>
<p class="formulaDsp">
\begin{align} \bar{x} &amp;= \bar{\rho}\bar{R}\cos\phi,\\ \bar{y} &amp;= \bar{\rho}\bar{R}\sin\phi. \end{align}
</p>
<h4><a class="anchor" id="autotoc_md296"></a>
Considerations when root-finding.</h4>
<p >We solve \(Q(\bar{\rho})=0\) numerically for \(\bar{\rho}\), where \(Q(\bar{\rho})\) is given by Eq. ( \(\ref{eq:defQ}\)).</p>
<p ><a class="anchor" id="autotoc_md297"></a> </p><h5>min/max values of \(\bar{\rho}\):</h5>
<p >Note that the root we care about must have \(0\leq\lambda\leq 1\); therefore from Eq. ( \(\ref{eq:lambda_from_rho}\)) we have</p>
<p class="formulaDsp">
\begin{align} \bar{\rho}_{\mathrm{min}} &amp;= \left\{\begin{array}{ll} 0 &amp; \text{for } x^2-C_1^2 \geq R_1, \\ \displaystyle \frac{1}{\theta_{1 \mathrm{max}}} \cos^{-1}\left(\frac{x^2-C_1^2}{R_1}\right) &amp; \text{otherwise} \end{array}\right.\label{eq:rhobarmin}\\ \bar{\rho}_{\mathrm{max}} &amp;= \left\{\begin{array}{ll} 1 &amp; \text{for } x^2-C_2^2 \leq R_2\cos\theta_{2 \mathrm{max}}, \\ \displaystyle \frac{1}{\theta_{2 \mathrm{max}}} \cos^{-1}\left(\frac{x^2-C_2^2}{R_2}\right) &amp; \text{otherwise} \end{array}\right.\label{eq:rhobarmax} \end{align}
</p>
<p >so we look for a root only between \(\bar{\rho}_{\mathrm{min}}\) and \(\bar{\rho}_{\mathrm{max}}\).</p>
<p ><a class="anchor" id="autotoc_md298"></a> </p><h5>Roots within roundoff of endpoints:</h5>
<p >Sometimes a root is within roundoff of \(\bar{\rho}_{\mathrm{min}}\) or \(\bar{\rho}_{\mathrm{max}}\). This tends to happen at points on the boundary of the mapped region. In this case, the root might not be bracketed by \([\bar{\rho}_{\mathrm{min}},\bar{\rho}_{\mathrm{max}}]\) if the root is slightly outside that interval. If we find that \(Q(\bar{\rho}_{\mathrm{min}})\) is near zero but has the wrong sign, then we slightly expand the interval as follows:</p>
<p class="formulaDsp">
\begin{align} \bar{\rho}_{\mathrm{min}} \to \bar{\rho}_{\mathrm{min}} - 2 \frac{Q(\bar{\rho}_{\mathrm{min}})}{Q&#39;(\bar{\rho}_{\mathrm{min}})}, \end{align}
</p>
<p >where \(Q&#39;(\bar{\rho}_{\mathrm{min}})\) is the derivative of the function in Eq. ( \(\ref{eq:defQ}\)). Note that without the factor of 2, this is a Newton-Raphson step; the factor of 2 is there to overcompensate so that the new \(\bar{\rho}_{\mathrm{min}}\) brackets the root.</p>
<p >Similarly, if it is found that \(Q(\bar{\rho}_{\mathrm{max}})\) is near zero but has the wrong sign so that the root is not bracketed, then the same formula is used to expand the interval near \(\bar{\rho} = \bar{\rho}_{\mathrm{max}}\) to bracket the root.</p>
<p >Note that by differentiating Eqs. ( \(\ref{eq:defQ}\)) and ( \(\ref{eq:lambda_from_rho}\)), one obtains</p>
<p class="formulaDsp">
\begin{align} Q&#39;(\bar{\rho}) =&amp; -2 \frac{d\lambda}{d\bar{\rho}}\left[ \left(x^0-C_1^0-\lambda(C_2^0-C_1^0)\right)(C_2^0-C_1^0)+ \left(x^1-C_1^1-\lambda(C_2^1-C_1^1)\right)(C_2^1-C_1^1) \right]\nonumber \\ &amp; -2 \left((1-\lambda)R_1\sin\theta_1 + \lambda R_2\sin\theta_2\right) \left[ \frac{d\lambda}{d\bar{\rho}} (R_2\sin\theta_2-R_1\sin\theta_1) +(1-\lambda)R_1\theta_{1 \mathrm{max}}\cos\theta_1 +\lambda R_2\theta_{2 \mathrm{max}}\cos\theta_2 \right], \label{eq:defQderiv} \end{align}
</p>
<p >where </p><p class="formulaDsp">
\begin{align} \frac{d\lambda}{d\bar{\rho}} &amp;= \frac{(1-\lambda)R_1\theta_{1 \mathrm{max}}\sin\theta_1 +\lambda R_2\theta_{2 \mathrm{max}}\sin\theta_2} {C_2^2-C_1^2 + R_2\cos\theta_2-R_1\cos\theta_1} \label{eq:dlambda_drhobar}. \end{align}
</p>
<p ><a class="anchor" id="autotoc_md299"></a> </p><h5>Roots within roundoff of \(\bar{\rho}=0\) or \(\bar{\rho}=1\):</h5>
<p >For some points on the boundary of the mapped domain, the root will be within roundoff of \(\bar{\rho}=0\) or \(\bar{\rho}=1\). Here it does not always make sense to expand the range of the map if the root fails (by roundoff) to be bracketed, as is done above. Furthermore, when \(\bar{\rho}=0\) is a root it turns out that both \(Q(\bar{\rho})=0\) and \(Q&#39;(\bar{\rho})=0\) for \(\bar{\rho}=0\), so some root-finders (e.g. Newton-Raphson) have difficulty converging. Therefore the cases where the root is within roundoff of \(\bar{\rho}=0\) or \(\bar{\rho}=1\) are treated separately.</p>
<p >These cases are detected by comparing terms in the first-order power series of \(Q(\bar{\rho})=0\) when expanded about \(\bar{\rho}=0\) or \(\bar{\rho}=1\). When one of these cases is recognized, the root is returned as either \(\bar{\rho}=0\) or \(\bar{\rho}=1\).</p>
<h4><a class="anchor" id="autotoc_md300"></a>
Quick rejection of points out of range of the map.</h4>
<p >It is expected that <code><a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalEndcap.html#ad248032fd4c47c268a94c2feba518e3d" title="The inverse function is only callable with doubles because the inverse might fail if called for a poi...">inverse()</a></code> will often be passed points \((x,y,z)\) that are out of the range of the map; in this case <code><a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalEndcap.html#ad248032fd4c47c268a94c2feba518e3d" title="The inverse function is only callable with doubles because the inverse might fail if called for a poi...">inverse()</a></code> returns a default-constructed <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;double, 3&gt;&gt;</code>. To avoid the difficulty and expense of attempting to solve \(Q(\bar{\rho})=0\) numerically for such points (and then having this solution fail), it is useful to quickly reject points \((x,y,z)\) that are outside the range of the map.</p>
<p >Any point in the range of the map must be inside or on sphere 2, and it must be outside or on sphere 1, so the inverse map can immediately return a default-constructed <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;double, 3&gt;&gt;</code> for a point that does not satisfy these conditions.</p>
<p >Likewise, the inverse map can immediately reject any point with \(z &lt; z_{\mathrm{P}1}\).</p>
<p >Finally, consider the circle \(S_1\) defining the intersection of sphere 1 and the plane \(z = z_{\mathrm{P}1}\); this circle has radius \(r_1 = R_1 \sin\theta_{1\mathrm{max}}\). Similarly, the circle \(S_2\) defining the intersection of sphere 2 and the plane \(z = z_{\mathrm{P}2}\) has radius \(r_2 = R_2 \sin\theta_{2\mathrm{max}}\). Now consider the cone that passes through these two circles. A point in the range of the map must be inside or on this cone. The cone can be defined parametrically as</p>
<p class="formulaDsp">
\begin{align} x_c &amp;= C_1^0 + \tilde{\lambda}(C_2^0-C_1^0) + \cos\varphi (r_1 + \tilde{\lambda} (r_2 -r_1)),\\ y_c &amp;= C_1^1 + \tilde{\lambda}(C_2^1-C_1^1),+ \sin\varphi (r_1 + \tilde{\lambda} (r_2 -r_1)),\\ z_c &amp;= C_1^2 + R_1 \cos\theta_{1\mathrm{max}} + \tilde{\lambda}(C_2^2 + R_2 \cos\theta_{2\mathrm{max}} - C_1^2 - R_1 \cos\theta_{1\mathrm{max}}), \end{align}
</p>
<p >where \((x_c,y_c,z_c)\) is a point on the cone, and the two parameters defining a point on the cone are the angle \(\varphi\) around the cone and the parameter \(\tilde{\lambda}\), which is defined to be zero on \(S_1\) and unity on \(S_2\).</p>
<p >Given an arbitrary point \((x, y, z)\), we can determine whether or not that point is inside the cone as follows. First determine</p>
<p class="formulaDsp">
\begin{align} \tilde{\lambda} &amp;= \frac{z - C_1^2 - R_1 \cos\theta_{1\mathrm{max}}} {C_2^2+ R_2 \cos\theta_{2\mathrm{max}}- C_1^2- R_1 \cos\theta_{1\mathrm{max}}}, \\ \tilde{x} &amp;= x - C_1^0 - \tilde{\lambda} (C_2^0-C_1^0),\\ \tilde{y} &amp;= y - C_1^1 - \tilde{\lambda} (C_2^1-C_1^1).\\ \end{align}
</p>
<p >Then the condition for the point to be inside or on the cone is </p><p class="formulaDsp">
\begin{align} \sqrt{\tilde{x}^2+\tilde{y}^2} \le r_1 + (r_2-r_1)\tilde{\lambda}. \end{align}
</p>
<p >The inverse map can therefore reject any points that do not satisfy this criterion.</p>
<h3><a class="anchor" id="autotoc_md301"></a>
jacobian</h3>
<p >One can rewrite Eqs.( \(\ref{eq:x0}\)) through ( \(\ref{eq:x2}\)) as</p>
<p class="formulaDsp">
\begin{align} x^0 &amp;= \frac{1}{2}\left((1-\bar{z})C_1^0+ (1+\bar{z})C_2^0\right) + \frac{\bar{x}}{2}\left( (1-\bar{z}) R_1 S(\bar{\rho},\theta_{1 \mathrm{max}}) + (1+\bar{z}) R_2 S(\bar{\rho},\theta_{2 \mathrm{max}}) \right), \label{eq:x0alt} \\ x^1 &amp;= \frac{1}{2}\left((1-\bar{z})C_1^1 + (1+\bar{z})C_2^1\right) + \frac{\bar{y}}{2}\left( (1-\bar{z})R_1 S(\bar{\rho},\theta_{1 \mathrm{max}}) + (1+\bar{z})R_2 S(\bar{\rho},\theta_{2 \mathrm{max}}) \right), \label{eq:x1alt} \\ x^2 &amp;= \frac{1}{2}\left((1-\bar{z})C_1^2 + (1+\bar{z})C_2^2\right) + \left( (1-\bar{z})R_1 \cos\theta_1 + (1+\bar{z})R_2 \cos\theta_2 \right), \label{eq:x2alt} \\ \end{align}
</p>
<p >where we have used Eq. ( \(\ref{eq:lambdafromzbar}\)) to eliminate \(\lambda\) in favor of \(\bar{z}\), and where we have defined the function</p>
<p class="formulaDsp">
\begin{align} S(\bar{\rho},a) = \frac{\sin(\bar{\rho} a)}{\bar{\rho}}. \label{eq:Sdef} \end{align}
</p>
<p >Note that \(S(\bar{\rho},a)\) is finite as \(\bar{\rho}\) approaches zero, and in the code we must take care that everything remains well-behaved in that limit.</p>
<p >Then differentiating Eqs. ( \(\ref{eq:x0alt}\)) and ( \(\ref{eq:x1alt}\)) with respect to \(\bar{x}\) and \(\bar{y}\), taking into account the dependence of \(\bar{\rho}\) on \(\bar{x}\) and \(\bar{y}\) from Eq. ( \(\ref{eq:defrhobar}\)), we find:</p>
<p class="formulaDsp">
\begin{align} \frac{\partial x^0}{\partial \bar{x}} &amp;= \frac{1}{2}\left( (1-\bar{z}) R_1 S(\bar{\rho},\theta_{1 \mathrm{max}}) + (1+\bar{z}) R_2 S(\bar{\rho},\theta_{2 \mathrm{max}}) \right) + \frac{\bar{x}^2}{2\bar{\rho}} \left[ (1-\bar{z}) R_1 S&#39;(\bar{\rho},\theta_{1 \mathrm{max}}) + (1+\bar{z}) R_2 S&#39;(\bar{\rho},\theta_{2 \mathrm{max}}) \right], \\ \frac{\partial x^1}{\partial \bar{y}} &amp;= \frac{1}{2}\left( (1-\bar{z}) R_1 S(\bar{\rho},\theta_{1 \mathrm{max}}) + (1+\bar{z}) R_2 S(\bar{\rho},\theta_{2 \mathrm{max}}) \right) + \frac{\bar{y}^2}{2\bar{\rho}} \left[ (1-\bar{z}) R_1 S&#39;(\bar{\rho},\theta_{1 \mathrm{max}}) + (1+\bar{z}) R_2 S&#39;(\bar{\rho},\theta_{2 \mathrm{max}}) \right], \\ \frac{\partial x^0}{\partial \bar{y}} &amp;= \frac{\bar{x}\bar{y}}{2\bar{\rho}}\left[ (1-\bar{z}) R_1 S&#39;(\bar{\rho},\theta_{1 \mathrm{max}}) + (1+\bar{z}) R_2 S&#39;(\bar{\rho},\theta_{2 \mathrm{max}}) \right], \\ \frac{\partial x^1}{\partial \bar{x}} &amp;= \frac{\partial x^0}{\partial \bar{y}}, \end{align}
</p>
<p >where \(S&#39;(\bar{\rho},a)\) means the derivative of \(S(\bar{\rho},a)\) with respect to \(\bar\rho\). Note that \(S&#39;(\bar{\rho},a)/\bar{\rho}\) approaches a constant value as \(\bar{\rho}\) approaches zero.</p>
<p >Differentiating Eq. ( \(\ref{eq:x2alt}\)) with respect to \(\bar{x}\) and \(\bar{y}\) we find</p>
<p class="formulaDsp">
\begin{align} \frac{\partial x^2}{\partial \bar{x}} &amp;= - \frac{\bar{x}}{2}\left[ (1-\bar{z}) R_1 \theta_{1 \mathrm{max}} S(\bar{\rho},\theta_{1 \mathrm{max}}) + (1+\bar{z}) R_2 \theta_{2 \mathrm{max}} S(\bar{\rho},\theta_{2 \mathrm{max}})- \right],\\ \frac{\partial x^2}{\partial \bar{y}} &amp;= - \frac{\bar{y}}{2}\left[ (1-\bar{z}) R_1 \theta_{1 \mathrm{max}} S(\bar{\rho},\theta_{1 \mathrm{max}}) + (1+\bar{z}) R_2 \theta_{2 \mathrm{max}} S(\bar{\rho},\theta_{2 \mathrm{max}})- \right]. \end{align}
</p>
<p >Differentiating Eqs. ( \(\ref{eq:x0alt}\)) through ( \(\ref{eq:x2alt}\)) with respect to \(\bar{z}\) yields</p>
<p class="formulaDsp">
\begin{align} \frac{\partial x^0}{\partial \bar{z}} &amp;= \frac{1}{2}\left[ C_2^0-C_1^0 + \bar{x}\left(R_2 S(\bar{\rho},\theta_{2 \mathrm{max}}) - R_1 S(\bar{\rho},\theta_{1 \mathrm{max}})\right) \right],\\ \frac{\partial x^1}{\partial \bar{z}} &amp;= \frac{1}{2}\left[ C_2^1-C_1^1 + \bar{y}\left(R_2 S(\bar{\rho},\theta_{2 \mathrm{max}}) - R_1 S(\bar{\rho},\theta_{1 \mathrm{max}})\right) \right],\\ \frac{\partial x^2}{\partial \bar{z}} &amp;= \frac{1}{2}\left( C_2^2-C_1^2 + R_2\cos\theta_2 - R_1\cos\theta_1 \right). \end{align}
</p>
<h3><a class="anchor" id="autotoc_md302"></a>
inv_jacobian</h3>
<p >The inverse Jacobian is computed by numerically inverting the Jacobian.</p>
<h3><a class="anchor" id="autotoc_md303"></a>
Restrictions on map parameters</h3>
<p >We demand that Sphere 1 is fully contained inside Sphere 2, and that the two spheres have at least some small separation between them. In particular, we demand that</p><ul>
<li>\(0.98 R_2 &gt;= R_1 + |C_1-C_2|\)</li>
</ul>
<p >where 0.98 is a safety factor. It is possible to construct a valid map without this assumption, but the assumption simplifies the code, and the expected use cases obey this restriction.</p>
<p >We also demand that \(z_{\mathrm{P}1} &lt;= z_{\mathrm{P}2} -0.04 R_2\), and that the z planes in the above figures lie above the centers of the corresponding spheres and are not too close to the centers or edges of those spheres; specificially, we demand that</p><ul>
<li>\( 0.075\pi &lt; \theta_{1 \mathrm{max}} &lt; 0.45\pi\)</li>
<li>\( 0.075\pi &lt; \theta_{2 \mathrm{max}} &lt; 0.45\pi\)</li>
</ul>
<p >Here 0.075 and 0.45 are safety factors. These restrictions are not strictly necessary but are made for simplicity and to ensure the accuracy of the inverse map (the inverse map becomes less accurate if the map parameters are extreme).</p>
<p >Consider the line segment \(L\) that connects a point on the circle \(S_1\) (the circle formed by the intersection of sphere 1 and the plane \(z=z_{\mathrm{P}1}\)) with the center of the circle \(S_1\). Consider another line segment \(L&#39;\) that connects the same point on the circle \(S_1\) with the corresponding point on the circle \(S_2\) (the circle formed by the intersection of sphere 2 and the plane \(z=z_{\mathrm{P}2}\)). Now consider the angle between \(L\) and \(L&#39;\), as measured from the interior of sphere 1, and Let \(\alpha\) be the minimum value of this angle over the circle. \(\alpha\) is shown in the figure above. If \(\alpha &lt; \theta_{1 \mathrm{max}}\), then the line segment \(L&#39;\) intersects the mapped portion of sphere 1 twice, so the map is multiply valued. Similarly, if \(\alpha &lt; \theta_{2 \mathrm{max}}\), then the line segment \(L&#39;\) intersects the mapped portion of sphere 2 twice, and again the map is multiply valued. Therefore we demand that the map parameters are such that</p><ul>
<li>\(\alpha &gt; 1.1 \theta_{1 \mathrm{max}}\)</li>
<li>\(\alpha &gt; 1.1 \theta_{2 \mathrm{max}}\)</li>
</ul>
<p >where 1.1 is a safety factor.</p>
<p >The condition on \(\alpha\) is guaranteed to provide an invertible map if \(C_1^0=C_2^0\) and \(C_1^1=C_2^1\). However, for \(C_1^0 \neq C_2^0\) or \(C_1^1\neq C_2^1\), even if the \(\alpha\) condition is satisfied, it is possible for two lines of constant \((\bar{x},\bar{y})\) (each line has different values of \((\bar{x},\bar{y})\)) to pass through the same point \((x,y,z)\) if those lines are not coplanar. This condition is difficult to check analytically, so we check it numerically. We have found empirically that if \(Q(\bar{\rho})\) from Eq. ( \(\ref{eq:defQ}\)) has only a single root between \(\bar{\rho}_{\mathrm{min}}\) and \(\bar{\rho}_{\mathrm{max}}\) for all points \((x,y,z)\) on the surface of sphere 1 with \(z\geq z_{\mathrm{P}1}\) and with \((x-C_1^0)/(y-C_1^1) = (C_1^0-C_2^0)/(C_1^1-C_2^1)\), then the map is single-valued everywhere. We cannot numerically check every point in this one-parameter family of points, but we demand that this condition is satisfied for a reasonably large number of points in this family. This check is not very expensive since it is done only once, in the constructor. </p>
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li>src/Domain/CoordinateMaps/UniformCylindricalEndcap.hpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedomain.html">domain</a></li><li class="navelem"><a class="el" href="namespacedomain_1_1CoordinateMaps.html">CoordinateMaps</a></li><li class="navelem"><a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalEndcap.html">UniformCylindricalEndcap</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
