<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: Parallelization, Charm++, and Core Concepts</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('dev_guide_parallelization_foundations.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Parallelization, Charm++, and Core Concepts </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#dev_guide_parallelization_introduction">Introduction</a></li>
<li class="level1"><a href="#dev_guide_parallelization_metavariables_class">The Metavariables Class</a></li>
<li class="level1"><a href="#dev_guide_parallelization_phases_of_execution">Phases of an Execution</a></li>
<li class="level1"><a href="#dev_guide_parallelization_core_algorithm">The Algorithm</a></li>
<li class="level1"><a href="#dev_guide_parallelization_parallel_components">Parallel Components</a><ul><li class="level2"><a href="#dev_guide_parallelization_component_types">1. Types of Parallel Components</a></li>
<li class="level2"><a href="#dev_guide_parallelization_component_requirements">2. Requirements</a></li>
<li class="level2"><a href="#dev_guide_parallelization_component_examples">3. Examples</a></li>
<li class="level2"><a href="#dev_guide_parallelization_component_placement">4. Placement</a></li>
</ul>
</li>
<li class="level1"><a href="#dev_guide_parallelization_actions">Actions</a><ul><li class="level2"><a href="#dev_guide_parallelization_simple_actions">1. Simple Actions</a></li>
<li class="level2"><a href="#dev_guide_parallelization_iterable_actions">2. Iterable Actions</a></li>
<li class="level2"><a href="#dev_guide_parallelization_reduction_actions">3. Reduction Actions</a></li>
<li class="level2"><a href="#dev_guide_parallelization_threaded_actions">4. Threaded Actions</a></li>
<li class="level2"><a href="#dev_guide_parallelization_local_synchronous_actions">5. Local Synchronous Actions</a></li>
</ul>
</li>
<li class="level1"><a href="#dev_guide_parallelization_mutable_global_cache">Mutable items in the GlobalCache</a><ul><li class="level2"><a href="#autotoc_md136">1. Specification of mutable GlobalCache items</a></li>
<li class="level2"><a href="#autotoc_md137">2. Use of mutable GlobalCache items</a><ul><li class="level3"><a href="#autotoc_md138">1. Checking if the item is up-to-date</a></li>
<li class="level3"><a href="#autotoc_md139">2. Retrieving the item</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md140">3. Modifying a mutable GlobalCache item</a></li>
</ul>
</li>
<li class="level1"><a href="#dev_guide_parallelization_charm_node_processor_level_initialization">Charm++ Node and Processor Level Initialization Functions</a></li>
</ul>
</div>
<div class="textblock"><p ><a class="anchor" id="md_docs_DevGuide_Parallelization"></a></p>
<h1><a class="anchor" id="dev_guide_parallelization_introduction"></a>
Introduction</h1>
<p >SpECTRE builds a layer on top of Charm++ that performs various safety checks and initialization for the user that can otherwise lead to difficult-to-debug undefined behavior. The central concept is what is called a Parallel Component. A Parallel Component is a struct with several type aliases that is used by SpECTRE to set up the Charm++ chares and allowed communication patterns. Parallel Components are input arguments to the compiler, which then writes the parallelization infrastructure that you requested for the executable. There is no restriction on the number of Parallel Components, though practically it is best to have around 10 at most.</p>
<p >Here is an overview of what is described in detail in the sections below:</p>
<ul>
<li><a class="el" href="dev_guide_parallelization_foundations.html#dev_guide_parallelization_metavariables_class">Metavariables</a>: Provides high-level configuration to the compiler, e.g. the physical system to be simulated.</li>
<li><a class="el" href="dev_guide_parallelization_foundations.html#dev_guide_parallelization_phases_of_execution">Phases</a>: Defines distinct simulation phases separated by a global synchronization point, e.g. <code>Initialization</code>, <code>Evolve</code> and <code>Exit</code>.</li>
<li><a class="el" href="dev_guide_parallelization_foundations.html#dev_guide_parallelization_core_algorithm">Algorithm</a>: In each phase, repeatedly iterates over a list of actions until the current phase ends.</li>
<li><a class="el" href="dev_guide_parallelization_foundations.html#dev_guide_parallelization_parallel_components">Parallel component</a>: Maintains and executes its algorithm.</li>
<li><a class="el" href="dev_guide_parallelization_foundations.html#dev_guide_parallelization_actions">Action</a>: Performs a computational task, e.g. evaluating the right hand side of the time evolution equations. May require data to be received from another action potentially being executed on a different core or node.</li>
</ul>
<h1><a class="anchor" id="dev_guide_parallelization_metavariables_class"></a>
The Metavariables Class</h1>
<p >SpECTRE takes a different approach to input options passed to an executable than is common. SpECTRE not only reads an input file at runtime but also has many choices made at compile time. The compile time options are specified by what is referred to as the metavariables. What exactly the metavariables struct specifies depends on the executable, but all metavariables structs must specify the following:</p>
<ul>
<li><code>help</code>: a <code>static constexpr <a class="el" href="namespaceOptions.html#aa61c7f41f21afa7646811456f673be89" title="The string used in option structs.">Options::String</a></code> that will be printed as part of the help message. It should describe the executable and basic usage of it, as well as any non-standard options that must be specified in the metavariables and their current values. An example of a help string for one of the testing executables is: <div class="fragment"><div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <a class="code hl_typedef" href="namespaceOptions.html#aa61c7f41f21afa7646811456f673be89">Options::String</a> help =</div>
<div class="line">      <span class="stringliteral">&quot;An executable for testing the core functionality of the Algorithm. &quot;</span></div>
<div class="line">      <span class="stringliteral">&quot;Actions that do not perform any operations (no-ops), invoking simple &quot;</span></div>
<div class="line">      <span class="stringliteral">&quot;actions, mutating data in the DataBox, receiving data from other &quot;</span></div>
<div class="line">      <span class="stringliteral">&quot;parallel components, and out-of-order execution of Actions are all &quot;</span></div>
<div class="line">      <span class="stringliteral">&quot;tested. All tests are run just by running the executable, no input file &quot;</span></div>
<div class="line">      <span class="stringliteral">&quot;or command line arguments are required&quot;</span>;</div>
<div class="ttc" id="anamespaceOptions_html_aa61c7f41f21afa7646811456f673be89"><div class="ttname"><a href="namespaceOptions.html#aa61c7f41f21afa7646811456f673be89">Options::String</a></div><div class="ttdeci">const char *const String</div><div class="ttdoc">The string used in option structs.</div><div class="ttdef"><b>Definition:</b> String.hpp:8</div></div>
</div><!-- fragment --></li>
<li><code>component_list</code>: a <code>tmpl::list</code> of the parallel components (described below) that are to be created. Most evolution executables will have the <code><a class="el" href="structDgElementArray.html" title="The parallel component responsible for managing the DG elements that compose the computational domain...">DgElementArray</a></code> parallel component listed. An example of a <code>component_list</code> for one of the test executables is: <div class="fragment"><div class="line">  <span class="keyword">using</span> component_list = tmpl::list&lt;NoOpsComponent&lt;TestMetavariables&gt;,</div>
<div class="line">                                    MutateComponent&lt;TestMetavariables&gt;,</div>
<div class="line">                                    ReceiveComponent&lt;TestMetavariables&gt;,</div>
<div class="line">                                    AnyOrderComponent&lt;TestMetavariables&gt;&gt;;</div>
</div><!-- fragment --></li>
<li><code>using const_global_cache_tags</code>: a <code>tmpl::list</code> of tags that are used to place const items in the GlobalCache. The alias may be omitted if the list is empty.</li>
<li><code>using mutable_global_cache_tags</code>: a <code>tmpl::list</code> of tags that are used to place mutable items in the GlobalCache. The alias may be omitted if the list is empty.</li>
<li><code>default_phase_order</code>: an array of <a class="el" href="group__ParallelGroup.html#ga027a2e60b10898507f92ba7290f0ba61" title="The possible phases of an executable.">Parallel::Phase</a> that must contain at least <code>Initialization</code> as the first element and <code>Exit</code>as the last element. Phases are described in the next section.</li>
</ul>
<p >There are also several optional members:</p>
<ul>
<li><code>input_file</code>: a <code>static constexpr <a class="el" href="namespaceOptions.html#aa61c7f41f21afa7646811456f673be89" title="The string used in option structs.">Options::String</a></code> that is the default name of the input file that is to be read. This can be overridden at runtime by passing the <code>--input-file</code> argument to the executable.</li>
<li><code>ignore_unrecognized_command_line_options</code>: a <code>static constexpr bool</code> that defaults to <code>false</code>. If set to <code>true</code> then unrecognized command line options are ignored. Ignoring unrecognized options is generally only necessary for tests where arguments for the testing framework, <a href="https://github.com/catchorg/Catch2/">Catch</a>, are passed to the executable.</li>
</ul>
<h1><a class="anchor" id="dev_guide_parallelization_phases_of_execution"></a>
Phases of an Execution</h1>
<p >Global synchronization points, where all cores wait for each other, are undesirable for scalability reasons. However, they are sometimes inevitable for algorithmic reasons. That is, in order to actually get a correct solution you need to have a global synchronization. SpECTRE executables can have multiple phases, where after each phase a global synchronization occurs. By global synchronization we mean that no parallel components are executing or have more tasks to execute: everything is waiting to be told what tasks to perform next.</p>
<p >Every executable must have at least two phases, <code>Initialization</code> and <code>Exit</code>. The next phase is decided by the member function <a class="el" href="classParallel_1_1Main.html#a3fee26c88570d1b74e58b9c32008b346" title="Determine the next phase of the simulation and execute it.">Parallel::Main&lt;Metavariables&gt;::execute_next_phase</a>. Usually the next phase is determined from the <code>default_phase_order</code> provided by the metavariables. If more complex decision making is desired, various components can send data to <a class="el" href="classParallel_1_1Main.html" title="The main function of a Charm++ executable. See the Parallelization documentation for an overview of M...">Parallel::Main</a> via the <a class="el" href="namespacePhaseControl.html" title="Contains utilities for determining control-flow among phases.">PhaseControl</a> infrastructure. This allows the next Phase to be determined dynamically. Here is an example of a <code>default_phase_order</code> member variable: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;Parallel::Phase, 6&gt;</a> default_phase_order{</div>
<div class="line">    {<a class="code hl_enumvalue" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a61bcd96a2c1f8026527cbf2019d6e9a4">Parallel::Phase::Initialization</a>, <a class="code hl_enumvalue" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a0ba7583639a274c434bbe6ef797115a4">Parallel::Phase::Register</a>,</div>
<div class="line">     <a class="code hl_enumvalue" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a97817e0979af8f0291365165b76a45b5">Parallel::Phase::Solve</a>, <a class="code hl_enumvalue" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61afa6a5a3224d7da66d9e0bdec25f62cf0">Parallel::Phase::Testing</a>, <a class="code hl_enumvalue" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a8c6384dda98d8864d00e29dc96179970">Parallel::Phase::Cleanup</a>,</div>
<div class="line">     <a class="code hl_enumvalue" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61afef46e5063ce3dc78b8ae64fa474241d">Parallel::Phase::Exit</a>}};</div>
<div class="ttc" id="aarray_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a></div></div>
<div class="ttc" id="agroup__ParallelGroup_html_gga027a2e60b10898507f92ba7290f0ba61a0ba7583639a274c434bbe6ef797115a4"><div class="ttname"><a href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a0ba7583639a274c434bbe6ef797115a4">Parallel::Phase::Register</a></div><div class="ttdeci">@ Register</div><div class="ttdoc">phase in which components register with other components</div></div>
<div class="ttc" id="agroup__ParallelGroup_html_gga027a2e60b10898507f92ba7290f0ba61a61bcd96a2c1f8026527cbf2019d6e9a4"><div class="ttname"><a href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a61bcd96a2c1f8026527cbf2019d6e9a4">Parallel::Phase::Initialization</a></div><div class="ttdeci">@ Initialization</div><div class="ttdoc">initial phase of an executable</div></div>
<div class="ttc" id="agroup__ParallelGroup_html_gga027a2e60b10898507f92ba7290f0ba61a8c6384dda98d8864d00e29dc96179970"><div class="ttname"><a href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a8c6384dda98d8864d00e29dc96179970">Parallel::Phase::Cleanup</a></div><div class="ttdeci">@ Cleanup</div><div class="ttdoc">a cleanup phase</div></div>
<div class="ttc" id="agroup__ParallelGroup_html_gga027a2e60b10898507f92ba7290f0ba61a97817e0979af8f0291365165b76a45b5"><div class="ttname"><a href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a97817e0979af8f0291365165b76a45b5">Parallel::Phase::Solve</a></div><div class="ttdeci">@ Solve</div><div class="ttdoc">phase in which something is solved</div></div>
<div class="ttc" id="agroup__ParallelGroup_html_gga027a2e60b10898507f92ba7290f0ba61afa6a5a3224d7da66d9e0bdec25f62cf0"><div class="ttname"><a href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61afa6a5a3224d7da66d9e0bdec25f62cf0">Parallel::Phase::Testing</a></div><div class="ttdeci">@ Testing</div><div class="ttdoc">phase in which something is tested</div></div>
<div class="ttc" id="agroup__ParallelGroup_html_gga027a2e60b10898507f92ba7290f0ba61afef46e5063ce3dc78b8ae64fa474241d"><div class="ttname"><a href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61afef46e5063ce3dc78b8ae64fa474241d">Parallel::Phase::Exit</a></div><div class="ttdeci">@ Exit</div><div class="ttdoc">final phase of an executable</div></div>
</div><!-- fragment --><p >In contrast, an evolution executable might have phases <code>Initialization</code>, <code>SetInitialData</code>, <code>Evolve</code>, and <code>Exit</code>. The first phase that is entered is always <code>Initialization</code>. During the <code>Initialization</code> phase the <code><a class="el" href="classParallel_1_1GlobalCache.html" title="A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++...">Parallel::GlobalCache</a></code> is created, all (node)group components are created, and empty array and singleton components are created. Next, the function <code>allocate_remaining_components_and_execute_initialization_phase</code> is called which allocates singleton components and the elements of each array component, and then starts the <code>Initialization</code> phase on all parallel components. Once all parallel components' <code>Initialization</code> phase is complete, the next phase is determined and the <code>execute_next_phase</code> function is called on all the parallel components.</p>
<p >At the end of an execution the <code>Exit</code> phase has the executable wait to make sure no parallel components are performing or need to perform any more tasks, and then exits. An example where this approach is important is if we are done evolving a system but still need to write data to disk. We do not want to exit the simulation until all data has been written to disk, even though we've reached the final time of the evolution.</p>
<dl class="section warning"><dt>Warning</dt><dd>Currently dead-locks are treated as successful termination. In the future checks against deadlocks will be performed before terminating.</dd></dl>
<h1><a class="anchor" id="dev_guide_parallelization_core_algorithm"></a>
The Algorithm</h1>
<p >Since most numerical algorithms repeat steps until some criterion such as the final time or convergence is met, SpECTRE's parallel components are designed to do such iterations for the user. An Algorithm executes an ordered list of actions until one of the actions cannot be evaluated, typically because it is waiting on data from elsewhere. When an algorithm can no longer evaluate actions it passively waits by handing control back to Charm++. Once an algorithm receives data, typically done by having another parallel component call the <code>receive_data</code> function, the algorithm will try again to execute the next action. If the algorithm is still waiting on more data then the algorithm will again return control to Charm++ and passively wait for more data. This is repeated until all required data is available. The actions that are iterated over by the algorithm are called iterable actions and are described below. Since the action list is phase dependent we refer to them generally as phase-dependent action lists (PDALs, pronounced "pedals").</p>
<h1><a class="anchor" id="dev_guide_parallelization_parallel_components"></a>
Parallel Components</h1>
<p >Building off the introduction, a Parallel Component is essentially a wrapper around Charm++ chares that makes it easy for a user to add parallel objects into their program. Charm++ chares can be confusing to work with which is why we wrap them. Each parallel component runs its own <a class="el" href="dev_guide_parallelization_foundations.html#dev_guide_parallelization_core_algorithm">Algorithm</a>. Data can be sent from one parallel component to another and the receiving parallel components' Algorithm will be able to take that data and continue the program.</p>
<h2><a class="anchor" id="dev_guide_parallelization_component_types"></a>
1. Types of Parallel Components</h2>
<p >There are four types of Parallel Components in SpECTRE:</p>
<ol type="1">
<li><code><a class="el" href="structParallel_1_1Algorithms_1_1Singleton.html" title="A struct that stores the charm++ types relevant for a particular singleton component.">Parallel::Algorithms::Singleton</a></code>s have one object in the entire execution of the program. They are implemented as single element Charm++ chare arrays. Charm++ does offer a distributed object called a singleton, however, we explicitly don't use this for various reasons (see <a class="el" href="structParallel_1_1Algorithms_1_1Singleton.html" title="A struct that stores the charm++ types relevant for a particular singleton component.">Parallel::Algorithms::Singleton</a>). Henceforth and throughout SpECTRE, a <code>singleton</code> will refer to <a class="el" href="structParallel_1_1Algorithms_1_1Singleton.html" title="A struct that stores the charm++ types relevant for a particular singleton component.">Parallel::Algorithms::Singleton</a> and <em>not</em> a Charm++ singleton.</li>
<li><code><a class="el" href="structParallel_1_1Algorithms_1_1Array.html" title="A struct that stores the charm++ types relevant for a particular array component.">Parallel::Algorithms::Array</a></code>s hold zero or more elements, each of which is an object distributed to some core. An array can grow and shrink in size dynamically if need be and can also be bound to another array. A bound array has the same number of elements as the array it is bound to, and elements with the same ID are on the same core. See Charm++'s chare arrays for details.</li>
<li><code><a class="el" href="structParallel_1_1Algorithms_1_1Group.html" title="A struct that stores the charm++ types relevant for a particular group component.">Parallel::Algorithms::Group</a></code>s are arrays with one element per core which are not able to be moved around between cores. These are typically useful for gathering data from elements of a <a class="el" href="structParallel_1_1Algorithms_1_1Array.html" title="A struct that stores the charm++ types relevant for a particular array component.">Parallel::Algorithms::Array</a> on their core, and then processing or reducing the data further. See <a href="http://charm.cs.illinois.edu/help">Charm++'s</a> group chares for details.</li>
<li><code><a class="el" href="structParallel_1_1Algorithms_1_1Nodegroup.html" title="A struct that stores the charm++ types relevant for a particular nodegroup component.">Parallel::Algorithms::Nodegroup</a></code>s are similar to groups except that there is one element per node. See <a class="el" href="dev_guide_parallelization_foundations.html#dev_guide_parallelization_component_placement">parallel component placement</a> for the definition of a cores and nodes. We ensure that all entry method calls done through the Algorithm's <code>simple_action</code> and <code>receive_data</code> functions are threadsafe. User-controlled threading is possible by calling the entry method member function <code>threaded_action</code>, which is like <code>simple_action</code> except it passes a node lock to the <code>Action</code>'s apply function. Note that unlike <code>simple_action</code>s, multiple <code>threaded_action</code>s can be executing simultaneously on the same chare, but on different cores of the node.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Technically there is a fifth type of parallel component called a MainChare which is placed and executed on the global zeroth core. However, there can only be one of these in a executable, it is entirely different from a Singleton, and it is not specifiable by the user so we omit it from the count here.</dd></dl>
<h2><a class="anchor" id="dev_guide_parallelization_component_requirements"></a>
2. Requirements</h2>
<p >Each Parallel Component struct must have the following type aliases:</p><ol type="1">
<li><code>using chare_type</code> is set to one of the four <a class="el" href="dev_guide_parallelization_foundations.html#dev_guide_parallelization_component_types">types of Parallel Components</a>.</li>
<li><code>using metavariables</code> is set to the Metavariables struct that stores the global metavariables. It is often easiest to have the Parallel Component struct have a template parameter <code>Metavariables</code> that is the global metavariables struct. Examples of this technique are given below.</li>
<li><code>using phase_dependent_action_list</code> is set to a <code>tmpl::list</code> of <code><a class="el" href="structParallel_1_1PhaseActions.html" title="List of all the actions to be executed in the specified phase.">Parallel::PhaseActions</a>&lt;Phase, tmpl::list&lt;Actions...&gt;&gt;</code> where each <code>PhaseAction</code> represents a PDAL that will be executed on the parallel component during the specified phase. The Actions are executed in the order that they are given in the <code>tmpl::list</code>s of the PDALs, but the phases need not be run in linear order. However, <code>db::DataBox</code> types are constructed assuming the phases are performed from first in the <code>phase_dependent_action_list</code> to the last. Simple actions (described below) can be executed in any phase. If there are no iterable actions in a phase then a <code>PhaseAction</code> need not be specified for that phase. However, at least one <code>PhaseAction</code>, even if it is empty, must be specified.</li>
<li><code>using simple_tags_from_options</code> which is a <code>tmpl::list</code> of all the tags that will be inserted into the initial <code>db::DataBox</code> of each component. These tags are <a class="el" href="structdb_1_1SimpleTag.html" title="Mark a struct as a simple tag by inheriting from this.">db::SimpleTag</a>s that have have a <code>using option_tags</code> type alias and a static function <code>create_from_options</code> (see the example below). This list can usually be constructed from the initialization actions of the component (i.e. the list of actions in the <code>PhaseAction</code> list for the <code>Initialization</code> phase) using the helper function <code><a class="el" href="group__ParallelGroup.html#ga7c2c630360df51b5cc4cf0f7fda6e87d" title="Given a list of initialization actions, returns a list of the unique simple_tags_from_options for all...">Parallel::get_simple_tags_from_options</a></code> (see the examples of components below). Each initialization action may specify a type alias <code>using simple_tags_from_options</code> which are a <code>tmpl::list</code> of tags that will be fetched from the db::DataBox by the action.</li>
<li><code>using const_global_cache_tags</code> is set to a <code>tmpl::list</code> of tags that are required by the <code>allocate_array</code> function of an array component, or simple actions called on the parallel component. These tags correspond to const items that are stored in the <a class="el" href="classParallel_1_1GlobalCache.html" title="A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++...">Parallel::GlobalCache</a> (of which there is one copy per Charm++ node). The alias can be omitted if the list is empty.</li>
<li><code>using mutable_global_cache_tags</code> is set to a <code>tmpl::list</code> of tags that correspond to mutable items that are stored in the <a class="el" href="classParallel_1_1GlobalCache.html" title="A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++...">Parallel::GlobalCache</a> (of which there is one copy per Charm++ core). The alias can be omitted if the list is empty.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Array parallel components must also specify the type alias <code>using array_index</code>, which is set to the type that indexes the Parallel Component Array. Charm++ allows arrays to be 1 through 6 dimensional or be indexed by a custom type. The Charm++ provided indexes are wrapped as <code>Parallel::ArrayIndex1D</code> through <code>Parallel::ArrayIndex6D</code>. When writing custom array indices, the <a href="http://charm.cs.illinois.edu/help">Charm++ manual</a> tells you to write your own <code>CkArrayIndex</code>, but we have written a general implementation that provides this functionality (see <code><a class="el" href="structParallel_1_1ArrayIndex.html" title="The array index used for indexing Chare Arrays, mostly an implementation detail.">Parallel::ArrayIndex</a></code>); all that you need to provide is a plain-old-data (<a href="http://en.cppreference.com/w/cpp/concept/PODType">POD</a>) struct of the size of at most 3 integers. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Singletons use an <code>array_index</code> of type <code>int</code>, but users need not specify this. It is already specified in the implementation of a singleton. </dd></dl>
<p >Parallel array components have a static <code>allocate_array</code> function that is used to construct the elements of the array. The signature of the <code>allocate_array</code> functions must be: </p><div class="fragment"><div class="line">static void allocate_array(</div>
<div class="line">    Parallel::CProxy_GlobalCache&lt;metavariables&gt;&amp; global_cache,</div>
<div class="line">    const tuples::tagged_tuple_from_typelist&lt;simple_tags_from_options&gt;&amp;</div>
<div class="line">    initialization_items,</div>
<div class="line">    const std::unordered_set&lt;size_t&gt;&amp; procs_to_ignore);</div>
</div><!-- fragment --><p> The <code>allocate_array</code> function is called by the Main parallel component when the execution starts and will typically insert elements into array parallel components. If the <code>allocate_array</code> function depends upon input options that are not in the GlobalCache, the array component must include the appropriate tag in the <code>simple_tags_from_options</code> type alias. This type alias is a <code>tmpl::list</code> of tags which are <a class="el" href="structdb_1_1SimpleTag.html" title="Mark a struct as a simple tag by inheriting from this.">db::SimpleTag</a>s that have have a <code>using option_tags</code> type alias and a static function <code>create_from_options</code>. They only need to be explicitly added to the list if no initialization action has added them to its <code>simple_tags_from_options</code> type alias. If you want to ignore specific processors when placing array elements, you can pass in a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt;size_t&gt;</code> to <code>allocate_array</code> that contains all the processors that shouldn't have array elements on them.</p>
<p >The <code>allocate_array</code> functions of different array components are called in random order and so it is not safe to have them depend on each other.</p>
<p >Each parallel component must also decide what to do in the different phases of the execution. This is controlled by an <code>execute_next_phase</code> function with signature: </p><div class="fragment"><div class="line">static void execute_next_phase(</div>
<div class="line">    const Parallel::Phase next_phase,</div>
<div class="line">    const Parallel::CProxy_GlobalCache&lt;metavariables&gt;&amp; global_cache);</div>
</div><!-- fragment --><p> <a class="el" href="classParallel_1_1Main.html#a3fee26c88570d1b74e58b9c32008b346" title="Determine the next phase of the simulation and execute it.">Parallel::Main&lt;Metavariables&gt;::execute_next_phase</a>` determines the next phase, after which the <code>execute_next_phase</code> function of each component gets called. The <code>execute_next_phase</code> function determines what the parallel component should do during the next phase. Typically the <code>execute_next_phase</code> function should just call <code>start_phase(phase)</code> on the parallel component.</p>
<h2><a class="anchor" id="dev_guide_parallelization_component_examples"></a>
3. Examples</h2>
<p >An example of a singleton parallel component is: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Metavariables&gt;</div>
<div class="line"><span class="keyword">struct </span>SingletonParallelComponent {</div>
<div class="line">  <span class="keyword">using</span> chare_type = <a class="code hl_struct" href="structParallel_1_1Algorithms_1_1Singleton.html">Parallel::Algorithms::Singleton</a>;</div>
<div class="line">  <span class="keyword">using</span> metavariables = Metavariables;</div>
<div class="line">  <span class="keyword">using</span> phase_dependent_action_list = tmpl::list&lt;</div>
<div class="line">      <a class="code hl_struct" href="structParallel_1_1PhaseActions.html">Parallel::PhaseActions</a>&lt;<a class="code hl_enumvalue" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a61bcd96a2c1f8026527cbf2019d6e9a4">Parallel::Phase::Initialization</a>,</div>
<div class="line">                             tmpl::list&lt;SingletonActions::Initialize&gt;&gt;,</div>
<div class="line">      <a class="code hl_struct" href="structParallel_1_1PhaseActions.html">Parallel::PhaseActions</a>&lt;<a class="code hl_enumvalue" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a97817e0979af8f0291365165b76a45b5">Parallel::Phase::Solve</a>,</div>
<div class="line">                             tmpl::list&lt;SingletonActions::CountReceives&gt;&gt;&gt;;</div>
<div class="line">  <span class="keyword">using</span> simple_tags_from_options = <a class="code hl_typedef" href="group__ParallelGroup.html#ga7c2c630360df51b5cc4cf0f7fda6e87d">Parallel::get_simple_tags_from_options</a>&lt;</div>
<div class="line">      <a class="code hl_typedef" href="group__ParallelGroup.html#gac5fb42f8eaf4da2707e32ed37ecf4e66">Parallel::get_initialization_actions_list&lt;phase_dependent_action_list&gt;</a>&gt;;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> execute_next_phase(</div>
<div class="line">      <span class="keyword">const</span> <a class="code hl_enumeration" href="group__ParallelGroup.html#ga027a2e60b10898507f92ba7290f0ba61">Parallel::Phase</a> next_phase,</div>
<div class="line">      <span class="keyword">const</span> Parallel::CProxy_GlobalCache&lt;Metavariables&gt;&amp; global_cache) {</div>
<div class="line">    <span class="keyword">auto</span>&amp; local_cache = *<a class="code hl_function" href="namespaceParallel.html#a3e4ca5b6143a3b8a8c5c1dd9dacf3d08">Parallel::local_branch</a>(global_cache);</div>
<div class="line">    Parallel::get_parallel_component&lt;SingletonParallelComponent&gt;(local_cache)</div>
<div class="line">        .start_phase(next_phase);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="ttc" id="agroup__ParallelGroup_html_ga027a2e60b10898507f92ba7290f0ba61"><div class="ttname"><a href="group__ParallelGroup.html#ga027a2e60b10898507f92ba7290f0ba61">Parallel::Phase</a></div><div class="ttdeci">Phase</div><div class="ttdoc">The possible phases of an executable.</div><div class="ttdef"><b>Definition:</b> Phase.hpp:40</div></div>
<div class="ttc" id="agroup__ParallelGroup_html_ga7c2c630360df51b5cc4cf0f7fda6e87d"><div class="ttname"><a href="group__ParallelGroup.html#ga7c2c630360df51b5cc4cf0f7fda6e87d">Parallel::get_simple_tags_from_options</a></div><div class="ttdeci">tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::transform&lt; InitializationActionsList, detail::get_simple_tags_from_options_from_action&lt; tmpl::_1 &gt; &gt; &gt; &gt; get_simple_tags_from_options</div><div class="ttdoc">Given a list of initialization actions, returns a list of the unique simple_tags_from_options for all...</div><div class="ttdef"><b>Definition:</b> ParallelComponentHelpers.hpp:272</div></div>
<div class="ttc" id="agroup__ParallelGroup_html_gac5fb42f8eaf4da2707e32ed37ecf4e66"><div class="ttname"><a href="group__ParallelGroup.html#gac5fb42f8eaf4da2707e32ed37ecf4e66">Parallel::get_initialization_actions_list</a></div><div class="ttdeci">tmpl::flatten&lt; tmpl::transform&lt; PhaseDepActionList, detail::get_initialization_actions_list&lt; tmpl::_1 &gt; &gt; &gt; get_initialization_actions_list</div><div class="ttdoc">Given the phase dependent action list, return the list of actions in the Initialization phase (or an ...</div><div class="ttdef"><b>Definition:</b> ParallelComponentHelpers.hpp:250</div></div>
<div class="ttc" id="anamespaceParallel_html_a3e4ca5b6143a3b8a8c5c1dd9dacf3d08"><div class="ttname"><a href="namespaceParallel.html#a3e4ca5b6143a3b8a8c5c1dd9dacf3d08">Parallel::local_branch</a></div><div class="ttdeci">auto * local_branch(Proxy &amp;&amp;proxy)</div><div class="ttdoc">Wrapper for calling Charm++'s .ckLocalBranch() on a proxy.</div><div class="ttdef"><b>Definition:</b> Local.hpp:48</div></div>
<div class="ttc" id="astructParallel_1_1Algorithms_1_1Singleton_html"><div class="ttname"><a href="structParallel_1_1Algorithms_1_1Singleton.html">Parallel::Algorithms::Singleton</a></div><div class="ttdoc">A struct that stores the charm++ types relevant for a particular singleton component.</div><div class="ttdef"><b>Definition:</b> AlgorithmSingletonDeclarations.hpp:31</div></div>
<div class="ttc" id="astructParallel_1_1PhaseActions_html"><div class="ttname"><a href="structParallel_1_1PhaseActions.html">Parallel::PhaseActions</a></div><div class="ttdoc">List of all the actions to be executed in the specified phase.</div><div class="ttdef"><b>Definition:</b> PhaseDependentActionList.hpp:17</div></div>
</div><!-- fragment --><p >An example of an array parallel component is: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Metavariables&gt;</div>
<div class="line"><span class="keyword">struct </span>ArrayParallelComponent {</div>
<div class="line">  <span class="keyword">using</span> chare_type = <a class="code hl_struct" href="structParallel_1_1Algorithms_1_1Array.html">Parallel::Algorithms::Array</a>;</div>
<div class="line">  <span class="keyword">using</span> metavariables = Metavariables;</div>
<div class="line">  <span class="keyword">using</span> phase_dependent_action_list = tmpl::list&lt;</div>
<div class="line">      <a class="code hl_struct" href="structParallel_1_1PhaseActions.html">Parallel::PhaseActions</a>&lt;<a class="code hl_enumvalue" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a61bcd96a2c1f8026527cbf2019d6e9a4">Parallel::Phase::Initialization</a>,</div>
<div class="line">                             tmpl::list&lt;ArrayActions::Initialize&gt;&gt;,</div>
<div class="line">      <a class="code hl_struct" href="structParallel_1_1PhaseActions.html">Parallel::PhaseActions</a>&lt;</div>
<div class="line">          <a class="code hl_enumvalue" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a97817e0979af8f0291365165b76a45b5">Parallel::Phase::Solve</a>,</div>
<div class="line">          tmpl::list&lt;ArrayActions::AddIntValue10, ArrayActions::IncrementInt0,</div>
<div class="line">                     ArrayActions::RemoveInt0, ArrayActions::SendToSingleton&gt;&gt;,</div>
<div class="line">      <a class="code hl_struct" href="structParallel_1_1PhaseActions.html">Parallel::PhaseActions</a>&lt;<a class="code hl_enumvalue" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61afa6a5a3224d7da66d9e0bdec25f62cf0">Parallel::Phase::Testing</a>,</div>
<div class="line">                             tmpl::list&lt;ArrayActions::CheckWasUnpacked&gt;&gt;&gt;;</div>
<div class="line">  <span class="keyword">using</span> simple_tags_from_options = <a class="code hl_typedef" href="group__ParallelGroup.html#ga7c2c630360df51b5cc4cf0f7fda6e87d">Parallel::get_simple_tags_from_options</a>&lt;</div>
<div class="line">      <a class="code hl_typedef" href="group__ParallelGroup.html#gac5fb42f8eaf4da2707e32ed37ecf4e66">Parallel::get_initialization_actions_list&lt;phase_dependent_action_list&gt;</a>&gt;;</div>
<div class="line">  <span class="keyword">using</span> array_index = int;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> allocate_array(</div>
<div class="line">      Parallel::CProxy_GlobalCache&lt;Metavariables&gt;&amp; global_cache,</div>
<div class="line">      <span class="keyword">const</span> tuples::tagged_tuple_from_typelist&lt;simple_tags_from_options&gt;&amp;</div>
<div class="line">      <span class="comment">/*initialization_items*/</span>,</div>
<div class="line">      <span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set&lt;size_t&gt;</a>&amp; procs_to_ignore = {}) {</div>
<div class="line">    <span class="keyword">auto</span>&amp; local_cache = *<a class="code hl_function" href="namespaceParallel.html#a3e4ca5b6143a3b8a8c5c1dd9dacf3d08">Parallel::local_branch</a>(global_cache);</div>
<div class="line">    <span class="keyword">auto</span>&amp; array_proxy =</div>
<div class="line">        Parallel::get_parallel_component&lt;ArrayParallelComponent&gt;(local_cache);</div>
<div class="line"> </div>
<div class="line">    TestHelpers::Parallel::assign_array_elements_round_robin_style(</div>
<div class="line">        array_proxy, <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(number_of_1d_array_elements),</div>
<div class="line">        <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(<a class="code hl_function" href="group__ParallelGroup.html#ga602c224997d604c7741c21dd4138e29d">sys::number_of_procs</a>()), {}, global_cache,</div>
<div class="line">        procs_to_ignore);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> execute_next_phase(</div>
<div class="line">      <span class="keyword">const</span> <a class="code hl_enumeration" href="group__ParallelGroup.html#ga027a2e60b10898507f92ba7290f0ba61">Parallel::Phase</a> next_phase,</div>
<div class="line">      Parallel::CProxy_GlobalCache&lt;Metavariables&gt;&amp; global_cache) {</div>
<div class="line">    <span class="keyword">auto</span>&amp; local_cache = *<a class="code hl_function" href="namespaceParallel.html#a3e4ca5b6143a3b8a8c5c1dd9dacf3d08">Parallel::local_branch</a>(global_cache);</div>
<div class="line">    Parallel::get_parallel_component&lt;ArrayParallelComponent&gt;(local_cache)</div>
<div class="line">        .start_phase(next_phase);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="ttc" id="agroup__ParallelGroup_html_ga602c224997d604c7741c21dd4138e29d"><div class="ttname"><a href="group__ParallelGroup.html#ga602c224997d604c7741c21dd4138e29d">Parallel::number_of_procs</a></div><div class="ttdeci">T number_of_procs(const DistribObject &amp;distributed_object)</div><div class="ttdoc">Number of processing elements.</div><div class="ttdef"><b>Definition:</b> Info.hpp:26</div></div>
<div class="ttc" id="astructParallel_1_1Algorithms_1_1Array_html"><div class="ttname"><a href="structParallel_1_1Algorithms_1_1Array.html">Parallel::Algorithms::Array</a></div><div class="ttdoc">A struct that stores the charm++ types relevant for a particular array component.</div><div class="ttdef"><b>Definition:</b> AlgorithmArrayDeclarations.hpp:33</div></div>
<div class="ttc" id="aunordered_set_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set&lt; size_t &gt;</a></div></div>
</div><!-- fragment --><p >There are some parallel components that are common to many executables.</p>
<ul>
<li><a class="el" href="classParallel_1_1GlobalCache.html" title="A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++...">Parallel::GlobalCache</a> (a <a class="el" href="structParallel_1_1Algorithms_1_1Nodegroup.html" title="A struct that stores the charm++ types relevant for a particular nodegroup component.">Parallel::Algorithms::Nodegroup</a>)</li>
<li><a class="el" href="classParallel_1_1MutableGlobalCache.html" title="A Charm++ chare that caches mutable data once per Charm++ core.">Parallel::MutableGlobalCache</a> (a <a class="el" href="structParallel_1_1Algorithms_1_1Group.html" title="A struct that stores the charm++ types relevant for a particular group component.">Parallel::Algorithms::Group</a>)</li>
<li><a class="el" href="structDgElementArray.html" title="The parallel component responsible for managing the DG elements that compose the computational domain...">DgElementArray</a> (a <a class="el" href="structParallel_1_1Algorithms_1_1Array.html" title="A struct that stores the charm++ types relevant for a particular array component.">Parallel::Algorithms::Array</a>)</li>
<li><a class="el" href="structobservers_1_1Observer.html" title="The group parallel component that is responsible for reducing data to be observed.">observers::Observer</a> (a <a class="el" href="structParallel_1_1Algorithms_1_1Group.html" title="A struct that stores the charm++ types relevant for a particular group component.">Parallel::Algorithms::Group</a>)</li>
<li><a class="el" href="structobservers_1_1ObserverWriter.html" title="The nodegroup parallel component that is responsible for writing data to disk.">observers::ObserverWriter</a> (a <a class="el" href="structParallel_1_1Algorithms_1_1Nodegroup.html" title="A struct that stores the charm++ types relevant for a particular nodegroup component.">Parallel::Algorithms::Nodegroup</a>)</li>
</ul>
<p >The MutableGlobalCache deserves special mention, which is why is has its own section with instructions on how to use it. See <a class="el" href="dev_guide_parallelization_foundations.html#dev_guide_parallelization_mutable_global_cache">Mutable items in the GlobalCache</a>.</p>
<h2><a class="anchor" id="dev_guide_parallelization_component_placement"></a>
4. Placement</h2>
<p >The user has some control over where parallel components get placed on the resources it is running on. Here is a figure that illustrates how one may place parallel components.</p>
<div class="image">
<img src="charm_node_structure.png" alt=""/>
<div class="caption">
Parallel component placement.</div></div>
<p >In this example we are running on three (3) nodes that have four (4) cores each. For all our executables, we reserve one core of each node purely for communication purposes. Nothing else is run on this core. Because of this, what Charm++ calls a node, doesn't correspond to a full node on a supercomputer. A charm-node simply corresponds to a collection of cores on a physical node. In our case, a charm-node is represented by the remaining cores on a node not used for communication (i.e. the first charm-node corresponds to cores 1-3 on the first physical node). Also the definition of a charm-core doesn't necessarily have to correspond to an actual core (it could correspond to a hyperthreaded virtual core), however, for our purposes, it does.</p>
<p >SpECTRE offers wrappers around Charm++ functions that will tell you the total number of charm-nodes/cores in an executable and what charm-node/core a parallel component is on. (In the following examples, the type <code>T</code> is an <code>int</code> or a <code>size_t</code>)</p>
<ul>
<li><code><a class="el" href="group__ParallelGroup.html#gad03ed6d71aee72251a19eb2c7d25b621" title="Index of my node.">Parallel::my_node</a>&lt;T&gt;()</code> returns the charm-node that the parallel component is on. In the figure, <code>Sing. 4</code> would return <code>2</code>.</li>
<li><code><a class="el" href="group__ParallelGroup.html#gadf89c583112f5be12c618a0ec2fc0cfb" title="Index of my processing element.">Parallel::my_proc</a>&lt;T&gt;()</code> returns the charm-core that the parallel component is on. In the figure, <code>Sing. 4</code> would return <code>6</code> (<em>not</em> <code>9</code>).</li>
<li><code><a class="el" href="group__ParallelGroup.html#gaf79215bb2d12770fdbd2ad6c3cec91a8" title="Number of nodes.">Parallel::number_of_nodes</a>&lt;T&gt;()</code> returns the total number of charm-nodes in an executable. The above figure would have <code>3</code> charm-nodes.</li>
<li><code><a class="el" href="group__ParallelGroup.html#ga602c224997d604c7741c21dd4138e29d" title="Number of processing elements.">Parallel::number_of_procs</a>&lt;T&gt;()</code> returns the total number of charm-cores in an executable. The above figure would have <code>9</code> charm-cores (<em>not</em> <code>12</code>).</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>For Charm++ SMP (shared memory parallelism) builds, a node corresponds to a collection of cores on a physical node, and a core corresponds to a processor on that physical node. However, for non-SMP builds, nodes and cores are equivalent. All of our builds are done with Charm++ SMP so nodes and cores have their usual definitions.</dd></dl>
<p>The placement of Groups and Nodegroups are determined by Charm++. This is because a Group is on every charm-core and a Nodegroup is on every charm-node. Even though Nodegroups are one per charm-node, the user can't choose which core is used on the charm-node. They run on the next available charm-core on the charm-node.</p>
<p >The Elements of an Array, however, can be placed on specific charm-cores. They are inserted into the Array by using the Charm++ <code>insert</code> member function of the CProxy for the Array. The <code>insert</code> function is documented in the Charm++ manual. In the Array example in the <a class="el" href="dev_guide_parallelization_foundations.html#dev_guide_parallelization_component_examples">Examples</a> section, <code>array_proxy</code> is a <code>CProxy</code> and so all the documentation for Charm++ array proxies applies. SpECTRE always creates empty arrays with the constructor and requires users to insert however many elements they want and on which charm-cores they want them to be placed. Note that load balancing calls may result in array elements being moved.</p>
<p >In a similar fashion, Singletons can also be placed on specific charm-cores. This can be specified in the input file.</p>
<p >From an input file, there are two ways to specify where Array/Singleton parallel components can be placed.</p>
<div class="fragment"><div class="line">ResourceInfo:</div>
<div class="line">  AvoidGlobalProc0: true</div>
<div class="line">  Singletons:</div>
<div class="line">    AhA:</div>
<div class="line">      Proc: 12</div>
<div class="line">      Exclusive: true</div>
<div class="line">    AhB:</div>
<div class="line">      Proc: Auto</div>
<div class="line">      Exclusive: false</div>
</div><!-- fragment --><p >First is the <code>AvoidGlobalProc0</code> option. This option will tell the program to not put <em>any</em> Array Elements or Singletons on the global zeroth charm-core. This core is sometimes used to write data to disk which is typically much slower than the program execution. The second is the <code>Singletons:</code> option. You can set the value to <code>Auto</code>, and then each singleton will have their proc be chosen automatically and they won't be exclusive. Otherwise, you must specify options for each singleton as in the example above. <code>AhA</code> is the <code><a class="el" href="group__PrettyTypeGroup.html#gac698d0d763b59b714fca6ed84376eb92" title="Return the result of the name() member of a class. If a class doesn&#39;t have a name() member,...">pretty_type::name()</a></code> of a Singleton in the program and the user has a choice of which proc to place the Singleton on (<code>Auto</code> will let the program decide) and whether to exclude Array Elements or other Singletons from being put on this core. This is useful in case the Singleton does some expensive computation that shouldn't be slowed down by having lots of Array Elements on the same core. In the figure above, <code>AvoidGlobalProc0</code> is true, and <code>Sing. 2</code> requested to be exclusively on core <code>2</code>.</p>
<h1><a class="anchor" id="dev_guide_parallelization_actions"></a>
Actions</h1>
<p >Actions are structs with a static <code>apply</code> method and come in five variants: simple actions, iterable actions, reduction actions, threaded actions, and local synchronous actions.</p>
<p >The signature of <code>apply</code> methods differs for the different types of actions, but all types have the same general form. Actions receive a <code>db::DataBox</code>, the <a class="el" href="classParallel_1_1GlobalCache.html" title="A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++...">Parallel::GlobalCache</a>, and their element's index and parallel component, as well as arguments specific to the action type.</p>
<p >The <code>db::DataBox</code> should be thought of as the member data of the parallel component while the actions are the member functions. The combination of a <code>db::DataBox</code> and actions allows building up classes with arbitrary member data and methods using template parameters and invocation of actions. This approach allows us to eliminate the need for users to work with Charm++'s interface files, which can be error prone and difficult to use.</p>
<p >The <a class="el" href="classParallel_1_1GlobalCache.html" title="A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++...">Parallel::GlobalCache</a> is passed to each action so that the action has access to global data and is able to invoke actions on other parallel components. The <code>ParallelComponent</code> template parameter is the tag of the parallel component that invoked the action. A proxy to the calling parallel component can then be retrieved from the <a class="el" href="classParallel_1_1GlobalCache.html" title="A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++...">Parallel::GlobalCache</a>. The remote entry method invocations are slightly different for different types of actions, so they will be discussed below. However, one thing that is disallowed for all actions is calling an action locally from within an action on the same parallel component. Specifically,</p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span>&amp; local_parallel_component = *<a class="code hl_function" href="namespaceParallel.html#a7c3299e04cea9f206f194e7b118c7b44">Parallel::local</a>(</div>
<div class="line">        Parallel::get_parallel_component&lt;ParallelComponent&gt;(cache));</div>
<div class="line">    Parallel::simple_action&lt;error_call_single_action_from_action&gt;(</div>
<div class="line">        local_parallel_component);</div>
<div class="ttc" id="anamespaceParallel_html_a7c3299e04cea9f206f194e7b118c7b44"><div class="ttname"><a href="namespaceParallel.html#a7c3299e04cea9f206f194e7b118c7b44">Parallel::local</a></div><div class="ttdeci">auto * local(Proxy &amp;&amp;proxy)</div><div class="ttdoc">Wrapper for calling Charm++'s .ckLocal() on a proxy.</div><div class="ttdef"><b>Definition:</b> Local.hpp:27</div></div>
</div><!-- fragment --><p >Here <code><a class="el" href="namespaceParallel.html#a7c3299e04cea9f206f194e7b118c7b44" title="Wrapper for calling Charm++&#39;s .ckLocal() on a proxy.">Parallel::local()</a></code> is a wrapper around <code>ckLocal()</code> which is a Charm++ provided method that returns a pointer to the local (currently executing) parallel component. See the <a href="http://charm.cs.illinois.edu/help">Charm++ manual</a> for more information. However, you are able to queue a new action to be executed later on the same parallel component by getting your own parallel component from the <a class="el" href="classParallel_1_1GlobalCache.html" title="A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++...">Parallel::GlobalCache</a> (<code><a class="el" href="group__ParallelGroup.html#gaeee02b1e4faf8051fe703e6b9adada0f" title="Access the Charm++ proxy associated with a ParallelComponent.">Parallel::get_parallel_component</a>&lt;ParallelComponent&gt;(cache)</code>). The difference between the two calls is that by calling an action through the parallel component you will first finish the series of actions you are in, then when they are complete Charm++ will call the next queued action.</p>
<p >Array, group, and nodegroup parallel components can have actions invoked in two ways. First is a broadcast where the action is called on all elements of the array:</p>
<div class="fragment"><div class="line">      <span class="keyword">auto</span>&amp; group_parallel_component = <a class="code hl_function" href="group__ParallelGroup.html#gaeee02b1e4faf8051fe703e6b9adada0f">Parallel::get_parallel_component</a>&lt;</div>
<div class="line">          GroupParallelComponent&lt;Metavariables&gt;&gt;(<a class="code hl_function" href="namespaceActionTesting.html#a645bd6af028059c31bced3807764827e">cache</a>);</div>
<div class="line">      Parallel::receive_data&lt;Tags::IntReceiveTag&gt;(</div>
<div class="line">          group_parallel_component,</div>
<div class="line">          db::get&lt;Tags::CountActionsCalled&gt;(box) + 100 * array_index,</div>
<div class="line">          db::get&lt;Tags::CountActionsCalled&gt;(box));</div>
<div class="ttc" id="agroup__ParallelGroup_html_gaeee02b1e4faf8051fe703e6b9adada0f"><div class="ttname"><a href="group__ParallelGroup.html#gaeee02b1e4faf8051fe703e6b9adada0f">Parallel::get_parallel_component</a></div><div class="ttdeci">auto get_parallel_component(GlobalCache&lt; Metavariables &gt; &amp;cache) -&gt; Parallel::proxy_from_parallel_component&lt; GlobalCache_detail::get_component_if_mocked&lt; typename Metavariables::component_list, ParallelComponentTag &gt; &gt; &amp;</div><div class="ttdoc">Access the Charm++ proxy associated with a ParallelComponent.</div><div class="ttdef"><b>Definition:</b> GlobalCache.hpp:835</div></div>
<div class="ttc" id="anamespaceActionTesting_html_a645bd6af028059c31bced3807764827e"><div class="ttname"><a href="namespaceActionTesting.html#a645bd6af028059c31bced3807764827e">ActionTesting::cache</a></div><div class="ttdeci">Parallel::GlobalCache&lt; Metavariables &gt; &amp; cache(MockRuntimeSystem&lt; Metavariables &gt; &amp;runner, const ArrayIndex &amp;array_index)</div><div class="ttdoc">Returns the GlobalCache of Component with index array_index.</div><div class="ttdef"><b>Definition:</b> MockRuntimeSystemFreeFunctions.hpp:379</div></div>
</div><!-- fragment --><p >The second case is invoking an action on a specific array element by using the array element's index. The below example shows how a broadcast would be done manually by looping over all elements in the array:</p>
<div class="fragment"><div class="line">      <span class="keyword">auto</span>&amp; array_parallel_component = <a class="code hl_function" href="group__ParallelGroup.html#gaeee02b1e4faf8051fe703e6b9adada0f">Parallel::get_parallel_component</a>&lt;</div>
<div class="line">          ArrayParallelComponent&lt;Metavariables&gt;&gt;(<a class="code hl_function" href="namespaceActionTesting.html#a645bd6af028059c31bced3807764827e">cache</a>);</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; number_of_1d_array_elements; ++i) {</div>
<div class="line">        Parallel::receive_data&lt;Tags::IntReceiveTag&gt;(array_parallel_component[i],</div>
<div class="line">                                                    0, 101, <span class="keyword">true</span>);</div>
<div class="line">      }</div>
</div><!-- fragment --><p >Note that in general you will not know what all the elements in the array are and so a broadcast is the correct method of sending data to or invoking an action on all elements of an array parallel component.</p>
<p >The <code>array_index</code> argument passed to all <code>apply</code> methods is the index into the parallel component array. If the parallel component is not an array the value and type of <code>array_index</code> is implementation defined and cannot be relied on.</p>
<h2><a class="anchor" id="dev_guide_parallelization_simple_actions"></a>
1. Simple Actions</h2>
<p >Simple actions can be thought of as member functions of remote objects (chares/parallel components). They are the direct analog of entry methods in Charm++ except that the member data is stored in the <code>db::DataBox</code> that is passed in as the first argument. A simple action must return void but can use <code><a class="el" href="group__DataBoxGroup.html#ga3c45b057d676d9f2cd90cf07185e653e" title="Allows changing the state of one or more non-computed elements in the DataBox.">db::mutate</a></code> to change values of items in the <code>db::DataBox</code> if the <code>db::DataBox</code> is taken as a non-const reference. In some cases you will need specific items to be in the <code>db::DataBox</code> otherwise the action won't compile. To restrict which <code>db::DataBox</code>es can be passed you should use <code>Requires</code> in the action's <code>apply</code> function template parameter list. For example, </p><div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ParallelComponent, <span class="keyword">typename</span> DbTags, <span class="keyword">typename</span> Metavariables,</div>
<div class="line">            <span class="keyword">typename</span> ArrayIndex,</div>
<div class="line">            <a class="code hl_typedef" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt;<a class="code hl_variable" href="group__DataBoxGroup.html#ga0e5d678f658a67bdbaa8b10d1ec50505">db::tag_is_retrievable_v</a>&lt;CountActionsCalled,</div>
<div class="line">                                              db::DataBox&lt;DbTags&gt;&gt;&gt; = <span class="keyword">nullptr</span>&gt;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code hl_function" href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">apply</a>(db::DataBox&lt;DbTags&gt;&amp; box,</div>
<div class="line">                    <span class="keyword">const</span> <a class="code hl_class" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache&lt;Metavariables&gt;</a>&amp; <span class="comment">/*cache*/</span>,</div>
<div class="line">                    <span class="keyword">const</span> ArrayIndex&amp; <span class="comment">/*array_index*/</span>, <span class="keyword">const</span> <span class="keywordtype">double</span> v0,</div>
<div class="line">                    <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>&amp;&amp; v1) {</div>
<div class="ttc" id="aclassParallel_1_1GlobalCache_html"><div class="ttname"><a href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache</a></div><div class="ttdoc">A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++...</div><div class="ttdef"><b>Definition:</b> GlobalCache.hpp:374</div></div>
<div class="ttc" id="agroup__DataBoxGroup_html_ga0e5d678f658a67bdbaa8b10d1ec50505"><div class="ttname"><a href="group__DataBoxGroup.html#ga0e5d678f658a67bdbaa8b10d1ec50505">db::tag_is_retrievable_v</a></div><div class="ttdeci">constexpr bool tag_is_retrievable_v</div><div class="ttdoc">Equal to true if Tag can be retrieved from a DataBox of type DataBoxType.</div><div class="ttdef"><b>Definition:</b> DataBox.hpp:65</div></div>
<div class="ttc" id="agroup__DataStructuresGroup_html_ga058ade0497757606713948256728c6db"><div class="ttname"><a href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">apply</a></div><div class="ttdeci">auto apply(F &amp;&amp;f, const ObservationBox&lt; ComputeTagsList, DataBoxType &gt; &amp;observation_box, Args &amp;&amp;... args)</div><div class="ttdoc">Apply the function object f using its nested argument_tags list of tags.</div><div class="ttdef"><b>Definition:</b> ObservationBox.hpp:182</div></div>
<div class="ttc" id="agroup__UtilitiesGroup_html_ga084d535585c18d4e80f8ec6052d341a3"><div class="ttname"><a href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a></div><div class="ttdeci">typename Requires_detail::requires_impl&lt; B &gt;::template_error_type_failed_to_meet_requirements_on_template_parameters Requires</div><div class="ttdoc">Express requirements on the template parameters of a function or class, replaces std::enable_if_t</div><div class="ttdef"><b>Definition:</b> Requires.hpp:67</div></div>
<div class="ttc" id="avector_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt; double &gt;</a></div></div>
</div><!-- fragment --><p> checks that <code>CountActionsCalled</code> is available in the box.</p>
<p >Simple actions can be called using a <code>CProxy</code> (see the <a href="http://charm.cs.illinois.edu/help">Charm++ manual</a>), which is retrieved from the <a class="el" href="classParallel_1_1GlobalCache.html" title="A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++...">Parallel::GlobalCache</a> using the parallel component struct and the <code><a class="el" href="group__ParallelGroup.html#gaeee02b1e4faf8051fe703e6b9adada0f" title="Access the Charm++ proxy associated with a ParallelComponent.">Parallel::get_parallel_component()</a></code> function. For example, the action above could be called as </p><div class="fragment"><div class="line">      Parallel::simple_action&lt;add_remove_test::test_args&gt;(</div>
<div class="line">          Parallel::get_parallel_component&lt;MutateComponent&gt;(local_cache),</div>
<div class="line">          4.82937, <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{3.2, -8.4, 7.5});</div>
</div><!-- fragment --><p> Any arguments after the proxy are passed as additional arguments to the action's <code>apply</code> function.</p>
<h2><a class="anchor" id="dev_guide_parallelization_iterable_actions"></a>
2. Iterable Actions</h2>
<p >Iterable actions make up the algorithms described by the PDALs. These actions are executed one after the other until one of them cannot be evaluated. Their <code>apply</code> methods signature is </p><div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> DbTags, <span class="keyword">typename</span>... InboxTags, <span class="keyword">typename</span> Metavariables,</div>
<div class="line">            <span class="keyword">typename</span> ArrayIndex, <span class="keyword">typename</span> ActionList,</div>
<div class="line">            <span class="keyword">typename</span> ParallelComponent&gt;</div>
<div class="line">  <span class="keyword">static</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">Parallel::iterable_action_return_t</a> <a class="code hl_function" href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">apply</a>(</div>
<div class="line">      db::DataBox&lt;DbTags&gt;&amp; <span class="comment">/*box*/</span>,</div>
<div class="line">      <span class="keyword">const</span> <a class="code hl_class" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple&lt;InboxTags...&gt;</a>&amp; <span class="comment">/*inboxes*/</span>,</div>
<div class="line">      <span class="keyword">const</span> <a class="code hl_class" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache&lt;Metavariables&gt;</a>&amp; <span class="comment">/*cache*/</span>,</div>
<div class="line">      <span class="keyword">const</span> ArrayIndex&amp; <span class="comment">/*array_index*/</span>, <span class="keyword">const</span> ActionList <span class="comment">/*meta*/</span>,</div>
<div class="line">      <span class="keyword">const</span> ParallelComponent* <span class="keyword">const</span> <span class="comment">/*meta*/</span>)</div>
<div class="ttc" id="aclasstuples_1_1TaggedTuple_html"><div class="ttname"><a href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a></div><div class="ttdoc">An associative container that is indexed by structs.</div><div class="ttdef"><b>Definition:</b> TaggedTuple.hpp:261</div></div>
<div class="ttc" id="atuple_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a></div></div>
</div><!-- fragment --><p> The <code>ActionList</code> type is the <code>tmpl::list</code> of iterable actions in the current phase. That is, it is equal to the <code>action_list</code> type alias in the current PDAL. The <code>inboxes</code> is a collection of the tags specified as <code>tmpl::list</code>s in the iterable actions' member type aliases <code>inbox_tags</code>. This collection represents data received from other chares using the <code>receive_data</code> function.</p>
<p >Iterable actions can request that the algorithm be paused or halted for the current phase, and control which action in the current PDAL will be executed next. This is all done via the return value from the <code>apply</code> function. The <code>apply</code> function for iterable actions must return a <a class="el" href="namespaceParallel.html#af78863455c4051f7335d78eaa9c5c4e8" title="Return type for iterable actions. The std::optional can be used to specify the index of the action to...">Parallel::iterable_action_return_t</a> which is a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt;<a class="el" href="namespaceParallel.html#af31fff079d116e958890e079a35955cf" title="The possible options for altering the current execution of the algorithm, used in the return type of ...">Parallel::AlgorithmExecution</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt;size_t&gt;&gt;</code>. The first element of the tuple controls how algorithm execution continues. See the documentation of <code><a class="el" href="namespaceParallel.html#af31fff079d116e958890e079a35955cf" title="The possible options for altering the current execution of the algorithm, used in the return type of ...">Parallel::AlgorithmExecution</a></code> for the meanings of different values of that enum. The second element of the tuple is usually set to <code>std::nullopt</code> in order to continue iterating through the algorithm, but can be used to jump to a different action in the current PDAL. Most iterable actions will simply return</p>
<div class="fragment"><div class="line">    <span class="keywordflow">return</span> {<a class="code hl_enumvalue" href="namespaceParallel.html#af31fff079d116e958890e079a35955cfaa0bfb8e59e6c13fc8d990781f77694fe">Parallel::AlgorithmExecution::Continue</a>, std::nullopt};</div>
<div class="ttc" id="anamespaceParallel_html_af31fff079d116e958890e079a35955cfaa0bfb8e59e6c13fc8d990781f77694fe"><div class="ttname"><a href="namespaceParallel.html#af31fff079d116e958890e079a35955cfaa0bfb8e59e6c13fc8d990781f77694fe">Parallel::AlgorithmExecution::Continue</a></div><div class="ttdeci">@ Continue</div><div class="ttdoc">Continue executing iterable actions.</div></div>
</div><!-- fragment --><p >An action that pauses the algorithm will return</p>
<div class="fragment"><div class="line">    <span class="keywordflow">return</span> {<a class="code hl_enumvalue" href="namespaceParallel.html#af31fff079d116e958890e079a35955cfa105b296a83f9c105355403f3332af50f">Parallel::AlgorithmExecution::Pause</a>, std::nullopt};</div>
<div class="ttc" id="anamespaceParallel_html_af31fff079d116e958890e079a35955cfa105b296a83f9c105355403f3332af50f"><div class="ttname"><a href="namespaceParallel.html#af31fff079d116e958890e079a35955cfa105b296a83f9c105355403f3332af50f">Parallel::AlgorithmExecution::Pause</a></div><div class="ttdeci">@ Pause</div><div class="ttdoc">Stop the execution of iterable actions, but allow entry methods (communication) to explicitly request...</div></div>
</div><!-- fragment --><p >After an algorithm has been paused it can be restarted by passing <code>false</code> to the <code>set_terminate</code> method or by calling <code>receive_data(...,
true)</code>. Since the order in which messages are received is undefined in most cases the <code>receive_data(..., true)</code> call should be used to restart the algorithm.</p>
<p >The return value <code><a class="el" href="namespaceParallel.html#af31fff079d116e958890e079a35955cfa6327b4e59f58137083214a1fec358855" title="Temporarily stop executing iterable actions, but try the same action again after receiving data from ...">Parallel::AlgorithmExecution::Retry</a></code> deserves special mention. It is intended for use by actions that use data supplied by other parallel objects to indicate that they have not received all of the data they require. The algorithm will stop until an operation that could supply data has occurred and then the action will be retried. An example of waiting because of missing data is</p>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span> (inbox.count(db::get&lt;TemporalId0&gt;(box)) == 0) {</div>
<div class="line">      <span class="keywordflow">return</span> {<a class="code hl_enumvalue" href="namespaceParallel.html#af31fff079d116e958890e079a35955cfa6327b4e59f58137083214a1fec358855">Parallel::AlgorithmExecution::Retry</a>, std::nullopt};</div>
<div class="line">    }</div>
<div class="ttc" id="anamespaceParallel_html_af31fff079d116e958890e079a35955cfa6327b4e59f58137083214a1fec358855"><div class="ttname"><a href="namespaceParallel.html#af31fff079d116e958890e079a35955cfa6327b4e59f58137083214a1fec358855">Parallel::AlgorithmExecution::Retry</a></div><div class="ttdeci">@ Retry</div><div class="ttdoc">Temporarily stop executing iterable actions, but try the same action again after receiving data from ...</div></div>
</div><!-- fragment --><p >In order to jump to a specific action, the metafunction <code>tmpl::index_of&lt;list, element&gt;</code> can be used to get an <code>tmpl::integral_constant</code> with the value of the index of the element <code>element</code> in the typelist <code>list</code>. For example,</p>
<div class="fragment"><div class="line">    <span class="keywordflow">return</span> {<a class="code hl_enumvalue" href="namespaceParallel.html#af31fff079d116e958890e079a35955cfa105b296a83f9c105355403f3332af50f">Parallel::AlgorithmExecution::Pause</a>,</div>
<div class="line">            <a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">tmpl::index_of&lt;ActionList, iterate_increment_int0&gt;::value</a> + 1};</div>
<div class="ttc" id="agroup__UtilitiesGroup_html_ga4316f2ea7fb92cf4a3c5cf53bf36fb82"><div class="ttname"><a href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">value</a></div><div class="ttdeci">constexpr T &amp; value(T &amp;t)</div><div class="ttdoc">Returns t.value() if t is a std::optional otherwise returns t.</div><div class="ttdef"><b>Definition:</b> OptionalHelpers.hpp:32</div></div>
</div><!-- fragment --><p >The metafunction call <code>tmpl::index_of&lt;ActionList, iterate_increment_int0&gt;::value</code> returns a <code>size_t</code> whose value is that of the action <code>iterate_increment_int0</code> in the PDAL. The indexing of actions in the PDAL starts at <code>0</code>.</p>
<p >Iterable actions are invoked as part of the algorithm and so the only way to request they be invoked is by having the algorithm run on the parallel component. The algorithm can be explicitly evaluated in a new phase by calling <code>start_phase(Phase::TheCurrentPhase)</code>:</p>
<div class="fragment"><div class="line">    Parallel::get_parallel_component&lt;NoOpsComponent&gt;(local_cache)</div>
<div class="line">        .start_phase(next_phase);</div>
</div><!-- fragment --><p >Alternatively, to evaluate the algorithm without changing phases the <code>perform_algorithm()</code> method can be used.</p>
<p >By passing <code>true</code> to <code>perform_algorithm</code> the algorithm will be restarted if it was paused.</p>
<p >The algorithm is also evaluated by calling the <code>receive_data</code> function, either on an entire array or singleton (this does a broadcast), or an on individual element of the array. Here is an example of a broadcast call:</p>
<div class="fragment"><div class="line">      <span class="keyword">auto</span>&amp; group_parallel_component = <a class="code hl_function" href="group__ParallelGroup.html#gaeee02b1e4faf8051fe703e6b9adada0f">Parallel::get_parallel_component</a>&lt;</div>
<div class="line">          GroupParallelComponent&lt;Metavariables&gt;&gt;(<a class="code hl_function" href="namespaceActionTesting.html#a645bd6af028059c31bced3807764827e">cache</a>);</div>
<div class="line">      Parallel::receive_data&lt;Tags::IntReceiveTag&gt;(</div>
<div class="line">          group_parallel_component,</div>
<div class="line">          db::get&lt;Tags::CountActionsCalled&gt;(box) + 100 * array_index,</div>
<div class="line">          db::get&lt;Tags::CountActionsCalled&gt;(box));</div>
</div><!-- fragment --><p >and of calling individual elements:</p>
<div class="fragment"><div class="line">      <span class="keyword">auto</span>&amp; array_parallel_component = <a class="code hl_function" href="group__ParallelGroup.html#gaeee02b1e4faf8051fe703e6b9adada0f">Parallel::get_parallel_component</a>&lt;</div>
<div class="line">          ArrayParallelComponent&lt;Metavariables&gt;&gt;(<a class="code hl_function" href="namespaceActionTesting.html#a645bd6af028059c31bced3807764827e">cache</a>);</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; number_of_1d_array_elements; ++i) {</div>
<div class="line">        Parallel::receive_data&lt;Tags::IntReceiveTag&gt;(array_parallel_component[i],</div>
<div class="line">                                                    0, 101, <span class="keyword">true</span>);</div>
<div class="line">      }</div>
</div><!-- fragment --><p >The <code>receive_data</code> function always takes a <code>ReceiveTag</code>, which is set in the actions' <code>inbox_tags</code> type aliases. The <code>inbox_tags</code> must have two member type aliases, a <code>temporal_id</code> which is used to identify when the data was sent, and a <code>type</code> which is the type of the data to be stored in the <code>inboxes</code>. The types are typically a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt;temporal_id, DATA&gt;</code>. In the discussed scenario of waiting for neighboring elements to send their data the <code>DATA</code> type would be a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt;TheElementId, DataSent&gt;</code>. Inbox tags must also specify a <code>static void insert_into_inbox()</code> function. For example,</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>IntReceiveTag {</div>
<div class="line">  <span class="keyword">using</span> temporal_id = int;</div>
<div class="line">  <span class="keyword">using</span> type = <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map&lt;temporal_id, std::unordered_multiset&lt;int&gt;</a>&gt;;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Inbox, <span class="keyword">typename</span> ReceiveDataType&gt;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> insert_into_inbox(<span class="keyword">const</span> <a class="code hl_class" href="classgsl_1_1not__null.html">gsl::not_null&lt;Inbox*&gt;</a> inbox,</div>
<div class="line">                                <span class="keyword">const</span> temporal_id&amp; temporal_id_v,</div>
<div class="line">                                ReceiveDataType&amp;&amp; data) {</div>
<div class="line">    (*inbox)[temporal_id_v].insert(std::forward&lt;ReceiveDataType&gt;(data));</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="ttc" id="aclassgsl_1_1not__null_html"><div class="ttname"><a href="classgsl_1_1not__null.html">gsl::not_null</a></div><div class="ttdoc">Require a pointer to not be a nullptr</div><div class="ttdef"><b>Definition:</b> Gsl.hpp:183</div></div>
<div class="ttc" id="aunordered_map_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a></div></div>
</div><!-- fragment --><p >For common types of <code>DATA</code>, such as a <code>map</code>, a data structure with an <code>insert</code> function, a data structure with a <code>push_back</code> function, or copy/move assignment that is used to insert the received data, inserters are available in <code><a class="el" href="namespaceParallel_1_1InboxInserters.html" title="Structs that have insert_into_inbox methods for commonly used cases.">Parallel::InboxInserters</a></code>. For example, there is <code><a class="el" href="structParallel_1_1InboxInserters_1_1Map.html" title="Inserter for inserting data that is received as the value_type (with non-const key_type) of a map dat...">Parallel::InboxInserters::Map</a></code> for <code>map</code> data structures. The inbox tag can inherit publicly off the inserters to gain the required insertion capabilities:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>IntReceiveTag</div>
<div class="line">    : <span class="keyword">public</span> <a class="code hl_struct" href="structParallel_1_1InboxInserters_1_1MemberInsert.html">Parallel::InboxInserters::MemberInsert</a>&lt;IntReceiveTag&gt; {</div>
<div class="line">  <span class="keyword">using</span> temporal_id = TestAlgorithmArrayInstance;</div>
<div class="line">  <span class="keyword">using</span> type = <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map&lt;temporal_id, std::unordered_multiset&lt;int&gt;</a>&gt;;</div>
<div class="line">};</div>
<div class="ttc" id="astructParallel_1_1InboxInserters_1_1MemberInsert_html"><div class="ttname"><a href="structParallel_1_1InboxInserters_1_1MemberInsert.html">Parallel::InboxInserters::MemberInsert</a></div><div class="ttdoc">Inserter for inserting data that is received as the value_type of a data structure that has an insert...</div><div class="ttdef"><b>Definition:</b> InboxInserters.hpp:67</div></div>
</div><!-- fragment --><p >Any inbox tag that uses Charm++ messages must also specify a <code>message_type</code> type alias which is the object that will be sent. An example is:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>BoundaryMessageReceiveTag {</div>
<div class="line">  <span class="keyword">using</span> temporal_id = int;</div>
<div class="line">  <span class="keyword">using</span> type =</div>
<div class="line">      <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map&lt;temporal_id, std::unique_ptr&lt;BoundaryMessage&lt;3&gt;</a>&gt;&gt;;</div>
<div class="line">  <span class="keyword">using</span> message_type = BoundaryMessage&lt;3&gt;;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Inbox&gt;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> insert_into_inbox(<span class="keyword">const</span> <a class="code hl_class" href="classgsl_1_1not__null.html">gsl::not_null&lt;Inbox*&gt;</a> inbox,</div>
<div class="line">                                BoundaryMessage&lt;3&gt;* message) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> receiver_element = message-&gt;tci_status;</div>
<div class="line">    (*inbox)[receiver_element] = <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr&lt;BoundaryMessage&lt;3&gt;</a>&gt;(message);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="ttc" id="aunique_ptr_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a></div></div>
</div><!-- fragment --><p >The <code>inbox_tags</code> type alias for the action is:</p>
<div class="fragment"><div class="line">  <span class="keyword">using</span> inbox_tags = tmpl::list&lt;Tags::IntReceiveTag&gt;;</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>It is the responsibility of the iterable action to remove data from the inboxes that will no longer be needed.</dd></dl>
<p>Normally when remote functions are invoked they go through the Charm++ runtime system, which adds some overhead. The <code>receive_data</code> function tries to elide the call to the Charm++ RTS for calls into array components. Charm++ refers to these types of remote calls as "inline entry methods". With the Charm++ method of eliding the RTS, the code becomes susceptible to stack overflows because of infinite recursion. The <code>receive_data</code> function is limited to at most 64 RTS elided calls, though in practice reaching this limit is rare. When the limit is reached the remote method invocation is done through the RTS instead of being elided.</p>
<h2><a class="anchor" id="dev_guide_parallelization_reduction_actions"></a>
3. Reduction Actions</h2>
<p >Reduction actions are the targets of reducing data over an array. For example, you may want to know the sum of a <code>int</code> from every element in the array. You can do this as follows:</p>
<div class="fragment"><div class="line">    Parallel::ReductionData&lt;Parallel::ReductionDatum&lt;int, funcl::Plus&lt;&gt;&gt;&gt;</div>
<div class="line">        my_send_int{array_index};</div>
<div class="line">    Parallel::contribute_to_reduction&lt;ProcessReducedSumOfInts&gt;(</div>
<div class="line">        my_send_int, my_proxy, singleton_proxy);</div>
</div><!-- fragment --><p >This reduces over the parallel component <code>ArrayParallelComponent&lt;Metavariables&gt;</code>, reduces to the parallel component <code>SingletonParallelComponent&lt;Metavariables&gt;</code>, and calls the action <code>ProcessReducedSumOfInts</code> after the reduction has been performed. The reduction action is:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ProcessReducedSumOfInts {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ParallelComponent, <span class="keyword">typename</span> DbTags, <span class="keyword">typename</span> Metavariables,</div>
<div class="line">            <span class="keyword">typename</span> ArrayIndex&gt;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code hl_function" href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">apply</a>(db::DataBox&lt;DbTags&gt;&amp; <span class="comment">/*box*/</span>,</div>
<div class="line">                    <span class="keyword">const</span> <a class="code hl_class" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache&lt;Metavariables&gt;</a>&amp; <span class="comment">/*cache*/</span>,</div>
<div class="line">                    <span class="keyword">const</span> ArrayIndex&amp; <span class="comment">/*array_index*/</span>, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; <a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">value</a>) {</div>
<div class="line">    <a class="code hl_define" href="group__TestingFrameworkGroup.html#ga37fce1ae5980139598815eda5a5de8ab">SPECTRE_PARALLEL_REQUIRE</a>(number_of_1d_array_elements *</div>
<div class="line">                                 (number_of_1d_array_elements - 1) / 2 ==</div>
<div class="line">                             <a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">value</a>);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="ttc" id="agroup__TestingFrameworkGroup_html_ga37fce1ae5980139598815eda5a5de8ab"><div class="ttname"><a href="group__TestingFrameworkGroup.html#ga37fce1ae5980139598815eda5a5de8ab">SPECTRE_PARALLEL_REQUIRE</a></div><div class="ttdeci">#define SPECTRE_PARALLEL_REQUIRE(expr)</div><div class="ttdoc">A similar to Catch's REQUIRE statement, but can be used in tests that spawn several chares with possi...</div><div class="ttdef"><b>Definition:</b> TestingFramework.hpp:55</div></div>
</div><!-- fragment --><p >As you can see, the last argument to the <code>apply</code> function is of type <code>int</code>, and is the reduced value.</p>
<p >You can also broadcast the result back to an array, even yourself. For example,</p>
<div class="fragment"><div class="line">    Parallel::contribute_to_reduction&lt;ProcessReducedSumOfInts&gt;(</div>
<div class="line">        my_send_int, my_proxy, array_proxy);</div>
</div><!-- fragment --><p >It is often necessary to reduce custom data types, such as <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></code> or <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a></code>. Charm++ supports such custom reductions, and so does our layer on top of Charm++. Custom reductions require one additional step to calling <code>contribute_to_reduction</code>, which is writing a reduction function to reduce the custom data. We provide a generic type that can be used in custom reductions, <code>Parallel::ReductionData</code>, which takes a series of <code><a class="el" href="structParallel_1_1ReductionDatum.html" title="The data to be reduced, and invokables to be called whenever two reduction messages are combined and ...">Parallel::ReductionDatum</a></code> as template parameters and <code>ReductionDatum::value_type</code>s as the arguments to the constructor. Each <code>ReductionDatum</code> takes up to four template parameters (two are required). The first is the type of data to reduce, and the second is a binary invokable that is called at each step of the reduction to combine two messages. The last two template parameters are used after the reduction has completed. The third parameter is an n-ary invokable that is called once the reduction is complete, whose first argument is the result of the reduction. The additional arguments can be any <code>ReductionDatum::value_type</code> in the <code>ReductionData</code> that are before the current one. The fourth template parameter of <code>ReductionDatum</code> is used to specify which data should be passed. It is a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::index_sequence</a></code> indexing into the <code>ReductionData</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>All elements of the array must call the same reductions in the same order. It is <em>defined</em> behavior to do multiple reductions at once as long as all contribute calls on all array elements occurred in the same order. It is <b>undefined</b> behavior if the contribute calls are made in different orders on different array elements.</dd></dl>
<h2><a class="anchor" id="dev_guide_parallelization_threaded_actions"></a>
4. Threaded Actions</h2>
<p >Threaded actions are similar to simple actions, with the difference being that multiple threaded actions may be running on the same chare at the same time (potentially in parallel with one simple or reduction action). The <code>apply</code> function for a threaded actions has the same signature as that for a simple action, except that it also receives a <code>NodeLock</code> intended to control access to the chare's <code>db::DataBox</code>. All access to the <code>db::DataBox</code>, including read-only access, must occur while the action owns this lock. (Simple and reduction actions implicitly hold the lock for their entire execution.)</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ParallelComponent, <span class="keyword">typename</span> DbTags, <span class="keyword">typename</span> Metavariables,</div>
<div class="line">            <span class="keyword">typename</span> ArrayIndex,</div>
<div class="line">            <a class="code hl_typedef" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt;<a class="code hl_variable" href="group__DataBoxGroup.html#ga0e5d678f658a67bdbaa8b10d1ec50505">db::tag_is_retrievable_v</a>&lt;Tags::vector_of_array_indexs,</div>
<div class="line">                                              db::DataBox&lt;DbTags&gt;&gt;&gt; = <span class="keyword">nullptr</span>&gt;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code hl_function" href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">apply</a>(db::DataBox&lt;DbTags&gt;&amp; box,</div>
<div class="line">                    <a class="code hl_class" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache&lt;Metavariables&gt;</a>&amp; <span class="comment">/*cache*/</span>,</div>
<div class="line">                    <span class="keyword">const</span> ArrayIndex&amp; <span class="comment">/*array_index*/</span>,</div>
<div class="line">                    <span class="keyword">const</span> <a class="code hl_class" href="classgsl_1_1not__null.html">gsl::not_null&lt;Parallel::NodeLock*&gt;</a> node_lock,</div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; id_of_array) {</div>
</div><!-- fragment --><p >Threaded actions can only be run on nodegroup chares.</p>
<h2><a class="anchor" id="dev_guide_parallelization_local_synchronous_actions"></a>
5. Local Synchronous Actions</h2>
<p >There is limited ability to retrieve data held by another parallel component via a direct synchronous call. Unlike the above actions, the invocation of a synchronous action is precisely a call to a member function of another parallel component; therefore, these invocations will run to completion, and return their result before the calling code proceeds in execution.</p>
<p >Aside from being synchronous and being able to return data, local synchronous actions behave the same as threaded actions, except that they will only run on the chare of a nodegroup that is on the local node.</p>
<p >Local synchronous actions' <code>apply</code> functions follow a signature motivated by threaded actions, but take fewer arguments. This may be a bug.</p>
<p >Local synchronous actions must specify their return type in a <code>return_type</code> type alias. This is to help simplify the logic with the variant <code>db::DataBox</code> held by the parallel component.</p>
<p >An example of a definition of a local synchronous action:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>SyncGetPointerFromNodegroup {</div>
<div class="line">  <span class="keyword">using</span> return_type = <span class="keywordtype">size_t</span>*;</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ParallelComponent, <span class="keyword">typename</span> DbTagsList&gt;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">size_t</span>* <a class="code hl_function" href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">apply</a>(db::DataBox&lt;DbTagsList&gt;&amp; box,</div>
<div class="line">                       <span class="keyword">const</span> <a class="code hl_class" href="classgsl_1_1not__null.html">gsl::not_null&lt;Parallel::NodeLock*&gt;</a> node_lock) {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (tmpl::list_contains_v&lt;DbTagsList, StepNumber&gt;) {</div>
<div class="line">      <span class="keywordtype">size_t</span>* result = <span class="keyword">nullptr</span>;</div>
<div class="line">      <span class="comment">// We must lock access to the box, because box access is non-atomic and</span></div>
<div class="line">      <span class="comment">// nodegroups can have multiple actions running in separate threads. Once</span></div>
<div class="line">      <span class="comment">// we retrieve the pointer to data from the box, we can safely pass it</span></div>
<div class="line">      <span class="comment">// along because we know that there are no compute tags that depend on</span></div>
<div class="line">      <span class="comment">// `StepNumber`. Without that guarantee, this would not be a supported use</span></div>
<div class="line">      <span class="comment">// of the box.</span></div>
<div class="line">      node_lock-&gt;lock();</div>
<div class="line">      db::mutate&lt;StepNumber&gt;(</div>
<div class="line">          [&amp;result](<span class="keyword">const</span> <a class="code hl_class" href="classgsl_1_1not__null.html">gsl::not_null&lt;size_t*&gt;</a> step_number) {</div>
<div class="line">            result = step_number;</div>
<div class="line">          },</div>
<div class="line">          make_not_null(&amp;box));</div>
<div class="line">      node_lock-&gt;unlock();</div>
<div class="line">      <span class="keywordflow">return</span> result;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="comment">// avoid &#39;unused&#39; warnings</span></div>
<div class="line">      (void)node_lock;</div>
<div class="line">      <a class="code hl_define" href="group__ErrorHandlingGroup.html#ga1d27028c1827976007fe9d29ad3a2f66">ERROR</a>(<span class="stringliteral">&quot;Could not find required tag `StepNumber` in the databox&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="ttc" id="agroup__ErrorHandlingGroup_html_ga1d27028c1827976007fe9d29ad3a2f66"><div class="ttname"><a href="group__ErrorHandlingGroup.html#ga1d27028c1827976007fe9d29ad3a2f66">ERROR</a></div><div class="ttdeci">#define ERROR(m)</div><div class="ttdoc">prints an error message to the standard error stream and aborts the program.</div><div class="ttdef"><b>Definition:</b> Error.hpp:64</div></div>
</div><!-- fragment --><p >And the corresponding invocation:</p>
<div class="fragment"><div class="line">    <span class="keywordtype">size_t</span>* step_number =</div>
<div class="line">        Parallel::local_synchronous_action&lt;SyncGetPointerFromNodegroup&gt;(</div>
<div class="line">            <a class="code hl_function" href="group__ParallelGroup.html#gaeee02b1e4faf8051fe703e6b9adada0f">Parallel::get_parallel_component</a>&lt;NodegroupComponent&lt;Metavariables&gt;&gt;(</div>
<div class="line">                cache));</div>
</div><!-- fragment --><h1><a class="anchor" id="dev_guide_parallelization_mutable_global_cache"></a>
Mutable items in the GlobalCache</h1>
<p >Most items in the GlobalCache are constant, and are specified by type aliases called <code>const_global_cache_tags</code> as described above. However, the GlobalCache can also store mutable items. Because of asynchronous execution, care must be taken when mutating items in the GlobalCache, as described below.</p>
<p >A mutable item can be of any type, as long as that type is something that can be checked for whether it is "up-to-date". Here "up-to-date" means that the item can be safely used (even read-only) without needing to be mutated first. For example, a mutable item might be a function of time that knows the range of times for which it is valid; the mutable item is then deemed up-to-date if it will be called for a time within its range of validity, and it is deemed not up-to-date if it will be called for a time outside its range of validity. Thus the up-to-date status of a mutable item is determined by both the state of the item itself and by the code that wishes to use that item.</p>
<h2><a class="anchor" id="autotoc_md136"></a>
1. Specification of mutable GlobalCache items</h2>
<p >Mutable GlobalCache items are specified by a type alias <code>mutable_global_cache_tags</code>, which is treated the same way as <code>const_global_cache_tags</code> for const items.</p>
<h2><a class="anchor" id="autotoc_md137"></a>
2. Use of mutable GlobalCache items</h2>
<h3><a class="anchor" id="autotoc_md138"></a>
1. Checking if the item is up-to-date</h3>
<p >Because execution is asynchronous, any code that uses a mutable item in the GlobalCache must first check whether that item is up-to-date. The information about whether an item is up-to-date is assumed to be stored in the item itself. For example, a mutable object stored in the GlobalCache might have type <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>&lt;temporal_id,T&gt;</code> (for some type <code>T</code>), and then any code that uses the stored object can check whether an entry exists for a particular <code>temporal_id</code>. To avoid race conditions, it is important that up-to-date checks are based on something that is independent of the order of mutation (like a <code>temporal_id</code>, and not like checking the size of a vector).</p>
<p >To check an item, use the function <code><a class="el" href="group__ParallelGroup.html#gaee973d82ab6a1dbac2b504e86d8de2e5" title="Returns whether the object identified by GlobalCacheTag is ready to be accessed by get.">Parallel::mutable_cache_item_is_ready</a></code>, which returns a bool indicating whether the item is up-to-date. If the item is up-to-date, then it can be used. <code><a class="el" href="group__ParallelGroup.html#gaee973d82ab6a1dbac2b504e86d8de2e5" title="Returns whether the object identified by GlobalCacheTag is ready to be accessed by get.">Parallel::mutable_cache_item_is_ready</a></code> takes a lambda as an argument. This lambda is passed a single argument: a const reference to the item being retrieved. The lambda should determine whether the item is up-to-date. If so, it should return a default_constructed <code><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;<a class="el" href="classParallel_1_1Callback.html" title="An abstract base class, whose derived class holds a function that can be invoked at a later time....">Parallel::Callback</a>&gt;</code>; if not, it should return a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;<a class="el" href="classParallel_1_1Callback.html" title="An abstract base class, whose derived class holds a function that can be invoked at a later time....">Parallel::Callback</a>&gt;</code> to a callback function that will be called on the next <code><a class="el" href="group__ParallelGroup.html#ga8fb8fc6f30581c450abecc8258dead3c" title="Mutates non-const data in the cache, by calling Function::apply()">Parallel::mutate</a></code> of that item. The callback will typically check again if the item is up-to-date and if so will execute some code that gets the item via <code><a class="el" href="group__ParallelGroup.html#ga43c98b994ca4a6ef61235109c5b94e14" title="Access data in the cache.">Parallel::get</a></code>.</p>
<p >For the case of iterable actions, <code><a class="el" href="group__ParallelGroup.html#gaee973d82ab6a1dbac2b504e86d8de2e5" title="Returns whether the object identified by GlobalCacheTag is ready to be accessed by get.">Parallel::mutable_cache_item_is_ready</a></code> typically uses the callback <code><a class="el" href="classParallel_1_1PerformAlgorithmCallback.html" title="Wraps a call to perform_algorithm.">Parallel::PerformAlgorithmCallback</a></code>. In the example below, the vector is considered up-to-date if it is non-empty. If the vector is not up-to-date, then when it becomes up-to-date the callback function will be invoked; in this case the callback function re-runs <code>perform_algorithm()</code>, which will call the same action again.</p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span>&amp; this_proxy = <a class="code hl_function" href="group__ParallelGroup.html#gaeee02b1e4faf8051fe703e6b9adada0f">Parallel::get_parallel_component</a>&lt;</div>
<div class="line">        UseMutatedCacheComponent&lt;Metavariables&gt;&gt;(<a class="code hl_function" href="namespaceActionTesting.html#a645bd6af028059c31bced3807764827e">cache</a>);</div>
<div class="line">    <span class="keywordflow">if</span> (not ::Parallel::mutable_cache_item_is_ready&lt;Tags::VectorOfDoubles&gt;(</div>
<div class="line">            cache,</div>
<div class="line">            [&amp;this_proxy](<span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>&amp; VectorOfDoubles)</div>
<div class="line">                -&gt; <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr&lt;Parallel::Callback&gt;</a> {</div>
<div class="line">              <span class="keywordflow">return</span> VectorOfDoubles.empty()</div>
<div class="line">                         ? <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr&lt;Parallel::Callback&gt;</a>(</div>
<div class="line">                               <span class="keyword">new</span> <a class="code hl_class" href="classParallel_1_1PerformAlgorithmCallback.html">Parallel::PerformAlgorithmCallback</a>(</div>
<div class="line">                                   this_proxy))</div>
<div class="line">                         : <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr&lt;Parallel::Callback&gt;</a>{};</div>
<div class="line">            })) {</div>
<div class="line">      <span class="keywordflow">return</span> {<a class="code hl_enumvalue" href="namespaceParallel.html#af31fff079d116e958890e079a35955cfa6327b4e59f58137083214a1fec358855">Parallel::AlgorithmExecution::Retry</a>, std::nullopt};</div>
<div class="line">    }</div>
<div class="ttc" id="aclassParallel_1_1PerformAlgorithmCallback_html"><div class="ttname"><a href="classParallel_1_1PerformAlgorithmCallback.html">Parallel::PerformAlgorithmCallback</a></div><div class="ttdoc">Wraps a call to perform_algorithm.</div><div class="ttdef"><b>Definition:</b> Callback.hpp:81</div></div>
</div><!-- fragment --><p >Note that <code><a class="el" href="group__ParallelGroup.html#gaee973d82ab6a1dbac2b504e86d8de2e5" title="Returns whether the object identified by GlobalCacheTag is ready to be accessed by get.">Parallel::mutable_cache_item_is_ready</a></code> is called on a local core and does no parallel communication.</p>
<h3><a class="anchor" id="autotoc_md139"></a>
2. Retrieving the item</h3>
<p >The item is retrieved using <code><a class="el" href="group__ParallelGroup.html#ga43c98b994ca4a6ef61235109c5b94e14" title="Access data in the cache.">Parallel::get</a></code> just like for constant items. For example, to retrieve the item <code>Tags::VectorOfDoubles</code>: </p><div class="fragment"><div class="line">    <a class="code hl_define" href="group__TestingFrameworkGroup.html#ga37fce1ae5980139598815eda5a5de8ab">SPECTRE_PARALLEL_REQUIRE</a>(Parallel::get&lt;Tags::VectorOfDoubles&gt;(cache) ==</div>
<div class="line">                             expected_result);</div>
</div><!-- fragment --><p >Note that <code><a class="el" href="group__ParallelGroup.html#ga43c98b994ca4a6ef61235109c5b94e14" title="Access data in the cache.">Parallel::get</a></code> is called on a local core and does no parallel communication.</p>
<p >Whereas we support getting <em>non-mutable</em> items in the GlobalCache from a DataBox via <code><a class="el" href="group__DataBoxGroup.html#gaa36fa9cf94ab1cb05c5a6e23d56f79ae" title="Retrieve the item with tag Tag from the DataBox.">db::get</a></code>, we intentionally do not support <code><a class="el" href="group__DataBoxGroup.html#gaa36fa9cf94ab1cb05c5a6e23d56f79ae" title="Retrieve the item with tag Tag from the DataBox.">db::get</a></code> of <em>mutable</em> items in the GlobalCache from a DataBox. The reason is that mutable items should be retrieved only after a <code><a class="el" href="group__ParallelGroup.html#gaee973d82ab6a1dbac2b504e86d8de2e5" title="Returns whether the object identified by GlobalCacheTag is ready to be accessed by get.">Parallel::mutable_cache_item_is_ready</a></code> check, and being able to retrieve a mutable item from a DataBox makes it difficult to enforce that check, especially when automatically-executing compute items are considered.</p>
<h2><a class="anchor" id="autotoc_md140"></a>
3. Modifying a mutable GlobalCache item</h2>
<p >To modify a mutable item, pass <code><a class="el" href="group__ParallelGroup.html#ga8fb8fc6f30581c450abecc8258dead3c" title="Mutates non-const data in the cache, by calling Function::apply()">Parallel::mutate</a></code> two template parameters: the tag to mutate, and a struct with an <code>apply</code> function that does the mutating. <code><a class="el" href="group__ParallelGroup.html#ga8fb8fc6f30581c450abecc8258dead3c" title="Mutates non-const data in the cache, by calling Function::apply()">Parallel::mutate</a></code> takes two arguments: a reference to the local GlobalCache, and a tuple that is passed into the mutator function. For the following example,</p>
<div class="fragment"><div class="line">    <a class="code hl_function" href="group__ParallelGroup.html#ga8fb8fc6f30581c450abecc8258dead3c">Parallel::mutate</a>&lt;Tags::VectorOfDoubles,</div>
<div class="line">                     MutationFunctions::add_stored_double&gt;(<a class="code hl_function" href="namespaceActionTesting.html#a645bd6af028059c31bced3807764827e">cache</a>, 42.0);</div>
<div class="ttc" id="agroup__ParallelGroup_html_ga8fb8fc6f30581c450abecc8258dead3c"><div class="ttname"><a href="group__ParallelGroup.html#ga8fb8fc6f30581c450abecc8258dead3c">Parallel::mutate</a></div><div class="ttdeci">void mutate(GlobalCache&lt; Metavariables &gt; &amp;cache, Args &amp;&amp;... args)</div><div class="ttdoc">Mutates non-const data in the cache, by calling Function::apply()</div><div class="ttdef"><b>Definition:</b> GlobalCache.hpp:927</div></div>
</div><!-- fragment --><p >the mutator function is defined as below: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>MutationFunctions {</div>
<div class="line"><span class="keyword">struct </span>add_stored_double {</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code hl_function" href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">apply</a>(<span class="keyword">const</span> <a class="code hl_class" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>*&gt; data,</div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> new_value) {</div>
<div class="line">    <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/iterator/data.html">data</a>-&gt;emplace_back(new_value);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line">}  <span class="comment">// namespace MutationFunctions</span></div>
<div class="ttc" id="adata_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/iterator/data.html">std::data</a></div><div class="ttdeci">T data(T... args)</div></div>
</div><!-- fragment --><p ><code><a class="el" href="group__ParallelGroup.html#ga8fb8fc6f30581c450abecc8258dead3c" title="Mutates non-const data in the cache, by calling Function::apply()">Parallel::mutate</a></code> broadcasts to every core, where it calls the mutator function and then calls all the callbacks that have been set on that core by <code><a class="el" href="group__ParallelGroup.html#gaee973d82ab6a1dbac2b504e86d8de2e5" title="Returns whether the object identified by GlobalCacheTag is ready to be accessed by get.">Parallel::mutable_cache_item_is_ready</a></code>. The <code><a class="el" href="group__ParallelGroup.html#ga8fb8fc6f30581c450abecc8258dead3c" title="Mutates non-const data in the cache, by calling Function::apply()">Parallel::mutate</a></code> operation is guaranteed to be thread-safe without any further action by the developer.</p>
<h1><a class="anchor" id="dev_guide_parallelization_charm_node_processor_level_initialization"></a>
Charm++ Node and Processor Level Initialization Functions</h1>
<p >Charm++ allows running functions once per core and once per node before the construction of any parallel components. This is commonly used for setting up error handling and enabling floating point exceptions. Other functions could also be run. Which functions are run on each node and core is set by specifying a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;void (*)()&gt;</code> called <code>charm_init_node_funcs</code> and <code>charm_init_proc_funcs</code> with function pointers to the functions to be called. For example, </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;void (*)()&gt; charm_init_node_funcs{</div>
<div class="line">    &amp;setup_error_handling, &amp;setup_memory_allocation_failure_reporting};</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;void (*)()&gt; charm_init_proc_funcs{</div>
<div class="line">    &amp;<a class="code hl_function" href="group__ErrorHandlingGroup.html#gac5fde843ca62e1d4288f4a4e6d480aa0">enable_floating_point_exceptions</a>, &amp;<a class="code hl_function" href="group__ErrorHandlingGroup.html#ga44f95ed3fe1fab4c632a36efc4d548d8">enable_segfault_handler</a>};</div>
<div class="ttc" id="agroup__ErrorHandlingGroup_html_ga44f95ed3fe1fab4c632a36efc4d548d8"><div class="ttname"><a href="group__ErrorHandlingGroup.html#ga44f95ed3fe1fab4c632a36efc4d548d8">enable_segfault_handler</a></div><div class="ttdeci">void enable_segfault_handler()</div><div class="ttdoc">After a call to this function, the code will handle SIGSEGV segmentation faults by printing an error ...</div></div>
<div class="ttc" id="agroup__ErrorHandlingGroup_html_gac5fde843ca62e1d4288f4a4e6d480aa0"><div class="ttname"><a href="group__ErrorHandlingGroup.html#gac5fde843ca62e1d4288f4a4e6d480aa0">enable_floating_point_exceptions</a></div><div class="ttdeci">void enable_floating_point_exceptions()</div><div class="ttdoc">After a call to this function, the code will terminate with a floating point exception on overflow,...</div></div>
</div><!-- fragment --><p >Finally, the user must include the <code>Parallel/CharmMain.tpp</code> file at the end of the main executable cpp file. So, the end of an executables main cpp file will then typically look as follows: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;void (*)()&gt; charm_init_node_funcs{</div>
<div class="line">    &amp;setup_error_handling, &amp;setup_memory_allocation_failure_reporting,</div>
<div class="line">    &amp;disable_openblas_multithreading};</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;void (*)()&gt; charm_init_proc_funcs{</div>
<div class="line">    &amp;<a class="code hl_function" href="group__ErrorHandlingGroup.html#gac5fde843ca62e1d4288f4a4e6d480aa0">enable_floating_point_exceptions</a>, &amp;<a class="code hl_function" href="group__ErrorHandlingGroup.html#ga44f95ed3fe1fab4c632a36efc4d548d8">enable_segfault_handler</a>};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> charmxx_main_component = <a class="code hl_class" href="classParallel_1_1Main.html">Parallel::Main&lt;TestMetavariables&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;Parallel/CharmMain.tpp&quot;</span>  <span class="comment">// IWYU pragma: keep</span></div>
<div class="ttc" id="aclassParallel_1_1Main_html"><div class="ttname"><a href="classParallel_1_1Main.html">Parallel::Main</a></div><div class="ttdoc">The main function of a Charm++ executable. See the Parallelization documentation for an overview of M...</div><div class="ttdef"><b>Definition:</b> Main.hpp:65</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dev_guide.html">Developer Guides</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
