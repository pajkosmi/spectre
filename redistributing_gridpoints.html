<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: Redistributing Gridpoints</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('redistributing_gridpoints.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Redistributing Gridpoints </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md161">Introduction</a></li>
<li class="level1"><a href="#autotoc_md162">Generalized Logical Coordinates</a></li>
<li class="level1"><a href="#autotoc_md163">Equiangular Maps</a></li>
<li class="level1"><a href="#autotoc_md164">Projective Maps</a></li>
</ul>
</div>
<div class="textblock"><p ><a class="anchor" id="md_docs_DevGuide_RedistributingGridpoints"></a></p>
<h1><a class="anchor" id="autotoc_md161"></a>
Introduction</h1>
<p >The simplest way to construct a volume map from two parameterized surfaces is by linearly interpolating between them:</p>
<p class="formulaDsp">
\[\vec{x}(\xi,\eta,\zeta) = \frac{1-\zeta}{2}\vec{\sigma}_-(\xi,\eta)+ \frac{1+\zeta}{2}\vec{\sigma}_+(\xi,\eta)\]
</p>
<p >In the above example, each surface \(\vec{\sigma}_+\) and \(\vec{\sigma}_-\) is parameterized using the logical coordinates \(\xi\) and \(\eta\), and a third coordinate \(\zeta\in[-1,1]\) is used to interpolate between them.</p>
<p >We then distribute gridpoints on this volume by specifying values of the coordinates \(\xi,\eta,\) and \(\zeta\) at which the gridpoints are located. In SpECTRE these values are the locations of the quadrature nodes. The distribution of the gridpoints throughout the volume depends on the parameterization used, and the simplest choice of parameterization does not necessarily lead to the best gridpoint distribution. In this section we discuss situations in which there exist better parameterizations than those obtained by linear interpolation.</p>
<h1><a class="anchor" id="autotoc_md162"></a>
Generalized Logical Coordinates</h1>
<p >In each of the following examples, we will obtain functions \(\Xi(\xi), \mathrm{H}(\eta),\) and \(\mathrm{Z}(\zeta)\) that give better gridpoint distributions than using the logical coordinates alone. Where possible, we will write the reparameterized map such that the functional form of the map is unchanged when replacing \(\Xi\) with \(\xi\), etc. We therefore refer to \(\Xi, \mathrm{H},\) and \(\mathrm{Z}\) as the <em>generalized logical coordinates</em>, as they can also refer to the logical coordinates \(\xi, \eta,\) and \(\zeta\) themselves, when the transformation is the identity.</p>
<h1><a class="anchor" id="autotoc_md163"></a>
Equiangular Maps</h1>
<p >The mapping for a cubed sphere surface can be easily obtained by taking points that lie on each face of a cube and normalizing them such that they lie on the sphere:</p>
<p class="formulaDsp">
\[\vec{\sigma}_{+z}(\xi,\eta) = \frac{1}{\sqrt{1 + \xi^2 + \eta^2}} \begin{bmatrix} \xi\\ \eta\\ 1\\ \end{bmatrix}\]
</p>
<p >In the above example the parameterization used for the upper \(+z\) surface of the cube is linear in \(\xi\) and \(\eta\). However, distances measured on the surface of the sphere are not linear in \(\xi\) and \(\eta\). To see this, one may compute \(g_{\xi\xi} = |\frac{\partial\vec{x}}{\partial\xi}|^2\) to see how distances are measured in terms of \(\xi\):</p>
<p class="formulaDsp">
\[g_{\xi,\xi}|_{\eta=0} = \frac{1}{(1+\xi^2)^2}\]
</p>
<p >This metric term demonstrates that a gridpoint distribution uniform in \(\xi\) will end up being compressed near \(\xi=\pm1\). Suppose we reparameterized the surface using the generalized logical coordinate \(\Xi\in[-1,1]\). We would find:</p>
<p class="formulaDsp">
\[g_{\xi,\xi}|_{\eta=0} = \frac{\Xi&#39;^2}{(1+\Xi^2)^2}\]
</p>
<p >Ideally, we would like distances measured along a curvilinear surface to be linear in the logical coordinates. We solve the differential equation and obtain:</p>
<p class="formulaDsp">
\[\Xi = \tan(\xi\pi/4)\]
</p>
<p >These two parameterizations of the cubed sphere are known as the <em>equidistant</em> and <em>equiangular</em> central projections of the cube onto the sphere. We now summarize their usage in SpECTRE CoordinateMaps that have <code>with_equiangular_map</code> as a specifiable parameter:</p>
<p >In the case where <code>with_equiangular_map</code> is <code>true</code>, we have the equiangular coordinates</p>
<p class="formulaDsp">
\[\textrm{equiangular xi} : \Xi(\xi) = \textrm{tan}(\xi\pi/4)\]
</p>
<p class="formulaDsp">
\[\textrm{equiangular eta} : \mathrm{H}(\eta) = \textrm{tan}(\eta\pi/4)\]
</p>
<p >with derivatives</p>
<p class="formulaDsp">
\[\Xi&#39;(\xi) = \frac{\pi}{4}(1+\Xi^2)\]
</p>
<p>,</p>
<p class="formulaDsp">
\[\mathrm{H}&#39;(\eta) = \frac{\pi}{4}(1+\mathrm{H}^2)\]
</p>
<p >In the case where <code>with_equiangular_map</code> is <code>false</code>, we have the equidistant coordinates</p>
<p class="formulaDsp">
\[ \textrm{equidistant xi} : \Xi = \xi\]
</p>
<p class="formulaDsp">
\[ \textrm{equidistant eta} : \mathrm{H} = \eta\]
</p>
<p >with derivatives:</p>
<p class="formulaDsp">
\[\Xi&#39;(\xi) = 1\]
</p>
 <p class="formulaDsp">
\[\mathrm{H}&#39;(\eta) = 1\]
</p>
<h1><a class="anchor" id="autotoc_md164"></a>
Projective Maps</h1>
<p >The mapping for any convex quadrilateral can be obtained by bilinearly interpolating between each vertex \(\vec{x}_1, \vec{x}_2, \vec{x}_3\) and \(\vec{x}_4\):</p>
<p class="formulaDsp">
\[\vec{x}(\xi,\eta) = \frac{(1-\xi)(1-\eta)}{4}\vec{x}_1+ \frac{(1+\xi)(1-\eta)}{4}\vec{x}_2+ \frac{(1-\xi)(1+\eta)}{4}\vec{x}_3+ \frac{(1+\xi)(1+\eta)}{4}\vec{x}_4 \]
</p>
<p >In the case of a trapezoid where two of the sides are parallel, it is appropriate to linearly interpolate along the parallel sides. However, linearly interpolating between the two bases results in a less than ideal gridpoint distribution. This happens in the case of SpECTRE's Frustum, where the logical coordinate \(\zeta\) interpolates between the bases.</p>
<div class="image">
<img src="BilinearVProjective.png" alt=""/>
<div class="caption">
Comparison of mappings. (Noah Veltman)</div></div>
<p >As seen in Veltman's [Warp-Off] (<a href="https://bl.ocks.org/veltman/8f5a157276b1dc18ce2fba1bc06dfb48">https://bl.ocks.org/veltman/8f5a157276b1dc18ce2fba1bc06dfb48</a>), linear interpolation between the two bases results in a uniformly spaced grid between the bases of the frustum. This causes elements near the smaller base to be longer in the direction normal to the base, and elements near the larger base to be shorter in the direction normal to the base. We desire elements that have roughly equal sizes along each of their dimensions.</p>
<p >We can redistribute the gridpoints in the \(\zeta\) direction using a projective map, moving more gridpoints toward the smaller base. We can also see in the figure above that a projective map can be applied incorrectly, leaving elements distorted at the opposite end. From this we can see that it is important to control the degree of projection.</p>
<p >We adapt a technique from projective geometry to obtain the desired grid spacing. The heart of the method lies in the fact that objects arranged in a line at equal distances from one another will appear to converge as they approach the horizon.</p>
<div class="image">
<img src="ProjectionOntoPlane.png" alt=""/>
<div class="caption">
Controlling the degree of projection.</div></div>
<p >The above diagram demonstrates how to obtain a nonlinearly parameterized object (seen in red) from a linearly parameterized one (seen in purple). This is done by lifting the linearly parameterized object into a higher spatial dimension \(w\), such that its projection onto the plane remains unchanged. As seen above, \(w_{\delta}\) controls the degree of projection of one end of the object (purple) into a higher spatial dimension \(w\). In projective geometry, these points that exist in the higher dimension are labeled with <em>homogeneous coordinates</em> \(\tilde{x}, \tilde{y}, \tilde{z}, w\), to distinguish them from the Cartesian coordinates that label points that exist on the \(w=1\) hyperplane, \(x,y,z\). The resulting grid (seen in red) is obtained by projecting back into the \(w=1\) hyperplane. The Cartesian coordinates are obtained by dividing each homogeneous coordinate of the linearly parameterized object by its respective \(w\) coordinate value.</p>
<p >The parametric equation for the purple object seen above in homogeneous coordinates is: </p><p class="formulaDsp">
\[\begin{bmatrix}\tilde{x}\\\tilde{y}\\\tilde{z}\\w\\\end{bmatrix}= \frac{1-\zeta}{2}\begin{bmatrix}x_1\\y_1\\z_1\\1\\\end{bmatrix}+ \frac{1+\zeta}{2}\begin{bmatrix}x_2w_{\delta}\\y_2w_{\delta}\\ z_2w_{\delta}\\w_{\delta}\\\end{bmatrix}\]
</p>
<p >The equation for the projected red object in Cartesian coordinates is obtained by dividing by w: </p><p class="formulaDsp">
\[\vec{x}(\zeta) = \frac{1}{w(\zeta)} \begin{bmatrix} \tilde{x}(\zeta)\\ \tilde{y}(\zeta)\\ \tilde{z}(\zeta)\\ \end{bmatrix}\]
</p>
<p >We wish to cast our parametric equation for the surface into the form: </p><p class="formulaDsp">
\[\vec{x}(\zeta) = \frac{1-\mathrm{Z}}{2}\vec{x}_1 + \frac{1+\mathrm{Z}}{2}\vec{x}_2\]
</p>
<p> for some appropriate choice of auxiliary variable <code>projective_zeta</code> \( = \mathrm{Z}(\zeta)\). We would also like for \(\mathrm{Z}\) to reduce to \(\zeta\) when \(w_{\delta}\ = 1\).</p>
<p >Defining the auxiliary variables \(w_{\pm} := w_{\delta}\pm 1\), the desired \(\mathrm{Z}(\zeta)\) is given by: </p><p class="formulaDsp">
\[\mathrm{Z} = \frac{w_- + \zeta w_+} {w_+ + \zeta w_-}\]
</p>
<p >with derivative: </p><p class="formulaDsp">
\[\mathrm{Z}&#39; = \frac{\partial\mathrm{Z}}{\partial \zeta} = \frac{w_+^2 - w_-^2}{(w_+ + \zeta w_-)^2}\]
</p>
<p >For SpECTRE CoordinateMaps that have <code>projective_scale_factor</code> as a specifiable parameter, the value \(w_{\delta} = 1\) should be supplied in case the user does not want to use projective scaling. If <code>auto_projective_scale_factor</code> is set to <code>true</code>, the map will compute a value of \(w_{\delta}\) that is appropriate. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dev_guide.html">Developer Guides</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
