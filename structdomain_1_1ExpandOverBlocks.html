<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: domain::ExpandOverBlocks&lt; T, Dim &gt; Struct Template Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structdomain_1_1ExpandOverBlocks.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structdomain_1_1ExpandOverBlocks-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">domain::ExpandOverBlocks&lt; T, Dim &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Produce a distribution of type <code>T</code> over all blocks and dimensions in the domain, based on values <code>T</code> of variable isotropy and homogeneity.  
 <a href="structdomain_1_1ExpandOverBlocks.html#details">More...</a></p>

<p><code>#include &lt;ExpandOverBlocks.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad2ec3364b412f3ca3451f75de0a0cd9d"><td class="memItemLeft" align="right" valign="top"><a id="ad2ec3364b412f3ca3451f75de0a0cd9d" name="ad2ec3364b412f3ca3451f75de0a0cd9d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ExpandOverBlocks</b> (size_t num_blocks)</td></tr>
<tr class="separator:ad2ec3364b412f3ca3451f75de0a0cd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46bf16be5555bfb08235a39ae31da64"><td class="memItemLeft" align="right" valign="top"><a id="af46bf16be5555bfb08235a39ae31da64" name="af46bf16be5555bfb08235a39ae31da64"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ExpandOverBlocks</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; block_names, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &gt; block_groups={})</td></tr>
<tr class="separator:af46bf16be5555bfb08235a39ae31da64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115af81ba0e7c2bfd68b44b37419a245"><td class="memItemLeft" align="right" valign="top"><a id="a115af81ba0e7c2bfd68b44b37419a245" name="a115af81ba0e7c2bfd68b44b37419a245"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (const T &amp;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">value</a>) const</td></tr>
<tr class="memdesc:a115af81ba0e7c2bfd68b44b37419a245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeat over all blocks and dimensions (isotropic and homogeneous) <br /></td></tr>
<tr class="separator:a115af81ba0e7c2bfd68b44b37419a245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501593951a1d417465dcafc0f8431d6e"><td class="memItemLeft" align="right" valign="top"><a id="a501593951a1d417465dcafc0f8431d6e" name="a501593951a1d417465dcafc0f8431d6e"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim &gt; &amp;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">value</a>) const</td></tr>
<tr class="memdesc:a501593951a1d417465dcafc0f8431d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeat over all blocks (homogeneous) <br /></td></tr>
<tr class="separator:a501593951a1d417465dcafc0f8431d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80f6f2cd3c6cde28dba957f9d60bb5e"><td class="memItemLeft" align="right" valign="top"><a id="af80f6f2cd3c6cde28dba957f9d60bb5e" name="af80f6f2cd3c6cde28dba957f9d60bb5e"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim &gt; &gt; <a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">value</a>) const</td></tr>
<tr class="memdesc:af80f6f2cd3c6cde28dba957f9d60bb5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only check if the size matches the number of blocks, throwing a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/error/length_error.html">std::length_error</a></code> if it doesn't. <br /></td></tr>
<tr class="separator:af80f6f2cd3c6cde28dba957f9d60bb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7184aa0dca6d74764bd1d9e7d1653e67"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1ExpandOverBlocks.html#a7184aa0dca6d74764bd1d9e7d1653e67">operator()</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim &gt; &gt; &amp;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">value</a>) const</td></tr>
<tr class="memdesc:a7184aa0dca6d74764bd1d9e7d1653e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map block names, or names of block groups, to values. The map must cover all blocks once the groups are expanded. To use this option you must pass the list of block names and groups to the constructor. Here's an example:  <a href="structdomain_1_1ExpandOverBlocks.html#a7184aa0dca6d74764bd1d9e7d1653e67">More...</a><br /></td></tr>
<tr class="separator:a7184aa0dca6d74764bd1d9e7d1653e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, size_t Dim&gt;<br />
struct domain::ExpandOverBlocks&lt; T, Dim &gt;</div><p >Produce a distribution of type <code>T</code> over all blocks and dimensions in the domain, based on values <code>T</code> of variable isotropy and homogeneity. </p>
<p >This class is useful to option-create values for e.g. the initial refinement level or initial number of grid points for domain creators. It can be used with <code>std::visit</code> and a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/variant.html">std::variant</a></code> with (a subset of) these types:</p>
<ul>
<li><code>T</code>: Repeat over all blocks and dimensions (isotropic and homogeneous).</li>
<li><code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;T, Dim&gt;</code>: Repeat over all blocks (homogeneous).</li>
<li><code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;T, Dim&gt;&gt;&gt;</code>: Only check if the size matches the number of blocks, throwing a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/error/length_error.html">std::length_error</a></code> if it doesn't.</li>
<li><code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;T, Dim&gt;&gt;</code>: Map block names, or names of block groups, to values. The map must cover all blocks once the groups are expanded. To use this option you must pass the list of block names and groups to the constructor.</li>
</ul>
<p >Note that the call-operators <code>throw</code> when they encounter errors, such as mismatches in the number of blocks. The exceptions can be used to output user-facing error messages in an option-parsing context.</p>
<p >Here's an example for using this class:</p>
<div class="fragment"><div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> Dim = 3;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_blocks = 3;</div>
<div class="line">    <span class="comment">// This is an example for a variant that represents the distribution of</span></div>
<div class="line">    <span class="comment">// initial refinement levels, which might be parsed from options:</span></div>
<div class="line">    <span class="keyword">using</span> InitialRefinementOptionType =</div>
<div class="line">        <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/utility/variant.html">std::variant&lt;size_t, std::array&lt;size_t, Dim&gt;</a>,</div>
<div class="line">                     <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;std::array&lt;size_t, Dim&gt;</a>&gt;&gt;;</div>
<div class="line">    <span class="comment">// In this example the user specified a single number:</span></div>
<div class="line">    <span class="keyword">const</span> InitialRefinementOptionType initial_refinement_from_options{</div>
<div class="line">        <span class="keywordtype">size_t</span>{2}};</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">      <span class="comment">// Invoke `ExpandOverBlocks`:</span></div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> initial_refinement =</div>
<div class="line">          std::visit(ExpandOverBlocks&lt;size_t, Dim&gt;{num_blocks},</div>
<div class="line">                     initial_refinement_from_options);</div>
<div class="line">      <span class="comment">// Since a single number was specified, we expect the vector over blocks</span></div>
<div class="line">      <span class="comment">// is homogeneously and isotropically filled with that number:</span></div>
<div class="line">      <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;std::array&lt;size_t, Dim&gt;</a>&gt; expected_initial_refinement{</div>
<div class="line">          num_blocks, {2, 2, 2}};</div>
<div class="line">      CHECK(initial_refinement == expected_initial_refinement);</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/error/length_error.html">std::length_error</a>&amp; error) {</div>
<div class="line">      <span class="comment">// This would be a `PARSE_ERROR` in an option-parsing context</span></div>
<div class="line">      <a class="code hl_define" href="group__ErrorHandlingGroup.html#ga1d27028c1827976007fe9d29ad3a2f66">ERROR</a>(<span class="stringliteral">&quot;Invalid &#39;InitialRefinement&#39;: &quot;</span> &lt;&lt; error.what());</div>
<div class="line">    }</div>
<div class="ttc" id="agroup__ErrorHandlingGroup_html_ga1d27028c1827976007fe9d29ad3a2f66"><div class="ttname"><a href="group__ErrorHandlingGroup.html#ga1d27028c1827976007fe9d29ad3a2f66">ERROR</a></div><div class="ttdeci">#define ERROR(m)</div><div class="ttdoc">prints an error message to the standard error stream and aborts the program.</div><div class="ttdef"><b>Definition:</b> Error.hpp:64</div></div>
<div class="ttc" id="alength_error_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/error/length_error.html">std::length_error</a></div></div>
<div class="ttc" id="avariant_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/utility/variant.html">std::variant</a></div></div>
<div class="ttc" id="avector_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></div></div>
</div><!-- fragment --><p >Here's an example using block names and groups:</p>
<div class="fragment"><div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> Dim = 2;</div>
<div class="line">    <span class="comment">// In this example we name the blocks, representing a cubed-sphere domain:</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;std::string&gt;</a> block_names{<span class="stringliteral">&quot;InnerCube&quot;</span>, <span class="stringliteral">&quot;East&quot;</span>, <span class="stringliteral">&quot;North&quot;</span>,</div>
<div class="line">                                               <span class="stringliteral">&quot;West&quot;</span>, <span class="stringliteral">&quot;South&quot;</span>};</div>
<div class="line">    <span class="comment">// The blocks can also be grouped:</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map&lt;std::string, std::unordered_set&lt;std::string&gt;</a>&gt;</div>
<div class="line">        block_groups{{<span class="stringliteral">&quot;Wedges&quot;</span>, {<span class="stringliteral">&quot;East&quot;</span>, <span class="stringliteral">&quot;North&quot;</span>, <span class="stringliteral">&quot;West&quot;</span>, <span class="stringliteral">&quot;South&quot;</span>}}};</div>
<div class="line">    <span class="comment">// Now we can expand values over blocks by giving their names. This can also</span></div>
<div class="line">    <span class="comment">// be used with a std::variant like in the other example.</span></div>
<div class="line">    ExpandOverBlocks&lt;size_t, Dim&gt; expand{block_names, block_groups};</div>
<div class="line">    CHECK(expand({{<span class="stringliteral">&quot;West&quot;</span>, {{3, 4}}},</div>
<div class="line">                  {<span class="stringliteral">&quot;InnerCube&quot;</span>, {{2, 3}}},</div>
<div class="line">                  {<span class="stringliteral">&quot;South&quot;</span>, {{3, 4}}},</div>
<div class="line">                  {<span class="stringliteral">&quot;North&quot;</span>, {{5, 6}}},</div>
<div class="line">                  {<span class="stringliteral">&quot;East&quot;</span>, {{1, 2}}}}) ==</div>
<div class="line">          <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;size_t, Dim&gt;</a>&gt;{</div>
<div class="line">              {{2, 3}}, {{1, 2}}, {{5, 6}}, {{3, 4}}, {{3, 4}}});</div>
<div class="line">    <span class="comment">// Instead of naming all blocks individually we can also name groups:</span></div>
<div class="line">    CHECK(expand({{<span class="stringliteral">&quot;InnerCube&quot;</span>, {{2, 3}}}, {<span class="stringliteral">&quot;Wedges&quot;</span>, {{3, 4}}}}) ==</div>
<div class="line">          <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;size_t, Dim&gt;</a>&gt;{</div>
<div class="line">              {{2, 3}}, {{3, 4}}, {{3, 4}}, {{3, 4}}, {{3, 4}}});</div>
<div class="ttc" id="aarray_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt; size_t, Dim &gt;</a></div></div>
<div class="ttc" id="aunordered_map_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a></div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type distributed over the domain </td></tr>
    <tr><td class="paramname">Dim</td><td>The number of spatial dimensions </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a7184aa0dca6d74764bd1d9e7d1653e67" name="a7184aa0dca6d74764bd1d9e7d1653e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7184aa0dca6d74764bd1d9e7d1653e67">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim &gt; &gt; <a class="el" href="structdomain_1_1ExpandOverBlocks.html">domain::ExpandOverBlocks</a>&lt; T, Dim &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map block names, or names of block groups, to values. The map must cover all blocks once the groups are expanded. To use this option you must pass the list of block names and groups to the constructor. Here's an example: </p>
<div class="fragment"><div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> Dim = 2;</div>
<div class="line">    <span class="comment">// In this example we name the blocks, representing a cubed-sphere domain:</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;std::string&gt;</a> block_names{<span class="stringliteral">&quot;InnerCube&quot;</span>, <span class="stringliteral">&quot;East&quot;</span>, <span class="stringliteral">&quot;North&quot;</span>,</div>
<div class="line">                                               <span class="stringliteral">&quot;West&quot;</span>, <span class="stringliteral">&quot;South&quot;</span>};</div>
<div class="line">    <span class="comment">// The blocks can also be grouped:</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map&lt;std::string, std::unordered_set&lt;std::string&gt;</a>&gt;</div>
<div class="line">        block_groups{{<span class="stringliteral">&quot;Wedges&quot;</span>, {<span class="stringliteral">&quot;East&quot;</span>, <span class="stringliteral">&quot;North&quot;</span>, <span class="stringliteral">&quot;West&quot;</span>, <span class="stringliteral">&quot;South&quot;</span>}}};</div>
<div class="line">    <span class="comment">// Now we can expand values over blocks by giving their names. This can also</span></div>
<div class="line">    <span class="comment">// be used with a std::variant like in the other example.</span></div>
<div class="line">    ExpandOverBlocks&lt;size_t, Dim&gt; expand{block_names, block_groups};</div>
<div class="line">    CHECK(expand({{<span class="stringliteral">&quot;West&quot;</span>, {{3, 4}}},</div>
<div class="line">                  {<span class="stringliteral">&quot;InnerCube&quot;</span>, {{2, 3}}},</div>
<div class="line">                  {<span class="stringliteral">&quot;South&quot;</span>, {{3, 4}}},</div>
<div class="line">                  {<span class="stringliteral">&quot;North&quot;</span>, {{5, 6}}},</div>
<div class="line">                  {<span class="stringliteral">&quot;East&quot;</span>, {{1, 2}}}}) ==</div>
<div class="line">          <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;size_t, Dim&gt;</a>&gt;{</div>
<div class="line">              {{2, 3}}, {{1, 2}}, {{5, 6}}, {{3, 4}}, {{3, 4}}});</div>
<div class="line">    <span class="comment">// Instead of naming all blocks individually we can also name groups:</span></div>
<div class="line">    CHECK(expand({{<span class="stringliteral">&quot;InnerCube&quot;</span>, {{2, 3}}}, {<span class="stringliteral">&quot;Wedges&quot;</span>, {{3, 4}}}}) ==</div>
<div class="line">          <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;size_t, Dim&gt;</a>&gt;{</div>
<div class="line">              {{2, 3}}, {{3, 4}}, {{3, 4}}, {{3, 4}}, {{3, 4}}});</div>
</div><!-- fragment --> 
</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>src/Domain/Creators/ExpandOverBlocks.hpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedomain.html">domain</a></li><li class="navelem"><a class="el" href="structdomain_1_1ExpandOverBlocks.html">ExpandOverBlocks</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
