<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: Profiling</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('profiling.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Profiling </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#profiling_with_hpctoolkit">Profiling with HPCToolkit</a></li>
<li class="level1"><a href="#profiling_with_amd_uprof">Profiling with AMD uProf</a></li>
<li class="level1"><a href="#profiling_with_projections">Profiling With Charm++ Projections</a><ul><li class="level2"><a href="#autotoc_md141">Running SpECTRE With Trace Output</a></li>
<li class="level2"><a href="#autotoc_md142">Visualizing Trace %Data In Projections</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p ><a class="anchor" id="md_docs_DevGuide_Profiling"></a></p>
<p >There are a number of tools available for profiling, each with their own strengths and weaknesses. This makes it difficult to recommend one "right" way of analyzing performance using profilers. Instead, one should use a combination of the tools to discover and eliminate performance bottle necks. Common profilers are Charm++ Projections (tracing-based), HPCToolkit (sampling-based, very versatile), Linux perf (sampling-based, command line only), Intel VTune (sampling-based, works well on Intel hardware), and AMD uProf (similar to Intel VTune).</p>
<h1><a class="anchor" id="profiling_with_hpctoolkit"></a>
Profiling with HPCToolkit</h1>
<p >Follow the HPCToolkit installation instructions at <a href="http://hpctoolkit.org">hpctoolkit.org</a>. The Spack installation seems to work well. Once installed, compile your executable in Release mode with <code>-D ENABLE_PROFILING=ON -D DEBUG_SYMBOLS=ON</code> since otherwise you won't be able to get call stacks and source analysis. Using <code>-D BUILD_SHARED_LIBS=ON</code> is recommended since it makes HPCToolkit a lot easier to use. You must also use the system allocator, <code>-D MEMORY_ALLOCATOR=SYSTEM</code>. We will work from the build directory and perform all runs and performance analysis there.</p>
<p >First run HPCToolkit as: </p><div class="fragment"><div class="line">hpcrun -t --event CYCLES@f200 ./bin/EXEC --input-file ./Input.yaml +p1</div>
</div><!-- fragment --><p> We will profile on one core, but you can profile on multiple cores as well as multiple nodes if using MPI as the Charm++ backend. This will generate a <code>hpctoolkit-EXEC-measurements</code> directory. Run </p><div class="fragment"><div class="line">hpcstruct -jN ./hpctoolkit-EXEC-measurements</div>
</div><!-- fragment --><p> where <code>N</code> is the number of cores to run on. This will generate a mapping to line numbers, etc. in the measurements directory.</p>
<dl class="section warning"><dt>Warning</dt><dd>Skipping the <code>hpcstruct</code> step will make <code>hprprof</code> below run extremely slowly.</dd></dl>
<p>Once the run is complete, run </p><div class="fragment"><div class="line">hpcprof -I /path/to/spectre/src/+ hpctoolkit-EXEC-measurements</div>
</div><!-- fragment --><p> Note that the <code>+</code> is a literal <code>+</code> symbol. This will create the directory </p><div class="fragment"><div class="line">hpctoolkit-EXEC-database</div>
</div><!-- fragment --><p> which you can view using </p><div class="fragment"><div class="line">hpcviewer ./hpctoolkit-EXEC-database</div>
</div><!-- fragment --><p >HPCViewer will generally start you in the <code>Top-down view</code> (callgraph of callers). You can select <code>Bottom-up view</code> (callgraph of callees) to get a different perspective. Whether you want to look at the callgraph of callers or callees depends a bit on the executable, what you're looking to measure, and how you like to think about things. The callees graph can give you a nice overview of what the low-level things taking up a lot of time are, but certainly makes the call stack not look like you would expect. On the right of the callgraphs you will see <code>CYCLES:Sum (I)</code> and <code>CYCLES:Sum (E)</code>. <code>I</code> means time spent <em>including</em> callees, while <code>E</code> means time spent in the function itself (exclusive time). Sorting by exclusive gives a good idea of what the hot functions are. Here is a screenshot from HPCViewer:</p>
<div class="image">
<img src="HpcViewerCallees.png" alt=""/>
<div class="caption">
HPCViewer callgraph of callees</div></div>
<p >You can see that 49.1% of inclusive time is spent in primitive recovery, and the line after the 49.1% function is a function inside the Kastaun recovery scheme. The <code>__nss_database_lookup</code> is some system call, e.g. <code>__memcpy_avx_unaligned_erms</code> or <code>__memset_avx2_unaligned_erms</code>. Looking at the calling code, e.g. <code>prepare_neighbor_data</code> gives a good hint as to what's going on. In most cases these are memory copies or memory sets (<code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></code> default initializes its memory, which is bad for performance). The way to fix these bottlenecks is to avoid memory copies and <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;double&gt;</code> as buffers.</p>
<p >HPCToolkit allows you to sample on a variety of different event counters instead of just cycles. Please see the HPCToolkit manual for details.</p>
<h1><a class="anchor" id="profiling_with_amd_uprof"></a>
Profiling with AMD uProf</h1>
<p ><a href="https://developer.amd.com/amd-uprof/">AMD uProf</a> is AMD's sampling-based profiler that makes it relatively easy to do quite a bit of detailed performance analysis. The uProf manual is quite good and extensive, so for the most part the reader is referred to that. However, we will go over some basics for profiling executables and understanding the results. Make sure to compile your executable in Release mode with <code>-DENABLE_PROFILING=ON -D DEBUG_SYMBOLS=ON</code> since otherwise you won't be able to get call stacks and source analysis.</p>
<p >When you open uProf you may be asked to change the kernel event paranoid level. Once you have uProf open, select <code>PROFILE</code> at the top. Specify the application path, options, etc. We will again run on a single core to analyze performance. It's recommended that you set the Core Affinity in AMD uProf so that your application isn't migrated between cores during a profiling run. Then choose <code>Next</code> in the lower right corner. Make sure the <code>CPU Profile Type</code> is set to <code>CPU Profile</code> at the top. We will first do a <code>Time-based Sampling</code> run (on the left). This means uProf will interrupt the application every <code>N</code> milliseconds and see where the application is. You typically want a few thousand total samples to get something that's reasonably representative of your application. Under the <code>Advanced Options</code> make sure <code>Enable CSS</code> (on the right) is enabled (green) and that <code>Enable FPO</code> is also enabled. Now click <code>Start Profile</code> in the bottom right. Once the profile is complete you will be presented with a summary outlining where your code is spending most of its time. Click <code>ANALYZE</code> at the top to get a more detailed view. On the left you can select between a callgraph of callees (Function HotSpots), a callgraph of callers (Call Graph), and a few other views. Below is an example of a result from the same run we used with HPCToolkit above.</p>
<div class="image">
<img src="AmdUprofCallgraph.png" alt=""/>
<div class="caption">
AMD uProf callgraph of callees</div></div>
<p >Again we see that most of our time is spent in primitive recovery but also that a lot of time is spent copying memory. This was grouped into <code>__nss_database_lookup</code> in HPCToolkit. Unfortunately, getting a call stack out of the <code>memcpy</code> doesn't always work and so while you know you're spending a lot of time copying memory, it's not so obvious where those copies are occurring.</p>
<h1><a class="anchor" id="profiling_with_projections"></a>
Profiling With Charm++ Projections</h1>
<p >To view trace data after a profiling run you must download Charm++'s Projections software from their <a href="http://charm.cs.illinois.edu/">website</a>. If you encounter issues it may be necessary to clone the git repository and build the correct version from scratch. Note that the version of Charm++ used to compile SpECTRE should match the version of Projections used to analyze the trace data. You can collect the trace data on a different machine than the one you will be analyzing the data on. For example, you can collect the data on a supercomputer and analyze it on your desktop or laptop.</p>
<p >For profiling you will want to use a production build of Charm++, which means compiling Charm++ with the <code>--with-production</code> flag. To enable trace collecting you must build with the <code>--enable-tracing</code> flag as well. For example, on a multicore 64-bit Linux machine the build command would be </p><div class="fragment"><div class="line">./build LIBS multicore-linux-x86_64 gcc -j8 --with-production --enable-tracing</div>
</div><!-- fragment --><p> You must build your executable in Release mode as well, specifying <code>-DCMAKE_BUILD_TYPE=Release</code> to CMake, as well as </p><div class="fragment"><div class="line">-DCHARM_TRACE_PROJECTIONS=ON -DCHARM_TRACE_SUMMARY=ON -DENABLE_PROFILING=ON</div>
</div><!-- fragment --><p> to enable SpECTRE to use Charm++'s tracing features.</p>
<h2><a class="anchor" id="autotoc_md141"></a>
Running SpECTRE With Trace Output</h2>
<p >When running SpECTRE you must specify a directory to output trace data into. This is done by adding the command line argument <code>+traceroot DIR</code> where <code>DIR</code> is the directory to dump the trace data into. Note that <code>DIR</code> must already exist, the application will not create it. For example,</p>
<div class="fragment"><div class="line">./bin/EXEC --input-file ./Input.yaml +p4 +traceroot ./ExecTraces</div>
</div><!-- fragment --><p> You might get a warning that Charm++ had to flush the log some number of times during the run. Flushing the log adds overhead to the execution and so affects timing measurements. While Charm++ has the ability to manually flush the log periodically (and therefore exclude the time it takes to flush the log from the trace), we have not yet implemented support for this. For short executable runs you can increase the log size by specifying <code>+logsize M</code> when running the executable. The default log size is 1,000,000 (1000000). Note that if you increase the log size too much you will run out of memory/RAM.</p>
<p >For more information on runtime options to control trace data see the <a href="http://charm.cs.illinois.edu/manuals/html/projections/1.html">Charm++ Projections manual</a>.</p>
<h2><a class="anchor" id="autotoc_md142"></a>
Visualizing Trace %Data In Projections</h2>
<p >By default Charm++ records entry method names by using the <code>PRETTY_FUNCTION</code> macro. This means entry method names include all class (parallel component) and action template parameter names, including any template parameters of the template parameters. This very quickly leads to incomprehensibly long names that are very difficult to read in the Projections interface. We include a basic Python executable to handle the majority of renames, but the executable supports additional basic (textual find-replace) and regular expression replacements via a JSON file. These additional replacements are useful for making executable-specific renames. The Python executable is <code>tools/CharmSimplifyTraces.py</code> and an example replacements file is <code>tools/CharmTraceReplacements.json</code>.</p>
<p >See the <a href="http://charm.cs.illinois.edu/manuals/html/projections/2.html">Charm++ Projections manual</a> for details. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dev_guide.html">Developer Guides</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
