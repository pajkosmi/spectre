<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: importers::Actions::ReadAllVolumeDataAndDistribute&lt; Dim, FieldTagsList, ReceiveComponent &gt; Struct Template Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structimporters_1_1Actions_1_1ReadAllVolumeDataAndDistribute.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="structimporters_1_1Actions_1_1ReadAllVolumeDataAndDistribute-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">importers::Actions::ReadAllVolumeDataAndDistribute&lt; Dim, FieldTagsList, ReceiveComponent &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Read a volume data file and distribute the data to all registered elements, interpolating to the target points if needed.  
 <a href="structimporters_1_1Actions_1_1ReadAllVolumeDataAndDistribute.html#details">More...</a></p>

<p><code>#include &lt;ReadVolumeData.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac5aaa2d312af29004f5410b8f0ece074"><td class="memTemplParams" colspan="2"><a id="ac5aaa2d312af29004f5410b8f0ece074" name="ac5aaa2d312af29004f5410b8f0ece074"></a>
template&lt;typename ParallelComponent , typename DataBox , typename Metavariables , typename ArrayIndex &gt; </td></tr>
<tr class="memitem:ac5aaa2d312af29004f5410b8f0ece074"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply</b> (DataBox &amp;box, <a class="el" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache</a>&lt; Metavariables &gt; &amp;cache, const ArrayIndex &amp;, const <a class="el" href="structimporters_1_1ImporterOptions.html">ImporterOptions</a> &amp;options, const size_t volume_data_id, tuples::tagged_tuple_from_typelist&lt; <a class="el" href="group__DataBoxTagsGroup.html#ga3dda5a16c7f6baccd115de2c8f12394e">db::wrap_tags_in</a>&lt; <a class="el" href="structimporters_1_1Tags_1_1Selected.html">Tags::Selected</a>, FieldTagsList &gt; &gt; selected_fields=select_all_fields(FieldTagsList{}))</td></tr>
<tr class="separator:ac5aaa2d312af29004f5410b8f0ece074"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;size_t Dim, typename FieldTagsList, typename ReceiveComponent&gt;<br />
struct importers::Actions::ReadAllVolumeDataAndDistribute&lt; Dim, FieldTagsList, ReceiveComponent &gt;</div><p >Read a volume data file and distribute the data to all registered elements, interpolating to the target points if needed. </p>
<p >This action can be invoked on the <code><a class="el" href="structimporters_1_1ElementDataReader.html" title="A nodegroup parallel component that reads in a volume data file and distributes its data to elements ...">importers::ElementDataReader</a></code> component once all elements have been registered with it. It opens the data file, reads the data for each registered element and uses <code><a class="el" href="group__ParallelGroup.html#gad1078fa99233851c6475fbfa99a2f51d" title="Send the data args... to the algorithm running on proxy, and tag the message with the identifier temp...">Parallel::receive_data</a></code> to distribute the data to the elements. The elements can monitor <code><a class="el" href="structimporters_1_1Tags_1_1VolumeData.html" title="Inbox tag that carries the data read from a volume data file.">importers::Tags::VolumeData</a></code> in their inbox to wait for the data and process it once it's available. You can use <code><a class="el" href="structimporters_1_1Actions_1_1ReceiveVolumeData.html" title="Wait for data from a volume data file to arrive and directly move it into the DataBox.">importers::Actions::ReceiveVolumeData</a></code> to wait for the data and move it directly into the DataBox, or implement a specialized action that might verify and post-process the data.</p>
<p >Note that instead of invoking this action directly on the <code><a class="el" href="structimporters_1_1ElementDataReader.html" title="A nodegroup parallel component that reads in a volume data file and distributes its data to elements ...">importers::ElementDataReader</a></code> component you can invoke the iterable action <code><a class="el" href="structimporters_1_1Actions_1_1ReadVolumeData.html" title="Read a volume data file and distribute the data to all registered elements, interpolating to the targ...">importers::Actions::ReadVolumeData</a></code> on the elements of an array parallel component for simple use cases.</p>
<ul>
<li>Pass along the following arguments to the simple action invocation:<ul>
<li><code>options</code>: <code><a class="el" href="structimporters_1_1ImporterOptions.html" title="Options that specify the volume data to load. See the option tags for details.">importers::ImporterOptions</a></code> that specify the H5 files with volume data to load.</li>
<li><code>volume_data_id</code>: A number (or hash) that identifies this import operation. Will also be used to identify the loaded volume data in the inbox of the receiving elements.</li>
<li><code>selected_fields</code> (optional): See below.</li>
</ul>
</li>
<li>The <code>FieldTagsList</code> parameter specifies a typelist of tensor tags that can be read from the file and provided to each element. The subset of tensors that will actually be read and distributed can be selected at runtime with the <code>selected_fields</code> argument that is passed to this simple action. See <a class="el" href="structimporters_1_1Tags_1_1Selected.html" title="Indicates an available tensor field is selected for importing, along with the name of the dataset in ...">importers::Tags::Selected</a> for details. By default, all tensors in the <code>FieldTagsList</code> are selected, and read from datasets named <code><a class="el" href="group__DataBoxGroup.html#ga394ce601ab663ac540db55037224aa59" title="Get the name of a DataBox tag, including prefixes.">db::tag_name</a>&lt;Tag&gt;() + suffix</code>, where the <code>suffix</code> is empty for scalars, or <code>"_"</code> followed by the <code>Tensor::component_name</code> for each independent tensor component.</li>
<li><code><a class="el" href="group__ParallelGroup.html#gad1078fa99233851c6475fbfa99a2f51d" title="Send the data args... to the algorithm running on proxy, and tag the message with the identifier temp...">Parallel::receive_data</a></code> is invoked on each registered element of the <code>ReceiveComponent</code> to populate <code><a class="el" href="structimporters_1_1Tags_1_1VolumeData.html" title="Inbox tag that carries the data read from a volume data file.">importers::Tags::VolumeData</a></code> in the element's inbox with a <code>tuples::tagged_tuple_from_typelist&lt;FieldTagsList&gt;</code> containing the tensor data for that element. The <code>ReceiveComponent</code> must the the same that was encoded into the <code><a class="el" href="classobservers_1_1ArrayComponentId.html" title="An ID type that identifies both the parallel component and the index in the parallel component.">observers::ArrayComponentId</a></code> used to register the elements. The <code>volume_data_id</code> passed to this action is used as key.</li>
</ul>
<dl class="section user"><dt>Memory consumption</dt><dd>This action runs once on every node. It reads all volume data files on the node, but doesn't keep them all in memory at once. The following items contribute primarily to memory consumption and can be reconsidered if we run into memory issues:</dd></dl>
<ul>
<li><code>all_tensor_data</code>: All requested tensor components in the volume data file at the specified observation ID. Only data from one volume data file is held in memory at any time. Only data from files that overlap with target elements on this node are read in.</li>
<li><code>target_element_data_buffer</code>: Holds incomplete interpolated data for each (target) element that resides on this node. In the worst case, when all target elements need data from the last source element in the last volume data file, the memory consumption of this buffer can grow to hold all requested tensor components on all elements that reside on this node. However, elements are erased from this buffer once their interpolated data is complete (and sent to the target element), so the memory consumption should remain much lower in practice.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd>Dev guide on <a class="el" href="dev_guide_importing.html">Importing data</a> </dd></dl>
</div><hr/>The documentation for this struct was generated from the following file:<ul>
<li>src/IO/Importers/Actions/ReadVolumeData.hpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceimporters.html">importers</a></li><li class="navelem"><b>Actions</b></li><li class="navelem"><a class="el" href="structimporters_1_1Actions_1_1ReadAllVolumeDataAndDistribute.html">ReadAllVolumeDataAndDistribute</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
