<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: intrp Namespace Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceintrp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">intrp Namespace Reference<div class="ingroups"><a class="el" href="group__NumericalAlgorithmsGroup.html">Numerical Algorithms</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Contains classes and functions for interpolation.  
<a href="namespaceintrp.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceintrp_1_1Actions"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceintrp_1_1Actions.html">Actions</a></td></tr>
<tr class="memdesc:namespaceintrp_1_1Actions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds <a class="el" href="namespaceintrp_1_1Actions.html" title="Holds Actions for Interpolator and InterpolationTarget.">Actions</a> for <a class="el" href="structintrp_1_1Interpolator.html" title="ParallelComponent responsible for collecting data from Elements and interpolating it onto Interpolati...">Interpolator</a> and <a class="el" href="structintrp_1_1InterpolationTarget.html" title="ParallelComponent representing a set of points to be interpolated to and a function to call upon inte...">InterpolationTarget</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceintrp_1_1callbacks"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceintrp_1_1callbacks.html">callbacks</a></td></tr>
<tr class="memdesc:namespaceintrp_1_1callbacks"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains callback functions called by <code><a class="el" href="structintrp_1_1InterpolationTarget.html" title="ParallelComponent representing a set of points to be interpolated to and a function to call upon inte...">InterpolationTarget</a></code>s. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceintrp_1_1protocols"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceintrp_1_1protocols.html">protocols</a></td></tr>
<tr class="memdesc:namespaceintrp_1_1protocols"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all protocols used in the interpolation framework. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceintrp_1_1Tags"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceintrp_1_1Tags.html">Tags</a></td></tr>
<tr class="memdesc:namespaceintrp_1_1Tags"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceintrp_1_1Tags.html" title="Tags for items held in the DataBox of InterpolationTarget or Interpolator.">Tags</a> for items held in the <code>DataBox</code> of <code><a class="el" href="structintrp_1_1InterpolationTarget.html" title="ParallelComponent representing a set of points to be interpolated to and a function to call upon inte...">InterpolationTarget</a></code> or <code><a class="el" href="structintrp_1_1Interpolator.html" title="ParallelComponent responsible for collecting data from Elements and interpolating it onto Interpolati...">Interpolator</a></code>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceintrp_1_1Vars"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceintrp_1_1Vars.html">Vars</a></td></tr>
<tr class="memdesc:namespaceintrp_1_1Vars"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structures holding quantities that are interpolated by <code><a class="el" href="structintrp_1_1Interpolator.html" title="ParallelComponent responsible for collecting data from Elements and interpolating it onto Interpolati...">Interpolator</a></code> for use by <code><a class="el" href="structintrp_1_1InterpolationTarget.html" title="ParallelComponent representing a set of points to be interpolated to and a function to call upon inte...">InterpolationTarget</a></code>s. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintrp_1_1BarycentricRational.html">BarycentricRational</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A barycentric rational interpolation class.  <a href="classintrp_1_1BarycentricRational.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintrp_1_1BarycentricRationalSpanInterpolator.html">BarycentricRationalSpanInterpolator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a barycentric interpolation with an order in a range fixed at construction; this class can be chosen via the options factory mechanism as a possible <code><a class="el" href="classintrp_1_1SpanInterpolator.html" title="Base class for interpolators so that the factory options mechanism can be used.">SpanInterpolator</a></code>.  <a href="classintrp_1_1BarycentricRationalSpanInterpolator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintrp_1_1CubicSpanInterpolator.html">CubicSpanInterpolator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a cubic interpolation; this class can be chosen via the options factory mechanism as a possible <code><a class="el" href="classintrp_1_1SpanInterpolator.html" title="Base class for interpolators so that the factory options mechanism can be used.">SpanInterpolator</a></code>.  <a href="classintrp_1_1CubicSpanInterpolator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintrp_1_1CubicSpline.html">CubicSpline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A natural cubic spline interpolation class.  <a href="classintrp_1_1CubicSpline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structintrp_1_1InterpolationTarget.html">InterpolationTarget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ParallelComponent representing a set of points to be interpolated to and a function to call upon interpolation to those points.  <a href="structintrp_1_1InterpolationTarget.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structintrp_1_1Interpolator.html">Interpolator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ParallelComponent responsible for collecting data from <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code>s and interpolating it onto <code><a class="el" href="structintrp_1_1InterpolationTarget.html" title="ParallelComponent representing a set of points to be interpolated to and a function to call upon inte...">InterpolationTarget</a></code>s.  <a href="structintrp_1_1Interpolator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintrp_1_1Irregular.html">Irregular</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates a <code>Variables</code> onto an arbitrary set of points.  <a href="classintrp_1_1Irregular.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintrp_1_1LinearLeastSquares.html">LinearLeastSquares</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear least squares solver class.  <a href="classintrp_1_1LinearLeastSquares.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structintrp_1_1LinearRegressionResult.html">LinearRegressionResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintrp_1_1LinearSpanInterpolator.html">LinearSpanInterpolator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a linear interpolation; this class can be chosen via the options factory mechanism as a possible <code><a class="el" href="classintrp_1_1SpanInterpolator.html" title="Base class for interpolators so that the factory options mechanism can be used.">SpanInterpolator</a></code>  <a href="classintrp_1_1LinearSpanInterpolator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintrp_1_1MultiLinearSpanInterpolation.html">MultiLinearSpanInterpolation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs linear interpolation in arbitrary dimensions. The class is non-owning and expects a C-ordered array, (n, x, y, z). The variable index, n, varies fastest in memory. Note that this class is intentionally non-pupable.  <a href="classintrp_1_1MultiLinearSpanInterpolation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintrp_1_1RegularGrid.html">RegularGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate data from a <a class="el" href="classMesh.html" title="Holds the number of grid points, basis, and quadrature in each direction of the computational grid.">Mesh</a> onto a regular grid of points.  <a href="classintrp_1_1RegularGrid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintrp_1_1SpanInterpolator.html">SpanInterpolator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for interpolators so that the factory options mechanism can be used.  <a href="classintrp_1_1SpanInterpolator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintrp_1_1ZeroCrossingPredictor.html">ZeroCrossingPredictor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that predicts when a function crosses zero.  <a href="classintrp_1_1ZeroCrossingPredictor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1cd099e1bbec119c53342dfc6df118d7"><td class="memTemplParams" colspan="2"><a id="a1cd099e1bbec119c53342dfc6df118d7" name="a1cd099e1bbec119c53342dfc6df118d7"></a>
template&lt;size_t Dimension, size_t NumberOfVariables&gt; </td></tr>
<tr class="memitem:a1cd099e1bbec119c53342dfc6df118d7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>UniformMultiLinearSpanInterpolation</b> = <a class="el" href="classintrp_1_1MultiLinearSpanInterpolation.html">MultiLinearSpanInterpolation</a>&lt; Dimension, NumberOfVariables, true &gt;</td></tr>
<tr class="memdesc:a1cd099e1bbec119c53342dfc6df118d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multilinear span interpolation with uniform grid spacing. <br /></td></tr>
<tr class="separator:a1cd099e1bbec119c53342dfc6df118d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a71eba1e8b4f931e73fd542292a06de"><td class="memTemplParams" colspan="2"><a id="a2a71eba1e8b4f931e73fd542292a06de" name="a2a71eba1e8b4f931e73fd542292a06de"></a>
template&lt;size_t Dimension, size_t NumberOfVariables&gt; </td></tr>
<tr class="memitem:a2a71eba1e8b4f931e73fd542292a06de"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GeneralMultiLinearSpanInterpolation</b> = <a class="el" href="classintrp_1_1MultiLinearSpanInterpolation.html">MultiLinearSpanInterpolation</a>&lt; Dimension, NumberOfVariables, false &gt;</td></tr>
<tr class="memdesc:a2a71eba1e8b4f931e73fd542292a06de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multilinear span interpolation with non-uniform grid spacing. <br /></td></tr>
<tr class="separator:a2a71eba1e8b4f931e73fd542292a06de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a60935d8d95701ed7a976a964d582f6a8"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceintrp.html#a60935d8d95701ed7a976a964d582f6a8">AngularOrdering</a> { <b>Strahlkorper</b>
, <b>Cce</b>
 }</td></tr>
<tr class="memdesc:a60935d8d95701ed7a976a964d582f6a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Label for the ordering of spherical harmonic points on a sphere.  <a href="namespaceintrp.html#a60935d8d95701ed7a976a964d582f6a8">More...</a><br /></td></tr>
<tr class="separator:a60935d8d95701ed7a976a964d582f6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a170da17e169cf27db40c66ff20c6349b"><td class="memTemplParams" colspan="2"><a id="a170da17e169cf27db40c66ff20c6349b" name="a170da17e169cf27db40c66ff20c6349b"></a>
template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:a170da17e169cf27db40c66ff20c6349b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classintrp_1_1Irregular.html">Irregular</a>&lt; Dim &gt; &amp;lhs, const <a class="el" href="classintrp_1_1Irregular.html">Irregular</a>&lt; Dim &gt; &amp;rhs)</td></tr>
<tr class="separator:a170da17e169cf27db40c66ff20c6349b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa09845b42e4ab196189f52146264d102"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa09845b42e4ab196189f52146264d102"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structintrp_1_1LinearRegressionResult.html">LinearRegressionResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#gaa09845b42e4ab196189f52146264d102">linear_regression</a> (const T &amp;x_values, const T &amp;y_values)</td></tr>
<tr class="memdesc:gaa09845b42e4ab196189f52146264d102"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear regression function.  <a href="group__NumericalAlgorithmsGroup.html#gaa09845b42e4ab196189f52146264d102">More...</a><br /></td></tr>
<tr class="separator:gaa09845b42e4ab196189f52146264d102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2b4743e6113288e9aeefa113db8e07"><td class="memTemplParams" colspan="2">template&lt;size_t Degree&gt; </td></tr>
<tr class="memitem:a5c2b4743e6113288e9aeefa113db8e07"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceintrp.html#a5c2b4743e6113288e9aeefa113db8e07">polynomial_interpolation</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; double * &gt; y, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; double * &gt; error_in_y, double target_x, const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;y_values, const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;x_values)</td></tr>
<tr class="memdesc:a5c2b4743e6113288e9aeefa113db8e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate <code>y_values</code> to <code>target_x</code> from tabulated <code>x_values</code> using a polynomial interpolant of degree <code>Degree</code>.  <a href="namespaceintrp.html#a5c2b4743e6113288e9aeefa113db8e07">More...</a><br /></td></tr>
<tr class="separator:a5c2b4743e6113288e9aeefa113db8e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b99de117dd868d0074e7fa68e2276c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceintrp.html#ac8b99de117dd868d0074e7fa68e2276c">predicted_zero_crossing_value</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;x_values, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;y_values)</td></tr>
<tr class="memdesc:ac8b99de117dd868d0074e7fa68e2276c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicts the zero crossing of a function.  <a href="namespaceintrp.html#ac8b99de117dd868d0074e7fa68e2276c">More...</a><br /></td></tr>
<tr class="separator:ac8b99de117dd868d0074e7fa68e2276c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9967aea8cc25282ab17d589de65305"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDataVector.html">DataVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceintrp.html#a5f9967aea8cc25282ab17d589de65305">predicted_zero_crossing_value</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>&lt; double &gt; &amp;x_values, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;y_values)</td></tr>
<tr class="memdesc:a5f9967aea8cc25282ab17d589de65305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicts the zero crossing of multiple functions.  <a href="namespaceintrp.html#a5f9967aea8cc25282ab17d589de65305">More...</a><br /></td></tr>
<tr class="separator:a5f9967aea8cc25282ab17d589de65305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c233082887235e9c1ec6ea553e6492"><td class="memTemplParams" colspan="2"><a id="a70c233082887235e9c1ec6ea553e6492" name="a70c233082887235e9c1ec6ea553e6492"></a>
template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:a70c233082887235e9c1ec6ea553e6492"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classintrp_1_1RegularGrid.html">RegularGrid</a>&lt; Dim &gt; &amp;lhs, const <a class="el" href="classintrp_1_1RegularGrid.html">RegularGrid</a>&lt; Dim &gt; &amp;rhs)</td></tr>
<tr class="separator:a70c233082887235e9c1ec6ea553e6492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631e0260c9f35222fc19d1913d0a6683"><td class="memItemLeft" align="right" valign="top"><a id="a631e0260c9f35222fc19d1913d0a6683" name="a631e0260c9f35222fc19d1913d0a6683"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classintrp_1_1ZeroCrossingPredictor.html">ZeroCrossingPredictor</a> &amp;, const <a class="el" href="classintrp_1_1ZeroCrossingPredictor.html">ZeroCrossingPredictor</a> &amp;)</td></tr>
<tr class="separator:a631e0260c9f35222fc19d1913d0a6683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac0894403fb5f45ded3cafac7a1cfbc"><td class="memTemplParams" colspan="2"><a id="a9ac0894403fb5f45ded3cafac7a1cfbc" name="a9ac0894403fb5f45ded3cafac7a1cfbc"></a>
template&lt;typename InterpolationTargetTag , typename Metavariables , typename DbTags &gt; </td></tr>
<tr class="memitem:a9ac0894403fb5f45ded3cafac7a1cfbc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_to_interpolate</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; db::DataBox&lt; DbTags &gt; * &gt; box, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache</a>&lt; Metavariables &gt; * &gt; cache, const typename InterpolationTargetTag::temporal_id::type &amp;temporal_id)</td></tr>
<tr class="memdesc:a9ac0894403fb5f45ded3cafac7a1cfbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if we have enough information to interpolate. If so, do the interpolation and send data to the <a class="el" href="structintrp_1_1InterpolationTarget.html" title="ParallelComponent representing a set of points to be interpolated to and a function to call upon inte...">InterpolationTarget</a>. <br /></td></tr>
<tr class="separator:a9ac0894403fb5f45ded3cafac7a1cfbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12b217ce9a4208edc63e46a5330f8a3"><td class="memTemplParams" colspan="2"><a id="ad12b217ce9a4208edc63e46a5330f8a3" name="ad12b217ce9a4208edc63e46a5330f8a3"></a>
template&lt;typename InterpolationTargetTag , size_t VolumeDim, typename Metavariables , typename... InterpolatorSourceVars&gt; </td></tr>
<tr class="memitem:ad12b217ce9a4208edc63e46a5330f8a3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>interpolate</b> (const typename InterpolationTargetTag::temporal_id::type &amp;temporal_id, const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim &gt; &amp;mesh, <a class="el" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache</a>&lt; Metavariables &gt; &amp;cache, const <a class="el" href="classElementId.html">ElementId</a>&lt; VolumeDim &gt; &amp;array_index, const InterpolatorSourceVars &amp;... interpolator_source_vars_input)</td></tr>
<tr class="separator:ad12b217ce9a4208edc63e46a5330f8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955c7582ffe88da4f08e5d79ef348f0a"><td class="memItemLeft" align="right" valign="top"><a id="a955c7582ffe88da4f08e5d79ef348f0a" name="a955c7582ffe88da4f08e5d79ef348f0a"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, <a class="el" href="namespaceintrp.html#a60935d8d95701ed7a976a964d582f6a8">AngularOrdering</a> ordering)</td></tr>
<tr class="separator:a955c7582ffe88da4f08e5d79ef348f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Contains classes and functions for interpolation. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a60935d8d95701ed7a976a964d582f6a8" name="a60935d8d95701ed7a976a964d582f6a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60935d8d95701ed7a976a964d582f6a8">&#9670;&nbsp;</a></span>AngularOrdering</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceintrp.html#a60935d8d95701ed7a976a964d582f6a8">intrp::AngularOrdering</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Label for the ordering of spherical harmonic points on a sphere. </p>
<h3>Details</h3>
<p ><code>Strahlkorper</code> refers to points on a sphere ordered by SPHEREPACK because <code><a class="el" href="classStrahlkorper.html" title="A star-shaped surface expanded in spherical harmonics.">Strahlkorper</a></code>s hold YlmSpherePacks internally. <code>Cce</code> refers to points on a sphere ordered by Libsharp because <a class="el" href="namespaceCce.html" title="The set of utilities for performing Cauchy characteristic evolution and Cauchy characteristic matchin...">Cce</a> uses Libsharp internally. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5c2b4743e6113288e9aeefa113db8e07" name="a5c2b4743e6113288e9aeefa113db8e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c2b4743e6113288e9aeefa113db8e07">&#9670;&nbsp;</a></span>polynomial_interpolation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Degree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void intrp::polynomial_interpolation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; double * &gt;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; double * &gt;&#160;</td>
          <td class="paramname"><em>error_in_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>target_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate <code>y_values</code> to <code>target_x</code> from tabulated <code>x_values</code> using a polynomial interpolant of degree <code>Degree</code>. </p>
<p ><code>error_in_y</code> is an estimate of the error of the interpolated value. Note that at least in the tests this is a significant overestimate of the errors (several orders of magnitude). However, this could be because in the test the polynomial can be represented exactly when all terms are present, but incurs significant errors when the largest degree term is omitted. </p>

</div>
</div>
<a id="a5f9967aea8cc25282ab17d589de65305" name="a5f9967aea8cc25282ab17d589de65305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9967aea8cc25282ab17d589de65305">&#9670;&nbsp;</a></span>predicted_zero_crossing_value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataVector.html">DataVector</a> intrp::predicted_zero_crossing_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>y_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicts the zero crossing of multiple functions. </p>
<p >For the ith element of the <a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a> inside y_values, calls predicted_zero_crossing_value(x_values,y_values[:][i]), where we have used python-like notation. </p>

</div>
</div>
<a id="ac8b99de117dd868d0074e7fa68e2276c" name="ac8b99de117dd868d0074e7fa68e2276c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b99de117dd868d0074e7fa68e2276c">&#9670;&nbsp;</a></span>predicted_zero_crossing_value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double intrp::predicted_zero_crossing_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicts the zero crossing of a function. </p>
<p >Fits a linear function to a set of y_values at different x_values and uses the fit to predict what x_value the y_value zero will be crossed.</p>
<p >predicted_zero_crossing treats x=0 in a special way: All of the x_values must be non-positive; one of the x_values is typically (but is not required to be) zero. In typical usage, x is time, and x=0 is the current time, and we are interested in whether the function crosses zero in the past or in the future. If it cannot be determined (within the error bars of the fit) whether the zero crossing occurs for x &lt; 0 versus x &gt; 0, then we return zero. Otherwise we return the best-fit x for when the function crosses zero.</p>
<h3>Details</h3>
<p >We fit to a straight line: y = intercept + slope*x. So our best guess is that the function will cross zero at x_best_fit = -intercept/slope.</p>
<p >However, the data are assumed to be noisy. The fit gives us error bars for the slope and the intercept. Given the error bars, we can compute four limiting crossing values x0, x1, x2, and x3 by using the maximum and minimum possible values of slope and intercept. For example, if we assume slope&lt;0 and intercept&gt;0, then the earliest possible crossing consistent with the error bars is x3=(-intercept+delta_intercept)/(slope-delta_slope) and the latest possible crossing consistent with the error bars is x0=(-intercept-delta_intercept)/(slope+delta_slope).</p>
<p >We compute all four crossing values and demand that all of them are either at x&gt;0 (i.e. in the future if x is time) or at x&lt;0 (i.e. in the past if x is time). Otherwise we conclude that we cannot determine even the sign of the crossing value, so we return zero. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceintrp.html">intrp</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
