<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: intrp::InterpolationTarget&lt; Metavariables, InterpolationTargetTag &gt; Struct Template Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structintrp_1_1InterpolationTarget.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="structintrp_1_1InterpolationTarget-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">intrp::InterpolationTarget&lt; Metavariables, InterpolationTargetTag &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>ParallelComponent representing a set of points to be interpolated to and a function to call upon interpolation to those points.  
 <a href="structintrp_1_1InterpolationTarget.html#details">More...</a></p>

<p><code>#include &lt;InterpolationTarget.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a08638c5023b928b6b43d25f4b8041bca"><td class="memItemLeft" align="right" valign="top"><a id="a08638c5023b928b6b43d25f4b8041bca" name="a08638c5023b928b6b43d25f4b8041bca"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>interpolation_target_tag</b> = InterpolationTargetTag</td></tr>
<tr class="separator:a08638c5023b928b6b43d25f4b8041bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f804467a5b6277ca3113ce45d3e9a22"><td class="memItemLeft" align="right" valign="top"><a id="a1f804467a5b6277ca3113ce45d3e9a22" name="a1f804467a5b6277ca3113ce45d3e9a22"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>chare_type</b> = <a class="el" href="structParallel_1_1Algorithms_1_1Singleton.html">::Parallel::Algorithms::Singleton</a></td></tr>
<tr class="separator:a1f804467a5b6277ca3113ce45d3e9a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1355d8f589c9deb60d4515d62ffe362f"><td class="memItemLeft" align="right" valign="top"><a id="a1355d8f589c9deb60d4515d62ffe362f" name="a1355d8f589c9deb60d4515d62ffe362f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_global_cache_tags</b> = <a class="el" href="group__ParallelGroup.html#gab2c3e5b7084f5cb31c8c5cc7595349a6">Parallel::get_const_global_cache_tags_from_actions</a>&lt; tmpl::list&lt; typename InterpolationTargetTag::compute_target_points, typename InterpolationTargetTag::post_interpolation_callback &gt; &gt;</td></tr>
<tr class="separator:a1355d8f589c9deb60d4515d62ffe362f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50323b0e589e07118b1cfbc39cc3107e"><td class="memItemLeft" align="right" valign="top"><a id="a50323b0e589e07118b1cfbc39cc3107e" name="a50323b0e589e07118b1cfbc39cc3107e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>metavariables</b> = Metavariables</td></tr>
<tr class="separator:a50323b0e589e07118b1cfbc39cc3107e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ea8ca1ba72c1da48cd974257c87ef4"><td class="memItemLeft" align="right" valign="top"><a id="ab3ea8ca1ba72c1da48cd974257c87ef4" name="ab3ea8ca1ba72c1da48cd974257c87ef4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>phase_dependent_action_list</b> = tmpl::list&lt; <a class="el" href="structParallel_1_1PhaseActions.html">Parallel::PhaseActions</a>&lt; <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a61bcd96a2c1f8026527cbf2019d6e9a4">Parallel::Phase::Initialization</a>, tmpl::list&lt; <a class="el" href="structintrp_1_1Actions_1_1InitializeInterpolationTarget.html">intrp::Actions::InitializeInterpolationTarget</a>&lt; Metavariables, InterpolationTargetTag &gt;, <a class="el" href="structParallel_1_1Actions_1_1TerminatePhase.html">Parallel::Actions::TerminatePhase</a> &gt; &gt;, <a class="el" href="structParallel_1_1PhaseActions.html">Parallel::PhaseActions</a>&lt; <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a0ba7583639a274c434bbe6ef797115a4">Parallel::Phase::Register</a>, tmpl::list&lt; tmpl::conditional_t&lt; <a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">InterpolationTargetTag::compute_target_points::is_sequential::value</a>, tmpl::list&lt;&gt;, tmpl::list&lt; <a class="el" href="structintrp_1_1Actions_1_1InterpolationTargetSendTimeIndepPointsToElements.html">Actions::InterpolationTargetSendTimeIndepPointsToElements</a>&lt; InterpolationTargetTag &gt; &gt; &gt;, <a class="el" href="structParallel_1_1Actions_1_1TerminatePhase.html">Parallel::Actions::TerminatePhase</a> &gt; &gt; &gt;</td></tr>
<tr class="separator:ab3ea8ca1ba72c1da48cd974257c87ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6fe7d50565bcc0f8a268f8f237655a"><td class="memItemLeft" align="right" valign="top"><a id="aec6fe7d50565bcc0f8a268f8f237655a" name="aec6fe7d50565bcc0f8a268f8f237655a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>simple_tags_from_options</b> = <a class="el" href="group__ParallelGroup.html#ga7c2c630360df51b5cc4cf0f7fda6e87d">Parallel::get_simple_tags_from_options</a>&lt; <a class="el" href="group__ParallelGroup.html#gac5fb42f8eaf4da2707e32ed37ecf4e66">Parallel::get_initialization_actions_list</a>&lt; phase_dependent_action_list &gt; &gt;</td></tr>
<tr class="separator:aec6fe7d50565bcc0f8a268f8f237655a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1fe64422d486cd9c9cc48d15d440411a"><td class="memItemLeft" align="right" valign="top"><a id="a1fe64422d486cd9c9cc48d15d440411a" name="a1fe64422d486cd9c9cc48d15d440411a"></a>
static <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><b>name</b> ()</td></tr>
<tr class="separator:a1fe64422d486cd9c9cc48d15d440411a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936e05308ae15c8fc1a24beaf27052c7"><td class="memItemLeft" align="right" valign="top"><a id="a936e05308ae15c8fc1a24beaf27052c7" name="a936e05308ae15c8fc1a24beaf27052c7"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>execute_next_phase</b> (<a class="el" href="group__ParallelGroup.html#ga027a2e60b10898507f92ba7290f0ba61">Parallel::Phase</a> next_phase, Parallel::CProxy_GlobalCache&lt; metavariables &gt; &amp;global_cache)</td></tr>
<tr class="separator:a936e05308ae15c8fc1a24beaf27052c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Metavariables, typename InterpolationTargetTag&gt;<br />
struct intrp::InterpolationTarget&lt; Metavariables, InterpolationTargetTag &gt;</div><p >ParallelComponent representing a set of points to be interpolated to and a function to call upon interpolation to those points. </p>
<p >Each <a class="el" href="structintrp_1_1InterpolationTarget.html" title="ParallelComponent representing a set of points to be interpolated to and a function to call upon inte...">InterpolationTarget</a> will communicate with the <code><a class="el" href="structintrp_1_1Interpolator.html" title="ParallelComponent responsible for collecting data from Elements and interpolating it onto Interpolati...">Interpolator</a></code>.</p>
<p ><code>InterpolationTargetTag</code> must conform to the <a class="el" href="structintrp_1_1protocols_1_1InterpolationTargetTag.html" title="A protocol for InterpolationTargetTags that are used in the intrp::InterpolationTarget parallel compo...">intrp::protocols::InterpolationTargetTag</a> protocol.</p>
<p >The metavariables must contain the following type aliases:</p><ul>
<li>interpolator_source_vars: A <code>tmpl::list</code> of tags that define a <code>Variables</code> sent from all <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code>s to the local <code><a class="el" href="structintrp_1_1Interpolator.html" title="ParallelComponent responsible for collecting data from Elements and interpolating it onto Interpolati...">Interpolator</a></code>.</li>
<li>interpolation_target_tags: A <code>tmpl::list</code> of all <code>InterpolationTargetTag</code>s.</li>
<li>temporal_id: The type held by <a class="el" href="structintrp_1_1Tags_1_1TemporalIds.html" title="temporal_ids on which to interpolate.">intrp::Tags::TemporalIds</a>.</li>
</ul>
<p ><code>Metavariables</code> must contain the following static constexpr members:</p><ul>
<li>size_t volume_dim: The dimension of the <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain.">Domain</a>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md367"></a>
Interpolation with time-dependent CoordinateMaps</h3>
<p >Each set of points to be interpolated onto is labeled by a <code>temporal_id</code>. If any step of the interpolation procedure ever uses a time-dependent <code>CoordinateMap</code>, then it needs to grab <code>FunctionOfTime</code>s from the <code>GlobalCache</code>. Before doing so, it must verify that those <code>FunctionOfTime</code>s are up-to-date for the given <code>temporal_id</code>.</p>
<p >Note that once the <code>FunctionOfTime</code> has been verified to be up-to-date for a particular <code>temporal_id</code> at one step in the interpolation procedure, all subsequent steps of the interpolation procedure for that same <code>temporal_id</code> need not worry about re-verifying the <code>FunctionOfTime</code>. Therefore, we need only focus on the first step in the interpolation procedure that needs <code>FunctionOfTime</code>s: computing the points on which to interpolate.</p>
<p >Each <code><a class="el" href="structintrp_1_1InterpolationTarget.html" title="ParallelComponent representing a set of points to be interpolated to and a function to call upon inte...">InterpolationTarget</a></code> has a function <code>InterpolationTargetTag::compute_target_points</code> that returns the points to be interpolated onto, expressed in the frame <code>InterpolationTargetTag::compute_target_points::frame</code>. Then the function <code>block_logical_coordinates</code> (and eventually <code>element_logical_coordinates</code>) is called to convert those points to the element logical frame to do the interpolation. If <code>InterpolationTargetTag::compute_target_points::frame</code> is different from the grid frame, and if the <code>CoordinateMap</code> is time-dependent, then <code>block_logical_coordinates</code> grabs <code>FunctionOfTime</code>s from the <code>GlobalCache</code>. So therefore any Action calling <code>block_logical_coordinates</code> must wait until the <code>FunctionOfTime</code>s in the <code>GlobalCache</code> are up-to-date for the <code>temporal_id</code> being passed into <code>block_logical_coordinates</code>.</p>
<p >Here we describe the logic used in all the <a class="el" href="namespaceintrp_1_1Actions.html" title="Holds Actions for Interpolator and InterpolationTarget.">Actions</a> that call <code>block_logical_coordinates</code>.</p>
<h4><a class="anchor" id="autotoc_md368"></a>
Interpolation using the Interpolator ParallelComponent</h4>
<p >Recall that <code><a class="el" href="structintrp_1_1InterpolationTarget.html" title="ParallelComponent representing a set of points to be interpolated to and a function to call upon inte...">InterpolationTarget</a></code> can be used with the <code><a class="el" href="structintrp_1_1Interpolator.html" title="ParallelComponent responsible for collecting data from Elements and interpolating it onto Interpolati...">Interpolator</a></code> ParallelComponent (as for the horizon finder), or by having the <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code>s interpolate directly (as for most Observers). Here we discuss the case when the <code><a class="el" href="structintrp_1_1Interpolator.html" title="ParallelComponent responsible for collecting data from Elements and interpolating it onto Interpolati...">Interpolator</a></code> is used; the other case is discussed below.</p>
<p >Ensuring the <code>FunctionOfTime</code>s are up-to-date is done via two <a class="el" href="namespaceintrp_1_1Tags.html" title="Tags for items held in the DataBox of InterpolationTarget or Interpolator.">Tags</a> in the DataBox and a helper Action. When interpolation is requested for a new <code>temporal_id</code> (e.g. by <code><a class="el" href="classintrp_1_1Events_1_1Interpolate.html" title="Does an interpolation onto InterpolationTargetTag by calling Actions on the Interpolator and Interpol...">intrp::Events::Interpolate</a></code>), the <code>temporal_id</code> is added to <code><a class="el" href="structintrp_1_1Tags_1_1PendingTemporalIds.html" title="temporal_ids that have been flagged to interpolate on, but that have not yet been added to Tags::Temp...">Tags::PendingTemporalIds</a></code>, which holds a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>&lt;temporal_id&gt;</code>, and represents <code>temporal_ids</code> that we want to interpolate onto, but for which <code>FunctionOfTime</code>s are not necessarily up-to-date. We also keep another list of <code>temporal_ids</code>: <code><a class="el" href="structintrp_1_1Tags_1_1TemporalIds.html" title="temporal_ids on which to interpolate.">Tags::TemporalIds</a></code>, for which <code>FunctionOfTime</code>s are guaranteed to be up-to-date.</p>
<p >The action <code><a class="el" href="structintrp_1_1Actions_1_1VerifyTemporalIdsAndSendPoints.html" title="Sends points to an Interpolator for verified temporal_ids.">Actions::VerifyTemporalIdsAndSendPoints</a></code> moves <code>temporal_id</code>s from <code>PendingTemporalIds</code> to <code>TemporalIds</code> as appropriate, and if any <code>temporal_id</code>s have been so moved, it generates the <code>block_logical_coordinates</code> and sends them to the <code><a class="el" href="structintrp_1_1Interpolator.html" title="ParallelComponent responsible for collecting data from Elements and interpolating it onto Interpolati...">Interpolator</a></code> <code>ParallelComponent</code>. The logic is illustrated in pseudocode below. Recall that some InterpolationTargets are sequential, (i.e. you cannot interpolate onto one temporal_id until interpolation on previous ones are done, like the apparent horizon finder), and some are non-sequential (i.e. you can interpolate in any order).</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (map is time-independent or frame is grid frame) {</div>
<div class="line">  move all PendingTemporalIds to TemporalIds</div>
<div class="line">  <span class="keywordflow">if</span> (sequential) {</div>
<div class="line">    <a class="code hl_function" href="namespacepypp.html#a0b8520e3e6d5c1abb3110b134c10683f">call</a> block_logical_coords and interpolate <span class="keywordflow">for</span> first temporal_id.</div>
<div class="line">    <span class="comment">// when interpolation is complete,</span></div>
<div class="line">    <span class="comment">// Actions::InterpolationTargetReceiveVars will begin interpolation</span></div>
<div class="line">    <span class="comment">// on the next temporal_id.</span></div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <a class="code hl_function" href="namespacepypp.html#a0b8520e3e6d5c1abb3110b134c10683f">call</a> block_logical_coords and interpolate <span class="keywordflow">for</span> all temporal_ids.</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (FunctionOfTimes are up-to-date <span class="keywordflow">for</span> any PendingTemporalIds) {</div>
<div class="line">  move up-to-date PendingTemporalIds to TemporalIds</div>
<div class="line">  <span class="keywordflow">if</span> (sequential) {</div>
<div class="line">    <a class="code hl_function" href="namespacepypp.html#a0b8520e3e6d5c1abb3110b134c10683f">call</a> block_logical_coords and interpolate <span class="keywordflow">for</span> first temporal_id.</div>
<div class="line">    <span class="comment">// when interpolation is complete,</span></div>
<div class="line">    <span class="comment">// Actions::InterpolationTargetReceiveVars will begin interpolation</span></div>
<div class="line">    <span class="comment">// on the next temporal_id.</span></div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <a class="code hl_function" href="namespacepypp.html#a0b8520e3e6d5c1abb3110b134c10683f">call</a> block_logical_coords and interpolate <span class="keywordflow">for</span> all temporal_ids.</div>
<div class="line">    <span class="keywordflow">if</span> (PendingTemporalIds is non-empty) {</div>
<div class="line">      <a class="code hl_function" href="namespacepypp.html#a0b8520e3e6d5c1abb3110b134c10683f">call</a> myself (i.e. execute VerifyTemporalIdsAndSendPoints)</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  set VerifyTemporalIdsAndSendPoints as a callback <span class="keywordflow">for</span> the</div>
<div class="line">  `<a class="code hl_struct" href="structdomain_1_1Tags_1_1FunctionsOfTime.html">domain::Tags::FunctionsOfTime</a>` in MutableGlobalCache, so that</div>
<div class="line">  once `FunctionsOfTime` are updated, VerifyTemporalIdsAndSendPoints</div>
<div class="line">  is called.</div>
<div class="line">}</div>
<div class="ttc" id="anamespacepypp_html_a0b8520e3e6d5c1abb3110b134c10683f"><div class="ttname"><a href="namespacepypp.html#a0b8520e3e6d5c1abb3110b134c10683f">pypp::call</a></div><div class="ttdeci">ReturnType call(const std::string &amp;module_name, const std::string &amp;function_name, const Args &amp;... t)</div><div class="ttdoc">Calls a Python function from a module/file with given parameters.</div><div class="ttdef"><b>Definition:</b> Pypp.hpp:495</div></div>
<div class="ttc" id="astructdomain_1_1Tags_1_1FunctionsOfTime_html"><div class="ttname"><a href="structdomain_1_1Tags_1_1FunctionsOfTime.html">domain::Tags::FunctionsOfTime</a></div><div class="ttdoc">Tag to retrieve the FunctionsOfTime from the GlobalCache.</div><div class="ttdef"><b>Definition:</b> Tags.hpp:10</div></div>
</div><!-- fragment --><p >Note that VerifyTemporalIdsAndSendPoints always exits in one of three ways:</p><ul>
<li>It has set itself up as a callback, so it will be called again.</li>
<li>It started a sequential interpolation that will automatically start another sequential interpolation when finished.</li>
<li>It started non-sequential interpolations on all <code>TemporalIds</code>, and there are no <code>PendingTemporalIds</code> left.</li>
</ul>
<p >We now describe the logic of the <a class="el" href="namespaceintrp_1_1Actions.html" title="Holds Actions for Interpolator and InterpolationTarget.">Actions</a> that use VerifyTemporalIdsAndSendPoints.</p>
<p ><a class="anchor" id="autotoc_md369"></a> </p><h5><a class="el" href="structintrp_1_1Actions_1_1AddTemporalIdsToInterpolationTarget.html" title="Adds temporal_ids on which this InterpolationTarget should be triggered.">Actions::AddTemporalIdsToInterpolationTarget</a></h5>
<p ><code><a class="el" href="structintrp_1_1Actions_1_1AddTemporalIdsToInterpolationTarget.html" title="Adds temporal_ids on which this InterpolationTarget should be triggered.">Actions::AddTemporalIdsToInterpolationTarget</a></code> is called by <code><a class="el" href="classintrp_1_1Events_1_1Interpolate.html" title="Does an interpolation onto InterpolationTargetTag by calling Actions on the Interpolator and Interpol...">intrp::Events::Interpolate</a></code> to trigger interpolation for new <code>temporal_id</code>s. Its logic is as follows, in pseudocode:</p>
<div class="fragment"><div class="line"> Add passed-in temporal_ids to PendingTemporalIds</div>
<div class="line"> <span class="keywordflow">if</span> (sequential) {</div>
<div class="line">   <span class="keywordflow">if</span> (TemporalIds is empty and</div>
<div class="line">       PendingTemporalIds was empty before it was appended above) {</div>
<div class="line">     <a class="code hl_function" href="namespacepypp.html#a0b8520e3e6d5c1abb3110b134c10683f">call</a> VerifyTemporalIdsAndSendPoints</div>
<div class="line">   } <span class="keywordflow">else</span> {</div>
<div class="line">     Do nothing, because there is already a sequential interpolation in</div>
<div class="line">     progress, or there is a callback already waiting.</div>
<div class="line">   }</div>
<div class="line"> } <span class="keywordflow">else</span> { <span class="comment">// not sequential</span></div>
<div class="line">   <span class="keywordflow">if</span> (TemporalIds is non-empty) {</div>
<div class="line">     <a class="code hl_function" href="namespacepypp.html#a0b8520e3e6d5c1abb3110b134c10683f">call</a> <a class="code hl_function" href="group__ComputationalDomainGroup.html#gad820f28f973850990200bcb2d858fe1d">block_logical_coordinates</a> and <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/iterator/begin.html">begin</a> interpolating <span class="keywordflow">for</span></div>
<div class="line">     all TemporalIds.</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordflow">if</span> (PendingTemporalIds is non-empty) {</div>
<div class="line">     <a class="code hl_function" href="namespacepypp.html#a0b8520e3e6d5c1abb3110b134c10683f">call</a> VerifyTemporalIdsAndSendPoints</div>
<div class="line">   }</div>
<div class="line">}</div>
<div class="ttc" id="abegin_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/iterator/begin.html">std::begin</a></div><div class="ttdeci">T begin(T... args)</div></div>
<div class="ttc" id="agroup__ComputationalDomainGroup_html_gad820f28f973850990200bcb2d858fe1d"><div class="ttname"><a href="group__ComputationalDomainGroup.html#gad820f28f973850990200bcb2d858fe1d">block_logical_coordinates</a></div><div class="ttdeci">auto block_logical_coordinates(const Domain&lt; Dim &gt; &amp;domain, const tnsr::I&lt; DataVector, Dim, Frame &gt; &amp;x, double time=std::numeric_limits&lt; double &gt;::signaling_NaN(), const std::unordered_map&lt; std::string, std::unique_ptr&lt; domain::FunctionsOfTime::FunctionOfTime &gt; &gt; &amp;functions_of_time=std::unordered_map&lt; std::string, std::unique_ptr&lt; domain::FunctionsOfTime::FunctionOfTime &gt; &gt;{}) -&gt; std::vector&lt; std::optional&lt; IdPair&lt; domain::BlockId, tnsr::I&lt; double, Dim, ::Frame::BlockLogical &gt; &gt; &gt; &gt;</div><div class="ttdoc">Computes the block logical coordinates and the containing BlockId of a set of points,...</div></div>
</div><!-- fragment --><p ><a class="anchor" id="autotoc_md370"></a> </p><h5><a class="el" href="structintrp_1_1Actions_1_1InterpolationTargetReceiveVars.html" title="Receives interpolated variables from an Interpolator on a subset of the target points.">Actions::InterpolationTargetReceiveVars</a></h5>
<p ><code><a class="el" href="structintrp_1_1Actions_1_1InterpolationTargetReceiveVars.html" title="Receives interpolated variables from an Interpolator on a subset of the target points.">Actions::InterpolationTargetReceiveVars</a></code> is called by the <code><a class="el" href="structintrp_1_1Interpolator.html" title="ParallelComponent responsible for collecting data from Elements and interpolating it onto Interpolati...">Interpolator</a></code> when it is finished interpolating the current <code>temporal_id</code>. For the sequential case, it needs to start interpolating for the next <code>temporal_id</code>. The logic is, in pseudocode:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (sequential) {</div>
<div class="line">  <span class="keywordflow">if</span> (TemporalIds is not empty) {</div>
<div class="line">    <a class="code hl_function" href="namespacepypp.html#a0b8520e3e6d5c1abb3110b134c10683f">call</a> <a class="code hl_function" href="group__ComputationalDomainGroup.html#gad820f28f973850990200bcb2d858fe1d">block_logical_coordinates</a> and interpolate <span class="keywordflow">for</span> <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/iterator/next.html">next</a> temporal_id</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (PendingTemporalIds is not empty) {</div>
<div class="line">    <a class="code hl_function" href="namespacepypp.html#a0b8520e3e6d5c1abb3110b134c10683f">call</a> VerifyTemporalIdsAndSendPoints</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="anext_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/iterator/next.html">std::next</a></div><div class="ttdeci">T next(T... args)</div></div>
</div><!-- fragment --><p ><a class="anchor" id="autotoc_md371"></a> </p><h5><a class="el" href="structintrp_1_1callbacks_1_1FindApparentHorizon.html" title="post interpolation callback (see intrp::protocols::PostInterpolationCallback) that does a FastFlow it...">intrp::callbacks::FindApparentHorizon</a></h5>
<p ><code><a class="el" href="structintrp_1_1callbacks_1_1FindApparentHorizon.html" title="post interpolation callback (see intrp::protocols::PostInterpolationCallback) that does a FastFlow it...">intrp::callbacks::FindApparentHorizon</a> calls</code> <code>block_logical_coordinates</code> when it needs to start a new iteration of the horizon finder at the same <code>temporal_id</code>, so one might think you need to worry about up-to-date <code>FunctionOfTime</code>s. But since <code><a class="el" href="structintrp_1_1callbacks_1_1FindApparentHorizon.html" title="post interpolation callback (see intrp::protocols::PostInterpolationCallback) that does a FastFlow it...">intrp::callbacks::FindApparentHorizon</a></code> always works on the same <code>temporal_id</code> for which the <code>FunctionOfTime</code>s have already been verified as up-to-date from the last iteration, no special consideration of <code>FunctionOfTime</code>s need be done here.</p>
<h4><a class="anchor" id="autotoc_md372"></a>
Interpolation without using the Interpolator ParallelComponent</h4>
<p >This case is easier than the case with the <code><a class="el" href="structintrp_1_1Interpolator.html" title="ParallelComponent responsible for collecting data from Elements and interpolating it onto Interpolati...">Interpolator</a></code>, because the target points are always time-independent in the frame <code>compute_target_points::frame</code>.</p>
<p ><a class="anchor" id="autotoc_md373"></a> </p><h5>Actions::EnsureFunctionOfTimeUpToDate</h5>
<p ><code>Actions::EnsureFunctionOfTimeUpToDate</code> verifies that the <code>FunctionOfTime</code>s are up-to-date at the <code><a class="el" href="structDgElementArray.html" title="The parallel component responsible for managing the DG elements that compose the computational domain...">DgElementArray</a></code>s current time.</p>
<h6>Current logic:</h6>
<blockquote class="doxtable">
<p >&zwj;<code>Actions::EnsureFunctionOfTimeUpToDate</code> is placed in <code><a class="el" href="structDgElementArray.html" title="The parallel component responsible for managing the DG elements that compose the computational domain...">DgElementArray</a></code>s PDAL before any use of interpolation. </p>
</blockquote>
<p><a class="anchor" id="autotoc_md374"></a> </p><h5><a class="el" href="structintrp_1_1Actions_1_1InterpolationTargetSendTimeIndepPointsToElements.html" title="Sends interpolation points to all the Elements.">Actions::InterpolationTargetSendTimeIndepPointsToElements</a></h5>
<p ><code><a class="el" href="structintrp_1_1Actions_1_1InterpolationTargetSendTimeIndepPointsToElements.html" title="Sends interpolation points to all the Elements.">Actions::InterpolationTargetSendTimeIndepPointsToElements</a></code> is invoked on <code><a class="el" href="structintrp_1_1InterpolationTarget.html" title="ParallelComponent representing a set of points to be interpolated to and a function to call upon inte...">InterpolationTarget</a></code> during the <a class="el" href="namespaceRegistration.html" title="Helpers for derived class registration.">Registration</a> PDAL, to send time-independent point information to <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code>s.</p>
<h6>Current logic:</h6>
<blockquote class="doxtable">
<p >&zwj;Send the result of <code>compute_target_points</code> to all <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code>s. </p>
</blockquote>
<p>Note that this may need to be revisited because every <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code> has a copy of every target point, which may use a lot of memory. An alternative is for each <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> to invoke an Action on each <code><a class="el" href="structintrp_1_1InterpolationTarget.html" title="ParallelComponent representing a set of points to be interpolated to and a function to call upon inte...">InterpolationTarget</a></code> (presumably from an <code><a class="el" href="classEvent.html" title="Base class for something that can happen during a simulation (such as an observation).">Event</a></code>) at each time, and then the <a class="el" href="structintrp_1_1InterpolationTarget.html" title="ParallelComponent representing a set of points to be interpolated to and a function to call upon inte...">InterpolationTarget</a> invokes another Action to send points to only those <code>Elements</code> that contain the points; this alternative uses less memory but much more communication. Another alternative would be to place the points in the MutableGlobalCache (so that there is one copy per core, rather than one copy per <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>), or even in the GlobalCache (one copy per node) since the points need be computed only once. </p>
</div><hr/>The documentation for this struct was generated from the following file:<ul>
<li>src/ParallelAlgorithms/Interpolation/InterpolationTarget.hpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceintrp.html">intrp</a></li><li class="navelem"><a class="el" href="structintrp_1_1InterpolationTarget.html">InterpolationTarget</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
