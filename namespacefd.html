<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: fd Namespace Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacefd.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">fd Namespace Reference<div class="ingroups"><a class="el" href="group__FiniteDifferenceGroup.html">Finite Difference</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Functions and classes for finite difference methods.  
<a href="namespacefd.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacefd_1_1reconstruction"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefd_1_1reconstruction.html">reconstruction</a></td></tr>
<tr class="memdesc:namespacefd_1_1reconstruction"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable and flux vector splitting reconstruction schemes for finite difference methods. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a64cf9d63e1d7c168d4077daba36ceccf"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefd.html#a64cf9d63e1d7c168d4077daba36ceccf">DerivativeOrder</a> : int { <br />
&#160;&#160;<a class="el" href="namespacefd.html#a64cf9d63e1d7c168d4077daba36ceccfa5f3139509417c9418f9c188821fcc25b">OneHigherThanRecons</a> = -1
, <a class="el" href="namespacefd.html#a64cf9d63e1d7c168d4077daba36ceccfaa88b89ab3a5e70982d40a7095ab5bf41">OneHigherThanReconsButFiveToFour</a> = -2
, <a class="el" href="namespacefd.html#a64cf9d63e1d7c168d4077daba36ceccfaaada29daee1d64ed0fe907043855cb7e">Two</a> = 2
, <a class="el" href="namespacefd.html#a64cf9d63e1d7c168d4077daba36ceccfa981b8fcee42e1e726a67a2b9a98ea6e9">Four</a> = 4
, <br />
&#160;&#160;<a class="el" href="namespacefd.html#a64cf9d63e1d7c168d4077daba36ceccfae6fbc0b9673f8c86726688d7607fc8f5">Six</a> = 6
, <a class="el" href="namespacefd.html#a64cf9d63e1d7c168d4077daba36ceccfabaca0ca6729684fd54206793ae4b5bd5">Eight</a> = 8
, <a class="el" href="namespacefd.html#a64cf9d63e1d7c168d4077daba36ceccfaa185c3c138dca5ef46afc33288a67d1f">Ten</a> = 10
<br />
 }</td></tr>
<tr class="memdesc:a64cf9d63e1d7c168d4077daba36ceccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls which FD derivative order is used.  <a href="namespacefd.html#a64cf9d63e1d7c168d4077daba36ceccf">More...</a><br /></td></tr>
<tr class="separator:a64cf9d63e1d7c168d4077daba36ceccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1655498a3d5532057fb0d8f1873434de"><td class="memItemLeft" align="right" valign="top"><a id="a1655498a3d5532057fb0d8f1873434de" name="a1655498a3d5532057fb0d8f1873434de"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, <a class="el" href="namespacefd.html#a64cf9d63e1d7c168d4077daba36ceccf">DerivativeOrder</a> der_order)</td></tr>
<tr class="separator:a1655498a3d5532057fb0d8f1873434de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa199d9b7ee01c8e9e93a0a7e72901fa5"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:aa199d9b7ee01c8e9e93a0a7e72901fa5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefd.html#aa199d9b7ee01c8e9e93a0a7e72901fa5">low_pass_filter</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt; * &gt; filtered_data, const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;volume_vars, const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &gt; &amp;ghost_cell_vars, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;volume_mesh, size_t number_of_variables, size_t fd_order, double epsilon)</td></tr>
<tr class="memdesc:aa199d9b7ee01c8e9e93a0a7e72901fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a low-pass filter to the data.  <a href="namespacefd.html#aa199d9b7ee01c8e9e93a0a7e72901fa5">More...</a><br /></td></tr>
<tr class="separator:aa199d9b7ee01c8e9e93a0a7e72901fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd8fc8b73d4f1ab74d2d285312353ea"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:a8cd8fc8b73d4f1ab74d2d285312353ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefd.html#a8cd8fc8b73d4f1ab74d2d285312353ea">kreiss_oliger_filter</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt; * &gt; filtered_data, const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;volume_vars, const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &gt; &amp;ghost_cell_vars, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;volume_mesh, size_t number_of_variables, size_t fd_order, double epsilon)</td></tr>
<tr class="memdesc:a8cd8fc8b73d4f1ab74d2d285312353ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply Kreiss-Oliger dissipation <a class="el" href="citelist.html#CITEREF_Kreiss1973">[101]</a> of order <code>fd_order</code> to the variables.  <a href="namespacefd.html#a8cd8fc8b73d4f1ab74d2d285312353ea">More...</a><br /></td></tr>
<tr class="separator:a8cd8fc8b73d4f1ab74d2d285312353ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac287ca45e0d4ee982718c2be7696ec15"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename FluxesTags &gt; </td></tr>
<tr class="memitem:ac287ca45e0d4ee982718c2be7696ec15"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefd.html#ac287ca45e0d4ee982718c2be7696ec15">set_cartesian_neighbor_cell_centered_fluxes</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, Variables&lt; FluxesTags &gt; &gt; * &gt; flux_neighbor_data, const <a class="el" href="classFixedHashMap.html">FixedHashMap</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#gafa8cb44daebc8f9e080718961530be89">maximum_number_of_neighbors</a>(Dim), <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt;, <a class="el" href="classevolution_1_1dg_1_1subcell_1_1GhostData.html">evolution::dg::subcell::GhostData</a>, boost::hash&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt; &gt; &gt; &amp;all_ghost_data, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;subcell_mesh, const size_t ghost_zone_size, const size_t number_of_rdmp_values_in_ghost_data)</td></tr>
<tr class="memdesc:ac287ca45e0d4ee982718c2be7696ec15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the <code>flux_neighbor_data</code> with pointers into the <code>all_ghost_data</code>.  <a href="namespacefd.html#ac287ca45e0d4ee982718c2be7696ec15">More...</a><br /></td></tr>
<tr class="separator:ac287ca45e0d4ee982718c2be7696ec15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18df6cce3d6392e8d2d55a434c1f7012"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename... EvolvedVarsTags, typename FluxesTags  = tmpl::list&lt;::Tags::Flux&lt;              EvolvedVarsTags, tmpl::size_t&lt;Dim&gt;, Frame::Inertial&gt;...&gt;&gt; </td></tr>
<tr class="memitem:a18df6cce3d6392e8d2d55a434c1f7012"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefd.html#a18df6cce3d6392e8d2d55a434c1f7012">cartesian_high_order_flux_corrections</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; Variables&lt; tmpl::list&lt; EvolvedVarsTags... &gt; &gt;, Dim &gt; &gt; * &gt; high_order_corrections, const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; Variables&lt; FluxesTags &gt; &gt; &amp;cell_centered_fluxes, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; Variables&lt; tmpl::list&lt; EvolvedVarsTags... &gt; &gt;, Dim &gt; &amp;second_order_boundary_corrections, const <a class="el" href="namespacefd.html#a64cf9d63e1d7c168d4077daba36ceccf">fd::DerivativeOrder</a> &amp;fd_derivative_order, const <a class="el" href="classFixedHashMap.html">FixedHashMap</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#gafa8cb44daebc8f9e080718961530be89">maximum_number_of_neighbors</a>(Dim), <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt;, <a class="el" href="classevolution_1_1dg_1_1subcell_1_1GhostData.html">evolution::dg::subcell::GhostData</a>, boost::hash&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt; &gt; &gt; &amp;all_ghost_data, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;subcell_mesh, const size_t ghost_zone_size, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint8_t</a> &gt;, Dim &gt; &amp;reconstruction_order={}, const size_t number_of_rdmp_values_in_ghost_data=0)</td></tr>
<tr class="memdesc:a18df6cce3d6392e8d2d55a434c1f7012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the high-order Cartesian flux corrections if necessary.  <a href="namespacefd.html#a18df6cce3d6392e8d2d55a434c1f7012">More...</a><br /></td></tr>
<tr class="separator:a18df6cce3d6392e8d2d55a434c1f7012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2059d92bb58a35535f40b8046f55f0"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename ReconstructionTags &gt; </td></tr>
<tr class="memitem:aaa2059d92bb58a35535f40b8046f55f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefd.html#aaa2059d92bb58a35535f40b8046f55f0">neighbor_data_as_variables</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classFixedHashMap.html">FixedHashMap</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#gafa8cb44daebc8f9e080718961530be89">maximum_number_of_neighbors</a>(Dim), <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt;, Variables&lt; ReconstructionTags &gt;, boost::hash&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt; &gt; &gt; * &gt; vars_neighbor_data, const <a class="el" href="classFixedHashMap.html">FixedHashMap</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#gafa8cb44daebc8f9e080718961530be89">maximum_number_of_neighbors</a>(Dim), <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt;, <a class="el" href="classevolution_1_1dg_1_1subcell_1_1GhostData.html">evolution::dg::subcell::GhostData</a>, boost::hash&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt; &gt; &gt; &amp;all_ghost_data, const size_t ghost_zone_size, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;subcell_mesh)</td></tr>
<tr class="memdesc:aaa2059d92bb58a35535f40b8046f55f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the type-erased neighbor data for reconstruction stored in a <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code>, have <code>Variables</code> point into them.  <a href="namespacefd.html#aaa2059d92bb58a35535f40b8046f55f0">More...</a><br /></td></tr>
<tr class="separator:aaa2059d92bb58a35535f40b8046f55f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f8b3572d823b4037ba780220781a668"><td class="memTemplParams" colspan="2">template&lt;size_t StencilSize&gt; </td></tr>
<tr class="memitem:ga1f8b3572d823b4037ba780220781a668"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, StencilSize &gt;, StencilSize &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FiniteDifferenceGroup.html#ga1f8b3572d823b4037ba780220781a668">non_uniform_1d_weights</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>&lt; double &gt; &amp;times)</td></tr>
<tr class="memdesc:ga1f8b3572d823b4037ba780220781a668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the weights for a 1D non-uniform finite difference stencil.  <a href="group__FiniteDifferenceGroup.html#ga1f8b3572d823b4037ba780220781a668">More...</a><br /></td></tr>
<tr class="separator:ga1f8b3572d823b4037ba780220781a668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c55181883d1bdde817937f7464f0e5a"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:a3c55181883d1bdde817937f7464f0e5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefd.html#a3c55181883d1bdde817937f7464f0e5a">logical_partial_derivatives</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt; logical_derivatives, const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;volume_vars, const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &gt; &amp;ghost_cell_vars, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;volume_mesh, size_t number_of_variables, size_t fd_order)</td></tr>
<tr class="memdesc:a3c55181883d1bdde817937f7464f0e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the logical partial derivatives using cell-centered finite difference derivatives.  <a href="namespacefd.html#a3c55181883d1bdde817937f7464f0e5a">More...</a><br /></td></tr>
<tr class="separator:a3c55181883d1bdde817937f7464f0e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54cf779a8fae10c139c1eec90fe18f7c"><td class="memTemplParams" colspan="2">template&lt;typename DerivativeTags , size_t Dim, typename DerivativeFrame &gt; </td></tr>
<tr class="memitem:a54cf779a8fae10c139c1eec90fe18f7c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefd.html#a54cf779a8fae10c139c1eec90fe18f7c">partial_derivatives</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; <a class="el" href="group__DataBoxTagsGroup.html#ga3dda5a16c7f6baccd115de2c8f12394e">db::wrap_tags_in</a>&lt; <a class="el" href="structTags_1_1deriv.html">Tags::deriv</a>, DerivativeTags, tmpl::size_t&lt; Dim &gt;, DerivativeFrame &gt; &gt; * &gt; partial_derivatives, const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;volume_vars, const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &gt; &amp;ghost_cell_vars, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;volume_mesh, size_t number_of_variables, size_t fd_order, const InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, DerivativeFrame &gt; &amp;inverse_jacobian)</td></tr>
<tr class="memdesc:a54cf779a8fae10c139c1eec90fe18f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the partial derivative on the <code>DerivativeFrame</code> using the <code>inverse_jacobian</code>.  <a href="namespacefd.html#a54cf779a8fae10c139c1eec90fe18f7c">More...</a><br /></td></tr>
<tr class="separator:a54cf779a8fae10c139c1eec90fe18f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a56aea6e85c443484e756d67fa6189e62"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacefd.html#a64cf9d63e1d7c168d4077daba36ceccf">DerivativeOrder</a> DerivOrder, size_t Dim, typename... EvolvedVarsTags&gt; </td></tr>
<tr class="memitem:a56aea6e85c443484e756d67fa6189e62"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefd.html#a56aea6e85c443484e756d67fa6189e62">cartesian_high_order_fluxes_using_nodes</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; Variables&lt; tmpl::list&lt; EvolvedVarsTags... &gt; &gt;, Dim &gt; * &gt; high_order_boundary_corrections_in_logical_direction, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; Variables&lt; tmpl::list&lt; EvolvedVarsTags... &gt; &gt;, Dim &gt; &amp;second_order_boundary_corrections_in_logical_direction, const Variables&lt; tmpl::list&lt; <a class="el" href="structTags_1_1Flux.html">::Tags::Flux</a>&lt; EvolvedVarsTags, tmpl::size_t&lt; Dim &gt;, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt;... &gt; &gt; &amp;cell_centered_inertial_flux, const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, Variables&lt; tmpl::list&lt;<a class="el" href="structTags_1_1Flux.html">::Tags::Flux</a>&lt; EvolvedVarsTags, tmpl::size_t&lt; Dim &gt;, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt;... &gt; &gt; &gt; &amp;ghost_cell_inertial_flux, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;subcell_mesh, const size_t number_of_ghost_cells, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint8_t</a> &gt;, Dim &gt; &amp;reconstruction_order={})</td></tr>
<tr class="memdesc:a56aea6e85c443484e756d67fa6189e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a high-order boundary correction \(G\) at the FD interface.  <a href="namespacefd.html#a56aea6e85c443484e756d67fa6189e62">More...</a><br /></td></tr>
<tr class="separator:a56aea6e85c443484e756d67fa6189e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c6e843c5b4ca5fa4a889750d716e25"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename... EvolvedVarsTags&gt; </td></tr>
<tr class="memitem:ad9c6e843c5b4ca5fa4a889750d716e25"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefd.html#ad9c6e843c5b4ca5fa4a889750d716e25">cartesian_high_order_fluxes_using_nodes</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; Variables&lt; tmpl::list&lt; EvolvedVarsTags... &gt; &gt;, Dim &gt; * &gt; high_order_boundary_corrections_in_logical_direction, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; Variables&lt; tmpl::list&lt; EvolvedVarsTags... &gt; &gt;, Dim &gt; &amp;second_order_boundary_corrections_in_logical_direction, const Variables&lt; tmpl::list&lt; <a class="el" href="structTags_1_1Flux.html">::Tags::Flux</a>&lt; EvolvedVarsTags, tmpl::size_t&lt; Dim &gt;, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt;... &gt; &gt; &amp;cell_centered_inertial_flux, const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, Variables&lt; tmpl::list&lt;<a class="el" href="structTags_1_1Flux.html">::Tags::Flux</a>&lt; EvolvedVarsTags, tmpl::size_t&lt; Dim &gt;, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt;... &gt; &gt; &gt; &amp;ghost_cell_inertial_flux, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;subcell_mesh, const size_t number_of_ghost_cells, const <a class="el" href="namespacefd.html#a64cf9d63e1d7c168d4077daba36ceccf">DerivativeOrder</a> derivative_order, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint8_t</a> &gt;, Dim &gt; &amp;reconstruction_order={})</td></tr>
<tr class="memdesc:ad9c6e843c5b4ca5fa4a889750d716e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a high-order boundary correction \(G\) at the FD interface.  <a href="namespacefd.html#ad9c6e843c5b4ca5fa4a889750d716e25">More...</a><br /></td></tr>
<tr class="separator:ad9c6e843c5b4ca5fa4a889750d716e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Functions and classes for finite difference methods. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a64cf9d63e1d7c168d4077daba36ceccf" name="a64cf9d63e1d7c168d4077daba36ceccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64cf9d63e1d7c168d4077daba36ceccf">&#9670;&nbsp;</a></span>DerivativeOrder</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacefd.html#a64cf9d63e1d7c168d4077daba36ceccf">fd::DerivativeOrder</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Controls which FD derivative order is used. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a64cf9d63e1d7c168d4077daba36ceccfa5f3139509417c9418f9c188821fcc25b" name="a64cf9d63e1d7c168d4077daba36ceccfa5f3139509417c9418f9c188821fcc25b"></a>OneHigherThanRecons&#160;</td><td class="fielddoc"><p >Use one order high derivative. </p>
<p >For example, if fifth order reconstruction is used, then a sixth-order derivative is used. </p>
</td></tr>
<tr><td class="fieldname"><a id="a64cf9d63e1d7c168d4077daba36ceccfaa88b89ab3a5e70982d40a7095ab5bf41" name="a64cf9d63e1d7c168d4077daba36ceccfaa88b89ab3a5e70982d40a7095ab5bf41"></a>OneHigherThanReconsButFiveToFour&#160;</td><td class="fielddoc"><p >Same as <code>OneHigherThanRecons</code> except uses a fourth-order derivative if fifth-order reconstruction was used. </p>
</td></tr>
<tr><td class="fieldname"><a id="a64cf9d63e1d7c168d4077daba36ceccfaaada29daee1d64ed0fe907043855cb7e" name="a64cf9d63e1d7c168d4077daba36ceccfaaada29daee1d64ed0fe907043855cb7e"></a>Two&#160;</td><td class="fielddoc"><p >Use 2nd order derivatives. </p>
</td></tr>
<tr><td class="fieldname"><a id="a64cf9d63e1d7c168d4077daba36ceccfa981b8fcee42e1e726a67a2b9a98ea6e9" name="a64cf9d63e1d7c168d4077daba36ceccfa981b8fcee42e1e726a67a2b9a98ea6e9"></a>Four&#160;</td><td class="fielddoc"><p >Use 4th order derivatives. </p>
</td></tr>
<tr><td class="fieldname"><a id="a64cf9d63e1d7c168d4077daba36ceccfae6fbc0b9673f8c86726688d7607fc8f5" name="a64cf9d63e1d7c168d4077daba36ceccfae6fbc0b9673f8c86726688d7607fc8f5"></a>Six&#160;</td><td class="fielddoc"><p >Use 6th order derivatives. </p>
</td></tr>
<tr><td class="fieldname"><a id="a64cf9d63e1d7c168d4077daba36ceccfabaca0ca6729684fd54206793ae4b5bd5" name="a64cf9d63e1d7c168d4077daba36ceccfabaca0ca6729684fd54206793ae4b5bd5"></a>Eight&#160;</td><td class="fielddoc"><p >Use 8th order derivatives. </p>
</td></tr>
<tr><td class="fieldname"><a id="a64cf9d63e1d7c168d4077daba36ceccfaa185c3c138dca5ef46afc33288a67d1f" name="a64cf9d63e1d7c168d4077daba36ceccfaa185c3c138dca5ef46afc33288a67d1f"></a>Ten&#160;</td><td class="fielddoc"><p >Use 10th order derivatives. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a18df6cce3d6392e8d2d55a434c1f7012" name="a18df6cce3d6392e8d2d55a434c1f7012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18df6cce3d6392e8d2d55a434c1f7012">&#9670;&nbsp;</a></span>cartesian_high_order_flux_corrections()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename... EvolvedVarsTags, typename FluxesTags  = tmpl::list&lt;::Tags::Flux&lt;              EvolvedVarsTags, tmpl::size_t&lt;Dim&gt;, Frame::Inertial&gt;...&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fd::cartesian_high_order_flux_corrections </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; Variables&lt; tmpl::list&lt; EvolvedVarsTags... &gt; &gt;, Dim &gt; &gt; * &gt;&#160;</td>
          <td class="paramname"><em>high_order_corrections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; Variables&lt; FluxesTags &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_centered_fluxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; Variables&lt; tmpl::list&lt; EvolvedVarsTags... &gt; &gt;, Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_order_boundary_corrections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacefd.html#a64cf9d63e1d7c168d4077daba36ceccf">fd::DerivativeOrder</a> &amp;&#160;</td>
          <td class="paramname"><em>fd_derivative_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFixedHashMap.html">FixedHashMap</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#gafa8cb44daebc8f9e080718961530be89">maximum_number_of_neighbors</a>(Dim), <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt;, <a class="el" href="classevolution_1_1dg_1_1subcell_1_1GhostData.html">evolution::dg::subcell::GhostData</a>, boost::hash&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_ghost_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ghost_zone_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint8_t</a> &gt;, Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>reconstruction_order</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>number_of_rdmp_values_in_ghost_data</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the high-order Cartesian flux corrections if necessary. </p>
<p >The <code>cell_centered_fluxes</code> is stored in the tag <code><a class="el" href="structevolution_1_1dg_1_1subcell_1_1Tags_1_1CellCenteredFlux.html" title="Holds the cell-centered fluxes on the subcell mesh.">evolution::dg::subcell::Tags::CellCenteredFlux</a></code>, <code>fd_derivative_order</code> is from <code><a class="el" href="structevolution_1_1dg_1_1subcell_1_1Tags_1_1SubcellOptions.html" title="System-agnostic options for DG-subcell.">evolution::dg::subcell::Tags::SubcellOptions</a></code> (<code>.finite_difference_derivative_order()</code>), the <code>all_ghost_data</code> is stored in the tag <code><a class="el" href="structevolution_1_1dg_1_1subcell_1_1Tags_1_1GhostDataForReconstruction.html" title="The ghost data used for reconstructing the solution on the interfaces between elements.">evolution::dg::subcell::Tags::GhostDataForReconstruction</a></code>, the <code>ghost_zone_size</code> should come from the FD reconstructor.</p>
<p >By default we assume no RDMP data is in the <code>ghost_data</code> buffer. In the future we will want to update how we store the data in order to eliminate more memory allocations and copies, in which case that value will be non-zero.</p>
<dl class="section note"><dt>Note</dt><dd><code>high_order_corrections</code> must either not have a value or have all elements be of the same size as <code>second_order_boundary_corrections[0].number_of_grid_points()</code>, where we've assumed <code>second_order_boundary_corrections</code> is the same in all directions. </dd></dl>

</div>
</div>
<a id="ad9c6e843c5b4ca5fa4a889750d716e25" name="ad9c6e843c5b4ca5fa4a889750d716e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c6e843c5b4ca5fa4a889750d716e25">&#9670;&nbsp;</a></span>cartesian_high_order_fluxes_using_nodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename... EvolvedVarsTags&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fd::cartesian_high_order_fluxes_using_nodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; Variables&lt; tmpl::list&lt; EvolvedVarsTags... &gt; &gt;, Dim &gt; * &gt;&#160;</td>
          <td class="paramname"><em>high_order_boundary_corrections_in_logical_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; Variables&lt; tmpl::list&lt; EvolvedVarsTags... &gt; &gt;, Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_order_boundary_corrections_in_logical_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Variables&lt; tmpl::list&lt; <a class="el" href="structTags_1_1Flux.html">::Tags::Flux</a>&lt; EvolvedVarsTags, tmpl::size_t&lt; Dim &gt;, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt;... &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_centered_inertial_flux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, Variables&lt; tmpl::list&lt;<a class="el" href="structTags_1_1Flux.html">::Tags::Flux</a>&lt; EvolvedVarsTags, tmpl::size_t&lt; Dim &gt;, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt;... &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_cell_inertial_flux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>number_of_ghost_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacefd.html#a64cf9d63e1d7c168d4077daba36ceccf">DerivativeOrder</a>&#160;</td>
          <td class="paramname"><em>derivative_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint8_t</a> &gt;, Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>reconstruction_order</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a high-order boundary correction \(G\) at the FD interface. </p>
<p >The correction to the second-order boundary correction is given by</p>
<p class="formulaDsp">
\begin{align*} G=G^{(2)}-G^{(4)}+G^{(6)}-G^{(8)}+G^{(10)}, \end{align*}
</p>
<p >where</p>
<p class="formulaDsp">
\begin{align*} G^{(4)}_{j+1/2}&amp;=\frac{1}{6}\left(G_j -2 G^{(2)} + G_{j+1}\right), \\ G^{(6)}_{j+1/2}&amp;=\frac{1}{180}\left(G_{j-1} - 9 G_j + 16 G^{(2)} -9 G_{j+1} + G_{j+2}\right), \\ G^{(8)}_{j+1/2}&amp;=\frac{1}{2100}\left(G_{j-2} - \frac{25}{3} G_{j-1} + 50 G_j - \frac{256}{3} G^{(2)} + 50 G_{j+1} - \frac{25}{3} G_{j+2} +G_{j+3}\right), \\ G^{(10)}_{j+1/2}&amp;=\frac{1}{17640} \left(G_{j-3} - \frac{49}{5} G_{j-2} + 49 G_{j-1} - 245 G_j + \frac{2048}{5} G^{(2)}\right. \nonumber \\ &amp;\left.- 245 G_{j+1}+ 49 G_{j+2} - \frac{49}{5} G_{j+3} + G_{j+4}\right), \end{align*}
</p>
<p >where</p>
<p class="formulaDsp">
\begin{align*} G_{j} &amp;= F^i_j n_i^{j+1/2}, \\ G_{j\pm1} &amp;= F^i_{j\pm1} n_i^{j+1/2}, \\ G_{j\pm2} &amp;= F^i_{j\pm2} n_i^{j+1/2}, \\ G_{j\pm3} &amp;= F^i_{j\pm3} n_i^{j+1/2}, \\ G_{j\pm4} &amp;= F^i_{j\pm4} n_i^{j+1/2}. \end{align*}
</p>
<p >This is a generalization of the correction presented in <a class="el" href="citelist.html#CITEREF_CHEN2016604">[35]</a>.</p>
<p >This high-order flux can be fed into a flux limiter, e.g. to guarantee positivity.</p>
<dl class="section note"><dt>Note</dt><dd>This implementation should be profiled and optimized.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This documentation is for the general case. In the restricted Cartesian case we use the cell-centered flux as opposed to <code>G^{(4)}</code>, which differs by a minus sign. This amounts to a minus sign change in front of the \(G^{(k)}\) terms in computing \(G\) for \(k&gt;2\), and also a sign change in front of \(G^{(2)}\) in all \(G^{(k)}\) for \(k&gt;2\). </dd></dl>

</div>
</div>
<a id="a56aea6e85c443484e756d67fa6189e62" name="a56aea6e85c443484e756d67fa6189e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56aea6e85c443484e756d67fa6189e62">&#9670;&nbsp;</a></span>cartesian_high_order_fluxes_using_nodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacefd.html#a64cf9d63e1d7c168d4077daba36ceccf">DerivativeOrder</a> DerivOrder, size_t Dim, typename... EvolvedVarsTags&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fd::cartesian_high_order_fluxes_using_nodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; Variables&lt; tmpl::list&lt; EvolvedVarsTags... &gt; &gt;, Dim &gt; * &gt;&#160;</td>
          <td class="paramname"><em>high_order_boundary_corrections_in_logical_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; Variables&lt; tmpl::list&lt; EvolvedVarsTags... &gt; &gt;, Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_order_boundary_corrections_in_logical_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Variables&lt; tmpl::list&lt; <a class="el" href="structTags_1_1Flux.html">::Tags::Flux</a>&lt; EvolvedVarsTags, tmpl::size_t&lt; Dim &gt;, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt;... &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_centered_inertial_flux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, Variables&lt; tmpl::list&lt;<a class="el" href="structTags_1_1Flux.html">::Tags::Flux</a>&lt; EvolvedVarsTags, tmpl::size_t&lt; Dim &gt;, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt;... &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_cell_inertial_flux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>number_of_ghost_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint8_t</a> &gt;, Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>reconstruction_order</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a high-order boundary correction \(G\) at the FD interface. </p>
<p >The correction to the second-order boundary correction is given by</p>
<p class="formulaDsp">
\begin{align*} G=G^{(2)}-G^{(4)}+G^{(6)}-G^{(8)}+G^{(10)}, \end{align*}
</p>
<p >where</p>
<p class="formulaDsp">
\begin{align*} G^{(4)}_{j+1/2}&amp;=\frac{1}{6}\left(G_j -2 G^{(2)} + G_{j+1}\right), \\ G^{(6)}_{j+1/2}&amp;=\frac{1}{180}\left(G_{j-1} - 9 G_j + 16 G^{(2)} -9 G_{j+1} + G_{j+2}\right), \\ G^{(8)}_{j+1/2}&amp;=\frac{1}{2100}\left(G_{j-2} - \frac{25}{3} G_{j-1} + 50 G_j - \frac{256}{3} G^{(2)} + 50 G_{j+1} - \frac{25}{3} G_{j+2} +G_{j+3}\right), \\ G^{(10)}_{j+1/2}&amp;=\frac{1}{17640} \left(G_{j-3} - \frac{49}{5} G_{j-2} + 49 G_{j-1} - 245 G_j + \frac{2048}{5} G^{(2)}\right. \nonumber \\ &amp;\left.- 245 G_{j+1}+ 49 G_{j+2} - \frac{49}{5} G_{j+3} + G_{j+4}\right), \end{align*}
</p>
<p >where</p>
<p class="formulaDsp">
\begin{align*} G_{j} &amp;= F^i_j n_i^{j+1/2}, \\ G_{j\pm1} &amp;= F^i_{j\pm1} n_i^{j+1/2}, \\ G_{j\pm2} &amp;= F^i_{j\pm2} n_i^{j+1/2}, \\ G_{j\pm3} &amp;= F^i_{j\pm3} n_i^{j+1/2}, \\ G_{j\pm4} &amp;= F^i_{j\pm4} n_i^{j+1/2}. \end{align*}
</p>
<p >This is a generalization of the correction presented in <a class="el" href="citelist.html#CITEREF_CHEN2016604">[35]</a>.</p>
<p >This high-order flux can be fed into a flux limiter, e.g. to guarantee positivity.</p>
<dl class="section note"><dt>Note</dt><dd>This implementation should be profiled and optimized.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This documentation is for the general case. In the restricted Cartesian case we use the cell-centered flux as opposed to <code>G^{(4)}</code>, which differs by a minus sign. This amounts to a minus sign change in front of the \(G^{(k)}\) terms in computing \(G\) for \(k&gt;2\), and also a sign change in front of \(G^{(2)}\) in all \(G^{(k)}\) for \(k&gt;2\). </dd></dl>

</div>
</div>
<a id="a8cd8fc8b73d4f1ab74d2d285312353ea" name="a8cd8fc8b73d4f1ab74d2d285312353ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd8fc8b73d4f1ab74d2d285312353ea">&#9670;&nbsp;</a></span>kreiss_oliger_filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fd::kreiss_oliger_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt; * &gt;&#160;</td>
          <td class="paramname"><em>filtered_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_cell_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>fd_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply Kreiss-Oliger dissipation <a class="el" href="citelist.html#CITEREF_Kreiss1973">[101]</a> of order <code>fd_order</code> to the variables. </p>
<p >Define the operators \(D_+\) and \(D_-\) be defined as:</p>
<p class="formulaDsp">
\begin{align*} D_+f_i&amp;=\frac{(f_{i+1}-f_i)}{\Delta x} \\ D_-f_i&amp;=\frac{(f_i-f_{i-1})}{\Delta x} \end{align*}
</p>
<p >where the subscript \(i\) refers to the grid index. The dissipation operators are generally applied dimension-by-dimension, and so we have:</p>
<p class="formulaDsp">
\begin{align*} \mathcal{D}^{(2m)}=-\frac{(-1)^m}{2^{2m}}\Delta x^{2m-1} \epsilon(D_{+})^m(D_{-})^m \end{align*}
</p>
<p >where \(\epsilon\) controls the amount of dissipation and is restricted to \(0\leq\epsilon\leq1\), and \(m\) is the order of the finite difference derivative so as not to spoil the accuracy of the scheme. That is, for second order FD, \(m=2\) and one should use \(\mathcal{D}^{(4)}\). However, this choice requires a larger stencil and whether or not this is necessary also depends on when and how in the algorithm the operators are applied.</p>
<p >We arrive at the following operators:</p>
<p class="formulaDsp">
\begin{align*} \mathcal{D}^{(2)}f_i&amp;=-\frac{\epsilon}{\Delta x} (f_{i+1} - 2f_i+f_{i-1}) \\ \mathcal{D}^{(4)}f_i&amp;=-\frac{\epsilon}{16\Delta x} (f_{i+2}-4f_{i+1}+6f_i-4f_{i-1}+f_{i-2}) \\ \mathcal{D}^{(6)}f_i&amp;=\frac{\epsilon}{64\Delta x}(f_{i+3}-6f_{i+2}+15f_{i+1} -20f_i+15f_{i-1}-6f_{i-2}+f_{i-3}) \\ \mathcal{D}^{(8)}f_i&amp;=-\frac{\epsilon}{256\Delta x} (f_{i+4}-8f_{i+3}+28f_{i+2}-56f_{i+1}+70f_{i}-56f_{i-1}+28f_{i-2} -8f_{i-3}+f_{i-4}) \\ \mathcal{D}^{(10)}f_i&amp;=\frac{\epsilon}{1024\Delta x} (f_{i+5}-10f_{i+4}+45f_{i+3} -120f_{i+2}+210f_{i+1}-252f_{i}+210f_{i-1}-120f_{i-2}+45f_{i-3} -10f_{i-4}+f_{i-5}) \end{align*}
</p>
<dl class="section note"><dt>Note</dt><dd>This function applies \(\Delta x \mathcal{D}^{(2m)}\). </dd></dl>

</div>
</div>
<a id="a3c55181883d1bdde817937f7464f0e5a" name="a3c55181883d1bdde817937f7464f0e5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c55181883d1bdde817937f7464f0e5a">&#9670;&nbsp;</a></span>logical_partial_derivatives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fd::logical_partial_derivatives </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt;&#160;</td>
          <td class="paramname"><em>logical_derivatives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_cell_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>fd_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the logical partial derivatives using cell-centered finite difference derivatives. </p>
<p >Up to 8th order stencils are supported.</p>
<dl class="section note"><dt>Note</dt><dd>Currently the stride is always one because we transpose the data before reconstruction. However, it may be faster to have a non-unit stride without the transpose. We have the <code>stride</code> parameter in the derivative stencils to make testing performance easier in the future.</dd>
<dd>
This code does not do any explicit SIMD vectorization. We will want to profile and decide if optimization are possible. The Vc SIMD library has an example of vectorizing single-precision FD derivatives. There is also a paper "Optimization of Finite-Differencing Kernels for Numerical Relativity
Applications" by Alfieri, Bernuzzi, Perego, and Radice that uses compiler auto-vectorization. </dd></dl>

</div>
</div>
<a id="aa199d9b7ee01c8e9e93a0a7e72901fa5" name="aa199d9b7ee01c8e9e93a0a7e72901fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa199d9b7ee01c8e9e93a0a7e72901fa5">&#9670;&nbsp;</a></span>low_pass_filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fd::low_pass_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt; * &gt;&#160;</td>
          <td class="paramname"><em>filtered_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_cell_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>fd_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a low-pass filter to the data. </p>
<p >The filter fits a Legendre polynomial of degree equal to <code>fd_order</code> to each grid point and its neighboring points, then subtracts out the highest mode contribution at the grid point. This is inspired by a Heaviside filter for Legendre polynomial-based spectral methods.</p>
<p >The filter at different orders is given by:</p>
<p class="formulaDsp">
\begin{align*} F^{(9)} u_i&amp;= -\frac{35 \times 531441}{128} \left( \frac{1}{6406400} (u_{i-4} + u_{i+4}) - \frac{1}{800800} (u_{i-3} + u_{i+3}) + \frac{1}{228800} (u_{i-2} + u_{i+2}) - \frac{1}{114400} (u_{i-1} + u_{i+1}) + \frac{1}{91520} u_i\right) \\ F^{(7)} u_i&amp;= \frac{5 \times 16807}{16} \left( \frac{1}{95040} (u_{i-3} + u_{i+3}) - \frac{1}{15840} (u_{i-2} + u_{i+2}) + \frac{1}{6336} (u_{i-1} + u_{i+1}) - \frac{1}{4572} u_i\right) \\ F^{(5)} u_i&amp;= -\frac{3 \times 125}{8} \left( \frac{1}{336} (u_{i-2} + u_{i+2}) - \frac{1}{84} (u_{i-1} + u_{i+1}) + \frac{1}{56} u_i\right) \\ F^{(3)} u_i&amp;= \frac{1 \times 3}{2} \left( \frac{1}{4} (u_{i-1} + u_{i+1}) - \frac{1}{2} u_i\right) \end{align*}
</p>
<dl class="section note"><dt>Note</dt><dd>The \(F^{(11)}\) filter isn't implemented yet.</dd>
<dd>
The argument \(\epsilon\) controls how much of the mode is filter out. \(\epsilon=1\) means the highest mode is completely filtered while \(\epsilon=0\) means it's not at all filtered. </dd></dl>

</div>
</div>
<a id="aaa2059d92bb58a35535f40b8046f55f0" name="aaa2059d92bb58a35535f40b8046f55f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa2059d92bb58a35535f40b8046f55f0">&#9670;&nbsp;</a></span>neighbor_data_as_variables()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename ReconstructionTags &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fd::neighbor_data_as_variables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classFixedHashMap.html">FixedHashMap</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#gafa8cb44daebc8f9e080718961530be89">maximum_number_of_neighbors</a>(Dim), <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt;, Variables&lt; ReconstructionTags &gt;, boost::hash&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt; &gt; &gt; * &gt;&#160;</td>
          <td class="paramname"><em>vars_neighbor_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFixedHashMap.html">FixedHashMap</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#gafa8cb44daebc8f9e080718961530be89">maximum_number_of_neighbors</a>(Dim), <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt;, <a class="el" href="classevolution_1_1dg_1_1subcell_1_1GhostData.html">evolution::dg::subcell::GhostData</a>, boost::hash&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_ghost_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ghost_zone_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the type-erased neighbor data for reconstruction stored in a <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code>, have <code>Variables</code> point into them. </p>
<p >This function is helpful for reconstruction, especially when wanting to apply different reconstruction methods to different tags. This can happen, for example, when doing positivity-preserving reconstruction. The density should remain positive, but negative velocities are fine. </p>

</div>
</div>
<a id="a54cf779a8fae10c139c1eec90fe18f7c" name="a54cf779a8fae10c139c1eec90fe18f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54cf779a8fae10c139c1eec90fe18f7c">&#9670;&nbsp;</a></span>partial_derivatives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivativeTags , size_t Dim, typename DerivativeFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fd::partial_derivatives </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; <a class="el" href="group__DataBoxTagsGroup.html#ga3dda5a16c7f6baccd115de2c8f12394e">db::wrap_tags_in</a>&lt; <a class="el" href="structTags_1_1deriv.html">Tags::deriv</a>, DerivativeTags, tmpl::size_t&lt; Dim &gt;, DerivativeFrame &gt; &gt; * &gt;&#160;</td>
          <td class="paramname"><em>partial_derivatives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_cell_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>fd_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, DerivativeFrame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_jacobian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the partial derivative on the <code>DerivativeFrame</code> using the <code>inverse_jacobian</code>. </p>
<p >Logical partial derivatives are first computed using the <code><a class="el" href="namespacefd.html#a3c55181883d1bdde817937f7464f0e5a" title="Compute the logical partial derivatives using cell-centered finite difference derivatives.">fd::logical_partial_derivatives()</a></code> function. </p>

</div>
</div>
<a id="ac287ca45e0d4ee982718c2be7696ec15" name="ac287ca45e0d4ee982718c2be7696ec15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac287ca45e0d4ee982718c2be7696ec15">&#9670;&nbsp;</a></span>set_cartesian_neighbor_cell_centered_fluxes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename FluxesTags &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fd::set_cartesian_neighbor_cell_centered_fluxes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, Variables&lt; FluxesTags &gt; &gt; * &gt;&#160;</td>
          <td class="paramname"><em>flux_neighbor_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFixedHashMap.html">FixedHashMap</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#gafa8cb44daebc8f9e080718961530be89">maximum_number_of_neighbors</a>(Dim), <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt;, <a class="el" href="classevolution_1_1dg_1_1subcell_1_1GhostData.html">evolution::dg::subcell::GhostData</a>, boost::hash&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_ghost_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ghost_zone_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>number_of_rdmp_values_in_ghost_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the <code>flux_neighbor_data</code> with pointers into the <code>all_ghost_data</code>. </p>
<p >The <code>all_ghost_data</code> is stored in the tag <code><a class="el" href="structevolution_1_1dg_1_1subcell_1_1Tags_1_1GhostDataForReconstruction.html" title="The ghost data used for reconstructing the solution on the interfaces between elements.">evolution::dg::subcell::Tags::GhostDataForReconstruction</a></code>, and the <code>ghost_zone_size</code> should come from the FD reconstructor. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacefd.html">fd</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
