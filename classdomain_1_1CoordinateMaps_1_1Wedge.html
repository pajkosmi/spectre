<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: domain::CoordinateMaps::Wedge&lt; Dim &gt; Class Template Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classdomain_1_1CoordinateMaps_1_1Wedge.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classdomain_1_1CoordinateMaps_1_1Wedge-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">domain::CoordinateMaps::Wedge&lt; Dim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__CoordinateMapsGroup.html">Coordinate Maps</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Map from a square or cube to a wedge.  
 <a href="classdomain_1_1CoordinateMaps_1_1Wedge.html#details">More...</a></p>

<p><code>#include &lt;Wedge.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aeee5fa344550f8f5e0cbbb6b38f15e1b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html#aeee5fa344550f8f5e0cbbb6b38f15e1b">WedgeHalves</a> { <a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html#aeee5fa344550f8f5e0cbbb6b38f15e1ba130c5b3473c57faa76e2a1c54e26f88e">Both</a>
, <a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html#aeee5fa344550f8f5e0cbbb6b38f15e1bab5cece95d3c855427c7ecfd597df02a2">UpperOnly</a>
, <a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html#aeee5fa344550f8f5e0cbbb6b38f15e1ba56e5c05093b6f35ba74db402c472b355">LowerOnly</a>
 }</td></tr>
<tr class="separator:aeee5fa344550f8f5e0cbbb6b38f15e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a182bb94a0b425af64371d559c1faf1aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html#a182bb94a0b425af64371d559c1faf1aa">Wedge</a> (double radius_inner, double radius_outer, double sphericity_inner, double sphericity_outer, <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; Dim &gt; orientation_of_wedge, bool with_equiangular_map, <a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html#aeee5fa344550f8f5e0cbbb6b38f15e1b">WedgeHalves</a> halves_to_use=<a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html#aeee5fa344550f8f5e0cbbb6b38f15e1ba130c5b3473c57faa76e2a1c54e26f88e">WedgeHalves::Both</a>, <a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">Distribution</a> radial_distribution=Distribution::Linear, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, Dim - 1 &gt; &amp;opening_angles=<a class="el" href="group__UtilitiesGroup.html#gaef51773ec780d16fddcda8e5094f2a21">make_array</a>&lt; Dim - 1 &gt;(M_PI_2), bool with_adapted_equiangular_map=true)</td></tr>
<tr class="separator:a182bb94a0b425af64371d559c1faf1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6005fa3882fca667f824245273779d01"><td class="memItemLeft" align="right" valign="top"><a id="a6005fa3882fca667f824245273779d01" name="a6005fa3882fca667f824245273779d01"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Wedge</b> (<a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html">Wedge</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a6005fa3882fca667f824245273779d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493fa042b1c900230571f0c004169c0e"><td class="memItemLeft" align="right" valign="top"><a id="a493fa042b1c900230571f0c004169c0e" name="a493fa042b1c900230571f0c004169c0e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Wedge</b> (const <a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html">Wedge</a> &amp;)=default</td></tr>
<tr class="separator:a493fa042b1c900230571f0c004169c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af382e833a349b2247ceda6f162c2ddf7"><td class="memItemLeft" align="right" valign="top"><a id="af382e833a349b2247ceda6f162c2ddf7" name="af382e833a349b2247ceda6f162c2ddf7"></a>
<a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html">Wedge</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html">Wedge</a> &amp;)=default</td></tr>
<tr class="separator:af382e833a349b2247ceda6f162c2ddf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace35154d00f7eda77854707c693fce4a"><td class="memItemLeft" align="right" valign="top"><a id="ace35154d00f7eda77854707c693fce4a" name="ace35154d00f7eda77854707c693fce4a"></a>
<a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html">Wedge</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html">Wedge</a> &amp;&amp;)=default</td></tr>
<tr class="separator:ace35154d00f7eda77854707c693fce4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc696cc005d3985e1429e26e3792a1f"><td class="memTemplParams" colspan="2"><a id="afdc696cc005d3985e1429e26e3792a1f" name="afdc696cc005d3985e1429e26e3792a1f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afdc696cc005d3985e1429e26e3792a1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; tt::remove_cvref_wrap_t&lt; T &gt;, Dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator()</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim &gt; &amp;source_coords) const</td></tr>
<tr class="separator:afdc696cc005d3985e1429e26e3792a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2486382342c7302c9f37ba313b80a5e0"><td class="memItemLeft" align="right" valign="top"><a id="a2486382342c7302c9f37ba313b80a5e0" name="a2486382342c7302c9f37ba313b80a5e0"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, Dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>inverse</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, Dim &gt; &amp;target_coords) const</td></tr>
<tr class="memdesc:a2486382342c7302c9f37ba313b80a5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a \(+z\)-oriented <code><a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html" title="Map from a square or cube to a wedge.">Wedge</a></code>, returns invalid if \(z&lt;=0\) or if \((x,y,z)\) is on or outside the cone defined by \((x^2/z^2 + y^2/z^2+1)^{1/2} = -S/F\), where \(S = \frac{1}{2}(s_1 r_1 - s_0 r_0)\) and \(F = \frac{1}{2\sqrt{3}}((1-s_1) r_1 - (1-s_0) r_0)\). Here \(s_0,s_1\) and \(r_0,r_1\) are the specified sphericities and radii of the inner and outer \(z\) surfaces. The map is singular on the cone and on the xy plane. The inverse function is only callable with doubles because the inverse might fail if called for a point out of range, and it is unclear what should happen if the inverse were to succeed for some points in a <a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a> but fail for other points. <br /></td></tr>
<tr class="separator:a2486382342c7302c9f37ba313b80a5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a276b4d63381cf5dc72139cb3671f9"><td class="memTemplParams" colspan="2"><a id="ad3a276b4d63381cf5dc72139cb3671f9" name="ad3a276b4d63381cf5dc72139cb3671f9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad3a276b4d63381cf5dc72139cb3671f9"><td class="memTemplItemLeft" align="right" valign="top">tnsr::Ij&lt; tt::remove_cvref_wrap_t&lt; T &gt;, Dim, <a class="el" href="structFrame_1_1NoFrame.html">Frame::NoFrame</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>jacobian</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim &gt; &amp;source_coords) const</td></tr>
<tr class="separator:ad3a276b4d63381cf5dc72139cb3671f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4342120f2929b5ddd75ef61bd2544d2c"><td class="memTemplParams" colspan="2"><a id="a4342120f2929b5ddd75ef61bd2544d2c" name="a4342120f2929b5ddd75ef61bd2544d2c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4342120f2929b5ddd75ef61bd2544d2c"><td class="memTemplItemLeft" align="right" valign="top">tnsr::Ij&lt; tt::remove_cvref_wrap_t&lt; T &gt;, Dim, <a class="el" href="structFrame_1_1NoFrame.html">Frame::NoFrame</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inv_jacobian</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim &gt; &amp;source_coords) const</td></tr>
<tr class="separator:a4342120f2929b5ddd75ef61bd2544d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f20caa7e01e51d115a023016bf0865"><td class="memItemLeft" align="right" valign="top"><a id="ad4f20caa7e01e51d115a023016bf0865" name="ad4f20caa7e01e51d115a023016bf0865"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pup</b> (PUP::er &amp;p)</td></tr>
<tr class="separator:ad4f20caa7e01e51d115a023016bf0865"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac60c20706762cd426667ea3c733b8b2e"><td class="memItemLeft" align="right" valign="top"><a id="ac60c20706762cd426667ea3c733b8b2e" name="ac60c20706762cd426667ea3c733b8b2e"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_identity</b> ()</td></tr>
<tr class="separator:ac60c20706762cd426667ea3c733b8b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a677f85d8dfd1ab979231c7057806848d"><td class="memItemLeft" align="right" valign="top"><a id="a677f85d8dfd1ab979231c7057806848d" name="a677f85d8dfd1ab979231c7057806848d"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>dim</b> = Dim</td></tr>
<tr class="separator:a677f85d8dfd1ab979231c7057806848d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aaba0d38b10e9fad7c08b090f60224945"><td class="memTemplParams" colspan="2"><a id="aaba0d38b10e9fad7c08b090f60224945" name="aaba0d38b10e9fad7c08b090f60224945"></a>
template&lt;size_t LocalDim&gt; </td></tr>
<tr class="memitem:aaba0d38b10e9fad7c08b090f60224945"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html">Wedge</a>&lt; LocalDim &gt; &amp;lhs, const <a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html">Wedge</a>&lt; LocalDim &gt; &amp;rhs)</td></tr>
<tr class="separator:aaba0d38b10e9fad7c08b090f60224945"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;size_t Dim&gt;<br />
class domain::CoordinateMaps::Wedge&lt; Dim &gt;</div><p >Map from a square or cube to a wedge. </p>
<div class="image">
<img src="Shell.png" alt=""/>
<div class="caption">
A shell can be constructed out of six wedges.</div></div>
<h3>Details</h3>
<p >The mapping that goes from a reference cube (in 3D) or square (in 2D) to a wedge centered on a coordinate axis covering a volume between an inner surface and outer surface. Each surface can be given a curvature between flat (a sphericity of 0) or spherical (a sphericity of 1).</p>
<p >In 2D, the first logical coordinate corresponds to the radial coordinate, and the second logical coordinates correspond to the angular coordinate. In 3D, the first two logical coordinates correspond to the two angular coordinates, and the third to the radial coordinate. This difference originates from separate implementations for the 2D and 3D map that were merged. The 3D implementation can be changed to use the first logical coordinate as radial direction, but this requires propagating the change through the rest of the domain code (see issue <a href="https://github.com/sxs-collaboration/spectre/issues/2988">https://github.com/sxs-collaboration/spectre/issues/2988</a>).</p>
<p >The following documentation is for the 3D map. The 2D map is obtained by setting either of the two angular coordinates to zero (and using \(\xi\) as radial coordinate).</p>
<p >The <a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html" title="Map from a square or cube to a wedge.">Wedge</a> map is constructed by linearly interpolating between a bulged face of radius <code>radius_of_inner_surface</code> to a bulged face of radius <code>radius_of_outer_surface</code>, where the radius of each bulged face is defined to be the radius of the sphere circumscribing the bulge.</p>
<p >We make a choice here as to whether we wish to use the logical coordinates parameterizing these surface as they are, in which case we have the equidistant choice of coordinates, or whether to apply a tangent map to them which leads us to the equiangular choice of coordinates. In terms of the logical coordinates, the equiangular coordinates are:</p>
<p class="formulaDsp">
\[\textrm{equiangular xi} : \Xi(\xi) = \textrm{tan}(\xi\pi/4)\]
</p>
<p class="formulaDsp">
\[\textrm{equiangular eta} : \mathrm{H}(\eta) = \textrm{tan}(\eta\pi/4)\]
</p>
<p >With derivatives:</p>
<p class="formulaDsp">
\[\Xi&#39;(\xi) = \frac{\pi}{4}(1+\Xi^2)\]
</p>
<p class="formulaDsp">
\[\mathrm{H}&#39;(\eta) = \frac{\pi}{4}(1+\mathrm{H}^2)\]
</p>
<p >The equidistant coordinates are:</p>
<p class="formulaDsp">
\[ \textrm{equidistant xi} : \Xi = \xi\]
</p>
<p class="formulaDsp">
\[ \textrm{equidistant eta} : \mathrm{H} = \eta\]
</p>
<p >with derivatives:</p>
<center> \(\Xi&#39;(\xi) = 1\), and \(\mathrm{H}&#39;(\eta) = 1\)</center><p >We also define the variable \(\rho\), given by:</p>
<p class="formulaDsp">
\[\textrm{rho} : \rho = \sqrt{1+\Xi^2+\mathrm{H}^2}\]
</p>
<h3><a class="anchor" id="autotoc_md328"></a>
The Spherical Face Map</h3>
<p >The surface map for the spherical face of radius \(R\) lying in the \(+z\) direction in either choice of coordinates is then given by:</p>
<p class="formulaDsp">
\[\vec{\sigma}_{spherical}: \vec{\xi} \rightarrow \vec{x}(\vec{\xi})\]
</p>
<p> Where </p><p class="formulaDsp">
\[ \vec{x}(\xi,\eta) = \begin{bmatrix} x(\xi,\eta)\\ y(\xi,\eta)\\ z(\xi,\eta)\\ \end{bmatrix} = \frac{R}{\rho} \begin{bmatrix} \Xi\\ \mathrm{H}\\ 1\\ \end{bmatrix}\]
</p>
<h3><a class="anchor" id="autotoc_md329"></a>
The Bulged Face Map</h3>
<p >The bulged surface is itself constructed by linearly interpolating between a cubical face and a spherical face. The surface map for the cubical face of side length \(2L\) lying in the \(+z\) direction is given by:</p>
<p class="formulaDsp">
\[\vec{\sigma}_{cubical}: \vec{\xi} \rightarrow \vec{x}(\vec{\xi})\]
</p>
<p> Where </p><p class="formulaDsp">
\[ \vec{x}(\xi,\eta) = \begin{bmatrix} x(\xi,\eta)\\ y(\xi,\eta)\\ L\\ \end{bmatrix} = L \begin{bmatrix} \Xi\\ \mathrm{H}\\ 1\\ \end{bmatrix}\]
</p>
<p >To construct the bulged map we interpolate between this cubical face map and a spherical face map of radius \(R\), with the interpolation parameter being \(s\). The surface map for the bulged face lying in the \(+z\) direction is then given by:</p>
<p class="formulaDsp">
\[\vec{\sigma}_{bulged}(\xi,\eta) = {(1-s)L + \frac{sR}{\rho}} \begin{bmatrix} \Xi\\ \mathrm{H}\\ 1\\ \end{bmatrix}\]
</p>
<p >We constrain L by demanding that the spherical face circumscribe the cube. With this condition, we have \(L = R/\sqrt3\). </p><dl class="section note"><dt>Note</dt><dd>This differs from the choice in SpEC where it is demanded that the surfaces touch at the center, which leads to \(L = R\).</dd></dl>
<h3><a class="anchor" id="autotoc_md330"></a>
The Full Volume Map</h3>
<p >The final map for the wedge which lies along the \(+z\) is obtained by interpolating between the two surfaces with the interpolation parameter being the logical coordinate \(\zeta\). This results in:</p>
<p class="formulaDsp">
\[\vec{x}(\xi,\eta,\zeta) = \frac{1}{2}\left\{(1-\zeta)\Big[(1-s_{inner})\frac{R_{inner}}{\sqrt 3} + s_{inner}\frac{R_{inner}}{\rho}\Big] + (1+\zeta)\Big[(1-s_{outer})\frac{R_{outer}}{\sqrt 3} +s_{outer} \frac{R_{outer}}{\rho}\Big] \right\}\begin{bmatrix} \Xi\\ \mathrm{H}\\ 1\\ \end{bmatrix}\]
</p>
<p >We will define the variables \(F(\zeta)\) and \(S(\zeta)\), the frustum and sphere factors: </p><p class="formulaDsp">
\[F(\zeta) = F_0 + F_1\zeta\]
</p>
 <p class="formulaDsp">
\[S(\zeta) = S_0 + S_1\zeta\]
</p>
<p> Where </p><p class="formulaDsp">
\begin{align*}F_0 &amp;= \frac{1}{2} \big\{ (1-s_{outer})R_{outer} + (1-s_{inner})R_{inner}\big\}\\ F_1 &amp;= \partial_{\zeta} F = \frac{1}{2} \big\{ (1-s_{outer})R_{outer} - (1-s_{inner})R_{inner}\big\}\\ S_0 &amp;= \frac{1}{2} \big\{ s_{outer}R_{outer} + s_{inner}R_{inner}\big\}\\ S_1 &amp;= \partial_{\zeta} S = \frac{1}{2} \big\{ s_{outer}R_{outer} - s_{inner}R_{inner}\big\}\end{align*}
</p>
<p >The map can then be rewritten as: </p><p class="formulaDsp">
\[\vec{x}(\xi,\eta,\zeta) = \left\{\frac{F(\zeta)}{\sqrt 3} + \frac{S(\zeta)}{\rho}\right\}\begin{bmatrix} \Xi\\ \mathrm{H}\\ 1\\ \end{bmatrix}\]
</p>
<p >We provide some common derivatives: </p><p class="formulaDsp">
\[\partial_{\xi}z = \frac{-S(\zeta)\Xi\Xi&#39;}{\rho^3}\]
</p>
 <p class="formulaDsp">
\[\partial_{\eta}z = \frac{-S(\zeta)\mathrm{H}\mathrm{H}&#39;}{\rho^3}\]
</p>
 <p class="formulaDsp">
\[\partial_{\zeta}z = \frac{F&#39;}{\sqrt 3} + \frac{S&#39;}{\rho}\]
</p>
<p> The Jacobian then is: </p><p class="formulaDsp">
\[J = \begin{bmatrix} \Xi&#39;z + \Xi\partial_{\xi}z &amp; \Xi\partial_{\eta}z &amp; \Xi\partial_{\zeta}z \\ \mathrm{H}\partial_{\xi}z &amp; \mathrm{H}&#39;z + \mathrm{H}\partial_{\eta}z &amp; \mathrm{H}\partial_{\zeta}z\\ \partial_{\xi}z&amp;\partial_{\eta}z &amp;\partial_{\zeta}z \\ \end{bmatrix} \]
</p>
<p >A common factor that shows up in the inverse jacobian is: </p><p class="formulaDsp">
\[ T:= \frac{S(\zeta)}{(\partial_{\zeta}z)\rho^3}\]
</p>
<p >The inverse Jacobian then is: </p><p class="formulaDsp">
\[J^{-1} = \frac{1}{z}\begin{bmatrix} \Xi&#39;^{-1} &amp; 0 &amp; -\Xi\Xi&#39;^{-1}\\ 0 &amp; \mathrm{H}&#39;^{-1} &amp; -\mathrm{H}\mathrm{H}&#39;^{-1}\\ T\Xi &amp; T\mathrm{H} &amp; T + F(\partial_{\zeta}z)^{-1}/\sqrt 3\\ \end{bmatrix} \]
</p>
<h3><a class="anchor" id="autotoc_md331"></a>
Changing the radial distribution of the gridpoints</h3>
<p >By default, <a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html" title="Map from a square or cube to a wedge.">Wedge</a> linearly distributes its gridpoints in the radial direction. An exponential distribution of gridpoints can be obtained by linearly interpolating in the logarithm of the radius, in order to obtain a relatively higher resolution at smaller radii. Since this is a radial rescaling of <a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html" title="Map from a square or cube to a wedge.">Wedge</a>, this option is only supported for fully spherical wedges with <code>sphericity_inner</code> = <code>sphericity_outer</code> = 1.</p>
<p >The linear interpolation done is: </p><p class="formulaDsp">
\[ \log r = \frac{1-\zeta}{2}\log R_{inner} + \frac{1+\zeta}{2}\log R_{outer} \]
</p>
<p >The map then is: </p><p class="formulaDsp">
\[\vec{x}(\xi,\eta,\zeta) = \frac{\sqrt{R_{inner}^{1-\zeta}R_{outer}^{1+\zeta}}}{\rho}\begin{bmatrix} \Xi\\ \mathrm{H}\\ 1\\ \end{bmatrix}\]
</p>
<p >The jacobian simplifies similarly.</p>
<p >Alternatively, an inverse radial distribution can be chosen where the linear interpolation is:</p>
<p class="formulaDsp">
\[ \frac{1}{r} = \frac{R_\mathrm{inner} + R_\mathrm{outer}}{2 R_\mathrm{inner} R_\mathrm{outer}} + \frac{R_\mathrm{inner} - R_\mathrm{outer}}{2 R_\mathrm{inner} R_\mathrm{outer}} \zeta \]
</p>
 </div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aeee5fa344550f8f5e0cbbb6b38f15e1b" name="aeee5fa344550f8f5e0cbbb6b38f15e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee5fa344550f8f5e0cbbb6b38f15e1b">&#9670;&nbsp;</a></span>WedgeHalves</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html#aeee5fa344550f8f5e0cbbb6b38f15e1b">domain::CoordinateMaps::Wedge::WedgeHalves</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aeee5fa344550f8f5e0cbbb6b38f15e1ba130c5b3473c57faa76e2a1c54e26f88e" name="aeee5fa344550f8f5e0cbbb6b38f15e1ba130c5b3473c57faa76e2a1c54e26f88e"></a>Both&#160;</td><td class="fielddoc"><p >Use the entire wedge. </p>
</td></tr>
<tr><td class="fieldname"><a id="aeee5fa344550f8f5e0cbbb6b38f15e1bab5cece95d3c855427c7ecfd597df02a2" name="aeee5fa344550f8f5e0cbbb6b38f15e1bab5cece95d3c855427c7ecfd597df02a2"></a>UpperOnly&#160;</td><td class="fielddoc"><p >Use only the upper logical half. </p>
</td></tr>
<tr><td class="fieldname"><a id="aeee5fa344550f8f5e0cbbb6b38f15e1ba56e5c05093b6f35ba74db402c472b355" name="aeee5fa344550f8f5e0cbbb6b38f15e1ba56e5c05093b6f35ba74db402c472b355"></a>LowerOnly&#160;</td><td class="fielddoc"><p >Use only the lower logical half. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a182bb94a0b425af64371d559c1faf1aa" name="a182bb94a0b425af64371d559c1faf1aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182bb94a0b425af64371d559c1faf1aa">&#9670;&nbsp;</a></span>Wedge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html">domain::CoordinateMaps::Wedge</a>&lt; Dim &gt;::Wedge </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius_inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius_outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sphericity_inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sphericity_outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; Dim &gt;&#160;</td>
          <td class="paramname"><em>orientation_of_wedge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>with_equiangular_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html#aeee5fa344550f8f5e0cbbb6b38f15e1b">WedgeHalves</a>&#160;</td>
          <td class="paramname"><em>halves_to_use</em> = <code><a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html#aeee5fa344550f8f5e0cbbb6b38f15e1ba130c5b3473c57faa76e2a1c54e26f88e">WedgeHalves::Both</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">Distribution</a>&#160;</td>
          <td class="paramname"><em>radial_distribution</em> = <code>Distribution::Linear</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, Dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>opening_angles</em> = <code><a class="el" href="group__UtilitiesGroup.html#gaef51773ec780d16fddcda8e5094f2a21">make_array</a>&lt;&#160;Dim&#160;-&#160;1&#160;&gt;(M_PI_2)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>with_adapted_equiangular_map</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Constructs a 3D wedge. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radius_inner</td><td>Distance from the origin to one of the corners which lie on the inner surface. </td></tr>
    <tr><td class="paramname">radius_outer</td><td>Distance from the origin to one of the corners which lie on the outer surface. </td></tr>
    <tr><td class="paramname">orientation_of_wedge</td><td>The orientation of the desired wedge relative to the orientation of the default wedge which is a wedge that has its curved surfaces pierced by the upper-z axis. The logical xi and eta coordinates point in the cartesian x and y directions, respectively. </td></tr>
    <tr><td class="paramname">sphericity_inner</td><td>Value between 0 and 1 which determines whether the inner surface is flat (value of 0), spherical (value of 1) or somewhere in between </td></tr>
    <tr><td class="paramname">sphericity_outer</td><td>Value between 0 and 1 which determines whether the outer surface is flat (value of 0), spherical (value of 1) or somewhere in between </td></tr>
    <tr><td class="paramname">with_equiangular_map</td><td>Determines whether to apply a tangent function mapping to the logical coordinates (for <code>true</code>) or not (for <code>false</code>). </td></tr>
    <tr><td class="paramname">halves_to_use</td><td>Determines whether to construct a full wedge or only half a wedge. If constructing only half a wedge, the resulting shape has a face normal to the x direction (assuming default <a class="el" href="classOrientationMap.html" title="A mapping of the logical coordinate axes of a host to the logical coordinate axes of a neighbor of th...">OrientationMap</a>). If constructing half a wedge, an intermediate affine map is applied to the logical xi coordinate such that the interval [-1,1] is mapped to the corresponding logical half of the wedge. For example, if <code>UpperOnly</code> is specified, [-1,1] is mapped to [0,1], and if <code>LowerOnly</code> is specified, [-1,1] is mapped to [-1,0]. The case of <code>Both</code> means a full wedge, with no intermediate map applied. In all cases, the logical points returned by the inverse map will lie in the range [-1,1] in each dimension. Half wedges are currently only useful in constructing domains for binary systems. </td></tr>
    <tr><td class="paramname">radial_distribution</td><td>Determines how to distribute grid points along the radial direction. For wedges that are not exactly spherical, only <code>Distribution::Linear</code> is currently supported. </td></tr>
    <tr><td class="paramname">opening_angles</td><td>Determines the angular size of the wedge. The default value is pi/2, which corresponds to a wedge size of pi/2. For this setting, four Wedges can be put together to cover 2pi in angle along a great circle. This option is meant to be used with the equiangular map option turned on. </td></tr>
    <tr><td class="paramname">with_adapted_equiangular_map</td><td>Determines whether to adapt the point distribution in the wedge to match its physical angular size. When <code>true</code>, angular distances are proportional to logical distances. Note that it is not possible to use adapted maps in every <a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html" title="Map from a square or cube to a wedge.">Wedge</a> of a Sphere unless each <a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html" title="Map from a square or cube to a wedge.">Wedge</a> has the same size along both angular directions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/Domain/CoordinateMaps/Wedge.hpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedomain.html">domain</a></li><li class="navelem"><a class="el" href="namespacedomain_1_1CoordinateMaps.html">CoordinateMaps</a></li><li class="navelem"><a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html">Wedge</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
