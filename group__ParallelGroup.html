<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: Parallelization</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__ParallelGroup.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Parallelization</div></div>
</div><!--header-->
<div class="contents">

<p>Functions, classes and documentation related to parallelization and Charm++.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceParallel_1_1InboxInserters"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParallel_1_1InboxInserters.html">Parallel::InboxInserters</a></td></tr>
<tr class="memdesc:namespaceParallel_1_1InboxInserters"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structs that have <code>insert_into_inbox</code> methods for commonly used cases. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemem__monitor"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem__monitor.html">mem_monitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithmArray.html">AlgorithmArray&lt; ParallelComponent, SpectreArrayIndex &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Spectre algorithm object that wraps a charm++ array chare.  <a href="classAlgorithmArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1Algorithms_1_1Array.html">Parallel::Algorithms::Array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct that stores the charm++ types relevant for a particular array component.  <a href="structParallel_1_1Algorithms_1_1Array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithmGroup.html">AlgorithmGroup&lt; ParallelComponent, SpectreArrayIndex &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Spectre algorithm object that wraps a charm++ group chare.  <a href="classAlgorithmGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1Algorithms_1_1Group.html">Parallel::Algorithms::Group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct that stores the charm++ types relevant for a particular group component.  <a href="structParallel_1_1Algorithms_1_1Group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithmNodegroup.html">AlgorithmNodegroup&lt; ParallelComponent, SpectreArrayIndex &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Spectre algorithm object that wraps a charm++ nodegroup chare.  <a href="classAlgorithmNodegroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1Algorithms_1_1Nodegroup.html">Parallel::Algorithms::Nodegroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct that stores the charm++ types relevant for a particular nodegroup component.  <a href="structParallel_1_1Algorithms_1_1Nodegroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithmSingleton.html">AlgorithmSingleton&lt; ParallelComponent, SpectreArrayIndex &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Spectre algorithm object that wraps a single element charm++ array chare.  <a href="classAlgorithmSingleton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1Algorithms_1_1Singleton.html">Parallel::Algorithms::Singleton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct that stores the charm++ types relevant for a particular singleton component.  <a href="structParallel_1_1Algorithms_1_1Singleton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1ArrayIndex.html">Parallel::ArrayIndex&lt; Index &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array index used for indexing Chare Arrays, mostly an implementation detail.  <a href="structParallel_1_1ArrayIndex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDistributedObject_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html">DistributedObject&lt; ParallelComponent, tmpl::list&lt; PhaseDepActionListsPack... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A distributed object (Charm++ Chare) that executes a series of Actions and is capable of sending and receiving data. Acts as an interface to Charm++.  <a href="classDistributedObject_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1MutableGlobalCache.html">Parallel::MutableGlobalCache&lt; Metavariables &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Charm++ chare that caches mutable data once per Charm++ core.  <a href="classParallel_1_1MutableGlobalCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache&lt; Metavariables &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++ core.  <a href="classParallel_1_1GlobalCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1Tags_1_1GlobalCache.html">Parallel::Tags::GlobalCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag to retrieve the <code><a class="el" href="classParallel_1_1GlobalCache.html" title="A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++...">Parallel::GlobalCache</a></code> from the DataBox.  <a href="structParallel_1_1Tags_1_1GlobalCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1Tags_1_1FromGlobalCache.html">Parallel::Tags::FromGlobalCache&lt; CacheTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag used to retrieve data from the <code><a class="el" href="classParallel_1_1GlobalCache.html" title="A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++...">Parallel::GlobalCache</a></code>. This is the recommended way for compute tags to retrieve data out of the global cache.  <a href="structParallel_1_1Tags_1_1FromGlobalCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1Main.html">Parallel::Main&lt; Metavariables &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main function of a Charm++ executable. See <a href="group__ParallelGroup.html#details">the Parallelization documentation</a> for an overview of Metavariables, Phases, and parallel components.  <a href="classParallel_1_1Main.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1NodeLock.html">Parallel::NodeLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typesafe wrapper for a lock for synchronization of shared resources on a given node, with safe creation, destruction, and serialization.  <a href="classParallel_1_1NodeLock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1PhaseActions.html">Parallel::PhaseActions&lt; Phase, ActionsList &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all the actions to be executed in the specified phase.  <a href="structParallel_1_1PhaseActions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1get__action__list__from__phase__dep__action__list.html">Parallel::get_action_list_from_phase_dep_action_list&lt; PhaseDepActionList &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Lazy) metafunction to get the action list from a <code><a class="el" href="structParallel_1_1PhaseActions.html" title="List of all the actions to be executed in the specified phase.">PhaseActions</a></code>  <a href="structParallel_1_1get__action__list__from__phase__dep__action__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1ReductionDatum.html">Parallel::ReductionDatum&lt; T, InvokeCombine, InvokeFinal, InvokeFinalExtraArgsIndices &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data to be reduced, and invokables to be called whenever two reduction messages are combined and after the reduction has been completed.  <a href="structParallel_1_1ReductionDatum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1ReductionData_3_01ReductionDatum_3_01Ts_00_01InvokeCombines_00_01InvokeFinals_92b572618a1ebe21ccf137654ec822ac.html">Parallel::ReductionData&lt; ReductionDatum&lt; Ts, InvokeCombines, InvokeFinals, InvokeFinalExtraArgsIndices &gt;... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for reducing a possibly heterogeneous collection of types in a single reduction call.  <a href="structParallel_1_1ReductionData_3_01ReductionDatum_3_01Ts_00_01InvokeCombines_00_01InvokeFinals_92b572618a1ebe21ccf137654ec822ac.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1SingletonInfoHolder.html">Parallel::SingletonInfoHolder&lt; Component &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds resource info for a single singleton component.  <a href="structParallel_1_1SingletonInfoHolder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1SingletonPack_3_01tmpl_1_1list_3_01ParallelComponents_8_8_8_01_4_01_4.html">Parallel::SingletonPack&lt; tmpl::list&lt; ParallelComponents... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds options for a group of singleton components.  <a href="structParallel_1_1SingletonPack_3_01tmpl_1_1list_3_01ParallelComponents_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1ResourceInfo.html">Parallel::ResourceInfo&lt; Metavariables &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds resource info for all singletons and for avoiding placing array elements/singletons on the global proc 0.  <a href="structParallel_1_1ResourceInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1Tags_1_1ArrayIndex.html">Parallel::Tags::ArrayIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag to retrieve the <code><a class="el" href="structParallel_1_1Tags_1_1ArrayIndex.html" title="Tag to retrieve the ArrayIndex from the DataBox.">ArrayIndex</a></code> from the DataBox.  <a href="structParallel_1_1Tags_1_1ArrayIndex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1Tags_1_1Metavariables.html">Parallel::Tags::Metavariables</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag to retrieve the <code><a class="el" href="structParallel_1_1Tags_1_1Metavariables.html" title="Tag to retrieve the Metavariables from the DataBox.">Metavariables</a></code> from the DataBox.  <a href="structParallel_1_1Tags_1_1Metavariables.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1OptionTags_1_1ResourceInfo.html">Parallel::OptionTags::ResourceInfo&lt; Metavariables &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceOptions.html" title="Utilities for parsing input files.">Options</a> group for resource allocation.  <a href="structParallel_1_1OptionTags_1_1ResourceInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1Tags_1_1ResourceInfo.html">Parallel::Tags::ResourceInfo&lt; Metavariables &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag to retrieve the <a class="el" href="structParallel_1_1Tags_1_1ResourceInfo.html" title="Tag to retrieve the ResourceInfo.">ResourceInfo</a>.  <a href="structParallel_1_1Tags_1_1ResourceInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__array__proxy.html">Parallel::is_array_proxy&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a Charm++ proxy for an array chare (the entire array)  <a href="structParallel_1_1is__array__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__array__element__proxy.html">Parallel::is_array_element_proxy&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a Charm++ proxy for an array chare element (from indexing into the array chare)  <a href="structParallel_1_1is__array__element__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__group__proxy.html">Parallel::is_group_proxy&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a Charm++ proxy for a group chare.  <a href="structParallel_1_1is__group__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__node__group__proxy.html">Parallel::is_node_group_proxy&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a Charm++ proxy for a node group chare.  <a href="structParallel_1_1is__node__group__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__bound__array.html">Parallel::is_bound_array&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a ParallelComponent for a Charm++ bound array.  <a href="structParallel_1_1is__bound__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__array.html">Parallel::is_array&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a SpECTRE Array.  <a href="structParallel_1_1is__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__singleton.html">Parallel::is_singleton&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a SpECTRE Singleton.  <a href="structParallel_1_1is__singleton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__group.html">Parallel::is_group&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a SpECTRE Group.  <a href="structParallel_1_1is__group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__nodegroup.html">Parallel::is_nodegroup&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a SpECTRE Nodegroup.  <a href="structParallel_1_1is__nodegroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1get__parallel__component__from__proxy.html">Parallel::get_parallel_component_from_proxy&lt; Proxy &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a parallel component from its proxy.  <a href="structParallel_1_1get__parallel__component__from__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1has__pup__member.html">Parallel::has_pup_member&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> has a <code>pup</code> member function.  <a href="structParallel_1_1has__pup__member.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__pupable.html">Parallel::is_pupable&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if type <code>T</code> has operator| defined for Charm++ serialization.  <a href="structParallel_1_1is__pupable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga54770b986b9c522da6d651e1be125a03"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga54770b986b9c522da6d651e1be125a03">WRAPPED_PUPable_decl_template</a>(className)&#160;&#160;&#160;  PUPable_decl_template(SINGLE_ARG(className))</td></tr>
<tr class="memdesc:ga54770b986b9c522da6d651e1be125a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark derived classes as serializable.  <a href="group__ParallelGroup.html#ga54770b986b9c522da6d651e1be125a03">More...</a><br /></td></tr>
<tr class="separator:ga54770b986b9c522da6d651e1be125a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade9eecd27ecadb3501ddae591bf07db0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gade9eecd27ecadb3501ddae591bf07db0">WRAPPED_PUPable_decl_base_template</a>(baseClassName,  className)</td></tr>
<tr class="memdesc:gade9eecd27ecadb3501ddae591bf07db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark derived template classes as serializable.  <a href="group__ParallelGroup.html#gade9eecd27ecadb3501ddae591bf07db0">More...</a><br /></td></tr>
<tr class="separator:gade9eecd27ecadb3501ddae591bf07db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gae918917e798cb6dd36a6cca9ede77616"><td class="memTemplParams" colspan="2"><a id="gae918917e798cb6dd36a6cca9ede77616" name="gae918917e798cb6dd36a6cca9ede77616"></a>
template&lt;class ActionsList &gt; </td></tr>
<tr class="memitem:gae918917e798cb6dd36a6cca9ede77616"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::get_inbox_tags</b> = tmpl::remove_duplicates&lt; tmpl::join&lt; tmpl::transform&lt; ActionsList, detail::get_inbox_tags_from_action&lt; tmpl::_1 &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gae918917e798cb6dd36a6cca9ede77616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of Actions, get a list of the unique inbox tags. <br /></td></tr>
<tr class="separator:gae918917e798cb6dd36a6cca9ede77616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2c3e5b7084f5cb31c8c5cc7595349a6"><td class="memTemplParams" colspan="2"><a id="gab2c3e5b7084f5cb31c8c5cc7595349a6" name="gab2c3e5b7084f5cb31c8c5cc7595349a6"></a>
template&lt;class ActionsList &gt; </td></tr>
<tr class="memitem:gab2c3e5b7084f5cb31c8c5cc7595349a6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::get_const_global_cache_tags_from_actions</b> = tmpl::remove_duplicates&lt; tmpl::join&lt; tmpl::transform&lt; ActionsList, detail::get_const_global_cache_tags_from_parallel_struct&lt; tmpl::_1 &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gab2c3e5b7084f5cb31c8c5cc7595349a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of Actions, get a list of the unique tags specified in the actions' <code>const_global_cache_tags</code> aliases. <br /></td></tr>
<tr class="separator:gab2c3e5b7084f5cb31c8c5cc7595349a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54c47960b4397660c8ece4b63da46558"><td class="memTemplParams" colspan="2"><a id="ga54c47960b4397660c8ece4b63da46558" name="ga54c47960b4397660c8ece4b63da46558"></a>
template&lt;class ActionsList &gt; </td></tr>
<tr class="memitem:ga54c47960b4397660c8ece4b63da46558"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::get_mutable_global_cache_tags_from_actions</b> = tmpl::remove_duplicates&lt; tmpl::join&lt; tmpl::transform&lt; ActionsList, detail::get_mutable_global_cache_tags_from_parallel_struct&lt; tmpl::_1 &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga54c47960b4397660c8ece4b63da46558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of Actions, get a list of the unique tags specified in the actions' <code>mutable_global_cache_tags</code> aliases. <br /></td></tr>
<tr class="separator:ga54c47960b4397660c8ece4b63da46558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03e3053314568ebf144ba895c04ead0e"><td class="memTemplParams" colspan="2"><a id="ga03e3053314568ebf144ba895c04ead0e" name="ga03e3053314568ebf144ba895c04ead0e"></a>
template&lt;typename Metavariables &gt; </td></tr>
<tr class="memitem:ga03e3053314568ebf144ba895c04ead0e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::get_const_global_cache_tags</b> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::list&lt; typename detail::get_const_global_cache_tags_from_parallel_struct&lt; Metavariables &gt;::type, tmpl::transform&lt; typename Metavariables::component_list, detail::get_const_global_cache_tags_from_parallel_struct&lt; tmpl::_1 &gt; &gt;, tmpl::transform&lt; typename Metavariables::component_list, detail::get_const_global_cache_tags_from_pdal&lt; tmpl::_1 &gt; &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga03e3053314568ebf144ba895c04ead0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the metavariables, get a list of the unique tags that will specify the items in the <a class="el" href="classParallel_1_1GlobalCache.html" title="A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++...">GlobalCache</a>. <br /></td></tr>
<tr class="separator:ga03e3053314568ebf144ba895c04ead0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab10d351ad8ecf07b1ec23dbad2e70a3d"><td class="memTemplParams" colspan="2"><a id="gab10d351ad8ecf07b1ec23dbad2e70a3d" name="gab10d351ad8ecf07b1ec23dbad2e70a3d"></a>
template&lt;typename Metavariables &gt; </td></tr>
<tr class="memitem:gab10d351ad8ecf07b1ec23dbad2e70a3d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::get_mutable_global_cache_tags</b> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::list&lt; typename detail::get_mutable_global_cache_tags_from_parallel_struct&lt; Metavariables &gt;::type, tmpl::transform&lt; typename Metavariables::component_list, detail::get_mutable_global_cache_tags_from_parallel_struct&lt; tmpl::_1 &gt; &gt;, tmpl::transform&lt; typename Metavariables::component_list, detail::get_mutable_global_cache_tags_from_pdal&lt; tmpl::_1 &gt; &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gab10d351ad8ecf07b1ec23dbad2e70a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the metavariables, get a list of the unique tags that will specify the mutable items in the <a class="el" href="classParallel_1_1GlobalCache.html" title="A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++...">GlobalCache</a>. <br /></td></tr>
<tr class="separator:gab10d351ad8ecf07b1ec23dbad2e70a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5fb42f8eaf4da2707e32ed37ecf4e66"><td class="memTemplParams" colspan="2"><a id="gac5fb42f8eaf4da2707e32ed37ecf4e66" name="gac5fb42f8eaf4da2707e32ed37ecf4e66"></a>
template&lt;typename PhaseDepActionList &gt; </td></tr>
<tr class="memitem:gac5fb42f8eaf4da2707e32ed37ecf4e66"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::get_initialization_actions_list</b> = tmpl::flatten&lt; tmpl::transform&lt; PhaseDepActionList, detail::get_initialization_actions_list&lt; tmpl::_1 &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gac5fb42f8eaf4da2707e32ed37ecf4e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the phase dependent action list, return the list of actions in the Initialization phase (or an empty list if the Initialization phase is absent from the phase dependent action list) <br /></td></tr>
<tr class="separator:gac5fb42f8eaf4da2707e32ed37ecf4e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c2c630360df51b5cc4cf0f7fda6e87d"><td class="memTemplParams" colspan="2"><a id="ga7c2c630360df51b5cc4cf0f7fda6e87d" name="ga7c2c630360df51b5cc4cf0f7fda6e87d"></a>
template&lt;typename InitializationActionsList &gt; </td></tr>
<tr class="memitem:ga7c2c630360df51b5cc4cf0f7fda6e87d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::get_simple_tags_from_options</b> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::transform&lt; InitializationActionsList, detail::get_simple_tags_from_options_from_action&lt; tmpl::_1 &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga7c2c630360df51b5cc4cf0f7fda6e87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of initialization actions, returns a list of the unique simple_tags_from_options for all the actions. <br /></td></tr>
<tr class="separator:ga7c2c630360df51b5cc4cf0f7fda6e87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a9af2d9b7484c86ea4e9594fd7c8a2f"><td class="memTemplParams" colspan="2"><a id="ga3a9af2d9b7484c86ea4e9594fd7c8a2f" name="ga3a9af2d9b7484c86ea4e9594fd7c8a2f"></a>
template&lt;typename SimpleTagsList , typename Metavariables &gt; </td></tr>
<tr class="memitem:ga3a9af2d9b7484c86ea4e9594fd7c8a2f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::get_option_tags</b> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::transform&lt; SimpleTagsList, tmpl::bind&lt; detail::get_option_tags_from_simple_tag&lt; Metavariables &gt;::template f, tmpl::_1 &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga3a9af2d9b7484c86ea4e9594fd7c8a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of simple tags, returns a list of the unique option tags required to construct them. <br /></td></tr>
<tr class="separator:ga3a9af2d9b7484c86ea4e9594fd7c8a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga027a2e60b10898507f92ba7290f0ba61"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga027a2e60b10898507f92ba7290f0ba61">Parallel::Phase</a> { <br />
&#160;&#160;<a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a87d39a9f8e226843f84e237b180ae012">Parallel::Phase::AdjustDomain</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a5b047d61130e0b2918cd1e9952abac77">Parallel::Phase::CheckDomain</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a8c6384dda98d8864d00e29dc96179970">Parallel::Phase::Cleanup</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61ad1365ec133a9a3d4195808473ef742d4">Parallel::Phase::EvaluateAmrCriteria</a>
, <br />
&#160;&#160;<a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a022b83d0b2bb2af3709c384b36e7ce2b">Parallel::Phase::Evolve</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a40cd014b7b6251e3a22e6a45a73a64e1">Parallel::Phase::Execute</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61afef46e5063ce3dc78b8ae64fa474241d">Parallel::Phase::Exit</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a0fff9cc14992a69d78edc10a85206c01">Parallel::Phase::ImportInitialData</a>
, <br />
&#160;&#160;<a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a61bcd96a2c1f8026527cbf2019d6e9a4">Parallel::Phase::Initialization</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61ab0fc63355327fdd0b60d600564afcc63">Parallel::Phase::InitializeInitialDataDependentQuantities</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a8c04c19a8219116bb54698ec3a8544c2">Parallel::Phase::InitializeTimeStepperHistory</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a5fb96ac8b4e030b4e88bd71b95460d02">Parallel::Phase::LoadBalancing</a>
, <br />
&#160;&#160;<a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a03777d3c99bd348b67be0944927faeee">Parallel::Phase::PostFailureCleanup</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a0ba7583639a274c434bbe6ef797115a4">Parallel::Phase::Register</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a303602e6afb9f2d4b528497410bdec47">Parallel::Phase::RegisterWithElementDataReader</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a97817e0979af8f0291365165b76a45b5">Parallel::Phase::Solve</a>
, <br />
&#160;&#160;<a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61afa6a5a3224d7da66d9e0bdec25f62cf0">Parallel::Phase::Testing</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a667488c55c3abca96b02755bfe193681">Parallel::Phase::WriteCheckpoint</a>
<br />
 }</td></tr>
<tr class="memdesc:ga027a2e60b10898507f92ba7290f0ba61"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible phases of an executable.  <a href="group__ParallelGroup.html#ga027a2e60b10898507f92ba7290f0ba61">More...</a><br /></td></tr>
<tr class="separator:ga027a2e60b10898507f92ba7290f0ba61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaed29f7ca4a887fbbea9e55d94f7674cd"><td class="memTemplParams" colspan="2"><a id="gaed29f7ca4a887fbbea9e55d94f7674cd" name="gaed29f7ca4a887fbbea9e55d94f7674cd"></a>
template&lt;typename Metavariables , typename... Tags, typename... OptionTags&gt; </td></tr>
<tr class="memitem:gaed29f7ca4a887fbbea9e55d94f7674cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; Tags... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::create_from_options</b> (const <a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; OptionTags... &gt; &amp;options, tmpl::list&lt; Tags... &gt;)</td></tr>
<tr class="memdesc:gaed29f7ca4a887fbbea9e55d94f7674cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of tags and a tagged tuple containing items created from input options, return a tagged tuple of items constructed by calls to create_from_options for each tag in the list. <br /></td></tr>
<tr class="separator:gaed29f7ca4a887fbbea9e55d94f7674cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga602c224997d604c7741c21dd4138e29d"><td class="memTemplParams" colspan="2"><a id="ga602c224997d604c7741c21dd4138e29d" name="ga602c224997d604c7741c21dd4138e29d"></a>
template&lt;typename T , typename DistribObject &gt; </td></tr>
<tr class="memitem:ga602c224997d604c7741c21dd4138e29d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::number_of_procs</b> (const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:ga602c224997d604c7741c21dd4138e29d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of processing elements. <br /></td></tr>
<tr class="separator:ga602c224997d604c7741c21dd4138e29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf89c583112f5be12c618a0ec2fc0cfb"><td class="memTemplParams" colspan="2"><a id="gadf89c583112f5be12c618a0ec2fc0cfb" name="gadf89c583112f5be12c618a0ec2fc0cfb"></a>
template&lt;typename T , typename DistribObject &gt; </td></tr>
<tr class="memitem:gadf89c583112f5be12c618a0ec2fc0cfb"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::my_proc</b> (const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:gadf89c583112f5be12c618a0ec2fc0cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of my processing element. <br /></td></tr>
<tr class="separator:gadf89c583112f5be12c618a0ec2fc0cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf79215bb2d12770fdbd2ad6c3cec91a8"><td class="memTemplParams" colspan="2"><a id="gaf79215bb2d12770fdbd2ad6c3cec91a8" name="gaf79215bb2d12770fdbd2ad6c3cec91a8"></a>
template&lt;typename T , typename DistribObject &gt; </td></tr>
<tr class="memitem:gaf79215bb2d12770fdbd2ad6c3cec91a8"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::number_of_nodes</b> (const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:gaf79215bb2d12770fdbd2ad6c3cec91a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes. <br /></td></tr>
<tr class="separator:gaf79215bb2d12770fdbd2ad6c3cec91a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad03ed6d71aee72251a19eb2c7d25b621"><td class="memTemplParams" colspan="2"><a id="gad03ed6d71aee72251a19eb2c7d25b621" name="gad03ed6d71aee72251a19eb2c7d25b621"></a>
template&lt;typename T , typename DistribObject &gt; </td></tr>
<tr class="memitem:gad03ed6d71aee72251a19eb2c7d25b621"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::my_node</b> (const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:gad03ed6d71aee72251a19eb2c7d25b621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of my node. <br /></td></tr>
<tr class="separator:gad03ed6d71aee72251a19eb2c7d25b621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga360db89dbc73353e6bf4c484db619403"><td class="memTemplParams" colspan="2"><a id="ga360db89dbc73353e6bf4c484db619403" name="ga360db89dbc73353e6bf4c484db619403"></a>
template&lt;typename T , typename R , typename DistribObject &gt; </td></tr>
<tr class="memitem:ga360db89dbc73353e6bf4c484db619403"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::procs_on_node</b> (const R node_index, const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:ga360db89dbc73353e6bf4c484db619403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of processing elements on the given node. <br /></td></tr>
<tr class="separator:ga360db89dbc73353e6bf4c484db619403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76a1e2bd8f33a1eb980b4eae811c0575"><td class="memTemplParams" colspan="2"><a id="ga76a1e2bd8f33a1eb980b4eae811c0575" name="ga76a1e2bd8f33a1eb980b4eae811c0575"></a>
template&lt;typename T , typename DistribObject &gt; </td></tr>
<tr class="memitem:ga76a1e2bd8f33a1eb980b4eae811c0575"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::my_local_rank</b> (const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:ga76a1e2bd8f33a1eb980b4eae811c0575"><td class="mdescLeft">&#160;</td><td class="mdescRight">The local index of my processing element on my node. This is in the interval 0, ..., procs_on_node(my_node()) - 1. <br /></td></tr>
<tr class="separator:ga76a1e2bd8f33a1eb980b4eae811c0575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga004b55d123b4f2541b38c16c195c07d1"><td class="memTemplParams" colspan="2"><a id="ga004b55d123b4f2541b38c16c195c07d1" name="ga004b55d123b4f2541b38c16c195c07d1"></a>
template&lt;typename T , typename R , typename DistribObject &gt; </td></tr>
<tr class="memitem:ga004b55d123b4f2541b38c16c195c07d1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::first_proc_on_node</b> (const R node_index, const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:ga004b55d123b4f2541b38c16c195c07d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of first processing element on the given node. <br /></td></tr>
<tr class="separator:ga004b55d123b4f2541b38c16c195c07d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga224caf730591903abf339e9f551adddc"><td class="memTemplParams" colspan="2"><a id="ga224caf730591903abf339e9f551adddc" name="ga224caf730591903abf339e9f551adddc"></a>
template&lt;typename T , typename R , typename DistribObject &gt; </td></tr>
<tr class="memitem:ga224caf730591903abf339e9f551adddc"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::node_of</b> (const R proc_index, const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:ga224caf730591903abf339e9f551adddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the node for the given processing element. <br /></td></tr>
<tr class="separator:ga224caf730591903abf339e9f551adddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbdc7feb7a9dfc90022976465b747d8c"><td class="memTemplParams" colspan="2"><a id="gafbdc7feb7a9dfc90022976465b747d8c" name="gafbdc7feb7a9dfc90022976465b747d8c"></a>
template&lt;typename T , typename R , typename DistribObject &gt; </td></tr>
<tr class="memitem:gafbdc7feb7a9dfc90022976465b747d8c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::local_rank_of</b> (const R proc_index, const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:gafbdc7feb7a9dfc90022976465b747d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The local index for the given processing element on its node. <br /></td></tr>
<tr class="separator:gafbdc7feb7a9dfc90022976465b747d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1078fa99233851c6475fbfa99a2f51d"><td class="memTemplParams" colspan="2">template&lt;typename ReceiveTag , typename Proxy , typename ReceiveDataType &gt; </td></tr>
<tr class="memitem:gad1078fa99233851c6475fbfa99a2f51d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gad1078fa99233851c6475fbfa99a2f51d">Parallel::receive_data</a> (Proxy &amp;&amp;proxy, typename ReceiveTag::temporal_id temporal_id, ReceiveDataType &amp;&amp;receive_data, const bool enable_if_disabled=false)</td></tr>
<tr class="memdesc:gad1078fa99233851c6475fbfa99a2f51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the data <code>args...</code> to the algorithm running on <code>proxy</code>, and tag the message with the identifier <code>temporal_id</code>.  <a href="group__ParallelGroup.html#gad1078fa99233851c6475fbfa99a2f51d">More...</a><br /></td></tr>
<tr class="separator:gad1078fa99233851c6475fbfa99a2f51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49aa2598782609c76503c8523e0f20f1"><td class="memTemplParams" colspan="2">template&lt;typename ReceiveTag , typename Proxy , typename MessageType &gt; </td></tr>
<tr class="memitem:ga49aa2598782609c76503c8523e0f20f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga49aa2598782609c76503c8523e0f20f1">Parallel::receive_data</a> (Proxy &amp;&amp;proxy, MessageType *message)</td></tr>
<tr class="memdesc:ga49aa2598782609c76503c8523e0f20f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a pointer <code>message</code> to the algorithm running on <code>proxy</code>.  <a href="group__ParallelGroup.html#ga49aa2598782609c76503c8523e0f20f1">More...</a><br /></td></tr>
<tr class="separator:ga49aa2598782609c76503c8523e0f20f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabed954105c6dfd7cc13d07dbcb0504b1"><td class="memTemplParams" colspan="2"><a id="gabed954105c6dfd7cc13d07dbcb0504b1" name="gabed954105c6dfd7cc13d07dbcb0504b1"></a>
template&lt;typename Action , typename Proxy , typename... Args&gt; </td></tr>
<tr class="memitem:gabed954105c6dfd7cc13d07dbcb0504b1"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::local_synchronous_action</b> (Proxy &amp;&amp;proxy, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gabed954105c6dfd7cc13d07dbcb0504b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a local synchronous action on <code>proxy</code> <br /></td></tr>
<tr class="separator:gabed954105c6dfd7cc13d07dbcb0504b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae21964b5d28608afd21ae090c1c4c073"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:gae21964b5d28608afd21ae090c1c4c073"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gae21964b5d28608afd21ae090c1c4c073">Parallel::printf</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;format, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gae21964b5d28608afd21ae090c1c4c073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an atomic message to stdout with C printf usage.  <a href="group__ParallelGroup.html#gae21964b5d28608afd21ae090c1c4c073">More...</a><br /></td></tr>
<tr class="separator:gae21964b5d28608afd21ae090c1c4c073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8448205dbaf9741505bd30dfad2cadc"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:gaa8448205dbaf9741505bd30dfad2cadc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gaa8448205dbaf9741505bd30dfad2cadc">Parallel::printf_error</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;format, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gaa8448205dbaf9741505bd30dfad2cadc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an atomic message to stderr with C printf usage.  <a href="group__ParallelGroup.html#gaa8448205dbaf9741505bd30dfad2cadc">More...</a><br /></td></tr>
<tr class="separator:gaa8448205dbaf9741505bd30dfad2cadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga893fa42fabb3cb7273cfdd7348e9a75d"><td class="memTemplParams" colspan="2">template&lt;class Action , class SenderProxy , class TargetProxy , class... Ts, class SectionType  = NoSection&gt; </td></tr>
<tr class="memitem:ga893fa42fabb3cb7273cfdd7348e9a75d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga893fa42fabb3cb7273cfdd7348e9a75d">Parallel::contribute_to_reduction</a> (ReductionData&lt; Ts... &gt; reduction_data, const SenderProxy &amp;sender_component, const TargetProxy &amp;target_component, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; SectionType * &gt; section=&amp;no_section())</td></tr>
<tr class="memdesc:ga893fa42fabb3cb7273cfdd7348e9a75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a reduction from the <code>sender_component</code> (typically your own parallel component) to the <code>target_component</code>, performing the <code>Action</code> upon receiving the reduction.  <a href="group__ParallelGroup.html#ga893fa42fabb3cb7273cfdd7348e9a75d">More...</a><br /></td></tr>
<tr class="separator:ga893fa42fabb3cb7273cfdd7348e9a75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4af821f3513f6b4c04e2a1419f486408"><td class="memTemplParams" colspan="2"><a id="ga4af821f3513f6b4c04e2a1419f486408" name="ga4af821f3513f6b4c04e2a1419f486408"></a>
template&lt;typename K , typename T , typename C &gt; </td></tr>
<tr class="memitem:ga4af821f3513f6b4c04e2a1419f486408"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pup_override</b> (PUP::er &amp;p, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>&lt; K, T, C &gt; &amp;m)</td></tr>
<tr class="memdesc:ga4af821f3513f6b4c04e2a1419f486408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary serialization function for a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a></code> with a comparator to circumvent a charm bug. <br /></td></tr>
<tr class="separator:ga4af821f3513f6b4c04e2a1419f486408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga313d201814db8c6e1c64fce9384276a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga313d201814db8c6e1c64fce9384276a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; char &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga313d201814db8c6e1c64fce9384276a3">serialize</a> (const T &amp;obj)</td></tr>
<tr class="memdesc:ga313d201814db8c6e1c64fce9384276a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize an object using PUP.  <a href="group__ParallelGroup.html#ga313d201814db8c6e1c64fce9384276a3">More...</a><br /></td></tr>
<tr class="separator:ga313d201814db8c6e1c64fce9384276a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fb3864413e851ea6dcd1ffa319f2f25"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6fb3864413e851ea6dcd1ffa319f2f25"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga6fb3864413e851ea6dcd1ffa319f2f25">deserialize</a> (const void *const data)</td></tr>
<tr class="memdesc:ga6fb3864413e851ea6dcd1ffa319f2f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize an object using PUP.  <a href="group__ParallelGroup.html#ga6fb3864413e851ea6dcd1ffa319f2f25">More...</a><br /></td></tr>
<tr class="separator:ga6fb3864413e851ea6dcd1ffa319f2f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3479433cebc81e70d646c6c755b47e1d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3479433cebc81e70d646c6c755b47e1d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga3479433cebc81e70d646c6c755b47e1d">deserialize</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; T * &gt; result, const void *const data)</td></tr>
<tr class="memdesc:ga3479433cebc81e70d646c6c755b47e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize an object using PUP.  <a href="group__ParallelGroup.html#ga3479433cebc81e70d646c6c755b47e1d">More...</a><br /></td></tr>
<tr class="separator:ga3479433cebc81e70d646c6c755b47e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabce21d948afe33c077e1e1122b971bbe"><td class="memTemplParams" colspan="2"><a id="gabce21d948afe33c077e1e1122b971bbe" name="gabce21d948afe33c077e1e1122b971bbe"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gabce21d948afe33c077e1e1122b971bbe"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>size_of_object_in_bytes</b> (const T &amp;obj)</td></tr>
<tr class="memdesc:gabce21d948afe33c077e1e1122b971bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of an object in bytes. <br /></td></tr>
<tr class="separator:gabce21d948afe33c077e1e1122b971bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga6794d6d662e9f601ebdbd8528536ead1"><td class="memTemplParams" colspan="2">template&lt;typename Metavariables , typename Tag &gt; </td></tr>
<tr class="memitem:ga6794d6d662e9f601ebdbd8528536ead1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga6794d6d662e9f601ebdbd8528536ead1">Parallel::is_in_const_global_cache</a></td></tr>
<tr class="memdesc:ga6794d6d662e9f601ebdbd8528536ead1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a tag is retrievable from the const portion of the global cache.  <a href="group__ParallelGroup.html#ga6794d6d662e9f601ebdbd8528536ead1">More...</a><br /></td></tr>
<tr class="separator:ga6794d6d662e9f601ebdbd8528536ead1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f79ab2930d68c2050849ff60f80f162"><td class="memTemplParams" colspan="2">template&lt;typename Metavariables , typename Tag &gt; </td></tr>
<tr class="memitem:ga6f79ab2930d68c2050849ff60f80f162"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga6f79ab2930d68c2050849ff60f80f162">Parallel::is_in_mutable_global_cache</a></td></tr>
<tr class="memdesc:ga6f79ab2930d68c2050849ff60f80f162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a tag is retrievable from the mutable portion of the global cache.  <a href="group__ParallelGroup.html#ga6f79ab2930d68c2050849ff60f80f162">More...</a><br /></td></tr>
<tr class="separator:ga6f79ab2930d68c2050849ff60f80f162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga118c900b55b0e55a8d11cef00c77bd2d"><td class="memTemplParams" colspan="2">template&lt;typename Metavariables , typename Tag &gt; </td></tr>
<tr class="memitem:ga118c900b55b0e55a8d11cef00c77bd2d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga118c900b55b0e55a8d11cef00c77bd2d">Parallel::is_in_global_cache</a></td></tr>
<tr class="memdesc:ga118c900b55b0e55a8d11cef00c77bd2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a tag is retrievable from the global cache.  <a href="group__ParallelGroup.html#ga118c900b55b0e55a8d11cef00c77bd2d">More...</a><br /></td></tr>
<tr class="separator:ga118c900b55b0e55a8d11cef00c77bd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeee02b1e4faf8051fe703e6b9adada0f"><td class="memTemplParams" colspan="2">template&lt;typename ParallelComponentTag , typename Metavariables &gt; </td></tr>
<tr class="memitem:gaeee02b1e4faf8051fe703e6b9adada0f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gaeee02b1e4faf8051fe703e6b9adada0f">Parallel::get_parallel_component</a> (<a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;cache) -&gt; Parallel::proxy_from_parallel_component&lt; GlobalCache_detail::get_component_if_mocked&lt; typename Metavariables::component_list, ParallelComponentTag &gt; &gt; &amp;</td></tr>
<tr class="memdesc:gaeee02b1e4faf8051fe703e6b9adada0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the Charm++ proxy associated with a ParallelComponent.  <a href="group__ParallelGroup.html#gaeee02b1e4faf8051fe703e6b9adada0f">More...</a><br /></td></tr>
<tr class="separator:gaeee02b1e4faf8051fe703e6b9adada0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c24e9812c22ee923354a3906e50f296"><td class="memTemplParams" colspan="2">template&lt;typename ParallelComponentTag , typename Metavariables &gt; </td></tr>
<tr class="memitem:ga8c24e9812c22ee923354a3906e50f296"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga8c24e9812c22ee923354a3906e50f296">Parallel::get_parallel_component</a> (const <a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;cache) -&gt; const Parallel::proxy_from_parallel_component&lt; GlobalCache_detail::get_component_if_mocked&lt; typename Metavariables::component_list, ParallelComponentTag &gt; &gt; &amp;</td></tr>
<tr class="memdesc:ga8c24e9812c22ee923354a3906e50f296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the Charm++ proxy associated with a ParallelComponent.  <a href="group__ParallelGroup.html#ga8c24e9812c22ee923354a3906e50f296">More...</a><br /></td></tr>
<tr class="separator:ga8c24e9812c22ee923354a3906e50f296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43c98b994ca4a6ef61235109c5b94e14"><td class="memTemplParams" colspan="2">template&lt;typename GlobalCacheTag , typename Metavariables &gt; </td></tr>
<tr class="memitem:ga43c98b994ca4a6ef61235109c5b94e14"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga43c98b994ca4a6ef61235109c5b94e14">Parallel::get</a> (const <a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;cache) -&gt; const GlobalCache_detail::type_for_get&lt; GlobalCacheTag, Metavariables &gt; &amp;</td></tr>
<tr class="memdesc:ga43c98b994ca4a6ef61235109c5b94e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access data in the cache.  <a href="group__ParallelGroup.html#ga43c98b994ca4a6ef61235109c5b94e14">More...</a><br /></td></tr>
<tr class="separator:ga43c98b994ca4a6ef61235109c5b94e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee973d82ab6a1dbac2b504e86d8de2e5"><td class="memTemplParams" colspan="2">template&lt;typename GlobalCacheTag , typename Function , typename Metavariables &gt; </td></tr>
<tr class="memitem:gaee973d82ab6a1dbac2b504e86d8de2e5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gaee973d82ab6a1dbac2b504e86d8de2e5">Parallel::mutable_cache_item_is_ready</a> (<a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;cache, const Function &amp;function)</td></tr>
<tr class="memdesc:gaee973d82ab6a1dbac2b504e86d8de2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the object identified by <code>GlobalCacheTag</code> is ready to be accessed by <code>get</code>.  <a href="group__ParallelGroup.html#gaee973d82ab6a1dbac2b504e86d8de2e5">More...</a><br /></td></tr>
<tr class="separator:gaee973d82ab6a1dbac2b504e86d8de2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fb8fc6f30581c450abecc8258dead3c"><td class="memTemplParams" colspan="2">template&lt;typename GlobalCacheTag , typename Function , typename Metavariables , typename... Args&gt; </td></tr>
<tr class="memitem:ga8fb8fc6f30581c450abecc8258dead3c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga8fb8fc6f30581c450abecc8258dead3c">Parallel::mutate</a> (<a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;cache, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga8fb8fc6f30581c450abecc8258dead3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutates non-const data in the cache, by calling <code>Function::apply()</code>  <a href="group__ParallelGroup.html#ga8fb8fc6f30581c450abecc8258dead3c">More...</a><br /></td></tr>
<tr class="separator:ga8fb8fc6f30581c450abecc8258dead3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1902e18e22b3092208b8dd9f0e5f11c0"><td class="memTemplParams" colspan="2"><a id="ga1902e18e22b3092208b8dd9f0e5f11c0" name="ga1902e18e22b3092208b8dd9f0e5f11c0"></a>
template&lt;typename Action , typename Proxy &gt; </td></tr>
<tr class="memitem:ga1902e18e22b3092208b8dd9f0e5f11c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::simple_action</b> (Proxy &amp;&amp;proxy)</td></tr>
<tr class="memdesc:ga1902e18e22b3092208b8dd9f0e5f11c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a simple action on <code>proxy</code> <br /></td></tr>
<tr class="separator:ga1902e18e22b3092208b8dd9f0e5f11c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e9708c581cfd958746b601be4a03eb5"><td class="memTemplParams" colspan="2"><a id="ga8e9708c581cfd958746b601be4a03eb5" name="ga8e9708c581cfd958746b601be4a03eb5"></a>
template&lt;typename Action , typename Proxy , typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:ga8e9708c581cfd958746b601be4a03eb5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::simple_action</b> (Proxy &amp;&amp;proxy, Arg0 &amp;&amp;arg0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga8e9708c581cfd958746b601be4a03eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a simple action on <code>proxy</code> <br /></td></tr>
<tr class="separator:ga8e9708c581cfd958746b601be4a03eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49eb59320a0258c95d58b1447ff8702b"><td class="memTemplParams" colspan="2"><a id="ga49eb59320a0258c95d58b1447ff8702b" name="ga49eb59320a0258c95d58b1447ff8702b"></a>
template&lt;typename Action , typename Proxy &gt; </td></tr>
<tr class="memitem:ga49eb59320a0258c95d58b1447ff8702b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::threaded_action</b> (Proxy &amp;&amp;proxy)</td></tr>
<tr class="memdesc:ga49eb59320a0258c95d58b1447ff8702b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a threaded action on <code>proxy</code>, where the proxy must be a nodegroup. <br /></td></tr>
<tr class="separator:ga49eb59320a0258c95d58b1447ff8702b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga942169b97926623cb569158e724e62e0"><td class="memTemplParams" colspan="2"><a id="ga942169b97926623cb569158e724e62e0" name="ga942169b97926623cb569158e724e62e0"></a>
template&lt;typename Action , typename Proxy , typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:ga942169b97926623cb569158e724e62e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::threaded_action</b> (Proxy &amp;&amp;proxy, Arg0 &amp;&amp;arg0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga942169b97926623cb569158e724e62e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a threaded action on <code>proxy</code>, where the proxy must be a nodegroup. <br /></td></tr>
<tr class="separator:ga942169b97926623cb569158e724e62e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Functions, classes and documentation related to parallelization and Charm++. </p>
<p >See <a class="el" href="dev_guide_parallelization_foundations.html">Parallelization infrastructure</a> for details. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gade9eecd27ecadb3501ddae591bf07db0" name="gade9eecd27ecadb3501ddae591bf07db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade9eecd27ecadb3501ddae591bf07db0">&#9670;&nbsp;</a></span>WRAPPED_PUPable_decl_base_template</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WRAPPED_PUPable_decl_base_template</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">baseClassName, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">className&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  PUPable_decl_base_template(SINGLE_ARG(baseClassName), <span class="comment">/* NOLINT */</span> \</div>
<div class="line">                             SINGLE_ARG(className))</div>
</div><!-- fragment -->
<p>Mark derived template classes as serializable. </p>
<p >Any class that inherits from an abstract base class where the base class is a template class must contain this macro if it is to be serialized. </p>

</div>
</div>
<a id="ga54770b986b9c522da6d651e1be125a03" name="ga54770b986b9c522da6d651e1be125a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54770b986b9c522da6d651e1be125a03">&#9670;&nbsp;</a></span>WRAPPED_PUPable_decl_template</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WRAPPED_PUPable_decl_template</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">className</td><td>)</td>
          <td>&#160;&#160;&#160;  PUPable_decl_template(SINGLE_ARG(className))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark derived classes as serializable. </p>
<p >Any class that inherits from an abstract base class where the base class is not a template class must contain this macro if it is to be serialized. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga027a2e60b10898507f92ba7290f0ba61" name="ga027a2e60b10898507f92ba7290f0ba61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga027a2e60b10898507f92ba7290f0ba61">&#9670;&nbsp;</a></span>Phase</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="group__ParallelGroup.html#ga027a2e60b10898507f92ba7290f0ba61">Parallel::Phase</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The possible phases of an executable. </p>
<h3>Details</h3>
<p >Spectre executables are split into distinct phases separated by global synchronizations. Each executable will start with phase <code>Initialization</code> and end with phase <code>Exit</code>. The metavariables of each executable must define <code>default_phase_order</code>, an array of <a class="el" href="group__ParallelGroup.html#ga027a2e60b10898507f92ba7290f0ba61" title="The possible phases of an executable.">Parallel::Phase</a> that must contain at least <code>Initialization</code> as the first element and <code>Exit</code> as the last element. Usually the next phase is determined from the <code>default_phase_order</code> provided by the metavariables. If more complex decision making is desired, use the <a class="el" href="namespacePhaseControl.html" title="Contains utilities for determining control-flow among phases.">PhaseControl</a> infrastructure.</p>
<dl class="section warning"><dt>Warning</dt><dd>The phases are in alphabetical order. Do not use the values of the underlying integral type as they will change as new phases are added to the list!</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structPhaseChange.html" title="PhaseChange objects determine the storage types and logic for moving between phases based on runtime ...">PhaseChange</a> and <a class="el" href="dev_guide_parallelization_foundations.html">Parallelization infrastructure</a> for details. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga027a2e60b10898507f92ba7290f0ba61a87d39a9f8e226843f84e237b180ae012" name="gga027a2e60b10898507f92ba7290f0ba61a87d39a9f8e226843f84e237b180ae012"></a>AdjustDomain&#160;</td><td class="fielddoc"><p >phase in which AMR adjusts the domain </p>
</td></tr>
<tr><td class="fieldname"><a id="gga027a2e60b10898507f92ba7290f0ba61a5b047d61130e0b2918cd1e9952abac77" name="gga027a2e60b10898507f92ba7290f0ba61a5b047d61130e0b2918cd1e9952abac77"></a>CheckDomain&#160;</td><td class="fielddoc"><p >phase in which sanity checks are done after AMR </p>
</td></tr>
<tr><td class="fieldname"><a id="gga027a2e60b10898507f92ba7290f0ba61a8c6384dda98d8864d00e29dc96179970" name="gga027a2e60b10898507f92ba7290f0ba61a8c6384dda98d8864d00e29dc96179970"></a>Cleanup&#160;</td><td class="fielddoc"><p >a cleanup phase </p>
</td></tr>
<tr><td class="fieldname"><a id="gga027a2e60b10898507f92ba7290f0ba61ad1365ec133a9a3d4195808473ef742d4" name="gga027a2e60b10898507f92ba7290f0ba61ad1365ec133a9a3d4195808473ef742d4"></a>EvaluateAmrCriteria&#160;</td><td class="fielddoc"><p >phase in which AMR criteria are evaluated </p>
</td></tr>
<tr><td class="fieldname"><a id="gga027a2e60b10898507f92ba7290f0ba61a022b83d0b2bb2af3709c384b36e7ce2b" name="gga027a2e60b10898507f92ba7290f0ba61a022b83d0b2bb2af3709c384b36e7ce2b"></a>Evolve&#160;</td><td class="fielddoc"><p >phase in which time steps are taken for an evolution executable </p>
</td></tr>
<tr><td class="fieldname"><a id="gga027a2e60b10898507f92ba7290f0ba61a40cd014b7b6251e3a22e6a45a73a64e1" name="gga027a2e60b10898507f92ba7290f0ba61a40cd014b7b6251e3a22e6a45a73a64e1"></a>Execute&#160;</td><td class="fielddoc"><p >generic execution phase of an executable </p>
</td></tr>
<tr><td class="fieldname"><a id="gga027a2e60b10898507f92ba7290f0ba61afef46e5063ce3dc78b8ae64fa474241d" name="gga027a2e60b10898507f92ba7290f0ba61afef46e5063ce3dc78b8ae64fa474241d"></a>Exit&#160;</td><td class="fielddoc"><p >final phase of an executable </p>
</td></tr>
<tr><td class="fieldname"><a id="gga027a2e60b10898507f92ba7290f0ba61a0fff9cc14992a69d78edc10a85206c01" name="gga027a2e60b10898507f92ba7290f0ba61a0fff9cc14992a69d78edc10a85206c01"></a>ImportInitialData&#160;</td><td class="fielddoc"><p >phase in which initial data is imported from volume files </p>
</td></tr>
<tr><td class="fieldname"><a id="gga027a2e60b10898507f92ba7290f0ba61a61bcd96a2c1f8026527cbf2019d6e9a4" name="gga027a2e60b10898507f92ba7290f0ba61a61bcd96a2c1f8026527cbf2019d6e9a4"></a>Initialization&#160;</td><td class="fielddoc"><p >initial phase of an executable </p>
</td></tr>
<tr><td class="fieldname"><a id="gga027a2e60b10898507f92ba7290f0ba61ab0fc63355327fdd0b60d600564afcc63" name="gga027a2e60b10898507f92ba7290f0ba61ab0fc63355327fdd0b60d600564afcc63"></a>InitializeInitialDataDependentQuantities&#160;</td><td class="fielddoc"><p >phase in which quantities dependent on imported initial data are initialized </p>
</td></tr>
<tr><td class="fieldname"><a id="gga027a2e60b10898507f92ba7290f0ba61a8c04c19a8219116bb54698ec3a8544c2" name="gga027a2e60b10898507f92ba7290f0ba61a8c04c19a8219116bb54698ec3a8544c2"></a>InitializeTimeStepperHistory&#160;</td><td class="fielddoc"><p >phase in which the time stepper executes a self-start procedure </p>
</td></tr>
<tr><td class="fieldname"><a id="gga027a2e60b10898507f92ba7290f0ba61a5fb96ac8b4e030b4e88bd71b95460d02" name="gga027a2e60b10898507f92ba7290f0ba61a5fb96ac8b4e030b4e88bd71b95460d02"></a>LoadBalancing&#160;</td><td class="fielddoc"><p >phase in which components are migrated </p>
</td></tr>
<tr><td class="fieldname"><a id="gga027a2e60b10898507f92ba7290f0ba61a03777d3c99bd348b67be0944927faeee" name="gga027a2e60b10898507f92ba7290f0ba61a03777d3c99bd348b67be0944927faeee"></a>PostFailureCleanup&#160;</td><td class="fielddoc"><p >phase in which components know an error occurred and they need to do some sort of cleanup, such as dumping data to disk. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga027a2e60b10898507f92ba7290f0ba61a0ba7583639a274c434bbe6ef797115a4" name="gga027a2e60b10898507f92ba7290f0ba61a0ba7583639a274c434bbe6ef797115a4"></a>Register&#160;</td><td class="fielddoc"><p >phase in which components register with other components </p>
</td></tr>
<tr><td class="fieldname"><a id="gga027a2e60b10898507f92ba7290f0ba61a303602e6afb9f2d4b528497410bdec47" name="gga027a2e60b10898507f92ba7290f0ba61a303602e6afb9f2d4b528497410bdec47"></a>RegisterWithElementDataReader&#160;</td><td class="fielddoc"><p >phase in which components register with the data importer components </p>
</td></tr>
<tr><td class="fieldname"><a id="gga027a2e60b10898507f92ba7290f0ba61a97817e0979af8f0291365165b76a45b5" name="gga027a2e60b10898507f92ba7290f0ba61a97817e0979af8f0291365165b76a45b5"></a>Solve&#160;</td><td class="fielddoc"><p >phase in which something is solved </p>
</td></tr>
<tr><td class="fieldname"><a id="gga027a2e60b10898507f92ba7290f0ba61afa6a5a3224d7da66d9e0bdec25f62cf0" name="gga027a2e60b10898507f92ba7290f0ba61afa6a5a3224d7da66d9e0bdec25f62cf0"></a>Testing&#160;</td><td class="fielddoc"><p >phase in which something is tested </p>
</td></tr>
<tr><td class="fieldname"><a id="gga027a2e60b10898507f92ba7290f0ba61a667488c55c3abca96b02755bfe193681" name="gga027a2e60b10898507f92ba7290f0ba61a667488c55c3abca96b02755bfe193681"></a>WriteCheckpoint&#160;</td><td class="fielddoc"><p >phase in which checkpoint files are written to disk </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga893fa42fabb3cb7273cfdd7348e9a75d" name="ga893fa42fabb3cb7273cfdd7348e9a75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga893fa42fabb3cb7273cfdd7348e9a75d">&#9670;&nbsp;</a></span>contribute_to_reduction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Action , class SenderProxy , class TargetProxy , class... Ts, class SectionType  = NoSection&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::contribute_to_reduction </td>
          <td>(</td>
          <td class="paramtype">ReductionData&lt; Ts... &gt;&#160;</td>
          <td class="paramname"><em>reduction_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SenderProxy &amp;&#160;</td>
          <td class="paramname"><em>sender_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TargetProxy &amp;&#160;</td>
          <td class="paramname"><em>target_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; SectionType * &gt;&#160;</td>
          <td class="paramname"><em>section</em> = <code>&amp;no_section()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a reduction from the <code>sender_component</code> (typically your own parallel component) to the <code>target_component</code>, performing the <code>Action</code> upon receiving the reduction. </p>
<dl class="section user"><dt>Section reductions</dt><dd>This function supports section reductions (see <code><a class="el" href="structParallel_1_1Section.html" title="A subset of chares in a parallel component.">Parallel::Section</a></code>). Pass the <code><a class="el" href="structParallel_1_1Section.html" title="A subset of chares in a parallel component.">Parallel::Section</a></code> as the <code>section</code> argument, or pass <code>Parallel::no_section()</code> to perform a reduction over the entire parallel component (default). Here's an example of a section reduction:</dd></dl>
<div class="fragment"><div class="line">    <span class="keyword">auto</span>&amp; array_section = <a class="code hl_function" href="group__DataBoxGroup.html#gac94b70fab454bd5ae3b218f0ed182684">db::get_mutable_reference</a>&lt;</div>
<div class="line">        <a class="code hl_struct" href="structParallel_1_1Tags_1_1Section.html">Parallel::Tags::Section&lt;ParallelComponent, ArraySectionIdTag&gt;</a>&gt;(</div>
<div class="line">        make_not_null(&amp;box));</div>
<div class="line">    <span class="keywordflow">if</span> (array_section.has_value()) {</div>
<div class="line">      <span class="comment">// We&#39;ll just count the elements in each section</span></div>
<div class="line">      Parallel::ReductionData&lt;</div>
<div class="line">          <a class="code hl_struct" href="structParallel_1_1ReductionDatum.html">Parallel::ReductionDatum&lt;bool, funcl::AssertEqual&lt;&gt;</a>&gt;,</div>
<div class="line">          <a class="code hl_struct" href="structParallel_1_1ReductionDatum.html">Parallel::ReductionDatum&lt;size_t, funcl::Plus&lt;&gt;</a>&gt;&gt;</div>
<div class="line">          reduction_data{section_id, 1};</div>
<div class="line">      <span class="comment">// Reduce over the section and broadcast to the full array</span></div>
<div class="line">      <span class="keyword">auto</span>&amp; array_proxy =</div>
<div class="line">          Parallel::get_parallel_component&lt;ParallelComponent&gt;(cache);</div>
<div class="line">      Parallel::contribute_to_reduction&lt;ReceiveCount&lt;ArraySectionIdTag&gt;&gt;(</div>
<div class="line">          std::move(reduction_data), array_proxy[array_index], array_proxy,</div>
<div class="line">          make_not_null(&amp;*array_section));</div>
<div class="line">    }</div>
<div class="ttc" id="agroup__DataBoxGroup_html_gac94b70fab454bd5ae3b218f0ed182684"><div class="ttname"><a href="group__DataBoxGroup.html#gac94b70fab454bd5ae3b218f0ed182684">db::get_mutable_reference</a></div><div class="ttdeci">auto &amp; get_mutable_reference(const gsl::not_null&lt; DataBox&lt; TagList &gt; * &gt; box)</div><div class="ttdoc">Retrieve a mutable reference to the item with tag Tag from the DataBox.</div><div class="ttdef"><b>Definition:</b> DataBox.hpp:988</div></div>
<div class="ttc" id="astructParallel_1_1ReductionDatum_html"><div class="ttname"><a href="structParallel_1_1ReductionDatum.html">Parallel::ReductionDatum</a></div><div class="ttdoc">The data to be reduced, and invokables to be called whenever two reduction messages are combined and ...</div><div class="ttdef"><b>Definition:</b> Reduction.hpp:65</div></div>
<div class="ttc" id="astructParallel_1_1Tags_1_1Section_html"><div class="ttname"><a href="structParallel_1_1Tags_1_1Section.html">Parallel::Tags::Section</a></div><div class="ttdoc">The Parallel::Section&lt;ParallelComponent, SectionIdTag&gt; that this element belongs to.</div><div class="ttdef"><b>Definition:</b> Section.hpp:29</div></div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd><a class="el" href="structParallel_1_1Section.html" title="A subset of chares in a parallel component.">Section</a> reductions currently don't support migrating elements, i.e. either load-balancing or restoring a checkpoint to a different number of PEs. Support for migrating elements may require <a href="https://charm.readthedocs.io/en/latest/charm++/manual.html#section-operations-with-migrating-elements">updating the "section cookie"</a>. One possibility to update the section cookie is to broadcast a CkMulticast message to the section elements and invoke <code>CkGetSectionInfo</code> within the message. </dd></dl>

</div>
</div>
<a id="ga3479433cebc81e70d646c6c755b47e1d" name="ga3479433cebc81e70d646c6c755b47e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3479433cebc81e70d646c6c755b47e1d">&#9670;&nbsp;</a></span>deserialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void deserialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; T * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserialize an object using PUP. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to deserialize to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6fb3864413e851ea6dcd1ffa319f2f25" name="ga6fb3864413e851ea6dcd1ffa319f2f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fb3864413e851ea6dcd1ffa319f2f25">&#9670;&nbsp;</a></span>deserialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T deserialize </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserialize an object using PUP. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to deserialize to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga43c98b994ca4a6ef61235109c5b94e14" name="ga43c98b994ca4a6ef61235109c5b94e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43c98b994ca4a6ef61235109c5b94e14">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GlobalCacheTag , typename Metavariables &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Parallel::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td> -&gt; const GlobalCache_detail::type_for_get&lt;GlobalCacheTag, Metavariables&gt;&amp; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access data in the cache. </p>
<p ><em>Requires:</em> GlobalCacheTag is a tag in the <code>mutable_global_cache_tags</code> or <code>const_global_cache_tags</code> defined by the Metavariables and in Actions.</p>
<p ><em>Returns:</em> a constant reference to an object in the cache </p>

</div>
</div>
<a id="ga8c24e9812c22ee923354a3906e50f296" name="ga8c24e9812c22ee923354a3906e50f296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c24e9812c22ee923354a3906e50f296">&#9670;&nbsp;</a></span>get_parallel_component() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParallelComponentTag , typename Metavariables &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Parallel::get_parallel_component </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td> -&gt; const Parallel::proxy_from_parallel_component&lt;
        GlobalCache_detail::get_component_if_mocked&lt;
            typename Metavariables::component_list, ParallelComponentTag&gt;&gt;&amp; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the Charm++ proxy associated with a ParallelComponent. </p>
<p ><em>Requires:</em> ParallelComponentTag is a tag in component_list</p>
<p ><em>Returns:</em> a Charm++ proxy that can be used to call an entry method on the chare(s) </p>

</div>
</div>
<a id="gaeee02b1e4faf8051fe703e6b9adada0f" name="gaeee02b1e4faf8051fe703e6b9adada0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeee02b1e4faf8051fe703e6b9adada0f">&#9670;&nbsp;</a></span>get_parallel_component() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParallelComponentTag , typename Metavariables &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Parallel::get_parallel_component </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td> -&gt; Parallel::proxy_from_parallel_component&lt;
        GlobalCache_detail::get_component_if_mocked&lt;
            typename Metavariables::component_list, ParallelComponentTag&gt;&gt;&amp; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the Charm++ proxy associated with a ParallelComponent. </p>
<p ><em>Requires:</em> ParallelComponentTag is a tag in component_list</p>
<p ><em>Returns:</em> a Charm++ proxy that can be used to call an entry method on the chare(s) </p>

</div>
</div>
<a id="gaee973d82ab6a1dbac2b504e86d8de2e5" name="gaee973d82ab6a1dbac2b504e86d8de2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee973d82ab6a1dbac2b504e86d8de2e5">&#9670;&nbsp;</a></span>mutable_cache_item_is_ready()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GlobalCacheTag , typename Function , typename Metavariables &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Parallel::mutable_cache_item_is_ready </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the object identified by <code>GlobalCacheTag</code> is ready to be accessed by <code>get</code>. </p>
<p ><em>Requires:</em> <code>GlobalCacheTag</code> is a tag in <code>mutable_global_cache_tags</code> defined by the Metavariables and in Actions.</p>
<p ><em>Requires:</em> <code>function</code> is a user-defined invokable that takes one argument: a const reference to the object referred to by the <code>GlobalCacheTag</code>. <code>function</code> returns a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;CallBack&gt;</code> that determines the readiness. To indicate that the item is ready, the <code><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a></code> returned by <code>function</code> must be nullptr; in this case <code>mutable_cache_item_is_ready</code> returns true. To indicate that the item is not ready, the <code><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a></code> returned by <code>function</code> must be valid; in this case, <code>mutable_cache_item_is_ready</code> appends the <code><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;<a class="el" href="classParallel_1_1Callback.html" title="An abstract base class, whose derived class holds a function that can be invoked at a later time....">Callback</a>&gt;</code> to an internal list of callbacks to be called on <code>mutate</code>, and then returns false. </p>

</div>
</div>
<a id="ga8fb8fc6f30581c450abecc8258dead3c" name="ga8fb8fc6f30581c450abecc8258dead3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fb8fc6f30581c450abecc8258dead3c">&#9670;&nbsp;</a></span>mutate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GlobalCacheTag , typename Function , typename Metavariables , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::mutate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mutates non-const data in the cache, by calling <code>Function::apply()</code> </p>
<p ><em>Requires:</em> <code>GlobalCacheTag</code> is a tag in tag_list. </p>
<p ><em>Requires:</em> <code>Function</code> is a struct with a static void <code><a class="el" href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db" title="Apply the function object f using its nested argument_tags list of tags.">apply()</a></code> function that mutates the object. <code>Function::apply()</code> takes as its first argument a <code><a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a></code> pointer to the object named by the <code>GlobalCacheTag</code>, and takes <code>args</code> as subsequent arguments. </p>

</div>
</div>
<a id="gae21964b5d28608afd21ae090c1c4c073" name="gae21964b5d28608afd21ae090c1c4c073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae21964b5d28608afd21ae090c1c4c073">&#9670;&nbsp;</a></span>printf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::printf </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print an atomic message to stdout with C printf usage. </p>
<p >Similar to Python, you can print any object that's streamable by passing it in as an argument and using the formatter "%s". For example, </p><div class="fragment"><div class="line"><a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a> a{0.8, 73, 9.8};</div>
<div class="line"><a class="code hl_function" href="group__ParallelGroup.html#gae21964b5d28608afd21ae090c1c4c073">Parallel::printf</a>(<span class="stringliteral">&quot;%s\n&quot;</span>, a);</div>
<div class="ttc" id="agroup__ParallelGroup_html_gae21964b5d28608afd21ae090c1c4c073"><div class="ttname"><a href="group__ParallelGroup.html#gae21964b5d28608afd21ae090c1c4c073">Parallel::printf</a></div><div class="ttdeci">void printf(const std::string &amp;format, Args &amp;&amp;... args)</div><div class="ttdoc">Print an atomic message to stdout with C printf usage.</div><div class="ttdef"><b>Definition:</b> Printf.hpp:103</div></div>
<div class="ttc" id="avector_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt; double &gt;</a></div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaa8448205dbaf9741505bd30dfad2cadc" name="gaa8448205dbaf9741505bd30dfad2cadc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8448205dbaf9741505bd30dfad2cadc">&#9670;&nbsp;</a></span>printf_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::printf_error </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print an atomic message to stderr with C printf usage. </p>
<p >See <a class="el" href="group__ParallelGroup.html#gae21964b5d28608afd21ae090c1c4c073" title="Print an atomic message to stdout with C printf usage.">Parallel::printf</a> for details. </p>

</div>
</div>
<a id="ga49aa2598782609c76503c8523e0f20f1" name="ga49aa2598782609c76503c8523e0f20f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49aa2598782609c76503c8523e0f20f1">&#9670;&nbsp;</a></span>receive_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReceiveTag , typename Proxy , typename MessageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::receive_data </td>
          <td>(</td>
          <td class="paramtype">Proxy &amp;&amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MessageType *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a pointer <code>message</code> to the algorithm running on <code>proxy</code>. </p>
<p >Here, <code>message</code> should hold all the information you need as member variables of the object. This includes, temporal ID identifiers, the data itself, and any auxilary information that needs to be communicated. The <code>ReceiveTag</code> associated with this <code>message</code> should be able unpack the information that was sent.</p>
<p >If the component associated with the <code>proxy</code> you are calling this on is running on the same charm-node, the exact pointer <code>message</code> is sent to the receiving component. No copies of data are done. If the receiving component is on a different charm-node, then the data pointed to by <code>message</code> is copied, sent through charm, and unpacked on the receiving component. The pointer that is passed to the algorithm on the receiving component then points to the copied data on the receiving component.</p>
<dl class="section warning"><dt>Warning</dt><dd>You cannot use the <code>message</code> pointer after you call this function. Doing so will result in undefined behavior because something else may be controlling the pointer. </dd></dl>

</div>
</div>
<a id="gad1078fa99233851c6475fbfa99a2f51d" name="gad1078fa99233851c6475fbfa99a2f51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1078fa99233851c6475fbfa99a2f51d">&#9670;&nbsp;</a></span>receive_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReceiveTag , typename Proxy , typename ReceiveDataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::receive_data </td>
          <td>(</td>
          <td class="paramtype">Proxy &amp;&amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ReceiveTag::temporal_id&#160;</td>
          <td class="paramname"><em>temporal_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReceiveDataType &amp;&amp;&#160;</td>
          <td class="paramname"><em>receive_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enable_if_disabled</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send the data <code>args...</code> to the algorithm running on <code>proxy</code>, and tag the message with the identifier <code>temporal_id</code>. </p>
<p >If the algorithm was previously disabled, set <code>enable_if_disabled</code> to true to enable the algorithm on the parallel component. </p>

</div>
</div>
<a id="ga313d201814db8c6e1c64fce9384276a3" name="ga313d201814db8c6e1c64fce9384276a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga313d201814db8c6e1c64fce9384276a3">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; char &gt; serialize </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize an object using PUP. </p>
<p >The type to serialize as must be explicitly specified. We require this because a mismatch between the serialize and deserialize calls causes undefined behavior and we do not want this to depend on inferred types for safety.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to serialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga6794d6d662e9f601ebdbd8528536ead1" name="ga6794d6d662e9f601ebdbd8528536ead1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6794d6d662e9f601ebdbd8528536ead1">&#9670;&nbsp;</a></span>is_in_const_global_cache</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Metavariables , typename Tag &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Parallel::is_in_const_global_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    tmpl::size&lt;tmpl::filter&lt;get_const_global_cache_tags&lt;Metavariables&gt;,</div>
<div class="line">                            <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_base_of.html">std::is_base_of&lt;tmpl::pin&lt;Tag&gt;</a>, tmpl::_1&gt;&gt;&gt;<a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">::value</a> &gt;</div>
<div class="line">    0</div>
<div class="ttc" id="agroup__UtilitiesGroup_html_ga4316f2ea7fb92cf4a3c5cf53bf36fb82"><div class="ttname"><a href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">value</a></div><div class="ttdeci">constexpr T &amp; value(T &amp;t)</div><div class="ttdoc">Returns t.value() if t is a std::optional otherwise returns t.</div><div class="ttdef"><b>Definition:</b> OptionalHelpers.hpp:32</div></div>
<div class="ttc" id="ais_base_of_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/types/is_base_of.html">std::is_base_of</a></div></div>
</div><!-- fragment -->
<p>Check whether a tag is retrievable from the const portion of the global cache. </p>

</div>
</div>
<a id="ga118c900b55b0e55a8d11cef00c77bd2d" name="ga118c900b55b0e55a8d11cef00c77bd2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga118c900b55b0e55a8d11cef00c77bd2d">&#9670;&nbsp;</a></span>is_in_global_cache</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Metavariables , typename Tag &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Parallel::is_in_global_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    is_in_const_global_cache&lt;Metavariables, Tag&gt; or</div>
<div class="line">    is_in_mutable_global_cache&lt;Metavariables, Tag&gt;</div>
</div><!-- fragment -->
<p>Check whether a tag is retrievable from the global cache. </p>

</div>
</div>
<a id="ga6f79ab2930d68c2050849ff60f80f162" name="ga6f79ab2930d68c2050849ff60f80f162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f79ab2930d68c2050849ff60f80f162">&#9670;&nbsp;</a></span>is_in_mutable_global_cache</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Metavariables , typename Tag &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Parallel::is_in_mutable_global_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    tmpl::size&lt;tmpl::filter&lt;get_mutable_global_cache_tags&lt;Metavariables&gt;,</div>
<div class="line">                            <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_base_of.html">std::is_base_of&lt;tmpl::pin&lt;Tag&gt;</a>, tmpl::_1&gt;&gt;&gt;<a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">::value</a> &gt;</div>
<div class="line">    0</div>
</div><!-- fragment -->
<p>Check whether a tag is retrievable from the mutable portion of the global cache. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
