<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: Testing Framework</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__TestingFrameworkGroup.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Testing Framework</div></div>
</div><!--header-->
<div class="contents">

<p>Classes, functions, macros, and instructions for developing tests.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceActionTesting"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceActionTesting.html">ActionTesting</a></td></tr>
<tr class="memdesc:namespaceActionTesting"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structures used for mocking the parallel components framework in order to test actions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepypp"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepypp.html">pypp</a></td></tr>
<tr class="memdesc:namespacepypp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all functions for calling python from C++. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTestHelpers_1_1domain_1_1BoundaryConditions"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTestHelpers_1_1domain_1_1BoundaryConditions.html">TestHelpers::domain::BoundaryConditions</a></td></tr>
<tr class="memdesc:namespaceTestHelpers_1_1domain_1_1BoundaryConditions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helpers for boundary conditions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTestHelpers_1_1elliptic"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTestHelpers_1_1elliptic.html">TestHelpers::elliptic</a></td></tr>
<tr class="memdesc:namespaceTestHelpers_1_1elliptic"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functions to test elliptic first-order systems. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTestHelpers_1_1AnalyticData"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTestHelpers_1_1AnalyticData.html">TestHelpers::AnalyticData</a></td></tr>
<tr class="memdesc:namespaceTestHelpers_1_1AnalyticData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions for testing analytic data. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTestHelpers_1_1VerifyGrSolution"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTestHelpers_1_1VerifyGrSolution.html">TestHelpers::VerifyGrSolution</a></td></tr>
<tr class="memdesc:namespaceTestHelpers_1_1VerifyGrSolution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions for testing GR analytic solutions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTestHelpers_1_1AnalyticSolutions"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTestHelpers_1_1AnalyticSolutions.html">TestHelpers::AnalyticSolutions</a></td></tr>
<tr class="memdesc:namespaceTestHelpers_1_1AnalyticSolutions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions for testing analytic solutions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTestHelpers_1_1gr"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTestHelpers_1_1gr.html">TestHelpers::gr</a></td></tr>
<tr class="memdesc:namespaceTestHelpers_1_1gr"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make random GR variables which correct physical behavior, e.g. spatial metric will be positive definite. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTestHelpers_1_1hydro"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTestHelpers_1_1hydro.html">TestHelpers::hydro</a></td></tr>
<tr class="memdesc:namespaceTestHelpers_1_1hydro"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make random hydro variables which correct physical behavior, e.g. Lorentz factor will be greater or equal than one. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">ActionTesting::MockRuntimeSystem&lt; Metavariables &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that mocks the infrastructure needed to run actions. It simulates message passing using the inbox infrastructure and handles most of the arguments to the apply method. This mocks the Charm++ runtime system as well as the layer built on top of it as part of SpECTRE.  <a href="classActionTesting_1_1MockRuntimeSystem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUniformCustomDistribution.html">UniformCustomDistribution&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A uniform distribution function object which redirects appropriately to either the <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution.html">std::uniform_int_distribution</a></code> or the <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution.html">std::uniform_real_distribution</a></code>. This also provides a convenience constructor which takes a 2-element array for the bounds for either floating point or int distributions.  <a href="classUniformCustomDistribution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrientationMapIterator.html">OrientationMapIterator&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator for looping through all possible orientations of the n-dim cube.  <a href="classOrientationMapIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga8cd2549e4a5627f34f8201af2bcbfd34"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga8cd2549e4a5627f34f8201af2bcbfd34">INVOKE_TEST_FUNCTION</a>(FUNCTION_NAME,  TUPLE_ARGS, ...)</td></tr>
<tr class="memdesc:ga8cd2549e4a5627f34f8201af2bcbfd34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro used to invoke a test function of multiple template arguments.  <a href="group__TestingFrameworkGroup.html#ga8cd2549e4a5627f34f8201af2bcbfd34">More...</a><br /></td></tr>
<tr class="separator:ga8cd2549e4a5627f34f8201af2bcbfd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21fcbc0b07905e0d2f8b012b388acd73"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga21fcbc0b07905e0d2f8b012b388acd73">CHECK_FOR_DOUBLES_AND_DATAVECTORS</a>(FUNCTION_NAME, ...)</td></tr>
<tr class="memdesc:ga21fcbc0b07905e0d2f8b012b388acd73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro used to test functions whose parameter can be a <code>double</code> or a <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code>.  <a href="group__TestingFrameworkGroup.html#ga21fcbc0b07905e0d2f8b012b388acd73">More...</a><br /></td></tr>
<tr class="separator:ga21fcbc0b07905e0d2f8b012b388acd73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec8dcdc783140fb14fe617cc0cc1dcae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gaec8dcdc783140fb14fe617cc0cc1dcae">CHECK_OP</a>(a,  op,  b,  c)</td></tr>
<tr class="memdesc:gaec8dcdc783140fb14fe617cc0cc1dcae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check a op b == c and also the op= version.  <a href="group__TestingFrameworkGroup.html#gaec8dcdc783140fb14fe617cc0cc1dcae">More...</a><br /></td></tr>
<tr class="separator:gaec8dcdc783140fb14fe617cc0cc1dcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7f766439113f958bf4f8ba0f53c4881"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gad7f766439113f958bf4f8ba0f53c4881">MAKE_GENERATOR</a>(...)</td></tr>
<tr class="memdesc:gad7f766439113f958bf4f8ba0f53c4881"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="group__TestingFrameworkGroup.html#gad7f766439113f958bf4f8ba0f53c4881" title="MAKE_GENERATOR(NAME [, SEED]) declares a variable of name NAME containing a generator of type std::mt...">MAKE_GENERATOR(NAME [, SEED])</a></code> declares a variable of name <code>NAME</code> containing a generator of type <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine.html">std::mt19937</a></code>.  <a href="group__TestingFrameworkGroup.html#gad7f766439113f958bf4f8ba0f53c4881">More...</a><br /></td></tr>
<tr class="separator:gad7f766439113f958bf4f8ba0f53c4881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga447b43fced460461e76beca1a28fc273"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga447b43fced460461e76beca1a28fc273">CHECK_VARIABLES_APPROX</a>(a,  b)</td></tr>
<tr class="memdesc:ga447b43fced460461e76beca1a28fc273"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around Catch's CHECK macro that checks approximate equality of each entry in each tag within a variables.  <a href="group__TestingFrameworkGroup.html#ga447b43fced460461e76beca1a28fc273">More...</a><br /></td></tr>
<tr class="separator:ga447b43fced460461e76beca1a28fc273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6553c686d7f6b55372814227d1542272"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga6553c686d7f6b55372814227d1542272">CHECK_VARIABLES_CUSTOM_APPROX</a>(a,  b,  appx)</td></tr>
<tr class="memdesc:ga6553c686d7f6b55372814227d1542272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>CHECK_VARIABLES_APPROX</code>, but with a user-defined Approx. The third argument should be of type <code>Approx</code>.  <a href="group__TestingFrameworkGroup.html#ga6553c686d7f6b55372814227d1542272">More...</a><br /></td></tr>
<tr class="separator:ga6553c686d7f6b55372814227d1542272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37fce1ae5980139598815eda5a5de8ab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga37fce1ae5980139598815eda5a5de8ab">SPECTRE_PARALLEL_REQUIRE</a>(expr)</td></tr>
<tr class="memdesc:ga37fce1ae5980139598815eda5a5de8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">A similar to Catch's REQUIRE statement, but can be used in tests that spawn several chares with possibly complex interaction between the chares.  <a href="group__TestingFrameworkGroup.html#ga37fce1ae5980139598815eda5a5de8ab">More...</a><br /></td></tr>
<tr class="separator:ga37fce1ae5980139598815eda5a5de8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2adb81ed48c421e8f77541f34eb3f821"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga2adb81ed48c421e8f77541f34eb3f821">SPECTRE_PARALLEL_REQUIRE_FALSE</a>(expr)</td></tr>
<tr class="memdesc:ga2adb81ed48c421e8f77541f34eb3f821"><td class="mdescLeft">&#160;</td><td class="mdescRight">A similar to Catch's REQUIRE_FALSE statement, but can be used in tests that spawn several chares with possibly complex interaction between the chares.  <a href="group__TestingFrameworkGroup.html#ga2adb81ed48c421e8f77541f34eb3f821">More...</a><br /></td></tr>
<tr class="separator:ga2adb81ed48c421e8f77541f34eb3f821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5509fb28c65f22498410618609f8c085"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga5509fb28c65f22498410618609f8c085">CHECK_COMPLEX_APPROX</a>(a,  b)</td></tr>
<tr class="memdesc:ga5509fb28c65f22498410618609f8c085"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around Catch's CHECK macro that checks approximate equality of the two entries in a <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>. For efficiency, no function forwarding is performed, just a pair of <code>CHECK</code>s inline.  <a href="group__TestingFrameworkGroup.html#ga5509fb28c65f22498410618609f8c085">More...</a><br /></td></tr>
<tr class="separator:ga5509fb28c65f22498410618609f8c085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5527bb2a3aa50f572faae13dfb8783e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga5527bb2a3aa50f572faae13dfb8783e5">CHECK_COMPLEX_CUSTOM_APPROX</a>(a,  b,  appx)</td></tr>
<tr class="memdesc:ga5527bb2a3aa50f572faae13dfb8783e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>CHECK_COMPLEX_APPROX</code> with user-defined Approx. The third argument should be of type <code>Approx</code>.  <a href="group__TestingFrameworkGroup.html#ga5527bb2a3aa50f572faae13dfb8783e5">More...</a><br /></td></tr>
<tr class="separator:ga5527bb2a3aa50f572faae13dfb8783e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ce5d669c94418f197e4c55c53e64a64"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga6ce5d669c94418f197e4c55c53e64a64">CHECK_ITERABLE_APPROX</a>(a,  b)</td></tr>
<tr class="memdesc:ga6ce5d669c94418f197e4c55c53e64a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around Catch's CHECK macro that checks approximate equality of entries in iterable containers. For maplike containers, keys are checked for strict equality and values are checked for approximate equality.  <a href="group__TestingFrameworkGroup.html#ga6ce5d669c94418f197e4c55c53e64a64">More...</a><br /></td></tr>
<tr class="separator:ga6ce5d669c94418f197e4c55c53e64a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f36d1ee34e6eb0721e35918eb488f0c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga4f36d1ee34e6eb0721e35918eb488f0c">CHECK_ITERABLE_CUSTOM_APPROX</a>(a,  b,  appx)</td></tr>
<tr class="memdesc:ga4f36d1ee34e6eb0721e35918eb488f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>CHECK_ITERABLE_APPROX</code> with user-defined Approx. The third argument should be of type <code>Approx</code>.  <a href="group__TestingFrameworkGroup.html#ga4f36d1ee34e6eb0721e35918eb488f0c">More...</a><br /></td></tr>
<tr class="separator:ga4f36d1ee34e6eb0721e35918eb488f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf962c28abc1a1f014f2a6b32c6f01680"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gaf962c28abc1a1f014f2a6b32c6f01680">ERROR_TEST</a>()</td></tr>
<tr class="memdesc:gaf962c28abc1a1f014f2a6b32c6f01680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a test as checking a call to ERROR.  <a href="group__TestingFrameworkGroup.html#gaf962c28abc1a1f014f2a6b32c6f01680">More...</a><br /></td></tr>
<tr class="separator:gaf962c28abc1a1f014f2a6b32c6f01680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4439208ed8accb2887ff47388e91e58b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga4439208ed8accb2887ff47388e91e58b">ASSERTION_TEST</a>()</td></tr>
<tr class="memdesc:ga4439208ed8accb2887ff47388e91e58b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a test to be checking an ASSERT.  <a href="group__TestingFrameworkGroup.html#ga4439208ed8accb2887ff47388e91e58b">More...</a><br /></td></tr>
<tr class="separator:ga4439208ed8accb2887ff47388e91e58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd515a98a97cf7fc82e722274b17e7ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gacd515a98a97cf7fc82e722274b17e7ce">OUTPUT_TEST</a>()</td></tr>
<tr class="memdesc:gacd515a98a97cf7fc82e722274b17e7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a test as checking the output with a regular expression.  <a href="group__TestingFrameworkGroup.html#gacd515a98a97cf7fc82e722274b17e7ce">More...</a><br /></td></tr>
<tr class="separator:gacd515a98a97cf7fc82e722274b17e7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga9983e020a1f6541d517aab417fb8ed41"><td class="memItemLeft" align="right" valign="top"><a id="ga9983e020a1f6541d517aab417fb8ed41" name="ga9983e020a1f6541d517aab417fb8ed41"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TestHelpers::VectorImpl::Bound</b> = <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 2 &gt;</td></tr>
<tr class="memdesc:ga9983e020a1f6541d517aab417fb8ed41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias to be more expressive with distribution bounds in vector tests which call the generic math test below. <br /></td></tr>
<tr class="separator:ga9983e020a1f6541d517aab417fb8ed41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga921a5dbf5f1704e2051d1daf593d0d90"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga921a5dbf5f1704e2051d1daf593d0d90">TestHelpers::VectorImpl::TestKind</a> { <b>Normal</b>
, <b>Strict</b>
, <b>Inplace</b>
, <b>GivenOrderOfArgumentsOnly</b>
 }</td></tr>
<tr class="memdesc:ga921a5dbf5f1704e2051d1daf593d0d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">the set of test types that may be used for the math operations  <a href="group__TestingFrameworkGroup.html#ga921a5dbf5f1704e2051d1daf593d0d90">More...</a><br /></td></tr>
<tr class="separator:ga921a5dbf5f1704e2051d1daf593d0d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7dfb31d9c4494e8d552e3cd3ca7eed81"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Metavariables  = NoSuchType&gt; </td></tr>
<tr class="memitem:ga7dfb31d9c4494e8d552e3cd3ca7eed81"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga7dfb31d9c4494e8d552e3cd3ca7eed81">TestHelpers::test_creation</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;construction_string)</td></tr>
<tr class="memdesc:ga7dfb31d9c4494e8d552e3cd3ca7eed81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of a given option-creatable type.  <a href="group__TestingFrameworkGroup.html#ga7dfb31d9c4494e8d552e3cd3ca7eed81">More...</a><br /></td></tr>
<tr class="separator:ga7dfb31d9c4494e8d552e3cd3ca7eed81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17b631a68906e714104e6c2fbdc2c1d2"><td class="memTemplParams" colspan="2">template&lt;typename OptionTag , typename Metavariables  = NoSuchType&gt; </td></tr>
<tr class="memitem:ga17b631a68906e714104e6c2fbdc2c1d2"><td class="memTemplItemLeft" align="right" valign="top">OptionTag::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga17b631a68906e714104e6c2fbdc2c1d2">TestHelpers::test_option_tag</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;construction_string)</td></tr>
<tr class="memdesc:ga17b631a68906e714104e6c2fbdc2c1d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the option parser on a given tag.  <a href="group__TestingFrameworkGroup.html#ga17b631a68906e714104e6c2fbdc2c1d2">More...</a><br /></td></tr>
<tr class="separator:ga17b631a68906e714104e6c2fbdc2c1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3783673fa2a65b2d51ac60e4252c9b0c"><td class="memTemplParams" colspan="2">template&lt;typename BaseClass , typename DerivedClass &gt; </td></tr>
<tr class="memitem:ga3783673fa2a65b2d51ac60e4252c9b0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; BaseClass &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga3783673fa2a65b2d51ac60e4252c9b0c">TestHelpers::test_factory_creation</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;construction_string)</td></tr>
<tr class="memdesc:ga3783673fa2a65b2d51ac60e4252c9b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a class of a known derived type using a factory.  <a href="group__TestingFrameworkGroup.html#ga3783673fa2a65b2d51ac60e4252c9b0c">More...</a><br /></td></tr>
<tr class="separator:ga3783673fa2a65b2d51ac60e4252c9b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae64239ff57740663c52a2abbdcce8cff"><td class="memTemplParams" colspan="2">template&lt;typename OptionTag , typename DerivedClass &gt; </td></tr>
<tr class="memitem:gae64239ff57740663c52a2abbdcce8cff"><td class="memTemplItemLeft" align="right" valign="top">OptionTag::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gae64239ff57740663c52a2abbdcce8cff">TestHelpers::test_option_tag_factory_creation</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;construction_string)</td></tr>
<tr class="memdesc:gae64239ff57740663c52a2abbdcce8cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper that allows testing an option tag without having to write a Metavariables class. Combines <code><a class="el" href="group__TestingFrameworkGroup.html#ga3783673fa2a65b2d51ac60e4252c9b0c" title="Creates a class of a known derived type using a factory.">TestHelpers::test_factory_creation()</a></code> and <code><a class="el" href="group__TestingFrameworkGroup.html#ga17b631a68906e714104e6c2fbdc2c1d2" title="Runs the option parser on a given tag.">TestHelpers::test_option_tag()</a></code>.  <a href="group__TestingFrameworkGroup.html#gae64239ff57740663c52a2abbdcce8cff">More...</a><br /></td></tr>
<tr class="separator:gae64239ff57740663c52a2abbdcce8cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2895e57f4cacd63d2549655bb29bba7b"><td class="memTemplParams" colspan="2"><a id="ga2895e57f4cacd63d2549655bb29bba7b" name="ga2895e57f4cacd63d2549655bb29bba7b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2895e57f4cacd63d2549655bb29bba7b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialize_and_deserialize</b> (const T &amp;t)</td></tr>
<tr class="memdesc:ga2895e57f4cacd63d2549655bb29bba7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes and deserializes an object <code>t</code> of type <code>T</code> <br /></td></tr>
<tr class="separator:ga2895e57f4cacd63d2549655bb29bba7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb54dd4cb5d073537d7fce7d8b7213d0"><td class="memTemplParams" colspan="2"><a id="gacb54dd4cb5d073537d7fce7d8b7213d0" name="gacb54dd4cb5d073537d7fce7d8b7213d0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacb54dd4cb5d073537d7fce7d8b7213d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialize_and_deserialize</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; T * &gt; result, const T &amp;t)</td></tr>
<tr class="memdesc:gacb54dd4cb5d073537d7fce7d8b7213d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes and deserializes an object <code>t</code> of type <code>T</code> <br /></td></tr>
<tr class="separator:gacb54dd4cb5d073537d7fce7d8b7213d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4294de51e79ce048d0a76bd72f80d19a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4294de51e79ce048d0a76bd72f80d19a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga4294de51e79ce048d0a76bd72f80d19a">test_serialization</a> (const T &amp;t)</td></tr>
<tr class="memdesc:ga4294de51e79ce048d0a76bd72f80d19a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests the serialization of comparable types.  <a href="group__TestingFrameworkGroup.html#ga4294de51e79ce048d0a76bd72f80d19a">More...</a><br /></td></tr>
<tr class="separator:ga4294de51e79ce048d0a76bd72f80d19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9032f7d7bb3698bab71a49d1df9c2d99"><td class="memTemplParams" colspan="2">template&lt;typename B , typename D , typename... Args&gt; </td></tr>
<tr class="memitem:ga9032f7d7bb3698bab71a49d1df9c2d99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga9032f7d7bb3698bab71a49d1df9c2d99">test_serialization_via_base</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga9032f7d7bb3698bab71a49d1df9c2d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test the serialization of a derived class via a base class pointer.  <a href="group__TestingFrameworkGroup.html#ga9032f7d7bb3698bab71a49d1df9c2d99">More...</a><br /></td></tr>
<tr class="separator:ga9032f7d7bb3698bab71a49d1df9c2d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeca05cc83258027c4547dfd39f399965"><td class="memTemplParams" colspan="2"><a id="gaeca05cc83258027c4547dfd39f399965" name="gaeca05cc83258027c4547dfd39f399965"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaeca05cc83258027c4547dfd39f399965"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>check_cmp</b> (const T &amp;less, const U &amp;greater)</td></tr>
<tr class="memdesc:gaeca05cc83258027c4547dfd39f399965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to test comparison operators. Pass values with less &lt; greater. <br /></td></tr>
<tr class="separator:gaeca05cc83258027c4547dfd39f399965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85e1325acbdf18be16d32ffa06454606"><td class="memTemplParams" colspan="2">template&lt;typename Invocable , size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga85e1325acbdf18be16d32ffa06454606"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/result_of.html">std::result_of_t</a>&lt; const Invocable &amp;(const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, VolumeDim &gt; &amp;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga85e1325acbdf18be16d32ffa06454606">numerical_derivative</a> (const Invocable &amp;function, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, VolumeDim &gt; &amp;x, const size_t direction, const double delta)</td></tr>
<tr class="memdesc:ga85e1325acbdf18be16d32ffa06454606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the derivative of an Invocable at a point x - represented by an array of doubles - in the domain of <code>map</code> with a sixth-order finite difference method.  <a href="group__TestingFrameworkGroup.html#ga85e1325acbdf18be16d32ffa06454606">More...</a><br /></td></tr>
<tr class="separator:ga85e1325acbdf18be16d32ffa06454606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga809dd7c089188c1c15f847f73cf6d924"><td class="memTemplParams" colspan="2">template&lt;typename Exception , typename ThrowingFunctor &gt; </td></tr>
<tr class="memitem:ga809dd7c089188c1c15f847f73cf6d924"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga809dd7c089188c1c15f847f73cf6d924">test_throw_exception</a> (const ThrowingFunctor &amp;func, const Exception &amp;expected)</td></tr>
<tr class="memdesc:ga809dd7c089188c1c15f847f73cf6d924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute <code>func</code> and check that it throws an exception <code>expected</code>.  <a href="group__TestingFrameworkGroup.html#ga809dd7c089188c1c15f847f73cf6d924">More...</a><br /></td></tr>
<tr class="separator:ga809dd7c089188c1c15f847f73cf6d924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad16627ae9048c611e374e9401fd6ecac"><td class="memTemplParams" colspan="2">template&lt;size_t NumSamples, typename Container , typename ValueType  = typename Container::value_type&gt; </td></tr>
<tr class="memitem:gad16627ae9048c611e374e9401fd6ecac"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; ValueType, NumSamples &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gad16627ae9048c611e374e9401fd6ecac">random_sample</a> (const Container &amp;container, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine.html">std::mt19937</a> * &gt; generator)</td></tr>
<tr class="memdesc:gad16627ae9048c611e374e9401fd6ecac"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>NumSamples</code> unique random elements of the <code>container</code>  <a href="group__TestingFrameworkGroup.html#gad16627ae9048c611e374e9401fd6ecac">More...</a><br /></td></tr>
<tr class="separator:gad16627ae9048c611e374e9401fd6ecac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8256d75ed63b572d451969df6ffc5e14"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename ValueType  = typename Container::value_type&gt; </td></tr>
<tr class="memitem:ga8256d75ed63b572d451969df6ffc5e14"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga8256d75ed63b572d451969df6ffc5e14">random_sample</a> (const size_t number_of_samples, const Container &amp;container, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine.html">std::mt19937</a> * &gt; generator)</td></tr>
<tr class="memdesc:ga8256d75ed63b572d451969df6ffc5e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> holding <code>number_of_samples</code> unique random elements of the <code>container</code>  <a href="group__TestingFrameworkGroup.html#ga8256d75ed63b572d451969df6ffc5e14">More...</a><br /></td></tr>
<tr class="separator:ga8256d75ed63b572d451969df6ffc5e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dbc4d90aaf171bc3f3e93e85c60e182"><td class="memTemplParams" colspan="2">template&lt;typename DataType , size_t SpatialDim, typename Frame &gt; </td></tr>
<tr class="memitem:ga4dbc4d90aaf171bc3f3e93e85c60e182"><td class="memTemplItemLeft" align="right" valign="top">tnsr::ii&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga4dbc4d90aaf171bc3f3e93e85c60e182">TestHelpers::Schwarzschild::spatial_ricci</a> (const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;x, double mass)</td></tr>
<tr class="memdesc:ga4dbc4d90aaf171bc3f3e93e85c60e182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schwarzschild (Kerr-Schild) spatial ricci tensor.  <a href="group__TestingFrameworkGroup.html#ga4dbc4d90aaf171bc3f3e93e85c60e182">More...</a><br /></td></tr>
<tr class="separator:ga4dbc4d90aaf171bc3f3e93e85c60e182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab257a106213aadd117761d5c871ee651"><td class="memTemplParams" colspan="2">template&lt;typename DataType , size_t SpatialDim, typename Frame &gt; </td></tr>
<tr class="memitem:gab257a106213aadd117761d5c871ee651"><td class="memTemplItemLeft" align="right" valign="top">tnsr::ii&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gab257a106213aadd117761d5c871ee651">TestHelpers::Minkowski::extrinsic_curvature_sphere</a> (const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;x)</td></tr>
<tr class="memdesc:gab257a106213aadd117761d5c871ee651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrinsic curvature of 2D sphere in 3D flat space.  <a href="group__TestingFrameworkGroup.html#gab257a106213aadd117761d5c871ee651">More...</a><br /></td></tr>
<tr class="separator:gab257a106213aadd117761d5c871ee651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09e2a86e1acdd8e076589351ce1b5908"><td class="memTemplParams" colspan="2">template&lt;typename DataType &gt; </td></tr>
<tr class="memitem:ga09e2a86e1acdd8e076589351ce1b5908"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga09e2a86e1acdd8e076589351ce1b5908">TestHelpers::Kerr::horizon_ricci_scalar</a> (const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;horizon_radius, double mass, double dimensionless_spin_z)</td></tr>
<tr class="memdesc:ga09e2a86e1acdd8e076589351ce1b5908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kerr (Kerr-Schild) horizon ricci scalar (spin on z axis)  <a href="group__TestingFrameworkGroup.html#ga09e2a86e1acdd8e076589351ce1b5908">More...</a><br /></td></tr>
<tr class="separator:ga09e2a86e1acdd8e076589351ce1b5908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaef417806f3d462b449dcbf7f57138f"><td class="memTemplParams" colspan="2">template&lt;typename DataType &gt; </td></tr>
<tr class="memitem:gafaef417806f3d462b449dcbf7f57138f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gafaef417806f3d462b449dcbf7f57138f">TestHelpers::Kerr::horizon_ricci_scalar</a> (const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;horizon_radius_with_spin_on_z_axis, const <a class="el" href="classylm_1_1Spherepack.html">ylm::Spherepack</a> &amp;ylm_with_spin_on_z_axis, const <a class="el" href="classylm_1_1Spherepack.html">ylm::Spherepack</a> &amp;ylm, double mass, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 3 &gt; &amp;dimensionless_spin)</td></tr>
<tr class="memdesc:gafaef417806f3d462b449dcbf7f57138f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kerr (Kerr-Schild) horizon ricci scalar (generic spin)  <a href="group__TestingFrameworkGroup.html#gafaef417806f3d462b449dcbf7f57138f">More...</a><br /></td></tr>
<tr class="separator:gafaef417806f3d462b449dcbf7f57138f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5959fa1de8d9a113fd07dd1058235184"><td class="memTemplParams" colspan="2">template&lt;typename DataType , size_t Dim, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> Ul, typename Fr  = Frame::Inertial, <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt;(Ul==<a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28a258f49887ef8d14ac268c92b02503aaa">UpLo::Up</a>)&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ga5959fa1de8d9a113fd07dd1058235184"><td class="memTemplItemLeft" align="right" valign="top">tnsr::I&lt; DataType, Dim, Fr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga5959fa1de8d9a113fd07dd1058235184">make_random_vector_in_magnitude_range</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine.html">std::mt19937</a> * &gt; nn_generator, const tnsr::ii&lt; DataType, Dim, Fr &gt; &amp;metric, const double min_magnitude, const double max_magnitude)</td></tr>
<tr class="memdesc:ga5959fa1de8d9a113fd07dd1058235184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a spatial vector in a given magnitude range.  <a href="group__TestingFrameworkGroup.html#ga5959fa1de8d9a113fd07dd1058235184">More...</a><br /></td></tr>
<tr class="separator:ga5959fa1de8d9a113fd07dd1058235184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4960c6cd2087ccde305379036172c884"><td class="memTemplParams" colspan="2">template&lt;typename DataType , size_t Dim, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> Ul, typename Fr  = Frame::Inertial, typename T &gt; </td></tr>
<tr class="memitem:ga4960c6cd2087ccde305379036172c884"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; Dim, Ul, Fr &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga4960c6cd2087ccde305379036172c884">make_random_vector_in_magnitude_range_flat</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine.html">std::mt19937</a> * &gt; nn_generator, const T &amp;used_for_size, const double min_magnitude, const double max_magnitude)</td></tr>
<tr class="memdesc:ga4960c6cd2087ccde305379036172c884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a spatial vector in a given magnitude range.  <a href="group__TestingFrameworkGroup.html#ga4960c6cd2087ccde305379036172c884">More...</a><br /></td></tr>
<tr class="separator:ga4960c6cd2087ccde305379036172c884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47e68c63da6b2326911ee6600b99e1b5"><td class="memTemplParams" colspan="2"><a id="ga47e68c63da6b2326911ee6600b99e1b5" name="ga47e68c63da6b2326911ee6600b99e1b5"></a>
template&lt;typename T , typename UniformRandomBitGenerator , typename RandomNumberDistribution &gt; </td></tr>
<tr class="memitem:ga47e68c63da6b2326911ee6600b99e1b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fill_with_random_values</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; T * &gt; data, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; UniformRandomBitGenerator * &gt; generator, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; RandomNumberDistribution * &gt; distribution)</td></tr>
<tr class="memdesc:ga47e68c63da6b2326911ee6600b99e1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill an existing data structure with random values. <br /></td></tr>
<tr class="separator:ga47e68c63da6b2326911ee6600b99e1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6547f8470e240380e23f08f7e649e91"><td class="memTemplParams" colspan="2">template&lt;typename T , typename UniformRandomBitGenerator , typename RandomNumberDistribution &gt; </td></tr>
<tr class="memitem:gaa6547f8470e240380e23f08f7e649e91"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gaa6547f8470e240380e23f08f7e649e91">make_with_random_values</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; UniformRandomBitGenerator * &gt; generator, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; RandomNumberDistribution * &gt; distribution)</td></tr>
<tr class="memdesc:gaa6547f8470e240380e23f08f7e649e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a fixed-size data structure and fill with random values.  <a href="group__TestingFrameworkGroup.html#gaa6547f8470e240380e23f08f7e649e91">More...</a><br /></td></tr>
<tr class="separator:gaa6547f8470e240380e23f08f7e649e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fe6541c6826e1c7b40d35cdf539c2ea"><td class="memTemplParams" colspan="2"><a id="ga9fe6541c6826e1c7b40d35cdf539c2ea" name="ga9fe6541c6826e1c7b40d35cdf539c2ea"></a>
template&lt;typename DataType &gt; </td></tr>
<tr class="memitem:ga9fe6541c6826e1c7b40d35cdf539c2ea"><td class="memTemplItemLeft" align="right" valign="top">tnsr::I&lt; DataType, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>random_unit_normal</b> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine.html">std::mt19937</a> * &gt; generator, const tnsr::ii&lt; DataType, 1 &gt; &amp;spatial_metric)</td></tr>
<tr class="memdesc:ga9fe6541c6826e1c7b40d35cdf539c2ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a random unit normal vector at each element of <code>DataType</code>. <br /></td></tr>
<tr class="separator:ga9fe6541c6826e1c7b40d35cdf539c2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga143a0f20c1d6a8e9556e39a978b6e76c"><td class="memTemplParams" colspan="2">template&lt;typename DataType &gt; </td></tr>
<tr class="memitem:ga143a0f20c1d6a8e9556e39a978b6e76c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga143a0f20c1d6a8e9556e39a978b6e76c">TestHelpers::tenex::test_evaluate_rank_0</a> (const DataType &amp;data)</td></tr>
<tr class="memdesc:ga143a0f20c1d6a8e9556e39a978b6e76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that evaluating a right hand side tensor expression containing a single rank 0 tensor correctly assigns the data to the evaluated left hand side tensor.  <a href="group__TestingFrameworkGroup.html#ga143a0f20c1d6a8e9556e39a978b6e76c">More...</a><br /></td></tr>
<tr class="separator:ga143a0f20c1d6a8e9556e39a978b6e76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacff120a6119acadc8b97ed7950c065a5"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename TensorIndexTypeList , auto &amp; TensorIndex&gt; </td></tr>
<tr class="memitem:gacff120a6119acadc8b97ed7950c065a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gacff120a6119acadc8b97ed7950c065a5">TestHelpers::tenex::test_evaluate_rank_1_impl</a> ()</td></tr>
<tr class="memdesc:gacff120a6119acadc8b97ed7950c065a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that evaluating a right hand side tensor expression containing a single rank 1 tensor correctly assigns the data to the evaluated left hand side tensor.  <a href="group__TestingFrameworkGroup.html#gacff120a6119acadc8b97ed7950c065a5">More...</a><br /></td></tr>
<tr class="separator:gacff120a6119acadc8b97ed7950c065a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf08c1f5aa4ec1bffe899af75f4349cd7"><td class="memTemplParams" colspan="2">template&lt;typename DataType , template&lt; size_t, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a>, typename &gt; class TensorIndexType, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> Valence, auto &amp; TensorIndex&gt; </td></tr>
<tr class="memitem:gaf08c1f5aa4ec1bffe899af75f4349cd7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gaf08c1f5aa4ec1bffe899af75f4349cd7">TestHelpers::tenex::test_evaluate_rank_1</a> ()</td></tr>
<tr class="memdesc:gaf08c1f5aa4ec1bffe899af75f4349cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate testing of evaluating single rank 1 Tensors on multiple <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> types and dimensions.  <a href="group__TestingFrameworkGroup.html#gaf08c1f5aa4ec1bffe899af75f4349cd7">More...</a><br /></td></tr>
<tr class="separator:gaf08c1f5aa4ec1bffe899af75f4349cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf8fe84127caf3ee49548648c016a9b9"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename RhsSymmetry , typename RhsTensorIndexTypeList , auto &amp; TensorIndexA, auto &amp; TensorIndexB&gt; </td></tr>
<tr class="memitem:gadf8fe84127caf3ee49548648c016a9b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gadf8fe84127caf3ee49548648c016a9b9">TestHelpers::tenex::test_evaluate_rank_2_impl</a> ()</td></tr>
<tr class="memdesc:gadf8fe84127caf3ee49548648c016a9b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that evaluating a right hand side tensor expression containing a single rank 2 tensor correctly assigns the data to the evaluated left hand side tensor.  <a href="group__TestingFrameworkGroup.html#gadf8fe84127caf3ee49548648c016a9b9">More...</a><br /></td></tr>
<tr class="separator:gadf8fe84127caf3ee49548648c016a9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4bcc29540d344199c0222d07459c5e0"><td class="memTemplParams" colspan="2">template&lt;typename DataType , template&lt; size_t, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a>, typename &gt; class TensorIndexTypeA, template&lt; size_t, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a>, typename &gt; class TensorIndexTypeB, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> ValenceA, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> ValenceB, auto &amp; TensorIndexA, auto &amp; TensorIndexB&gt; </td></tr>
<tr class="memitem:gaa4bcc29540d344199c0222d07459c5e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gaa4bcc29540d344199c0222d07459c5e0">TestHelpers::tenex::test_evaluate_rank_2_no_symmetry</a> ()</td></tr>
<tr class="memdesc:gaa4bcc29540d344199c0222d07459c5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate testing of evaluating single rank 2 Tensors on multiple <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> types and dimension combinations.  <a href="group__TestingFrameworkGroup.html#gaa4bcc29540d344199c0222d07459c5e0">More...</a><br /></td></tr>
<tr class="separator:gaa4bcc29540d344199c0222d07459c5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6d7b7cc18b7257bb1d5978b55799763"><td class="memTemplParams" colspan="2">template&lt;typename DataType , template&lt; size_t, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a>, typename &gt; class TensorIndexType, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> Valence, auto &amp; TensorIndexA, auto &amp; TensorIndexB&gt; </td></tr>
<tr class="memitem:gad6d7b7cc18b7257bb1d5978b55799763"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gad6d7b7cc18b7257bb1d5978b55799763">TestHelpers::tenex::test_evaluate_rank_2_symmetric</a> ()</td></tr>
<tr class="separator:gad6d7b7cc18b7257bb1d5978b55799763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72c6d07c6937fa97907624bcd7bab842"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename RhsSymmetry , typename RhsTensorIndexTypeList , auto &amp; TensorIndexA, auto &amp; TensorIndexB, auto &amp; TensorIndexC&gt; </td></tr>
<tr class="memitem:ga72c6d07c6937fa97907624bcd7bab842"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga72c6d07c6937fa97907624bcd7bab842">TestHelpers::tenex::test_evaluate_rank_3_impl</a> ()</td></tr>
<tr class="memdesc:ga72c6d07c6937fa97907624bcd7bab842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that evaluating a right hand side tensor expression containing a single rank 3 tensor correctly assigns the data to the evaluated left hand side tensor.  <a href="group__TestingFrameworkGroup.html#ga72c6d07c6937fa97907624bcd7bab842">More...</a><br /></td></tr>
<tr class="separator:ga72c6d07c6937fa97907624bcd7bab842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffd8031d31f026abe36d85f5017c99c5"><td class="memTemplParams" colspan="2">template&lt;typename DataType , template&lt; size_t, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a>, typename &gt; class TensorIndexTypeA, template&lt; size_t, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a>, typename &gt; class TensorIndexTypeB, template&lt; size_t, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a>, typename &gt; class TensorIndexTypeC, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> ValenceA, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> ValenceB, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> ValenceC, auto &amp; TensorIndexA, auto &amp; TensorIndexB, auto &amp; TensorIndexC&gt; </td></tr>
<tr class="memitem:gaffd8031d31f026abe36d85f5017c99c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gaffd8031d31f026abe36d85f5017c99c5">TestHelpers::tenex::test_evaluate_rank_3_no_symmetry</a> ()</td></tr>
<tr class="memdesc:gaffd8031d31f026abe36d85f5017c99c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate testing of evaluating single rank 3 Tensors on multiple <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> types and dimension combinations.  <a href="group__TestingFrameworkGroup.html#gaffd8031d31f026abe36d85f5017c99c5">More...</a><br /></td></tr>
<tr class="separator:gaffd8031d31f026abe36d85f5017c99c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf270dbea08fc80e0c4b38fb1aeef01de"><td class="memTemplParams" colspan="2">template&lt;typename DataType , template&lt; size_t, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a>, typename &gt; class TensorIndexTypeAB, template&lt; size_t, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a>, typename &gt; class TensorIndexTypeC, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> ValenceAB, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> ValenceC, auto &amp; TensorIndexA, auto &amp; TensorIndexB, auto &amp; TensorIndexC&gt; </td></tr>
<tr class="memitem:gaf270dbea08fc80e0c4b38fb1aeef01de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gaf270dbea08fc80e0c4b38fb1aeef01de">TestHelpers::tenex::test_evaluate_rank_3_ab_symmetry</a> ()</td></tr>
<tr class="separator:gaf270dbea08fc80e0c4b38fb1aeef01de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4426c46c2fe17a47a23474f2f476cd2e"><td class="memTemplParams" colspan="2">template&lt;typename DataType , template&lt; size_t, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a>, typename &gt; class TensorIndexTypeAC, template&lt; size_t, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a>, typename &gt; class TensorIndexTypeB, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> ValenceAC, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> ValenceB, auto &amp; TensorIndexA, auto &amp; TensorIndexB, auto &amp; TensorIndexC&gt; </td></tr>
<tr class="memitem:ga4426c46c2fe17a47a23474f2f476cd2e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga4426c46c2fe17a47a23474f2f476cd2e">TestHelpers::tenex::test_evaluate_rank_3_ac_symmetry</a> ()</td></tr>
<tr class="separator:ga4426c46c2fe17a47a23474f2f476cd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ca2f4b11b54b8dfb4cba772c9419900"><td class="memTemplParams" colspan="2">template&lt;typename DataType , template&lt; size_t, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a>, typename &gt; class TensorIndexTypeA, template&lt; size_t, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a>, typename &gt; class TensorIndexTypeBC, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> ValenceA, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> ValenceBC, auto &amp; TensorIndexA, auto &amp; TensorIndexB, auto &amp; TensorIndexC&gt; </td></tr>
<tr class="memitem:ga8ca2f4b11b54b8dfb4cba772c9419900"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga8ca2f4b11b54b8dfb4cba772c9419900">TestHelpers::tenex::test_evaluate_rank_3_bc_symmetry</a> ()</td></tr>
<tr class="separator:ga8ca2f4b11b54b8dfb4cba772c9419900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fdc3b3a7f9e815772e06b4ff544f35c"><td class="memTemplParams" colspan="2">template&lt;typename DataType , template&lt; size_t, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a>, typename &gt; class TensorIndexType, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> Valence, auto &amp; TensorIndexA, auto &amp; TensorIndexB, auto &amp; TensorIndexC&gt; </td></tr>
<tr class="memitem:ga6fdc3b3a7f9e815772e06b4ff544f35c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga6fdc3b3a7f9e815772e06b4ff544f35c">TestHelpers::tenex::test_evaluate_rank_3_abc_symmetry</a> ()</td></tr>
<tr class="separator:ga6fdc3b3a7f9e815772e06b4ff544f35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafff0c4391d6169d9357c436b0eff2969"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename RhsSymmetry , typename RhsTensorIndexTypeList , auto &amp; TensorIndexA, auto &amp; TensorIndexB, auto &amp; TensorIndexC, auto &amp; TensorIndexD&gt; </td></tr>
<tr class="memitem:gafff0c4391d6169d9357c436b0eff2969"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gafff0c4391d6169d9357c436b0eff2969">TestHelpers::tenex::test_evaluate_rank_4</a> ()</td></tr>
<tr class="memdesc:gafff0c4391d6169d9357c436b0eff2969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that evaluating a right hand side tensor expression containing a single rank 4 tensor correctly assigns the data to the evaluated left hand side tensor.  <a href="group__TestingFrameworkGroup.html#gafff0c4391d6169d9357c436b0eff2969">More...</a><br /></td></tr>
<tr class="separator:gafff0c4391d6169d9357c436b0eff2969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5e273d9f807e8e9e5ae88c8d3035bd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gae5e273d9f807e8e9e5ae88c8d3035bd2">TestHelpers::tenex::test_tensor_index_transformation_rank_0</a> ()</td></tr>
<tr class="memdesc:gae5e273d9f807e8e9e5ae88c8d3035bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the transformation between two rank 0 tensors' generic indices and the subsequent transformed multi-index is correctly computed.  <a href="group__TestingFrameworkGroup.html#gae5e273d9f807e8e9e5ae88c8d3035bd2">More...</a><br /></td></tr>
<tr class="separator:gae5e273d9f807e8e9e5ae88c8d3035bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c7291c51a6f01aeda865dae8ecb873e"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="structTensorIndex.html">TensorIndex</a> &gt; </td></tr>
<tr class="memitem:ga6c7291c51a6f01aeda865dae8ecb873e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga6c7291c51a6f01aeda865dae8ecb873e">TestHelpers::tenex::test_tensor_index_transformation_rank_1</a> (const <a class="el" href="structTensorIndex.html">TensorIndex</a> &amp;)</td></tr>
<tr class="memdesc:ga6c7291c51a6f01aeda865dae8ecb873e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the transformation between two rank 1 tensors' generic indices and the subsequent transformed multi-indices are correctly computed.  <a href="group__TestingFrameworkGroup.html#ga6c7291c51a6f01aeda865dae8ecb873e">More...</a><br /></td></tr>
<tr class="separator:ga6c7291c51a6f01aeda865dae8ecb873e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2b08ffdd19e622301540b8694a67784"><td class="memTemplParams" colspan="2">template&lt;typename TensorIndexA , typename TensorIndexB &gt; </td></tr>
<tr class="memitem:gae2b08ffdd19e622301540b8694a67784"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gae2b08ffdd19e622301540b8694a67784">TestHelpers::tenex::test_tensor_index_transformation_rank_2</a> (const TensorIndexA &amp;, const TensorIndexB &amp;)</td></tr>
<tr class="memdesc:gae2b08ffdd19e622301540b8694a67784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the transformation between two rank 2 tensors' generic indices and the subsequent transformed multi-indices are correctly computed.  <a href="group__TestingFrameworkGroup.html#gae2b08ffdd19e622301540b8694a67784">More...</a><br /></td></tr>
<tr class="separator:gae2b08ffdd19e622301540b8694a67784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76b77b43487b741679c4dc479c9ee8ab"><td class="memTemplParams" colspan="2">template&lt;typename TensorIndexA , typename TensorIndexB , typename TensorIndexC &gt; </td></tr>
<tr class="memitem:ga76b77b43487b741679c4dc479c9ee8ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga76b77b43487b741679c4dc479c9ee8ab">TestHelpers::tenex::test_tensor_index_transformation_rank_3</a> (const TensorIndexA &amp;, const TensorIndexB &amp;, const TensorIndexC &amp;)</td></tr>
<tr class="memdesc:ga76b77b43487b741679c4dc479c9ee8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the transformation between two rank 3 tensors' generic indices and the subsequent transformed multi-indices are correctly computed.  <a href="group__TestingFrameworkGroup.html#ga76b77b43487b741679c4dc479c9ee8ab">More...</a><br /></td></tr>
<tr class="separator:ga76b77b43487b741679c4dc479c9ee8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05f460af35fe3e1416e3f5371fccd8bc"><td class="memTemplParams" colspan="2">template&lt;typename TensorIndexA , typename TensorIndexB , typename TensorIndexC , typename TensorIndexD &gt; </td></tr>
<tr class="memitem:ga05f460af35fe3e1416e3f5371fccd8bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga05f460af35fe3e1416e3f5371fccd8bc">TestHelpers::tenex::test_tensor_index_transformation_rank_4</a> (const TensorIndexA &amp;, const TensorIndexB &amp;, const TensorIndexC &amp;, const TensorIndexD &amp;)</td></tr>
<tr class="memdesc:ga05f460af35fe3e1416e3f5371fccd8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the transformation between two rank 4 tensors' generic indices and the subsequent transformed multi-indices are correctly computed.  <a href="group__TestingFrameworkGroup.html#ga05f460af35fe3e1416e3f5371fccd8bc">More...</a><br /></td></tr>
<tr class="separator:ga05f460af35fe3e1416e3f5371fccd8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11bc653f483c16da824829fecb5f8a04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga11bc653f483c16da824829fecb5f8a04">TestHelpers::tenex::test_tensor_index_transformation_with_time_indices</a> ()</td></tr>
<tr class="memdesc:ga11bc653f483c16da824829fecb5f8a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the transformation between two tensors generic indices and the subsequent transformed multi-indices are correctly computed when time indices are used with at least one of the tensors.  <a href="group__TestingFrameworkGroup.html#ga11bc653f483c16da824829fecb5f8a04">More...</a><br /></td></tr>
<tr class="separator:ga11bc653f483c16da824829fecb5f8a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa24b695b88214f1e7506ddbe3ac7dd36"><td class="memTemplParams" colspan="2"><a id="gaa24b695b88214f1e7506ddbe3ac7dd36" name="gaa24b695b88214f1e7506ddbe3ac7dd36"></a>
template&lt;typename VectorType , typename ValueType &gt; </td></tr>
<tr class="memitem:gaa24b695b88214f1e7506ddbe3ac7dd36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TestHelpers::VectorImpl::vector_test_construct_and_assign</b> (tt::get_fundamental_type_t&lt; ValueType &gt; low=tt::get_fundamental_type_t&lt; ValueType &gt;{-100.0}, tt::get_fundamental_type_t&lt; ValueType &gt; high=tt::get_fundamental_type_t&lt; ValueType &gt;{100.0})</td></tr>
<tr class="memdesc:gaa24b695b88214f1e7506ddbe3ac7dd36"><td class="mdescLeft">&#160;</td><td class="mdescRight">test construction and assignment of a <code>VectorType</code> with a <code>ValueType</code> <br /></td></tr>
<tr class="separator:gaa24b695b88214f1e7506ddbe3ac7dd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e8715fb3d5118f6ca6f0530b7b66151"><td class="memTemplParams" colspan="2"><a id="ga0e8715fb3d5118f6ca6f0530b7b66151" name="ga0e8715fb3d5118f6ca6f0530b7b66151"></a>
template&lt;typename VectorType , typename ValueType &gt; </td></tr>
<tr class="memitem:ga0e8715fb3d5118f6ca6f0530b7b66151"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TestHelpers::VectorImpl::vector_test_serialize</b> (tt::get_fundamental_type_t&lt; ValueType &gt; low=tt::get_fundamental_type_t&lt; ValueType &gt;{-100.0}, tt::get_fundamental_type_t&lt; ValueType &gt; high=tt::get_fundamental_type_t&lt; ValueType &gt;{100.0})</td></tr>
<tr class="memdesc:ga0e8715fb3d5118f6ca6f0530b7b66151"><td class="mdescLeft">&#160;</td><td class="mdescRight">test the serialization of a <code>VectorType</code> constructed with a <code>ValueType</code> <br /></td></tr>
<tr class="separator:ga0e8715fb3d5118f6ca6f0530b7b66151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49cbbff4ce8c323279e3453b8c75c029"><td class="memTemplParams" colspan="2"><a id="ga49cbbff4ce8c323279e3453b8c75c029" name="ga49cbbff4ce8c323279e3453b8c75c029"></a>
template&lt;typename VectorType , typename ValueType &gt; </td></tr>
<tr class="memitem:ga49cbbff4ce8c323279e3453b8c75c029"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TestHelpers::VectorImpl::vector_test_ref</b> (tt::get_fundamental_type_t&lt; ValueType &gt; low=tt::get_fundamental_type_t&lt; ValueType &gt;{-100.0}, tt::get_fundamental_type_t&lt; ValueType &gt; high=tt::get_fundamental_type_t&lt; ValueType &gt;{100.0})</td></tr>
<tr class="memdesc:ga49cbbff4ce8c323279e3453b8c75c029"><td class="mdescLeft">&#160;</td><td class="mdescRight">test the construction and move of a reference <code>VectorType</code> constructed with a <code>ValueType</code> <br /></td></tr>
<tr class="separator:ga49cbbff4ce8c323279e3453b8c75c029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca8f3c157268ccafd499b96d617766dd"><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename ValueType  = typename VectorType::ElementType&gt; </td></tr>
<tr class="memitem:gaca8f3c157268ccafd499b96d617766dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gaca8f3c157268ccafd499b96d617766dd">TestHelpers::VectorImpl::vector_ref_test_size_error</a> (RefSizeErrorTestKind test_kind, tt::get_fundamental_type_t&lt; ValueType &gt; low=tt::get_fundamental_type_t&lt; ValueType &gt;{-100.0}, tt::get_fundamental_type_t&lt; ValueType &gt; high=tt::get_fundamental_type_t&lt; ValueType &gt;{100.0})</td></tr>
<tr class="memdesc:gaca8f3c157268ccafd499b96d617766dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that assigning to a non-owning <code>VectorType</code> of the wrong size appropriately generates an error.  <a href="group__TestingFrameworkGroup.html#gaca8f3c157268ccafd499b96d617766dd">More...</a><br /></td></tr>
<tr class="separator:gaca8f3c157268ccafd499b96d617766dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed0ec26b3b33dc0254389f727de302ea"><td class="memTemplParams" colspan="2"><a id="gaed0ec26b3b33dc0254389f727de302ea" name="gaed0ec26b3b33dc0254389f727de302ea"></a>
template&lt;typename VectorType , typename ValueType &gt; </td></tr>
<tr class="memitem:gaed0ec26b3b33dc0254389f727de302ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TestHelpers::VectorImpl::vector_test_math_after_move</b> (tt::get_fundamental_type_t&lt; ValueType &gt; low=tt::get_fundamental_type_t&lt; ValueType &gt;{-100.0}, tt::get_fundamental_type_t&lt; ValueType &gt; high=tt::get_fundamental_type_t&lt; ValueType &gt;{100.0})</td></tr>
<tr class="memdesc:gaed0ec26b3b33dc0254389f727de302ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests a small sample of math functions after a move of a <code>VectorType</code> initialized with <code>ValueType</code> <br /></td></tr>
<tr class="separator:gaed0ec26b3b33dc0254389f727de302ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa22edca07de9742e60f55cd0532db34"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__TestingFrameworkGroup.html#ga921a5dbf5f1704e2051d1daf593d0d90">TestKind</a> Test, typename VectorType0 , typename... VectorTypes, typename... FunctionsAndArgumentBounds&gt; </td></tr>
<tr class="memitem:gafa22edca07de9742e60f55cd0532db34"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gafa22edca07de9742e60f55cd0532db34">TestHelpers::VectorImpl::test_functions_with_vector_arguments</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; FunctionsAndArgumentBounds... &gt; &amp;tuple_of_functions_and_argument_bounds)</td></tr>
<tr class="memdesc:gafa22edca07de9742e60f55cd0532db34"><td class="mdescLeft">&#160;</td><td class="mdescRight">General entry function for testing arbitrary math functions on vector types.  <a href="group__TestingFrameworkGroup.html#gafa22edca07de9742e60f55cd0532db34">More...</a><br /></td></tr>
<tr class="separator:gafa22edca07de9742e60f55cd0532db34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab62c80da19ece5d2a9b5b9359d2657f9"><td class="memTemplParams" colspan="2"><a id="gab62c80da19ece5d2a9b5b9359d2657f9" name="gab62c80da19ece5d2a9b5b9359d2657f9"></a>
template&lt;typename Map &gt; </td></tr>
<tr class="memitem:gab62c80da19ece5d2a9b5b9359d2657f9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>are_maps_equal</b> (const Map &amp;map, const <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1BlockLogical.html">Frame::BlockLogical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, Map::dim &gt; &amp;map_base)</td></tr>
<tr class="memdesc:gab62c80da19ece5d2a9b5b9359d2657f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a Map and a CoordinateMapBase, checks that the maps are equal by downcasting <code>map_base</code> and then comparing to <code>map</code>. Returns false if the downcast fails. <br /></td></tr>
<tr class="separator:gab62c80da19ece5d2a9b5b9359d2657f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7fc61535e9dcfa80aeccd6d80d457cf"><td class="memTemplParams" colspan="2"><a id="gaa7fc61535e9dcfa80aeccd6d80d457cf" name="gaa7fc61535e9dcfa80aeccd6d80d457cf"></a>
template&lt;typename SourceFrame , typename TargetFrame , size_t VolumeDim&gt; </td></tr>
<tr class="memitem:gaa7fc61535e9dcfa80aeccd6d80d457cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>check_if_maps_are_equal</b> (const <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; SourceFrame, TargetFrame, VolumeDim &gt; &amp;map_one, const <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; SourceFrame, TargetFrame, VolumeDim &gt; &amp;map_two, const double time=<a class="elRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits</a>&lt; double &gt;::quiet_NaN(), const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt; &gt; &amp;functions_of_time={}, Approx custom_approx=approx)</td></tr>
<tr class="memdesc:gaa7fc61535e9dcfa80aeccd6d80d457cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two coordinate maps (but not their types), check that the maps are equal by evaluating them at a random set of points. <br /></td></tr>
<tr class="separator:gaa7fc61535e9dcfa80aeccd6d80d457cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf11cebfe6faef19ed9071beea156cb83"><td class="memTemplParams" colspan="2"><a id="gaf11cebfe6faef19ed9071beea156cb83" name="gaf11cebfe6faef19ed9071beea156cb83"></a>
template&lt;typename Map &gt; </td></tr>
<tr class="memitem:gaf11cebfe6faef19ed9071beea156cb83"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>check_if_map_is_identity</b> (const Map &amp;map)</td></tr>
<tr class="memdesc:gaf11cebfe6faef19ed9071beea156cb83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a coordinate map, check that this map is equal to the identity by evaluating the map at a random set of points. <br /></td></tr>
<tr class="separator:gaf11cebfe6faef19ed9071beea156cb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc70a714534092fd0f458bfa3c4903b8"><td class="memTemplParams" colspan="2"><a id="gafc70a714534092fd0f458bfa3c4903b8" name="gafc70a714534092fd0f458bfa3c4903b8"></a>
template&lt;typename Map &gt; </td></tr>
<tr class="memitem:gafc70a714534092fd0f458bfa3c4903b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_frame_velocity</b> (const Map &amp;map, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, Map::dim &gt; &amp;test_point, const double time, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt; &gt; &amp;functions_of_time)</td></tr>
<tr class="memdesc:gafc70a714534092fd0f458bfa3c4903b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a Map <code>map</code>, checks that the frame velocity matches a sixth-order finite difference approximation. <br /></td></tr>
<tr class="separator:gafc70a714534092fd0f458bfa3c4903b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78426b870bda77db6a8e6df8aac4db02"><td class="memTemplParams" colspan="2"><a id="ga78426b870bda77db6a8e6df8aac4db02" name="ga78426b870bda77db6a8e6df8aac4db02"></a>
template&lt;typename Map , typename... Args&gt; </td></tr>
<tr class="memitem:ga78426b870bda77db6a8e6df8aac4db02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_coordinate_map_implementation</b> (const Map &amp;map)</td></tr>
<tr class="memdesc:ga78426b870bda77db6a8e6df8aac4db02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the CoordinateMap <code>map</code> functions as expected when used as the template parameter to the <code>CoordinateMap</code> type. <br /></td></tr>
<tr class="separator:ga78426b870bda77db6a8e6df8aac4db02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2b86f2fe7f836fef3a95233ae9bde7c"><td class="memTemplParams" colspan="2"><a id="gad2b86f2fe7f836fef3a95233ae9bde7c" name="gad2b86f2fe7f836fef3a95233ae9bde7c"></a>
template&lt;typename Map , typename... Args&gt; </td></tr>
<tr class="memitem:gad2b86f2fe7f836fef3a95233ae9bde7c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_coordinate_map_argument_types</b> (const Map &amp;map, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, Map::dim &gt; &amp;test_point, const Args &amp;... args)</td></tr>
<tr class="memdesc:gad2b86f2fe7f836fef3a95233ae9bde7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the CoordinateMap <code>map</code> functions as expected when used with different argument types. <br /></td></tr>
<tr class="separator:gad2b86f2fe7f836fef3a95233ae9bde7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58438d363c5500b83f4f06a3a8db5910"><td class="memTemplParams" colspan="2"><a id="ga58438d363c5500b83f4f06a3a8db5910" name="ga58438d363c5500b83f4f06a3a8db5910"></a>
template&lt;typename Map &gt; </td></tr>
<tr class="memitem:ga58438d363c5500b83f4f06a3a8db5910"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_suite_for_map_on_unit_cube</b> (const Map &amp;map)</td></tr>
<tr class="memdesc:ga58438d363c5500b83f4f06a3a8db5910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a Map <code>map</code>, tests the map functions, including map inverse, jacobian, and inverse jacobian, for a series of points. These points are chosen in a dim-dimensonal cube of side 2 centered at the origin. The map is expected to be valid on the boundaries of the cube. <br /></td></tr>
<tr class="separator:ga58438d363c5500b83f4f06a3a8db5910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7baa6e16abbf3cb34691cde874db1dbc"><td class="memTemplParams" colspan="2"><a id="ga7baa6e16abbf3cb34691cde874db1dbc" name="ga7baa6e16abbf3cb34691cde874db1dbc"></a>
template&lt;typename Map &gt; </td></tr>
<tr class="memitem:ga7baa6e16abbf3cb34691cde874db1dbc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_suite_for_map_on_sphere</b> (const Map &amp;map, const bool include_origin=true, const double radius_of_sphere=1.0)</td></tr>
<tr class="memdesc:ga7baa6e16abbf3cb34691cde874db1dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a Map <code>map</code>, tests the map functions, including map inverse, jacobian, and inverse jacobian, for a series of points. These points are chosen in a sphere of radius <code>radius_of_sphere</code>, and the map is expected to be valid on the boundary of that sphere as well as in its interior. The flag <code>include_origin</code> indicates whether to test the map at the origin. This test works only in 3 dimensions. <br /></td></tr>
<tr class="separator:ga7baa6e16abbf3cb34691cde874db1dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19ebc890415c0a73def2d4ed15a81c32"><td class="memTemplParams" colspan="2"><a id="ga19ebc890415c0a73def2d4ed15a81c32" name="ga19ebc890415c0a73def2d4ed15a81c32"></a>
template&lt;typename Map &gt; </td></tr>
<tr class="memitem:ga19ebc890415c0a73def2d4ed15a81c32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_suite_for_map_on_cylinder</b> (const Map &amp;map, const double inner_radius, const double outer_radius, const bool test_random_z_bdry_roundoff=false, const bool test_random_rho_bdry_roundoff=false)</td></tr>
<tr class="memdesc:ga19ebc890415c0a73def2d4ed15a81c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a Map <code>map</code>, tests the map functions, including map inverse, jacobian, and inverse jacobian, for a series of points. These points are chosen in a right cylinder with cylindrical radius 1 and z-axis extending from -1 to +1. The map is expected to be valid on the boundary of that cylinder as well as in its interior. This test works only in 3 dimensions. <br /></td></tr>
<tr class="separator:ga19ebc890415c0a73def2d4ed15a81c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87ebb39e2d7d2d90f670baccc873c5b8"><td class="memItemLeft" align="right" valign="top"><a id="ga87ebb39e2d7d2d90f670baccc873c5b8" name="ga87ebb39e2d7d2d90f670baccc873c5b8"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; 3 &gt;, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>all_wedge_directions</b> ()</td></tr>
<tr class="memdesc:ga87ebb39e2d7d2d90f670baccc873c5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wedge <a class="el" href="classOrientationMap.html" title="A mapping of the logical coordinate axes of a host to the logical coordinate axes of a neighbor of th...">OrientationMap</a> in each of the six directions used in the Sphere domain creator. <br /></td></tr>
<tr class="separator:ga87ebb39e2d7d2d90f670baccc873c5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f5e51c75c5d48069e8a541fff9b6768"><td class="memTemplParams" colspan="2">template&lt;typename System , typename BoundaryCorrection , size_t FaceDim, typename... VolumeTags, typename... RangeTags&gt; </td></tr>
<tr class="memitem:ga3f5e51c75c5d48069e8a541fff9b6768"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga3f5e51c75c5d48069e8a541fff9b6768">TestHelpers::evolution::dg::test_boundary_correction_conservation</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine.html">std::mt19937</a> * &gt; generator, const BoundaryCorrection &amp;correction, const <a class="el" href="classMesh.html">Mesh</a>&lt; FaceDim &gt; &amp;face_mesh, const <a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; VolumeTags... &gt; &amp;volume_data, const <a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; <a class="el" href="structTestHelpers_1_1evolution_1_1dg_1_1Tags_1_1Range.html">Tags::Range</a>&lt; RangeTags &gt;... &gt; &amp;ranges, const ZeroOnSmoothSolution zero_on_smooth_solution=ZeroOnSmoothSolution::Yes, const double eps=1.0e-12)</td></tr>
<tr class="memdesc:ga3f5e51c75c5d48069e8a541fff9b6768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the boundary correction is conservative and that for smooth solutions the strong-form correction is zero.  <a href="group__TestingFrameworkGroup.html#ga3f5e51c75c5d48069e8a541fff9b6768">More...</a><br /></td></tr>
<tr class="separator:ga3f5e51c75c5d48069e8a541fff9b6768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7087e6c7112ed8c761dc88ca8659bff2"><td class="memTemplParams" colspan="2">template&lt;typename System , typename ConversionClassList  = tmpl::list&lt;&gt;, typename BoundaryCorrection , size_t FaceDim, typename... VolumeTags, typename... RangeTags&gt; </td></tr>
<tr class="memitem:ga7087e6c7112ed8c761dc88ca8659bff2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga7087e6c7112ed8c761dc88ca8659bff2">TestHelpers::evolution::dg::test_boundary_correction_with_python</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine.html">std::mt19937</a> * &gt; generator, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;python_module, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, tmpl::size&lt; typename BoundaryCorrection::dg_package_field_tags &gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a> &gt; &amp;python_dg_package_data_functions, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, tmpl::size&lt; typename System::variables_tag::tags_list &gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a> &gt; &amp;python_dg_boundary_terms_functions, const BoundaryCorrection &amp;correction, const <a class="el" href="classMesh.html">Mesh</a>&lt; FaceDim &gt; &amp;face_mesh, const <a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; VolumeTags... &gt; &amp;volume_data, const <a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; <a class="el" href="structTestHelpers_1_1evolution_1_1dg_1_1Tags_1_1Range.html">Tags::Range</a>&lt; RangeTags &gt;... &gt; &amp;ranges, const double epsilon=1.0e-12)</td></tr>
<tr class="memdesc:ga7087e6c7112ed8c761dc88ca8659bff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests that the <code>dg_package_data</code> and <code>dg_boundary_terms</code> functions agree with the python implementation.  <a href="group__TestingFrameworkGroup.html#ga7087e6c7112ed8c761dc88ca8659bff2">More...</a><br /></td></tr>
<tr class="separator:ga7087e6c7112ed8c761dc88ca8659bff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac01f40512b0cf3c754268134d19f0dd"><td class="memTemplParams" colspan="2">template&lt;typename System , typename SolutionType , size_t Dim = System::volume_dim, typename... Maps, typename PackageFluxesArgs &gt; </td></tr>
<tr class="memitem:gaac01f40512b0cf3c754268134d19f0dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gaac01f40512b0cf3c754268134d19f0dd">FirstOrderEllipticSolutionsTestHelpers::verify_smooth_solution</a> (const SolutionType &amp;solution, const <a class="el" href="classdomain_1_1CoordinateMap.html">domain::CoordinateMap</a>&lt; <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, Maps... &gt; &amp;coord_map, const double tolerance_offset, const double tolerance_scaling, PackageFluxesArgs &amp;&amp;package_fluxes_args)</td></tr>
<tr class="separator:gaac01f40512b0cf3c754268134d19f0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72787f3b08aa73df7781cff8a5192ea8"><td class="memTemplParams" colspan="2">template&lt;typename System , typename SolutionType , size_t Dim = System::volume_dim, typename... Maps&gt; </td></tr>
<tr class="memitem:ga72787f3b08aa73df7781cff8a5192ea8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga72787f3b08aa73df7781cff8a5192ea8">FirstOrderEllipticSolutionsTestHelpers::verify_solution_with_power_law_convergence</a> (const SolutionType &amp;solution, const <a class="el" href="classdomain_1_1CoordinateMap.html">domain::CoordinateMap</a>&lt; <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, Maps... &gt; &amp;coord_map, const double tolerance_offset, const double tolerance_pow)</td></tr>
<tr class="separator:ga72787f3b08aa73df7781cff8a5192ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabec6cfa0fc0e149eeaa14ae2dabf4eff"><td class="memTemplParams" colspan="2">template&lt;typename Solution &gt; </td></tr>
<tr class="memitem:gabec6cfa0fc0e149eeaa14ae2dabf4eff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gabec6cfa0fc0e149eeaa14ae2dabf4eff">verify_grmhd_solution</a> (const Solution &amp;solution, const <a class="el" href="classBlock.html">Block</a>&lt; 3 &gt; &amp;block, const <a class="el" href="classMesh.html">Mesh</a>&lt; 3 &gt; &amp;mesh, const double error_tolerance, const double time, const double delta_time)</td></tr>
<tr class="memdesc:gabec6cfa0fc0e149eeaa14ae2dabf4eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given <code>solution</code> is a solution of the GRMHD equations.  <a href="group__TestingFrameworkGroup.html#gabec6cfa0fc0e149eeaa14ae2dabf4eff">More...</a><br /></td></tr>
<tr class="separator:gabec6cfa0fc0e149eeaa14ae2dabf4eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bf8d239cc44933ed6836e4d604afced"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , typename T , typename UniformRandomBitGenerator , typename RandomNumberDistribution &gt; </td></tr>
<tr class="memitem:ga0bf8d239cc44933ed6836e4d604afced"><td class="memTemplItemLeft" align="right" valign="top">ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga0bf8d239cc44933ed6836e4d604afced">make_with_random_values</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; UniformRandomBitGenerator * &gt; generator, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; RandomNumberDistribution * &gt; distribution, const T &amp;used_for_size)</td></tr>
<tr class="memdesc:ga0bf8d239cc44933ed6836e4d604afced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a data structure and fill it with random values.  <a href="group__TestingFrameworkGroup.html#ga0bf8d239cc44933ed6836e4d604afced">More...</a><br /></td></tr>
<tr class="separator:ga0bf8d239cc44933ed6836e4d604afced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c6c3cc0910230ad3d2e274c7fa256fe"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , typename T , typename UniformRandomBitGenerator , typename RandomNumberDistribution &gt; </td></tr>
<tr class="memitem:ga7c6c3cc0910230ad3d2e274c7fa256fe"><td class="memTemplItemLeft" align="right" valign="top">ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga7c6c3cc0910230ad3d2e274c7fa256fe">make_with_random_values</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; UniformRandomBitGenerator * &gt; generator, RandomNumberDistribution distribution, const T &amp;used_for_size)</td></tr>
<tr class="memdesc:ga7c6c3cc0910230ad3d2e274c7fa256fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a data structure and fill it with random values.  <a href="group__TestingFrameworkGroup.html#ga7c6c3cc0910230ad3d2e274c7fa256fe">More...</a><br /></td></tr>
<tr class="separator:ga7c6c3cc0910230ad3d2e274c7fa256fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf02c223800e6dff5b7ef7e26cd9346d"><td class="memTemplParams" colspan="2"><a id="gabf02c223800e6dff5b7ef7e26cd9346d" name="gabf02c223800e6dff5b7ef7e26cd9346d"></a>
template&lt;typename Map &gt; </td></tr>
<tr class="memitem:gabf02c223800e6dff5b7ef7e26cd9346d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_jacobian</b> (const Map &amp;map, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, Map::dim &gt; &amp;test_point)</td></tr>
<tr class="memdesc:gabf02c223800e6dff5b7ef7e26cd9346d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a Map <code>map</code>, checks that the jacobian gives expected results when compared to the numerical derivative in each direction. <br /></td></tr>
<tr class="separator:gabf02c223800e6dff5b7ef7e26cd9346d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dbe087348716b50dffe2d26a51fdc6a"><td class="memTemplParams" colspan="2"><a id="ga7dbe087348716b50dffe2d26a51fdc6a" name="ga7dbe087348716b50dffe2d26a51fdc6a"></a>
template&lt;typename Map &gt; </td></tr>
<tr class="memitem:ga7dbe087348716b50dffe2d26a51fdc6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_jacobian</b> (const Map &amp;map, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, Map::dim &gt; &amp;test_point, const double time, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt; &gt; &amp;functions_of_time)</td></tr>
<tr class="memdesc:ga7dbe087348716b50dffe2d26a51fdc6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a Map <code>map</code>, checks that the jacobian gives expected results when compared to the numerical derivative in each direction. <br /></td></tr>
<tr class="separator:ga7dbe087348716b50dffe2d26a51fdc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa520953bc8d464f7e10e8eb194d60f48"><td class="memTemplParams" colspan="2"><a id="gaa520953bc8d464f7e10e8eb194d60f48" name="gaa520953bc8d464f7e10e8eb194d60f48"></a>
template&lt;typename Map &gt; </td></tr>
<tr class="memitem:gaa520953bc8d464f7e10e8eb194d60f48"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_inv_jacobian</b> (const Map &amp;map, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, Map::dim &gt; &amp;test_point)</td></tr>
<tr class="memdesc:gaa520953bc8d464f7e10e8eb194d60f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a Map <code>map</code>, checks that the inverse jacobian and jacobian multiply together to produce the identity matrix. <br /></td></tr>
<tr class="separator:gaa520953bc8d464f7e10e8eb194d60f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0f06c0c4d64e4aad8d4df7e7c9213b6"><td class="memTemplParams" colspan="2"><a id="gae0f06c0c4d64e4aad8d4df7e7c9213b6" name="gae0f06c0c4d64e4aad8d4df7e7c9213b6"></a>
template&lt;typename Map &gt; </td></tr>
<tr class="memitem:gae0f06c0c4d64e4aad8d4df7e7c9213b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_inv_jacobian</b> (const Map &amp;map, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, Map::dim &gt; &amp;test_point, const double time, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt; &gt; &amp;functions_of_time)</td></tr>
<tr class="memdesc:gae0f06c0c4d64e4aad8d4df7e7c9213b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a Map <code>map</code>, checks that the inverse jacobian and jacobian multiply together to produce the identity matrix. <br /></td></tr>
<tr class="separator:gae0f06c0c4d64e4aad8d4df7e7c9213b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39ae8490d3901771ac4387ee02128025"><td class="memTemplParams" colspan="2"><a id="ga39ae8490d3901771ac4387ee02128025" name="ga39ae8490d3901771ac4387ee02128025"></a>
template&lt;typename Map , typename T &gt; </td></tr>
<tr class="memitem:ga39ae8490d3901771ac4387ee02128025"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_inverse_map</b> (const Map &amp;map, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Map::dim &gt; &amp;test_point)</td></tr>
<tr class="memdesc:ga39ae8490d3901771ac4387ee02128025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a Map <code>map</code>, checks that the inverse map gives expected results. <br /></td></tr>
<tr class="separator:ga39ae8490d3901771ac4387ee02128025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc8571ece42ca2a0012d36adf4a605dd"><td class="memTemplParams" colspan="2"><a id="gabc8571ece42ca2a0012d36adf4a605dd" name="gabc8571ece42ca2a0012d36adf4a605dd"></a>
template&lt;typename Map , typename T &gt; </td></tr>
<tr class="memitem:gabc8571ece42ca2a0012d36adf4a605dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_inverse_map</b> (const Map &amp;map, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Map::dim &gt; &amp;test_point, const double time, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt; &gt; &amp;functions_of_time)</td></tr>
<tr class="memdesc:gabc8571ece42ca2a0012d36adf4a605dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a Map <code>map</code>, checks that the inverse map gives expected results. <br /></td></tr>
<tr class="separator:gabc8571ece42ca2a0012d36adf4a605dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6cf9f799c2fec832c8f3f5330676b6d"><td class="memTemplParams" colspan="2">template&lt;class DampingFunctionType , class T , class... MemberArgs&gt; </td></tr>
<tr class="memitem:gaf6cf9f799c2fec832c8f3f5330676b6d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gaf6cf9f799c2fec832c8f3f5330676b6d">TestHelpers::gh::ConstraintDamping::check</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; DampingFunctionType &gt; in_gh_damping_function, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;python_function_prefix, const T &amp;used_for_size, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; double, double &gt;, 1 &gt; &amp;random_value_bounds, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;function_of_time_names, const MemberArgs &amp;... member_args)</td></tr>
<tr class="memdesc:gaf6cf9f799c2fec832c8f3f5330676b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test a DampingFunction by comparing to python functions.  <a href="group__TestingFrameworkGroup.html#gaf6cf9f799c2fec832c8f3f5330676b6d">More...</a><br /></td></tr>
<tr class="separator:gaf6cf9f799c2fec832c8f3f5330676b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa23eb20b9665d1a932d9e1eb23ee2fc9"><td class="memTemplParams" colspan="2">template&lt;class DampingFunctionType , class T , class... MemberArgs&gt; </td></tr>
<tr class="memitem:gaa23eb20b9665d1a932d9e1eb23ee2fc9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gaa23eb20b9665d1a932d9e1eb23ee2fc9">TestHelpers::gh::ConstraintDamping::check</a> (DampingFunctionType in_gh_damping_function, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;python_function_prefix, const T &amp;used_for_size, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; double, double &gt;, 1 &gt; &amp;random_value_bounds, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;function_of_time_names, const MemberArgs &amp;... member_args)</td></tr>
<tr class="memdesc:gaa23eb20b9665d1a932d9e1eb23ee2fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test a DampingFunction by comparing to python functions.  <a href="group__TestingFrameworkGroup.html#gaa23eb20b9665d1a932d9e1eb23ee2fc9">More...</a><br /></td></tr>
<tr class="separator:gaa23eb20b9665d1a932d9e1eb23ee2fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9c172babf519ad50dacb87147134c10"><td class="memTemplParams" colspan="2"><a id="gab9c172babf519ad50dacb87147134c10" name="gab9c172babf519ad50dacb87147134c10"></a>
template&lt;typename System , typename SolutionType , typename... Maps, typename... FluxesArgs, typename... SourcesArgs&gt; </td></tr>
<tr class="memitem:gab9c172babf519ad50dacb87147134c10"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FirstOrderEllipticSolutionsTestHelpers::verify_solution</b> (const SolutionType &amp;solution, const <a class="el" href="classMesh.html">Mesh</a>&lt; System::volume_dim &gt; &amp;mesh, const <a class="el" href="classdomain_1_1CoordinateMap.html">domain::CoordinateMap</a>&lt; <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, Maps... &gt; coord_map, const double tolerance, const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; FluxesArgs... &gt; &amp;fluxes_args, const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; SourcesArgs... &gt; &amp;sources_args=<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt;&gt;{})</td></tr>
<tr class="memdesc:gab9c172babf519ad50dacb87147134c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the <code>solution</code> numerically solves the <code>System</code> on the given grid for the given tolerance. <br /></td></tr>
<tr class="separator:gab9c172babf519ad50dacb87147134c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga007c095dc39fb8c3109e15a92915bae6"><td class="memTemplParams" colspan="2"><a id="ga007c095dc39fb8c3109e15a92915bae6" name="ga007c095dc39fb8c3109e15a92915bae6"></a>
template&lt;typename System , typename SolutionType , typename... Maps&gt; </td></tr>
<tr class="memitem:ga007c095dc39fb8c3109e15a92915bae6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FirstOrderEllipticSolutionsTestHelpers::verify_solution</b> (const SolutionType &amp;solution, const <a class="el" href="classMesh.html">Mesh</a>&lt; System::volume_dim &gt; &amp;mesh, const <a class="el" href="classdomain_1_1CoordinateMap.html">domain::CoordinateMap</a>&lt; <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, Maps... &gt; coord_map, const double tolerance)</td></tr>
<tr class="memdesc:ga007c095dc39fb8c3109e15a92915bae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the <code>solution</code> numerically solves the <code>System</code> on the given grid for the given tolerance. <br /></td></tr>
<tr class="separator:ga007c095dc39fb8c3109e15a92915bae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03d261aaea4d10436566df746e88a6a5"><td class="memTemplParams" colspan="2">template&lt;class EosType , class T , class... MemberArgs&gt; </td></tr>
<tr class="memitem:ga03d261aaea4d10436566df746e88a6a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga03d261aaea4d10436566df746e88a6a5">TestHelpers::EquationsOfState::check</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; EosType &gt; in_eos, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;python_file_name, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;python_function_prefix, const T &amp;used_for_size, const MemberArgs &amp;... member_args)</td></tr>
<tr class="memdesc:ga03d261aaea4d10436566df746e88a6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test an equation of state by comparing to python functions.  <a href="group__TestingFrameworkGroup.html#ga03d261aaea4d10436566df746e88a6a5">More...</a><br /></td></tr>
<tr class="separator:ga03d261aaea4d10436566df746e88a6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62bc06eb56f2b61c118bb77d20f7abfd"><td class="memTemplParams" colspan="2">template&lt;class EosType , class T , class... MemberArgs&gt; </td></tr>
<tr class="memitem:ga62bc06eb56f2b61c118bb77d20f7abfd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga62bc06eb56f2b61c118bb77d20f7abfd">TestHelpers::EquationsOfState::check</a> (EosType in_eos, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;python_file_name, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;python_function_prefix, const T &amp;used_for_size, const MemberArgs &amp;... member_args)</td></tr>
<tr class="memdesc:ga62bc06eb56f2b61c118bb77d20f7abfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test an equation of state by comparing to python functions.  <a href="group__TestingFrameworkGroup.html#ga62bc06eb56f2b61c118bb77d20f7abfd">More...</a><br /></td></tr>
<tr class="separator:ga62bc06eb56f2b61c118bb77d20f7abfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafda4244b1430fc33ac0350228fda4625"><td class="memTemplParams" colspan="2">template&lt;class MathFunctionType , class T , class... MemberArgs&gt; </td></tr>
<tr class="memitem:gafda4244b1430fc33ac0350228fda4625"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gafda4244b1430fc33ac0350228fda4625">TestHelpers::MathFunctions::check</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; MathFunctionType &gt; in_math_function, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;python_function_prefix, const T &amp;used_for_size, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; double, double &gt;, 1 &gt; random_value_bounds, const MemberArgs &amp;... member_args)</td></tr>
<tr class="memdesc:gafda4244b1430fc33ac0350228fda4625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test a <a class="el" href="classMathFunction.html">MathFunction</a> by comparing to python functions.  <a href="group__TestingFrameworkGroup.html#gafda4244b1430fc33ac0350228fda4625">More...</a><br /></td></tr>
<tr class="separator:gafda4244b1430fc33ac0350228fda4625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85ceb5d3fa39fa2527dc984d8be4a1b8"><td class="memTemplParams" colspan="2">template&lt;class MathFunctionType , class T , class... MemberArgs&gt; </td></tr>
<tr class="memitem:ga85ceb5d3fa39fa2527dc984d8be4a1b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga85ceb5d3fa39fa2527dc984d8be4a1b8">TestHelpers::MathFunctions::check</a> (MathFunctionType in_math_function, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;python_function_prefix, const T &amp;used_for_size, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; double, double &gt;, 1 &gt; random_value_bounds, const MemberArgs &amp;... member_args)</td></tr>
<tr class="memdesc:ga85ceb5d3fa39fa2527dc984d8be4a1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test a <a class="el" href="classMathFunction.html">MathFunction</a> by comparing to python functions.  <a href="group__TestingFrameworkGroup.html#ga85ceb5d3fa39fa2527dc984d8be4a1b8">More...</a><br /></td></tr>
<tr class="separator:ga85ceb5d3fa39fa2527dc984d8be4a1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Classes, functions, macros, and instructions for developing tests. </p>
<h3>Details</h3>
<p >SpECTRE uses the testing framework <a href="https://github.com/philsquared/Catch">Catch</a>. Catch supports a variety of different styles of tests including BDD and fixture tests. The file <code>cmake/SpectreAddCatchTests.cmake</code> parses the source files and adds the found tests to ctest with the correct properties specified by tags and attributes.</p>
<h3><a class="anchor" id="autotoc_md187"></a>
Usage</h3>
<p >To run the tests, type <code>ctest</code> in the build directory. You can specify a regex to match the test name using <code>ctest -R Unit.Blah</code>, or run all tests with a certain tag using <code>ctest -L tag</code>.</p>
<h3><a class="anchor" id="autotoc_md188"></a>
Comparing double-precision results</h3>
<p >To compare two floating-point numbers that may differ by round-off, use the helper object <code>approx</code>. This is an instance of Catch's comparison class <code>Approx</code> in which the relative tolerance for comparisons is set to roughly \(10^{-14}\) (i.e. <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits</a>&lt;double&gt;::epsilon()*100</code>). When possible, we recommend using <code>approx</code> for fuzzy comparisons as follows: </p>
<h3>Example</h3>
<div class="fragment"><div class="line">  CHECK(<a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/numeric/math/sin.html">sin</a>(M_PI / 4.0) == approx(<a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/numeric/math/cos.html">cos</a>(M_PI / 4.0)));</div>
<div class="ttc" id="acos_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/numeric/math/cos.html">std::cos</a></div><div class="ttdeci">T cos(T... args)</div></div>
<div class="ttc" id="asin_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/numeric/math/sin.html">std::sin</a></div><div class="ttdeci">T sin(T... args)</div></div>
</div><!-- fragment --><p >For checks that need more control over the precision (e.g. an algorithm in which round-off errors accumulate to a higher level), we recommend using the <code>approx</code> helper with a one-time tolerance adjustment. A comment should explain the reason for the adjustment: </p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="comment">// This check needs tolerance 1e-12 for X reason.</span></div>
<div class="line">  CHECK(1.0 == approx(1.0 + 5e-13).epsilon(1e-12));</div>
</div><!-- fragment --><p >For tests in which the same precision adjustment is re-used many times, a new helper object can be created from Catch's <code>Approx</code> with a custom precision: </p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="comment">// The checks in this test need tolerance 1e-12 for X reason.</span></div>
<div class="line">  Approx my_approx = Approx::custom().epsilon(1e-12);</div>
<div class="line">  CHECK(1.0 == my_approx(1.0 + 5e-13));</div>
<div class="line">  CHECK(1.0 != my_approx(1.0 + 5e-12));</div>
</div><!-- fragment --><p >Note: We provide the <code>approx</code> object because Catch's <code>Approx</code> defaults to a very loose tolerance (<code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits</a>&lt;float&gt;::epsilon()*100</code>, or roughly \(10^{-5}\) relative error), and so is poorly-suited to checking many numerical algorithms that rely on double-precision accuracy. By providing a tighter tolerance with <code>approx</code>, we avoid having to redefine the tolerance in every test.</p>
<h3><a class="anchor" id="autotoc_md189"></a>
Attributes</h3>
<p >Attributes allow you to modify properties of the test. Attributes are specified as follows: </p><div class="fragment"><div class="line"><span class="comment">// [[TimeOut, 10]]</span></div>
<div class="line"><span class="comment">// [[OutputRegex, The error message expected from the test]]</span></div>
<div class="line">SPECTRE_TEST_CASE(<span class="stringliteral">&quot;Unit.Blah&quot;</span>, <span class="stringliteral">&quot;[Unit]&quot;</span>) {</div>
</div><!-- fragment --><p >Available attributes are:</p>
<table class="doxtable">
<tr>
<th>Attribute </th><th>Description   </th></tr>
<tr>
<td>TimeOut  </td><td>override the default timeout and set the timeout to N seconds. This should be set very sparingly since unit tests are designed to be short. If your test is too long you should consider testing smaller portions of the code if possible, or writing an integration test instead.   </td></tr>
<tr>
<td>OutputRegex  </td><td>When testing failure modes the exact error message must be tested, not just that the test failed. Since the string passed is a regular expression you must escape any regex tokens. For example, to match <code>some (word) and</code> you must specify the string <code>some \(word\) and</code>. If your error message contains a newline, you can match it using the dot operator <code>.</code>, which matches any character.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md190"></a>
Debugging Tests in GDB or LLDB</h3>
<p >Several tests fail intentionally at the executable level to test error handling like ASSERT statements in the code. CTest is aware of which should fail and passes them. If you want to debug an individual test in a debugger you need to run a single test using the RunTests executable (in dg-charm-build/bin/RunTests) you must specify the name of the test as the first argument. For example, if you want to run just the "Unit.Gradient" test you can run <code>./bin/RunTests Unit.Gradient</code>. If you are using a debugger launch the debugger, for example if you're using LLDB then run <code>lldb ./bin/RunTests</code> and then to run the executable inside the debugger use <code>run Unit.Gradient</code> inside the debugger.</p>
<h3>Details</h3>
<p >SpECTRE uses the testing framework <a href="https://github.com/philsquared/Catch">Catch</a>. Catch supports a variety of different styles of tests including BDD and fixture tests. The file <code>cmake/SpectreAddCatchTests.cmake</code> parses the source files and adds the found tests to ctest with the correct properties specified by tags and attributes.</p>
<h3><a class="anchor" id="autotoc_md206"></a>
Usage</h3>
<p >To run the tests, type <code>ctest</code> in the build directory. You can specify a regex to match the test name using <code>ctest -R Unit.Blah</code>, or run all tests with a certain tag using <code>ctest -L tag</code>.</p>
<h3><a class="anchor" id="autotoc_md207"></a>
Comparing double-precision results</h3>
<p >To compare two floating-point numbers that may differ by round-off, use the helper object <code>approx</code>. This is an instance of Catch's comparison class <code>Approx</code> in which the relative tolerance for comparisons is set to roughly \(10^{-14}\) (i.e. <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits</a>&lt;double&gt;::epsilon()*100</code>). When possible, we recommend using <code>approx</code> for fuzzy comparisons as follows: </p>
<h3>Example</h3>
<div class="fragment"><div class="line">  CHECK(<a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/numeric/math/sin.html">sin</a>(M_PI / 4.0) == approx(<a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/numeric/math/cos.html">cos</a>(M_PI / 4.0)));</div>
</div><!-- fragment --><p >For checks that need more control over the precision (e.g. an algorithm in which round-off errors accumulate to a higher level), we recommend using the <code>approx</code> helper with a one-time tolerance adjustment. A comment should explain the reason for the adjustment: </p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="comment">// This check needs tolerance 1e-12 for X reason.</span></div>
<div class="line">  CHECK(1.0 == approx(1.0 + 5e-13).epsilon(1e-12));</div>
</div><!-- fragment --><p >For tests in which the same precision adjustment is re-used many times, a new helper object can be created from Catch's <code>Approx</code> with a custom precision: </p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="comment">// The checks in this test need tolerance 1e-12 for X reason.</span></div>
<div class="line">  Approx my_approx = Approx::custom().epsilon(1e-12);</div>
<div class="line">  CHECK(1.0 == my_approx(1.0 + 5e-13));</div>
<div class="line">  CHECK(1.0 != my_approx(1.0 + 5e-12));</div>
</div><!-- fragment --><p >Note: We provide the <code>approx</code> object because Catch's <code>Approx</code> defaults to a very loose tolerance (<code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits</a>&lt;float&gt;::epsilon()*100</code>, or roughly \(10^{-5}\) relative error), and so is poorly-suited to checking many numerical algorithms that rely on double-precision accuracy. By providing a tighter tolerance with <code>approx</code>, we avoid having to redefine the tolerance in every test.</p>
<h3><a class="anchor" id="autotoc_md208"></a>
Attributes</h3>
<p >Attributes allow you to modify properties of the test. Attributes are specified as follows: </p><div class="fragment"><div class="line"><span class="comment">// [[TimeOut, 10]]</span></div>
<div class="line"><span class="comment">// [[OutputRegex, The error message expected from the test]]</span></div>
<div class="line">SPECTRE_TEST_CASE(<span class="stringliteral">&quot;Unit.Blah&quot;</span>, <span class="stringliteral">&quot;[Unit]&quot;</span>) {</div>
</div><!-- fragment --><p >Available attributes are:</p>
<table class="doxtable">
<tr>
<th>Attribute </th><th>Description   </th></tr>
<tr>
<td>TimeOut  </td><td>override the default timeout and set the timeout to N seconds. This should be set very sparingly since unit tests are designed to be short. If your test is too long you should consider testing smaller portions of the code if possible, or writing an integration test instead.   </td></tr>
<tr>
<td>OutputRegex  </td><td>When testing failure modes the exact error message must be tested, not just that the test failed. Since the string passed is a regular expression you must escape any regex tokens. For example, to match <code>some (word) and</code> you must specify the string <code>some \(word\) and</code>. If your error message contains a newline, you can match it using the dot operator <code>.</code>, which matches any character.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md209"></a>
Debugging Tests in GDB or LLDB</h3>
<p >Several tests fail intentionally at the executable level to test error handling like ASSERT statements in the code. CTest is aware of which should fail and passes them. If you want to debug an individual test in a debugger you need to run a single test using the RunTests executable (in dg-charm-build/bin/RunTests) you must specify the name of the test as the first argument. For example, if you want to run just the "Unit.Gradient" test you can run <code>./bin/RunTests Unit.Gradient</code>. If you are using a debugger launch the debugger, for example if you're using LLDB then run <code>lldb ./bin/RunTests</code> and then to run the executable inside the debugger use <code>run Unit.Gradient</code> inside the debugger. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga4439208ed8accb2887ff47388e91e58b" name="ga4439208ed8accb2887ff47388e91e58b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4439208ed8accb2887ff47388e91e58b">&#9670;&nbsp;</a></span>ASSERTION_TEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ASSERTION_TEST</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                     \</div>
<div class="line">    ERROR_TEST();                                          <a class="code hl_function" href="group__ErrorHandlingGroup.html#gad6d2339bbc734dda9d64a6767a74b796">\</a></div>
<div class="line"><a class="code hl_function" href="group__ErrorHandlingGroup.html#gad6d2339bbc734dda9d64a6767a74b796">    sys::abort</a>(<span class="stringliteral">&quot;### No ASSERT tests in release mode ###&quot;</span>); \</div>
<div class="line">  } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
<div class="ttc" id="agroup__ErrorHandlingGroup_html_gad6d2339bbc734dda9d64a6767a74b796"><div class="ttname"><a href="group__ErrorHandlingGroup.html#gad6d2339bbc734dda9d64a6767a74b796">sys::abort</a></div><div class="ttdeci">void abort(const std::string &amp;message)</div><div class="ttdoc">Abort the program with an error message.</div></div>
</div><!-- fragment -->
<p>Mark a test to be checking an ASSERT. </p>
<h3>Details</h3>
<p >Testing error handling is just as important as testing functionality. Tests that are supposed to exit with an error must be annotated with the attribute </p><div class="fragment"><div class="line"><span class="comment">// [[OutputRegex, The regex that should be found in the output]]</span></div>
</div><!-- fragment --><p> Note that the regex only needs to be a sub-expression of the error message, that is, there are implicit wildcards before and after the string.</p>
<p >In order to test ASSERT's properly the test must also fail for release builds. This is done by adding this macro at the beginning for the test.</p>
<dl class="section warning"><dt>Warning</dt><dd>This macro is deprecated. See <a class="el" href="writing_unit_tests.html#testing_failure_cases">the DevGuide</a> for the modern way to do this. </dd></dl>

</div>
</div>
<a id="ga5509fb28c65f22498410618609f8c085" name="ga5509fb28c65f22498410618609f8c085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5509fb28c65f22498410618609f8c085">&#9670;&nbsp;</a></span>CHECK_COMPLEX_APPROX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_COMPLEX_APPROX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                 \</div>
<div class="line">    INFO(__FILE__ <span class="stringliteral">&quot;:&quot;</span> + std::to_string(__LINE__) + <span class="stringliteral">&quot;: &quot;</span> #a <span class="stringliteral">&quot; == &quot;</span> #b); \</div>
<div class="line">    CHECK(approx(real(a)) == real(b));                                 \</div>
<div class="line">    CHECK(approx(imag(a)) == imag(b));                                 \</div>
<div class="line">  } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p>A wrapper around Catch's CHECK macro that checks approximate equality of the two entries in a <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>. For efficiency, no function forwarding is performed, just a pair of <code>CHECK</code>s inline. </p>

</div>
</div>
<a id="ga5527bb2a3aa50f572faae13dfb8783e5" name="ga5527bb2a3aa50f572faae13dfb8783e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5527bb2a3aa50f572faae13dfb8783e5">&#9670;&nbsp;</a></span>CHECK_COMPLEX_CUSTOM_APPROX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_COMPLEX_CUSTOM_APPROX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">appx&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                 \</div>
<div class="line">    INFO(__FILE__ <span class="stringliteral">&quot;:&quot;</span> + std::to_string(__LINE__) + <span class="stringliteral">&quot;: &quot;</span> #a <span class="stringliteral">&quot; == &quot;</span> #b); \</div>
<div class="line">    CHECK(appx(real(a)) == real(b));                                   \</div>
<div class="line">    CHECK(appx(imag(a)) == imag(b));                                   \</div>
<div class="line">  } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p>Same as <code>CHECK_COMPLEX_APPROX</code> with user-defined Approx. The third argument should be of type <code>Approx</code>. </p>

</div>
</div>
<a id="ga21fcbc0b07905e0d2f8b012b388acd73" name="ga21fcbc0b07905e0d2f8b012b388acd73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21fcbc0b07905e0d2f8b012b388acd73">&#9670;&nbsp;</a></span>CHECK_FOR_DOUBLES_AND_DATAVECTORS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_FOR_DOUBLES_AND_DATAVECTORS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">FUNCTION_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  CHECK_FOR_DOUBLES(FUNCTION_NAME, __VA_ARGS__)               \</div>
<div class="line">  CHECK_FOR_DATAVECTORS(FUNCTION_NAME, __VA_ARGS__)</div>
</div><!-- fragment -->
<p>Macro used to test functions whose parameter can be a <code>double</code> or a <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code>. </p>
<p >In testing multiple instances of a function template using random values, it often proves useful to write a wrapper around <code><a class="el" href="namespacepypp.html#a796819ebc4f228d875772c6d40cc021a" title="Tests a C++ function returning by value by comparing the result to a python function.">pypp::check_with_random_values</a></code>. This way, one can easily loop over several values of one or multiple template parameters (e.g. when testing a function templated in the number of spacetime dimensions.) The template parameters of the wrapper will then correspond to the template parameters of the function, which will be used by <code><a class="el" href="namespacepypp.html#a796819ebc4f228d875772c6d40cc021a" title="Tests a C++ function returning by value by comparing the result to a python function.">pypp::check_with_random_values</a></code> to invoke and test each instance. Each of these wrappers will generally need only one parameter, namely a variable <code>used_for_size</code> passed to <code><a class="el" href="namespacepypp.html#a796819ebc4f228d875772c6d40cc021a" title="Tests a C++ function returning by value by comparing the result to a python function.">pypp::check_with_random_values</a></code> that can be a <code>double</code>, a <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code>, or both (provided that the function being tested is templated in the type of <code>used_for_size</code>.) Since this is applied in multiple test files, all of these files will share the same way to generate the required calls to the wrapper.</p>
<p >This macro, along with</p>
<div class="fragment"><div class="line">CHECK_FOR_DOUBLES(FUNCTION_NAME, ...)</div>
</div><!-- fragment --> <div class="fragment"><div class="line">CHECK_FOR_DATAVECTORS(FUNCTION_NAME, ...)</div>
</div><!-- fragment --><p >allow to generate calls to multiple instances of a test function template in the same way as done by <code><a class="el" href="group__TestingFrameworkGroup.html#ga8cd2549e4a5627f34f8201af2bcbfd34" title="Macro used to invoke a test function of multiple template arguments.">INVOKE_TEST_FUNCTION(FUNCTION_NAME, ARGS_TUPLE,
...)</a></code> (to which these macros call), except that the tuple of arguments is not passed, as these macros will assume that a <code>double</code> <code>d</code> and/or a <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code> <code>dv</code> will be previously defined. Although any <code>d</code>s and <code>dv</code>s will work, one can (and it is recommended to) generate signaling <code>NaN</code> values for <code>d</code> and <code>dv</code>. This can be done by invoking one of the three provided macros: <code>GENERATE_UNINIATILIZED_DOUBLE</code>, <code>GENERATE_UNINITIALIZED_DATAVECTOR</code>, or <code>GENERATE_UNINITIALIZED_DOUBLE_AND_DATAVECTOR</code>. For example,</p>
<div class="fragment"><div class="line">GENERATE_UNINITIALIZED_DATAVECTOR;</div>
<div class="line">CHECK_FOR_DATAVECTORS(test_fluxes, (1, 2, 3))</div>
</div><!-- fragment --><p >will generate a test case for 1, 2 and 3 dimensions:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classDataVector.html">DataVector</a> dv(5);</div>
<div class="line">test_fluxes&lt;1&gt;(dv);</div>
<div class="line">test_fluxes&lt;2&gt;(dv);</div>
<div class="line">test_fluxes&lt;3&gt;(dv);</div>
<div class="ttc" id="aclassDataVector_html"><div class="ttname"><a href="classDataVector.html">DataVector</a></div><div class="ttdoc">Stores a collection of function values.</div><div class="ttdef"><b>Definition:</b> DataVector.hpp:48</div></div>
</div><!-- fragment --><p >Analogously, the wrapper</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Dim, IndexType TypeOfIndex, <span class="keyword">typename</span> DataType&gt;</div>
<div class="line">test_ricci(<span class="keyword">const</span> DataType&amp; used_for_size) { ... }</div>
</div><!-- fragment --><p >can be invoked by writing</p>
<div class="fragment"><div class="line">GENERATE_UNINITIALIZED_DOUBLE_AND_DATAVECTOR;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__TestingFrameworkGroup.html#ga21fcbc0b07905e0d2f8b012b388acd73">CHECK_FOR_DOUBLES_AND_DATAVECTORS</a>(test_ricci, (1, 2, 3),</div>
<div class="line">                                  (<a class="code hl_enumvalue" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504">IndexType::Spatial</a>, <a class="code hl_enumvalue" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8eaed5df3a695921f514a83c22d119c0f8e">IndexType::Spacetime</a>))</div>
<div class="ttc" id="agroup__TensorGroup_html_gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504"><div class="ttname"><a href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504">IndexType::Spatial</a></div><div class="ttdeci">@ Spatial</div><div class="ttdoc">The TensorIndexType is purely spatial.</div></div>
<div class="ttc" id="agroup__TensorGroup_html_gga875b107b929ff008a27078792ac0bc8eaed5df3a695921f514a83c22d119c0f8e"><div class="ttname"><a href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8eaed5df3a695921f514a83c22d119c0f8e">IndexType::Spacetime</a></div><div class="ttdeci">@ Spacetime</div><div class="ttdoc">The TensorIndexType is a spacetime index.</div></div>
<div class="ttc" id="agroup__TestingFrameworkGroup_html_ga21fcbc0b07905e0d2f8b012b388acd73"><div class="ttname"><a href="group__TestingFrameworkGroup.html#ga21fcbc0b07905e0d2f8b012b388acd73">CHECK_FOR_DOUBLES_AND_DATAVECTORS</a></div><div class="ttdeci">#define CHECK_FOR_DOUBLES_AND_DATAVECTORS(FUNCTION_NAME,...)</div><div class="ttdoc">Macro used to test functions whose parameter can be a double or a DataVector.</div><div class="ttdef"><b>Definition:</b> CheckWithRandomValues.hpp:937</div></div>
</div><!-- fragment --><p >which will generate</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> d(<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits&lt;double&gt;::signaling_NaN</a>());</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classDataVector.html">DataVector</a> dv(5);</div>
<div class="line"> </div>
<div class="line">test_ricci&lt;1, IndexType::Spatial&gt;(d);</div>
<div class="line">test_ricci&lt;1, IndexType::Spacetime&gt;(d);</div>
<div class="line">test_ricci&lt;2, IndexType::Spatial&gt;(d);</div>
<div class="line">test_ricci&lt;2, IndexType::Spacetime&gt;(d);</div>
<div class="line">test_ricci&lt;3, IndexType::Spatial&gt;(d);</div>
<div class="line">test_ricci&lt;3, IndexType::Spacetime&gt;(d);</div>
<div class="line">test_ricci&lt;1, IndexType::Spatial&gt;(dv);</div>
<div class="line">test_ricci&lt;1, IndexType::Spacetime&gt;(dv);</div>
<div class="line">test_ricci&lt;2, IndexType::Spatial&gt;(dv);</div>
<div class="line">test_ricci&lt;2, IndexType::Spacetime&gt;(dv);</div>
<div class="line">test_ricci&lt;3, IndexType::Spatial&gt;(dv);</div>
<div class="line">test_ricci&lt;3, IndexType::Spacetime&gt;(dv);</div>
<div class="ttc" id="anumeric_limits_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits</a></div></div>
</div><!-- fragment --><p >Note that it is not necessary to pass values for <code>DataType</code>, as they are deduced from <code>used_for_size</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The order of the macro-tuples of values must match the order of the template parameters of the function.</dd>
<dd>
The function to be called must at least have one template argument, so passing an empty set of template parameters will not work. </dd></dl>

</div>
</div>
<a id="ga6ce5d669c94418f197e4c55c53e64a64" name="ga6ce5d669c94418f197e4c55c53e64a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ce5d669c94418f197e4c55c53e64a64">&#9670;&nbsp;</a></span>CHECK_ITERABLE_APPROX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_ITERABLE_APPROX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                       \</div>
<div class="line">    INFO(__FILE__ <span class="stringliteral">&quot;:&quot;</span> + std::to_string(__LINE__) + <span class="stringliteral">&quot;: &quot;</span> #a <span class="stringliteral">&quot; == &quot;</span> #b);       \</div>
<div class="line">    check_iterable_approx&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/common_type.html">std::common_type_t</a>&lt;                                \</div>
<div class="line">        std::decay_t&lt;<span class="keyword">decltype</span>(a)&gt;, <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt;<span class="keyword">decltype</span>(b)&gt;&gt;&gt;<a class="code hl_function" href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">::apply</a>(a, b); \</div>
<div class="line">  } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
<div class="ttc" id="acommon_type_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/types/common_type.html">std::common_type_t</a></div></div>
<div class="ttc" id="adecay_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a></div></div>
<div class="ttc" id="agroup__DataStructuresGroup_html_ga058ade0497757606713948256728c6db"><div class="ttname"><a href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">apply</a></div><div class="ttdeci">auto apply(F &amp;&amp;f, const ObservationBox&lt; ComputeTagsList, DataBoxType &gt; &amp;observation_box, Args &amp;&amp;... args)</div><div class="ttdoc">Apply the function object f using its nested argument_tags list of tags.</div><div class="ttdef"><b>Definition:</b> ObservationBox.hpp:182</div></div>
</div><!-- fragment -->
<p>A wrapper around Catch's CHECK macro that checks approximate equality of entries in iterable containers. For maplike containers, keys are checked for strict equality and values are checked for approximate equality. </p>

</div>
</div>
<a id="ga4f36d1ee34e6eb0721e35918eb488f0c" name="ga4f36d1ee34e6eb0721e35918eb488f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f36d1ee34e6eb0721e35918eb488f0c">&#9670;&nbsp;</a></span>CHECK_ITERABLE_CUSTOM_APPROX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_ITERABLE_CUSTOM_APPROX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">appx&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                       \</div>
<div class="line">    INFO(__FILE__ <span class="stringliteral">&quot;:&quot;</span> + std::to_string(__LINE__) + <span class="stringliteral">&quot;: &quot;</span> #a <span class="stringliteral">&quot; == &quot;</span> #b);       \</div>
<div class="line">    check_iterable_approx&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/common_type.html">std::common_type_t</a>&lt;                                \</div>
<div class="line">        std::decay_t&lt;<span class="keyword">decltype</span>(a)&gt;, <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt;<span class="keyword">decltype</span>(b)&gt;&gt;&gt;<a class="code hl_function" href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">::apply</a>(a, b,  \</div>
<div class="line">                                                                      appx); \</div>
<div class="line">  } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p>Same as <code>CHECK_ITERABLE_APPROX</code> with user-defined Approx. The third argument should be of type <code>Approx</code>. </p>

</div>
</div>
<a id="gaec8dcdc783140fb14fe617cc0cc1dcae" name="gaec8dcdc783140fb14fe617cc0cc1dcae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec8dcdc783140fb14fe617cc0cc1dcae">&#9670;&nbsp;</a></span>CHECK_OP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_OP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">op, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                          \</div>
<div class="line">    const <span class="keyword">auto</span>&amp; a_ = a;         \</div>
<div class="line">    const <span class="keyword">auto</span>&amp; b_ = b;         \</div>
<div class="line">    const <span class="keyword">auto</span>&amp; c_ = c;         \</div>
<div class="line">    CHECK(a_ op b_ == c_);      \</div>
<div class="line">    auto f = a_;                \</div>
<div class="line">    CHECK((f op## = b_) == c_); \</div>
<div class="line">    CHECK(f == c_);             \</div>
<div class="line">  } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p>Check a op b == c and also the op= version. </p>

</div>
</div>
<a id="ga447b43fced460461e76beca1a28fc273" name="ga447b43fced460461e76beca1a28fc273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga447b43fced460461e76beca1a28fc273">&#9670;&nbsp;</a></span>CHECK_VARIABLES_APPROX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_VARIABLES_APPROX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                       \</div>
<div class="line">    INFO(__FILE__ <span class="stringliteral">&quot;:&quot;</span> + std::to_string(__LINE__) + <span class="stringliteral">&quot;: &quot;</span> #a <span class="stringliteral">&quot; == &quot;</span> #b);       \</div>
<div class="line">    check_variables_approx&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/common_type.html">std::common_type_t</a>&lt;                               \</div>
<div class="line">        std::decay_t&lt;<span class="keyword">decltype</span>(a)&gt;, <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt;<span class="keyword">decltype</span>(b)&gt;&gt;&gt;<a class="code hl_function" href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">::apply</a>(a, b); \</div>
<div class="line">  } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p>A wrapper around Catch's CHECK macro that checks approximate equality of each entry in each tag within a variables. </p>

</div>
</div>
<a id="ga6553c686d7f6b55372814227d1542272" name="ga6553c686d7f6b55372814227d1542272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6553c686d7f6b55372814227d1542272">&#9670;&nbsp;</a></span>CHECK_VARIABLES_CUSTOM_APPROX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_VARIABLES_CUSTOM_APPROX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">appx&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                       \</div>
<div class="line">    INFO(__FILE__ <span class="stringliteral">&quot;:&quot;</span> + std::to_string(__LINE__) + <span class="stringliteral">&quot;: &quot;</span> #a <span class="stringliteral">&quot; == &quot;</span> #b);       \</div>
<div class="line">    check_variables_approx&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/common_type.html">std::common_type_t</a>&lt;                               \</div>
<div class="line">        std::decay_t&lt;<span class="keyword">decltype</span>(a)&gt;, <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt;<span class="keyword">decltype</span>(b)&gt;&gt;&gt;<a class="code hl_function" href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">::apply</a>(a, b,  \</div>
<div class="line">                                                                      appx); \</div>
<div class="line">  } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p>Same as <code>CHECK_VARIABLES_APPROX</code>, but with a user-defined Approx. The third argument should be of type <code>Approx</code>. </p>

</div>
</div>
<a id="gaf962c28abc1a1f014f2a6b32c6f01680" name="gaf962c28abc1a1f014f2a6b32c6f01680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf962c28abc1a1f014f2a6b32c6f01680">&#9670;&nbsp;</a></span>ERROR_TEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ERROR_TEST</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                    \</div>
<div class="line">    std::signal(SIGABRT, spectre_testing_signal_handler); \</div>
<div class="line">  } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p>Mark a test as checking a call to ERROR. </p>
<h3>Details</h3>
<p >In order to properly handle aborting with Catch versions newer than 1.6.1 we must install a signal handler after Catch does, which means inside the SPECTRE_TEST_CASE itself. The <a class="el" href="group__TestingFrameworkGroup.html#gaf962c28abc1a1f014f2a6b32c6f01680" title="Mark a test as checking a call to ERROR.">ERROR_TEST()</a> macro should be the first line in the SPECTRE_TEST_CASE.</p>
<dl class="section warning"><dt>Warning</dt><dd>This macro is deprecated. See <a class="el" href="writing_unit_tests.html#testing_failure_cases">the DevGuide</a> for the modern way to do this. </dd></dl>

</div>
</div>
<a id="ga8cd2549e4a5627f34f8201af2bcbfd34" name="ga8cd2549e4a5627f34f8201af2bcbfd34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cd2549e4a5627f34f8201af2bcbfd34">&#9670;&nbsp;</a></span>INVOKE_TEST_FUNCTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INVOKE_TEST_FUNCTION</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">FUNCTION_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TUPLE_ARGS, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  BOOST_PP_ASSERT_MSG(BOOST_PP_NOT(BOOST_VMD_IS_EMPTY(__VA_ARGS__)),           \</div>
<div class="line">                      <span class="stringliteral">&quot;You cannot pass an empty set of template parameters &quot;</span>   \</div>
<div class="line">                      <span class="stringliteral">&quot;to INVOKE_TEST_FUNCTION&quot;</span>)                               \</div>
<div class="line">  BOOST_PP_TUPLE_ENUM(                                                         \</div>
<div class="line">      0,                                                                       \</div>
<div class="line">      BOOST_PP_IF(                                                             \</div>
<div class="line">          BOOST_PP_EQUAL(                                                      \</div>
<div class="line">              BOOST_PP_TUPLE_SIZE(BOOST_PP_VARIADIC_TO_TUPLE(__VA_ARGS__)),    \</div>
<div class="line">              1),                                                              \</div>
<div class="line">          (BOOST_PP_LIST_FOR_EACH(                                             \</div>
<div class="line">              INVOKE_FUNCTION_WITH_SINGLE_TEMPLATE_PARAM,                      \</div>
<div class="line">              (FUNCTION_NAME, TUPLE_ARGS),                                     \</div>
<div class="line">              BOOST_PP_TUPLE_TO_LIST(                                          \</div>
<div class="line">                  BOOST_PP_VARIADIC_ELEM(0, __VA_ARGS__)))),                   \</div>
<div class="line">          (INVOKE_FUNCTION_WITH_MANY_TEMPLATE_PARAMS(                          \</div>
<div class="line">              BOOST_PP_TUPLE_PUSH_FRONT(                                       \</div>
<div class="line">                  BOOST_PP_LIST_TO_TUPLE(BOOST_PP_LIST_TRANSFORM(              \</div>
<div class="line">                      INVOKE_FUNCTION_WITH_MANY_TEMPLATE_PARAMS_TUPLE_TO_LIST, \</div>
<div class="line">                      _,                                                       \</div>
<div class="line">                      BOOST_PP_LIST_REST(                                      \</div>
<div class="line">                          BOOST_PP_VARIADIC_TO_LIST(__VA_ARGS__)))),           \</div>
<div class="line">                  BOOST_PP_LIST_TRANSFORM(                                     \</div>
<div class="line">                      INVOKE_FUNCTION_TUPLE_PUSH_BACK,                         \</div>
<div class="line">                      (FUNCTION_NAME, TUPLE_ARGS),                             \</div>
<div class="line">                      BOOST_PP_TUPLE_TO_LIST(                                  \</div>
<div class="line">                          BOOST_PP_VARIADIC_ELEM(0, __VA_ARGS__))))))))</div>
</div><!-- fragment -->
<p>Macro used to invoke a test function of multiple template arguments. </p>
<p >This macro allows to generate calls to multiple instances of a test function template, all of which will receive the same parameters. The first argument to this macro is the name of the function. The second argument is a macro-tuple containing the parameters passed to each instance, e.g. <code>(x, y)</code>. The remaining arguments are macro-tuples of the values for each template parameter one wants to loop over, e.g. <code>(1, 2, 3), (<a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, <a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a>)</code>. For example, a function template</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Arg1, <span class="keywordtype">size_t</span> Arg2, <span class="keyword">class</span> Arg3&gt;</div>
<div class="line">my_function(<span class="keyword">const</span> <span class="keywordtype">double</span> var_1, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; var_2) { ... }</div>
</div><!-- fragment --><p >can be invoked by writing</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__TestingFrameworkGroup.html#ga8cd2549e4a5627f34f8201af2bcbfd34">INVOKE_TEST_FUNCTION</a>(my_function, (d, i), (a, b, c), (1, 2, 3), (A, B, C))</div>
<div class="ttc" id="agroup__TestingFrameworkGroup_html_ga8cd2549e4a5627f34f8201af2bcbfd34"><div class="ttname"><a href="group__TestingFrameworkGroup.html#ga8cd2549e4a5627f34f8201af2bcbfd34">INVOKE_TEST_FUNCTION</a></div><div class="ttdeci">#define INVOKE_TEST_FUNCTION(FUNCTION_NAME, TUPLE_ARGS,...)</div><div class="ttdoc">Macro used to invoke a test function of multiple template arguments.</div><div class="ttdef"><b>Definition:</b> CheckWithRandomValues.hpp:793</div></div>
</div><!-- fragment --><p >which will generate</p>
<div class="fragment"><div class="line">my_function&lt;a, 1, A&gt;(d, i);</div>
<div class="line">my_function&lt;a, 1, B&gt;(d, i);</div>
<div class="line">my_function&lt;a, 1, C&gt;(d, i);</div>
<div class="line">my_function&lt;a, 2, A&gt;(d, i);</div>
<div class="line">my_function&lt;a, 2, B&gt;(d, i);</div>
<div class="line">my_function&lt;a, 2, C&gt;(d, i);</div>
<div class="line">my_function&lt;a, 3, A&gt;(d, i);</div>
<div class="line">my_function&lt;a, 3, B&gt;(d, i);</div>
<div class="line">my_function&lt;a, 3, C&gt;(d, i);</div>
<div class="line">my_function&lt;b, 1, A&gt;(d, i);</div>
<div class="line">my_function&lt;b, 1, B&gt;(d, i);</div>
<div class="line">my_function&lt;b, 1, C&gt;(d, i);</div>
<div class="line">my_function&lt;b, 2, A&gt;(d, i);</div>
<div class="line">my_function&lt;b, 2, B&gt;(d, i);</div>
<div class="line">my_function&lt;b, 2, C&gt;(d, i);</div>
<div class="line">my_function&lt;b, 3, A&gt;(d, i);</div>
<div class="line">my_function&lt;b, 3, B&gt;(d, i);</div>
<div class="line">my_function&lt;b, 3, C&gt;(d, i);</div>
<div class="line">my_function&lt;c, 1, A&gt;(d, i);</div>
<div class="line">my_function&lt;c, 1, B&gt;(d, i);</div>
<div class="line">my_function&lt;c, 1, C&gt;(d, i);</div>
<div class="line">my_function&lt;c, 2, A&gt;(d, i);</div>
<div class="line">my_function&lt;c, 2, B&gt;(d, i);</div>
<div class="line">my_function&lt;c, 2, C&gt;(d, i);</div>
<div class="line">my_function&lt;c, 3, A&gt;(d, i);</div>
<div class="line">my_function&lt;c, 3, B&gt;(d, i);</div>
<div class="line">my_function&lt;c, 3, C&gt;(d, i);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The order of the macro-tuples of values must match the order of the template parameters of the function.</dd>
<dd>
The function to be called must at least have one template argument, so passing an empty set of template parameters will not work. </dd></dl>

</div>
</div>
<a id="gad7f766439113f958bf4f8ba0f53c4881" name="gad7f766439113f958bf4f8ba0f53c4881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7f766439113f958bf4f8ba0f53c4881">&#9670;&nbsp;</a></span>MAKE_GENERATOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAKE_GENERATOR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine.html">std::mt19937</a> MAKE_GENERATOR_IMPL_FIRST_ARG(__VA_ARGS__, DUMMY_TOKEN); \</div>
<div class="line">  <span class="comment">/* Capture everything because we don&#39;t know what passed seed uses */</span>  \</div>
<div class="line">  INFO(<span class="stringliteral">&quot;Seed is: &quot;</span> &lt;&lt; [&amp;]() {                                           \</div>
<div class="line">    const <span class="keyword">auto</span> MAKE_GENERATOR_seed = (MAKE_GENERATOR_IMPL_SECOND_ARG(   \</div>
<div class="line">        __VA_ARGS__, <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/numeric/random/random_device.html">std::random_device</a>{}(), DUMMY_TOKEN));             \</div>
<div class="line">    MAKE_GENERATOR_IMPL_FIRST_ARG(__VA_ARGS__, DUMMY_TOKEN)             \</div>
<div class="line">        .seed(MAKE_GENERATOR_seed);                                     \</div>
<div class="line">    return <a class="code hl_class" href="classMakeString.html">MakeString</a>{} &lt;&lt; MAKE_GENERATOR_seed &lt;&lt; <span class="stringliteral">&quot; from &quot;</span> __FILE__ <span class="stringliteral">&quot;:&quot;</span> \</div>
<div class="line">                        &lt;&lt; __LINE__;                                    \</div>
<div class="line">  }())</div>
<div class="ttc" id="aclassMakeString_html"><div class="ttname"><a href="classMakeString.html">MakeString</a></div><div class="ttdoc">Make a string by streaming into object.</div><div class="ttdef"><b>Definition:</b> MakeString.hpp:18</div></div>
<div class="ttc" id="amersenne_twister_engine_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine.html">std::mt19937</a></div></div>
<div class="ttc" id="arandom_device_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/numeric/random/random_device.html">std::random_device</a></div></div>
</div><!-- fragment -->
<p><code><a class="el" href="group__TestingFrameworkGroup.html#gad7f766439113f958bf4f8ba0f53c4881" title="MAKE_GENERATOR(NAME [, SEED]) declares a variable of name NAME containing a generator of type std::mt...">MAKE_GENERATOR(NAME [, SEED])</a></code> declares a variable of name <code>NAME</code> containing a generator of type <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine.html">std::mt19937</a></code>. </p>
<h3>Details</h3>
<p >As the generator is made, <code>INFO</code> is called to make sure failed tests provide seed information. <code>SEED</code> is chosen randomly if not supplied, otherwise it must be a constant expression. </p>

</div>
</div>
<a id="gacd515a98a97cf7fc82e722274b17e7ce" name="gacd515a98a97cf7fc82e722274b17e7ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd515a98a97cf7fc82e722274b17e7ce">&#9670;&nbsp;</a></span>OUTPUT_TEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OUTPUT_TEST</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                \</div>
<div class="line">    CHECK(<span class="keyword">true</span>);      \</div>
<div class="line">  } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p>Mark a test as checking the output with a regular expression. </p>
<h3>Details</h3>
<p >The <a class="el" href="group__TestingFrameworkGroup.html#gacd515a98a97cf7fc82e722274b17e7ce" title="Mark a test as checking the output with a regular expression.">OUTPUT_TEST()</a> macro should be the first line in the SPECTRE_TEST_CASE. Catch requires at least one CHECK in each test to pass, so we add one in case nothing but the output is checked.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">// [[OutputRegex, -100 3000000000 1.0000000000000000000e\+00 \&zwj;(0,4,8,-7\&zwj;) test 1</span></div>
<div class="line"><span class="comment">// 2 3 abf a o e u Value 2]]</span></div>
<div class="line">SPECTRE_TEST_CASE(<span class="stringliteral">&quot;Unit.Parallel.printf&quot;</span>, <span class="stringliteral">&quot;[Unit][Parallel]&quot;</span>) {</div>
<div class="line">  <a class="code hl_define" href="group__TestingFrameworkGroup.html#gacd515a98a97cf7fc82e722274b17e7ce">OUTPUT_TEST</a>();</div>
<div class="line">  <span class="comment">// clang-tidy doesn&#39;t want c-style arrays, but here we are trying</span></div>
<div class="line">  <span class="comment">// to test them explicitly.</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span> c_string0[40] = {<span class="stringliteral">&quot;test 1 2 3&quot;</span>}; <span class="comment">// NOLINT</span></div>
<div class="line">  <span class="comment">// clang-tidy doesn&#39;t want raw pointers, wants gsl::owner&lt;&gt;.</span></div>
<div class="line">  <span class="keyword">auto</span>* c_string1 = <span class="keyword">new</span> <span class="keywordtype">char</span>[80]; <span class="comment">// NOLINT</span></div>
<div class="line">  <span class="comment">// clang-tidy: do not use pointer arithmetic</span></div>
<div class="line">  c_string1[0] = <span class="charliteral">&#39;a&#39;</span>;   <span class="comment">// NOLINT</span></div>
<div class="line">  c_string1[1] = <span class="charliteral">&#39;b&#39;</span>;   <span class="comment">// NOLINT</span></div>
<div class="line">  c_string1[2] = <span class="charliteral">&#39;f&#39;</span>;   <span class="comment">// NOLINT</span></div>
<div class="line">  c_string1[3] = <span class="charliteral">&#39;\0&#39;</span>;  <span class="comment">// NOLINT</span></div>
<div class="line">  <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> c_string2 = {<span class="stringliteral">&quot;a o e u&quot;</span>};</div>
<div class="line">  <a class="code hl_function" href="group__ParallelGroup.html#gae21964b5d28608afd21ae090c1c4c073">Parallel::printf</a>(<span class="stringliteral">&quot;%d %lld %s %s %s %s %s\n&quot;</span>, -100, 3000000000, TestStream{},</div>
<div class="line">                   c_string0, c_string1, c_string2, TestEnum::Value2);</div>
<div class="line">  <span class="comment">// clang-tidy doesn&#39;t want delete on anything without gsl::owner&lt;&gt;.</span></div>
<div class="line">  <span class="keyword">delete</span>[] c_string1; <span class="comment">// NOLINT</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ParallelGroup_html_gae21964b5d28608afd21ae090c1c4c073"><div class="ttname"><a href="group__ParallelGroup.html#gae21964b5d28608afd21ae090c1c4c073">Parallel::printf</a></div><div class="ttdeci">void printf(const std::string &amp;format, Args &amp;&amp;... args)</div><div class="ttdoc">Print an atomic message to stdout with C printf usage.</div><div class="ttdef"><b>Definition:</b> Printf.hpp:103</div></div>
<div class="ttc" id="agroup__TestingFrameworkGroup_html_gacd515a98a97cf7fc82e722274b17e7ce"><div class="ttname"><a href="group__TestingFrameworkGroup.html#gacd515a98a97cf7fc82e722274b17e7ce">OUTPUT_TEST</a></div><div class="ttdeci">#define OUTPUT_TEST()</div><div class="ttdoc">Mark a test as checking the output with a regular expression.</div><div class="ttdef"><b>Definition:</b> TestingFramework.hpp:366</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga37fce1ae5980139598815eda5a5de8ab" name="ga37fce1ae5980139598815eda5a5de8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37fce1ae5980139598815eda5a5de8ab">&#9670;&nbsp;</a></span>SPECTRE_PARALLEL_REQUIRE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPECTRE_PARALLEL_REQUIRE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">expr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                  \</div>
<div class="line">    if (not(expr)) {                                                    \</div>
<div class="line">      ERROR(<span class="stringliteral">&quot;\nFailed comparison: &quot;</span> &lt;&lt; #expr &lt;&lt; <span class="stringliteral">&quot;\nLine: &quot;</span> &lt;&lt; __LINE__  \</div>
<div class="line">                                    &lt;&lt; <span class="stringliteral">&quot;\nFile: &quot;</span> &lt;&lt; __FILE__ &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>); \</div>
<div class="line">    }                                                                   \</div>
<div class="line">  } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p>A similar to Catch's REQUIRE statement, but can be used in tests that spawn several chares with possibly complex interaction between the chares. </p>

</div>
</div>
<a id="ga2adb81ed48c421e8f77541f34eb3f821" name="ga2adb81ed48c421e8f77541f34eb3f821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2adb81ed48c421e8f77541f34eb3f821">&#9670;&nbsp;</a></span>SPECTRE_PARALLEL_REQUIRE_FALSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPECTRE_PARALLEL_REQUIRE_FALSE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">expr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                  \</div>
<div class="line">    if ((expr)) {                                                       \</div>
<div class="line">      ERROR(<span class="stringliteral">&quot;\nFailed comparison: &quot;</span> &lt;&lt; #expr &lt;&lt; <span class="stringliteral">&quot;\nLine: &quot;</span> &lt;&lt; __LINE__  \</div>
<div class="line">                                    &lt;&lt; <span class="stringliteral">&quot;\nFile: &quot;</span> &lt;&lt; __FILE__ &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>); \</div>
<div class="line">    }                                                                   \</div>
<div class="line">  } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p>A similar to Catch's REQUIRE_FALSE statement, but can be used in tests that spawn several chares with possibly complex interaction between the chares. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga921a5dbf5f1704e2051d1daf593d0d90" name="ga921a5dbf5f1704e2051d1daf593d0d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga921a5dbf5f1704e2051d1daf593d0d90">&#9670;&nbsp;</a></span>TestKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__TestingFrameworkGroup.html#ga921a5dbf5f1704e2051d1daf593d0d90">TestHelpers::VectorImpl::TestKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the set of test types that may be used for the math operations </p>
<h3>Details</h3>
<p >Three types of test are provided:</p><ul>
<li><code>Normal</code> is used to indicate those tests which should be performed over all combinations of the supplied vector type(s) and their value types. This is useful for e.g. <code>+</code>.</li>
<li><code>Strict</code> is used to indicate those tests which should be performed over only sets of the vector type and compared to the same operation of the set of its value type. This is useful for e.g. <code>atan2</code>, which cannot take a <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code> and a double as arguments.</li>
<li><code>Inplace</code> is used to indicate those tests which should be performed maintaining the type of the left-hand side of the operator and not including it in the combinations. Inplace operators such as <code>+=</code> have a more restrictive condition on the type of the left hand side than do simply <code>+</code>. (e.g. <code>double + complex&lt;double&gt;</code> compiles, but <code>double += complex&lt;double&gt;</code> does not)</li>
<li><code>GivenOrderOfArgumentsOnly</code> is used to indicate that the arguments given should not be taken in any combination apart from the given combination. This should be used for highly restrictive operations which are only supported for certain type combinations. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa23eb20b9665d1a932d9e1eb23ee2fc9" name="gaa23eb20b9665d1a932d9e1eb23ee2fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa23eb20b9665d1a932d9e1eb23ee2fc9">&#9670;&nbsp;</a></span>check() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DampingFunctionType , class T , class... MemberArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::gh::ConstraintDamping::check </td>
          <td>(</td>
          <td class="paramtype">DampingFunctionType&#160;</td>
          <td class="paramname"><em>in_gh_damping_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>python_function_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>used_for_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; double, double &gt;, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>random_value_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>function_of_time_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MemberArgs &amp;...&#160;</td>
          <td class="paramname"><em>member_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test a DampingFunction by comparing to python functions. </p>
<p >The python functions must be added to TestFunctions.py in tests/Unit/Evolution/Systems/GeneralizedHarmonic/ConstraintDamping/Python. Each python function for a corresponding DampingFunction should begin with a prefix <code>python_function_prefix</code>. The prefix for each class of DampingFunction is arbitrary, but should generally be descriptive (e.g. 'gaussian_plus_constant') of the DampingFunction.</p>
<p >The input parameter <code>function_of_time_name</code> is the name of the FunctionOfTime that will be included in the FunctionsOfTime passed to the DampingFunction's call operator. For time-dependent DampingFunctions, this parameter must be consistent with the FunctionOfTime name that the call operator of <code>in_gh_damping_function</code> expects. For time-independent DampingFunctions, <code>function_of_time_name</code> will be ignored.</p>
<p >If a DampingFunction class has member variables set by its constructor, then these member variables must be passed in as the last arguments to the <code>check</code> function`. Each python function must take these same arguments as the trailing arguments. </p>

</div>
</div>
<a id="ga62bc06eb56f2b61c118bb77d20f7abfd" name="ga62bc06eb56f2b61c118bb77d20f7abfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62bc06eb56f2b61c118bb77d20f7abfd">&#9670;&nbsp;</a></span>check() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class EosType , class T , class... MemberArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::EquationsOfState::check </td>
          <td>(</td>
          <td class="paramtype">EosType&#160;</td>
          <td class="paramname"><em>in_eos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>python_file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>python_function_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>used_for_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MemberArgs &amp;...&#160;</td>
          <td class="paramname"><em>member_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test an equation of state by comparing to python functions. </p>
<p >The python functions must be added to tests/Unit/PointwiseFunctions/Hydro/EquationsOfState/TestFunctions.py. The prefix for each class of equation of state is arbitrary, but should generally be something like "polytropic" for polytropic fluids.</p>
<p >The <code>python_function_prefix</code> argument passed to <code>check</code> must be <code>PREFIX</code>. If an EoS class has member variables (these must be <code>double</code>s currently) that are used to compute the quantities, such as the polytropic constant and polytropic exponent for a fluid, then they must be passed in as the last arguments to the <code>check</code> function`. Each python function must take these same arguments as the trailing arguments. </p>

</div>
</div>
<a id="ga85ceb5d3fa39fa2527dc984d8be4a1b8" name="ga85ceb5d3fa39fa2527dc984d8be4a1b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85ceb5d3fa39fa2527dc984d8be4a1b8">&#9670;&nbsp;</a></span>check() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MathFunctionType , class T , class... MemberArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::MathFunctions::check </td>
          <td>(</td>
          <td class="paramtype">MathFunctionType&#160;</td>
          <td class="paramname"><em>in_math_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>python_function_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>used_for_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; double, double &gt;, 1 &gt;&#160;</td>
          <td class="paramname"><em>random_value_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MemberArgs &amp;...&#160;</td>
          <td class="paramname"><em>member_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test a <a class="el" href="classMathFunction.html">MathFunction</a> by comparing to python functions. </p>
<p >The python functions must be added to tests/Unit/PointwiseFunctions/MathFunctions/Python/TestFunctions.py. The prefix for each class of <a class="el" href="classMathFunction.html">MathFunction</a> is arbitrary, but should generally be descriptive (e.g. 'gaussian', 'sinusoid', 'pow_x') of the <a class="el" href="classMathFunction.html">MathFunction</a>.</p>
<p >The <code>python_function_prefix</code> argument passed to <code>check</code> must be <code>PREFIX</code>. If a <a class="el" href="classMathFunction.html">MathFunction</a> class has member variables set by its constructor, then these member variables must be passed in as the last arguments to the <code>check</code> function`. Each python function must take these same arguments as the trailing arguments. </p>

</div>
</div>
<a id="gaf6cf9f799c2fec832c8f3f5330676b6d" name="gaf6cf9f799c2fec832c8f3f5330676b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6cf9f799c2fec832c8f3f5330676b6d">&#9670;&nbsp;</a></span>check() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DampingFunctionType , class T , class... MemberArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::gh::ConstraintDamping::check </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; DampingFunctionType &gt;&#160;</td>
          <td class="paramname"><em>in_gh_damping_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>python_function_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>used_for_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; double, double &gt;, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>random_value_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>function_of_time_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MemberArgs &amp;...&#160;</td>
          <td class="paramname"><em>member_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test a DampingFunction by comparing to python functions. </p>
<p >The python functions must be added to TestFunctions.py in tests/Unit/Evolution/Systems/GeneralizedHarmonic/ConstraintDamping/Python. Each python function for a corresponding DampingFunction should begin with a prefix <code>python_function_prefix</code>. The prefix for each class of DampingFunction is arbitrary, but should generally be descriptive (e.g. 'gaussian_plus_constant') of the DampingFunction.</p>
<p >The input parameter <code>function_of_time_name</code> is the name of the FunctionOfTime that will be included in the FunctionsOfTime passed to the DampingFunction's call operator. For time-dependent DampingFunctions, this parameter must be consistent with the FunctionOfTime name that the call operator of <code>in_gh_damping_function</code> expects. For time-independent DampingFunctions, <code>function_of_time_name</code> will be ignored.</p>
<p >If a DampingFunction class has member variables set by its constructor, then these member variables must be passed in as the last arguments to the <code>check</code> function`. Each python function must take these same arguments as the trailing arguments. </p>

</div>
</div>
<a id="ga03d261aaea4d10436566df746e88a6a5" name="ga03d261aaea4d10436566df746e88a6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03d261aaea4d10436566df746e88a6a5">&#9670;&nbsp;</a></span>check() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class EosType , class T , class... MemberArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::EquationsOfState::check </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; EosType &gt;&#160;</td>
          <td class="paramname"><em>in_eos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>python_file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>python_function_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>used_for_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MemberArgs &amp;...&#160;</td>
          <td class="paramname"><em>member_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test an equation of state by comparing to python functions. </p>
<p >The python functions must be added to tests/Unit/PointwiseFunctions/Hydro/EquationsOfState/TestFunctions.py. The prefix for each class of equation of state is arbitrary, but should generally be something like "polytropic" for polytropic fluids.</p>
<p >The <code>python_function_prefix</code> argument passed to <code>check</code> must be <code>PREFIX</code>. If an EoS class has member variables (these must be <code>double</code>s currently) that are used to compute the quantities, such as the polytropic constant and polytropic exponent for a fluid, then they must be passed in as the last arguments to the <code>check</code> function`. Each python function must take these same arguments as the trailing arguments. </p>

</div>
</div>
<a id="gafda4244b1430fc33ac0350228fda4625" name="gafda4244b1430fc33ac0350228fda4625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafda4244b1430fc33ac0350228fda4625">&#9670;&nbsp;</a></span>check() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MathFunctionType , class T , class... MemberArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::MathFunctions::check </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; MathFunctionType &gt;&#160;</td>
          <td class="paramname"><em>in_math_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>python_function_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>used_for_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; double, double &gt;, 1 &gt;&#160;</td>
          <td class="paramname"><em>random_value_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MemberArgs &amp;...&#160;</td>
          <td class="paramname"><em>member_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test a <a class="el" href="classMathFunction.html">MathFunction</a> by comparing to python functions. </p>
<p >The python functions must be added to tests/Unit/PointwiseFunctions/MathFunctions/Python/TestFunctions.py. The prefix for each class of <a class="el" href="classMathFunction.html">MathFunction</a> is arbitrary, but should generally be descriptive (e.g. 'gaussian', 'sinusoid', 'pow_x') of the <a class="el" href="classMathFunction.html">MathFunction</a>.</p>
<p >The <code>python_function_prefix</code> argument passed to <code>check</code> must be <code>PREFIX</code>. If a <a class="el" href="classMathFunction.html">MathFunction</a> class has member variables set by its constructor, then these member variables must be passed in as the last arguments to the <code>check</code> function`. Each python function must take these same arguments as the trailing arguments. </p>

</div>
</div>
<a id="gab257a106213aadd117761d5c871ee651" name="gab257a106213aadd117761d5c871ee651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab257a106213aadd117761d5c871ee651">&#9670;&nbsp;</a></span>extrinsic_curvature_sphere()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , size_t SpatialDim, typename Frame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::ii&lt; DataType, SpatialDim, Frame &gt; TestHelpers::Minkowski::extrinsic_curvature_sphere </td>
          <td>(</td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extrinsic curvature of 2D sphere in 3D flat space. </p>
<h3>Details</h3>
<p >Computes \(K_{ij} = \frac{1}{r}\left(\delta_{ij} - \frac{x_i x_j}{r}\right),\) where \(r = x_i x_j \delta^{ij}\) and \(x_i\) is the position vector in Cartesian coordinates. </p>

</div>
</div>
<a id="ga09e2a86e1acdd8e076589351ce1b5908" name="ga09e2a86e1acdd8e076589351ce1b5908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09e2a86e1acdd8e076589351ce1b5908">&#9670;&nbsp;</a></span>horizon_ricci_scalar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; TestHelpers::Kerr::horizon_ricci_scalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>horizon_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dimensionless_spin_z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kerr (Kerr-Schild) horizon ricci scalar (spin on z axis) </p>
<h3>Details</h3>
<p >Computes the 2-dimensional Ricci scalar \(R\) on the horizon of a Kerr-Schild black hole with spin in the z direction in terms of mass <code>mass</code> and dimensionless spin <code>dimensionless_spin_z</code>. </p>

</div>
</div>
<a id="gafaef417806f3d462b449dcbf7f57138f" name="gafaef417806f3d462b449dcbf7f57138f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafaef417806f3d462b449dcbf7f57138f">&#9670;&nbsp;</a></span>horizon_ricci_scalar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; TestHelpers::Kerr::horizon_ricci_scalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>horizon_radius_with_spin_on_z_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classylm_1_1Spherepack.html">ylm::Spherepack</a> &amp;&#160;</td>
          <td class="paramname"><em>ylm_with_spin_on_z_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classylm_1_1Spherepack.html">ylm::Spherepack</a> &amp;&#160;</td>
          <td class="paramname"><em>ylm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dimensionless_spin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kerr (Kerr-Schild) horizon ricci scalar (generic spin) </p>
<h3>Details</h3>
<p >Computes the 2-dimensional Ricci scalar \(R\) on the horizon of a Kerr-Schild black hole with generic spin in terms of mass <code>mass</code> and dimensionless spin <code>dimensionless_spin</code>. </p>

</div>
</div>
<a id="ga5959fa1de8d9a113fd07dd1058235184" name="ga5959fa1de8d9a113fd07dd1058235184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5959fa1de8d9a113fd07dd1058235184">&#9670;&nbsp;</a></span>make_random_vector_in_magnitude_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , size_t Dim, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> Ul, typename Fr  = Frame::Inertial, <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt;(Ul==<a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28a258f49887ef8d14ac268c92b02503aaa">UpLo::Up</a>)&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::I&lt; DataType, Dim, Fr &gt; make_random_vector_in_magnitude_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine.html">std::mt19937</a> * &gt;&#160;</td>
          <td class="paramname"><em>nn_generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, Dim, Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>min_magnitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>max_magnitude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a spatial vector in a given magnitude range. </p>
<p >The magnitude is computed with respect to the given metric, where the metric is assumed to have positive signature. </p>

</div>
</div>
<a id="ga4960c6cd2087ccde305379036172c884" name="ga4960c6cd2087ccde305379036172c884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4960c6cd2087ccde305379036172c884">&#9670;&nbsp;</a></span>make_random_vector_in_magnitude_range_flat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , size_t Dim, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> Ul, typename Fr  = Frame::Inertial, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; Dim, Ul, Fr &gt; &gt; &gt; make_random_vector_in_magnitude_range_flat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine.html">std::mt19937</a> * &gt;&#160;</td>
          <td class="paramname"><em>nn_generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>used_for_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>min_magnitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>max_magnitude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a spatial vector in a given magnitude range. </p>
<p >The magnitude is computed with respect to the flat space Euclidian metric. </p>

</div>
</div>
<a id="gaa6547f8470e240380e23f08f7e649e91" name="gaa6547f8470e240380e23f08f7e649e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6547f8470e240380e23f08f7e649e91">&#9670;&nbsp;</a></span>make_with_random_values() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename UniformRandomBitGenerator , typename RandomNumberDistribution &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T make_with_random_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; UniformRandomBitGenerator * &gt;&#160;</td>
          <td class="paramname"><em>generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; RandomNumberDistribution * &gt;&#160;</td>
          <td class="paramname"><em>distribution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a fixed-size data structure and fill with random values. </p>
<h3>Details</h3>
<p >Given a template argument type <code>T</code>, create an object of the same type, fills it with random values, and returns the result. Acts as a convenience function to avoid users needing to put in constructors with <code>signaling_NaN()</code>s or <code>max()</code>s themselves when making with random values. Used as <code>make_with_random_values&lt;Type&gt;(make_not_null(&amp;gen),make_not_null(&amp;dist))</code> </p>

</div>
</div>
<a id="ga0bf8d239cc44933ed6836e4d604afced" name="ga0bf8d239cc44933ed6836e4d604afced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bf8d239cc44933ed6836e4d604afced">&#9670;&nbsp;</a></span>make_with_random_values() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , typename T , typename UniformRandomBitGenerator , typename RandomNumberDistribution &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ReturnType make_with_random_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; UniformRandomBitGenerator * &gt;&#160;</td>
          <td class="paramname"><em>generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; RandomNumberDistribution * &gt;&#160;</td>
          <td class="paramname"><em>distribution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>used_for_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a data structure and fill it with random values. </p>
<h3>Details</h3>
<p >Given an object of type <code>T</code>, create an object of type <code>ReturnType</code> whose elements are initialized to random values using the given random number generator and random number distribution.</p>
<p ><em>Requires:</em> the type <code>ReturnType</code> to be creatable using <code>make_with_value&lt;ReturnType&gt;(T)</code> </p>

</div>
</div>
<a id="ga7c6c3cc0910230ad3d2e274c7fa256fe" name="ga7c6c3cc0910230ad3d2e274c7fa256fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c6c3cc0910230ad3d2e274c7fa256fe">&#9670;&nbsp;</a></span>make_with_random_values() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , typename T , typename UniformRandomBitGenerator , typename RandomNumberDistribution &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ReturnType make_with_random_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; UniformRandomBitGenerator * &gt;&#160;</td>
          <td class="paramname"><em>generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomNumberDistribution&#160;</td>
          <td class="paramname"><em>distribution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>used_for_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a data structure and fill it with random values. </p>
<h3>Details</h3>
<p >Given an object of type <code>T</code>, create an object of type <code>ReturnType</code> whose elements are initialized to random values using the given random number generator and random number distribution.</p>
<p ><em>Requires:</em> the type <code>ReturnType</code> to be creatable using <code>make_with_value&lt;ReturnType&gt;(T)</code> </p>

</div>
</div>
<a id="ga85e1325acbdf18be16d32ffa06454606" name="ga85e1325acbdf18be16d32ffa06454606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85e1325acbdf18be16d32ffa06454606">&#9670;&nbsp;</a></span>numerical_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Invocable , size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/result_of.html">std::result_of_t</a>&lt; const Invocable &amp;(const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, VolumeDim &gt; &amp;)&gt; numerical_derivative </td>
          <td>(</td>
          <td class="paramtype">const Invocable &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the derivative of an Invocable at a point x - represented by an array of doubles - in the domain of <code>map</code> with a sixth-order finite difference method. </p>
<h3>Details</h3>
<p >Intended for use with CoordinateMaps taking the domain {xi,eta,zeta} to the range {x,y,z}. This function calculates the derivative along the direction given by <code>direction</code> with a step size of <code>h</code>.</p>
<p ><em>Requires:</em> direction be between 0 and VolumeDim </p>

</div>
</div>
<a id="gad16627ae9048c611e374e9401fd6ecac" name="gad16627ae9048c611e374e9401fd6ecac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad16627ae9048c611e374e9401fd6ecac">&#9670;&nbsp;</a></span>random_sample() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NumSamples, typename Container , typename ValueType  = typename Container::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; ValueType, NumSamples &gt; random_sample </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine.html">std::mt19937</a> * &gt;&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>NumSamples</code> unique random elements of the <code>container</code> </p>
<p >This function is useful to iterate over a random subset of a container, like this:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [halves, orientation, with_equiangular_map,</div>
<div class="line">                    radial_distribution] :</div>
<div class="line">       random_sample&lt;5&gt;(</div>
<div class="line">           <a class="code hl_function" href="group__UtilitiesGroup.html#ga1bface2d122a6251e4758f089f49ff11">cartesian_product</a>(</div>
<div class="line">               halves_array, <a class="code hl_function" href="group__TestingFrameworkGroup.html#ga87ebb39e2d7d2d90f670baccc873c5b8">all_wedge_directions</a>(), <a class="code hl_function" href="group__UtilitiesGroup.html#gad0d14339a15c6913c09fb2baeffe72be">make_array</a>(<span class="keyword">true</span>, <span class="keyword">false</span>),</div>
<div class="line">               <a class="code hl_function" href="group__UtilitiesGroup.html#gad0d14339a15c6913c09fb2baeffe72be">make_array</a>(CoordinateMaps::Distribution::Linear,</div>
<div class="line">                          CoordinateMaps::Distribution::Logarithmic,</div>
<div class="line">                          CoordinateMaps::Distribution::Inverse)),</div>
<div class="line">           make_not_null(&amp;gen))) {</div>
<div class="ttc" id="agroup__TestingFrameworkGroup_html_ga87ebb39e2d7d2d90f670baccc873c5b8"><div class="ttname"><a href="group__TestingFrameworkGroup.html#ga87ebb39e2d7d2d90f670baccc873c5b8">all_wedge_directions</a></div><div class="ttdeci">std::array&lt; OrientationMap&lt; 3 &gt;, 6 &gt; all_wedge_directions()</div><div class="ttdoc">Wedge OrientationMap in each of the six directions used in the Sphere domain creator.</div><div class="ttdef"><b>Definition:</b> TestMapHelpers.hpp:726</div></div>
<div class="ttc" id="agroup__UtilitiesGroup_html_ga1bface2d122a6251e4758f089f49ff11"><div class="ttname"><a href="group__UtilitiesGroup.html#ga1bface2d122a6251e4758f089f49ff11">cartesian_product</a></div><div class="ttdeci">void cartesian_product(OutputIterator result, std::pair&lt; InputIterator, InputIterator &gt;... dimensions)</div><div class="ttdoc">Fill the result iterator with the Cartesian product of a sequence of iterators.</div><div class="ttdef"><b>Definition:</b> CartesianProduct.hpp:49</div></div>
<div class="ttc" id="agroup__UtilitiesGroup_html_gad0d14339a15c6913c09fb2baeffe72be"><div class="ttname"><a href="group__UtilitiesGroup.html#gad0d14339a15c6913c09fb2baeffe72be">make_array</a></div><div class="ttdeci">constexpr std::array&lt; T, Size &gt; make_array(Args &amp;&amp;... args)</div><div class="ttdoc">Create a std::array&lt;T, Size&gt;{{T(args...), T(args...), ...}}</div><div class="ttdef"><b>Definition:</b> MakeArray.hpp:65</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This implementation copies the random elements into a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a></code> that can be iterated over. This can be changed if we need to support noncopyable types. </dd></dl>

</div>
</div>
<a id="ga8256d75ed63b572d451969df6ffc5e14" name="ga8256d75ed63b572d451969df6ffc5e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8256d75ed63b572d451969df6ffc5e14">&#9670;&nbsp;</a></span>random_sample() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename ValueType  = typename Container::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; ValueType &gt; random_sample </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>number_of_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine.html">std::mt19937</a> * &gt;&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> holding <code>number_of_samples</code> unique random elements of the <code>container</code> </p>
<dl class="section note"><dt>Note</dt><dd>If <code>container</code> has fewer elements than <code>number_of_samples</code>, this function returns a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> of all elements in <code>container</code> </dd></dl>

</div>
</div>
<a id="ga4dbc4d90aaf171bc3f3e93e85c60e182" name="ga4dbc4d90aaf171bc3f3e93e85c60e182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dbc4d90aaf171bc3f3e93e85c60e182">&#9670;&nbsp;</a></span>spatial_ricci()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , size_t SpatialDim, typename Frame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::ii&lt; DataType, SpatialDim, Frame &gt; TestHelpers::Schwarzschild::spatial_ricci </td>
          <td>(</td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schwarzschild (Kerr-Schild) spatial ricci tensor. </p>
<h3>Details</h3>
<p >Computes \(R_{ij} = M \frac{r^2(4M+r)\delta_{ij}-(8M+3r)x_i x_j} {r^4(2M+r^2)},\) where \(r = x_i x_j \delta^{ij}\), \(x_i\) is the position vector in Cartesian coordinates, and M is the mass. </p>

</div>
</div>
<a id="ga3f5e51c75c5d48069e8a541fff9b6768" name="ga3f5e51c75c5d48069e8a541fff9b6768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f5e51c75c5d48069e8a541fff9b6768">&#9670;&nbsp;</a></span>test_boundary_correction_conservation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename System , typename BoundaryCorrection , size_t FaceDim, typename... VolumeTags, typename... RangeTags&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::evolution::dg::test_boundary_correction_conservation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine.html">std::mt19937</a> * &gt;&#160;</td>
          <td class="paramname"><em>generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BoundaryCorrection &amp;&#160;</td>
          <td class="paramname"><em>correction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; FaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; VolumeTags... &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; <a class="el" href="structTestHelpers_1_1evolution_1_1dg_1_1Tags_1_1Range.html">Tags::Range</a>&lt; RangeTags &gt;... &gt; &amp;&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ZeroOnSmoothSolution&#160;</td>
          <td class="paramname"><em>zero_on_smooth_solution</em> = <code>ZeroOnSmoothSolution::Yes</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1.0e-12</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that the boundary correction is conservative and that for smooth solutions the strong-form correction is zero. </p>
<p >By default, each input tensor for <code>dg_package_data</code> is randomly generated from the interval <code>[-1,1)</code> (except the metric, which for systems with a metric is generated to be close to flat space). The argument <code>ranges</code> is a <code>TaggedTuple</code> of <code><a class="el" href="structTestHelpers_1_1evolution_1_1dg_1_1Tags_1_1Range.html" title="Tag for a TaggedTuple that holds the range of validity for the variable associated with Tag.">TestHelpers::evolution::dg::Tags::Range</a>&lt;tag&gt;</code> that enables the caller to pick a custom interval for generating the input <code>tag</code>. This is useful, for example, for tensors that need positive values. Each <code>tag</code> in <code>ranges</code> must be an argument of <code>dg_package_data</code>. </p>

</div>
</div>
<a id="ga7087e6c7112ed8c761dc88ca8659bff2" name="ga7087e6c7112ed8c761dc88ca8659bff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7087e6c7112ed8c761dc88ca8659bff2">&#9670;&nbsp;</a></span>test_boundary_correction_with_python()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename System , typename ConversionClassList  = tmpl::list&lt;&gt;, typename BoundaryCorrection , size_t FaceDim, typename... VolumeTags, typename... RangeTags&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::evolution::dg::test_boundary_correction_with_python </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine.html">std::mt19937</a> * &gt;&#160;</td>
          <td class="paramname"><em>generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>python_module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, tmpl::size&lt; typename BoundaryCorrection::dg_package_field_tags &gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>python_dg_package_data_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, tmpl::size&lt; typename System::variables_tag::tags_list &gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>python_dg_boundary_terms_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BoundaryCorrection &amp;&#160;</td>
          <td class="paramname"><em>correction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; FaceDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; VolumeTags... &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; <a class="el" href="structTestHelpers_1_1evolution_1_1dg_1_1Tags_1_1Range.html">Tags::Range</a>&lt; RangeTags &gt;... &gt; &amp;&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>1.0e-12</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests that the <code>dg_package_data</code> and <code>dg_boundary_terms</code> functions agree with the python implementation. </p>
<p >The variables are filled with random numbers between zero and one before being passed to the implementations. If in the future we need support for negative numbers we can add the ability to specify a single range for all random numbers or each individually.</p>
<p >Please note the following:</p><ul>
<li>The <code><a class="el" href="structpypp_1_1SetupLocalPythonEnvironment.html" title="Enable calling of python in the local scope, and add directory(ies) to the front of the search path f...">pypp::SetupLocalPythonEnvironment</a></code> must be created before the <code>test_boundary_correction_with_python</code> can be called.</li>
<li>The <code>dg_formulation</code> is passed as a bool <code>use_strong_form</code> to the python functions since we don't want to rely on python bindings for the enum.</li>
<li>You can convert custom types using the <code>ConversionClassList</code> template parameter, which is then passed to <code><a class="el" href="namespacepypp.html#a0b8520e3e6d5c1abb3110b134c10683f" title="Calls a Python function from a module/file with given parameters.">pypp::call()</a></code>. This allows you to, e.g., convert an equation of state into an array locally in a test file.</li>
<li>There must be one python function to compute the packaged data for each tag in <code>dg_package_field_tags</code></li>
<li>There must be one python function to compute the boundary correction for each tag in <code>System::variables_tag</code></li>
<li>The arguments to the python functions for computing the packaged data are the same as the arguments for the C++ <code>dg_package_data</code> function, excluding the <code><a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a></code> arguments.</li>
<li>The arguments to the python functions for computing the boundary corrections are the same as the arguments for the C++ <code>dg_boundary_terms</code> function, excluding the <code><a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a></code> arguments.</li>
<li>By default, each input tensor for <code>dg_package_data</code> is randomly generated from the interval <code>[-1,1)</code> (except the metric, which for systems with a metric is generated to be close to flat space). The argument <code>ranges</code> is a <code>TaggedTuple</code> of <code><a class="el" href="structTestHelpers_1_1evolution_1_1dg_1_1Tags_1_1Range.html" title="Tag for a TaggedTuple that holds the range of validity for the variable associated with Tag.">TestHelpers::evolution::dg::Tags::Range</a>&lt;tag&gt;</code> that enables the caller to pick a custom interval for generating the input <code>tag</code>. This is useful, for example, for tensors that need positive values. Each <code>tag</code> in <code>ranges</code> must be an argument of <code>dg_package_data</code>. </li>
</ul>

</div>
</div>
<a id="ga7dfb31d9c4494e8d552e3cd3ca7eed81" name="ga7dfb31d9c4494e8d552e3cd3ca7eed81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7dfb31d9c4494e8d552e3cd3ca7eed81">&#9670;&nbsp;</a></span>test_creation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Metavariables  = NoSuchType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T TestHelpers::test_creation </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>construction_string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of a given option-creatable type. </p>
<p >This is a wrapper around <a class="el" href="classOptions_1_1Parser.html" title="Class that handles parsing an input file.">Options::Parser</a> constructing a single, specified type <code>T</code> from the supplied string. If necessary, metavariables can be supplied as the second template argument.</p>
<p >A class can be explicitly created through a factory by passing <code><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;BaseClass&gt;</code> as the type. This will require metavariables to be passed. For testing basic factory creation, the simpler <a class="el" href="group__TestingFrameworkGroup.html#ga3783673fa2a65b2d51ac60e4252c9b0c" title="Creates a class of a known derived type using a factory.">TestHelpers::test_factory_creation()</a> can be used instead.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ClassWithoutMetavariables {</div>
<div class="line">  <span class="keyword">struct </span>SizeT {</div>
<div class="line">    <span class="keyword">using</span> type = size_t;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <a class="code hl_typedef" href="namespaceOptions.html#aa61c7f41f21afa7646811456f673be89">Options::String</a> help = {<span class="stringliteral">&quot;SizeT help&quot;</span>};</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">using</span> options = tmpl::list&lt;SizeT&gt;;</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <a class="code hl_typedef" href="namespaceOptions.html#aa61c7f41f21afa7646811456f673be89">Options::String</a> help = {<span class="stringliteral">&quot;Help&quot;</span>};</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">explicit</span> ClassWithoutMetavariables(<span class="keyword">const</span> <span class="keywordtype">size_t</span> in_value) : <a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">value</a>(in_value) {}</div>
<div class="line"> </div>
<div class="line">  ClassWithoutMetavariables() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">size_t</span> <a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">value</a>{0};</div>
<div class="line">};</div>
<div class="ttc" id="agroup__UtilitiesGroup_html_ga4316f2ea7fb92cf4a3c5cf53bf36fb82"><div class="ttname"><a href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">value</a></div><div class="ttdeci">constexpr T &amp; value(T &amp;t)</div><div class="ttdoc">Returns t.value() if t is a std::optional otherwise returns t.</div><div class="ttdef"><b>Definition:</b> OptionalHelpers.hpp:32</div></div>
<div class="ttc" id="anamespaceOptions_html_aa61c7f41f21afa7646811456f673be89"><div class="ttname"><a href="namespaceOptions.html#aa61c7f41f21afa7646811456f673be89">Options::String</a></div><div class="ttdeci">const char *const String</div><div class="ttdoc">The string used in option structs.</div><div class="ttdef"><b>Definition:</b> String.hpp:8</div></div>
</div><!-- fragment --> <div class="fragment"><div class="line">  CHECK(</div>
<div class="line">      TestHelpers::test_creation&lt;ClassWithoutMetavariables&gt;(<span class="stringliteral">&quot;SizeT: 7&quot;</span>).<a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">value</a> ==</div>
<div class="line">      7);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TestingFrameworkGroup.html#ga17b631a68906e714104e6c2fbdc2c1d2" title="Runs the option parser on a given tag.">TestHelpers::test_option_tag()</a> </dd></dl>

</div>
</div>
<a id="ga143a0f20c1d6a8e9556e39a978b6e76c" name="ga143a0f20c1d6a8e9556e39a978b6e76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga143a0f20c1d6a8e9556e39a978b6e76c">&#9670;&nbsp;</a></span>test_evaluate_rank_0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::tenex::test_evaluate_rank_0 </td>
          <td>(</td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test that evaluating a right hand side tensor expression containing a single rank 0 tensor correctly assigns the data to the evaluated left hand side tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the data being stored in the Tensors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf08c1f5aa4ec1bffe899af75f4349cd7" name="gaf08c1f5aa4ec1bffe899af75f4349cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf08c1f5aa4ec1bffe899af75f4349cd7">&#9670;&nbsp;</a></span>test_evaluate_rank_1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , template&lt; size_t, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a>, typename &gt; class TensorIndexType, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> Valence, auto &amp; TensorIndex&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::tenex::test_evaluate_rank_1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate testing of evaluating single rank 1 Tensors on multiple <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> types and dimensions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">TensorIndexType</td><td>the Tensors' <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> </td></tr>
    <tr><td class="paramname">Valence</td><td>the valence of the Tensors' index </td></tr>
    <tr><td class="paramname"><a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a></td><td>the <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used in the the TensorExpression, e.g. <code>ti::a</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacff120a6119acadc8b97ed7950c065a5" name="gacff120a6119acadc8b97ed7950c065a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacff120a6119acadc8b97ed7950c065a5">&#9670;&nbsp;</a></span>test_evaluate_rank_1_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename TensorIndexTypeList , auto &amp; TensorIndex&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::tenex::test_evaluate_rank_1_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test that evaluating a right hand side tensor expression containing a single rank 1 tensor correctly assigns the data to the evaluated left hand side tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">TensorIndexTypeList</td><td>the Tensors' typelist containing their <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> </td></tr>
    <tr><td class="paramname"><a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a></td><td>the <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used in the the TensorExpression, e.g. <code>ti::a</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadf8fe84127caf3ee49548648c016a9b9" name="gadf8fe84127caf3ee49548648c016a9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf8fe84127caf3ee49548648c016a9b9">&#9670;&nbsp;</a></span>test_evaluate_rank_2_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename RhsSymmetry , typename RhsTensorIndexTypeList , auto &amp; TensorIndexA, auto &amp; TensorIndexB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::tenex::test_evaluate_rank_2_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test that evaluating a right hand side tensor expression containing a single rank 2 tensor correctly assigns the data to the evaluated left hand side tensor. </p>
<h3>Details</h3>
<p ><code>TensorIndexA</code> and <code>TensorIndexB</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti::a</code> and <code>ti::b</code>. The "A" and "B" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used and <code>TensorIndexB</code> is the second index used.</p>
<p >If we consider the RHS tensor's generic indices to be (a, b), then this test checks that the data in the evaluated LHS tensor is correct according to the index orders of the LHS and RHS. The two possible cases that are checked are when the LHS tensor is evaluated with index order (a, b) and when it is evaluated with the index order (b, a).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">RhsSymmetry</td><td>the <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9" title="Computes the canonical symmetry from the integers T">Symmetry</a> of the RHS Tensor </td></tr>
    <tr><td class="paramname">RhsTensorIndexTypeList</td><td>the RHS Tensor's typelist of <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a>s </td></tr>
    <tr><td class="paramname">TensorIndexA</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti::a</code> </td></tr>
    <tr><td class="paramname">TensorIndexB</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti::B</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa4bcc29540d344199c0222d07459c5e0" name="gaa4bcc29540d344199c0222d07459c5e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4bcc29540d344199c0222d07459c5e0">&#9670;&nbsp;</a></span>test_evaluate_rank_2_no_symmetry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , template&lt; size_t, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a>, typename &gt; class TensorIndexTypeA, template&lt; size_t, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a>, typename &gt; class TensorIndexTypeB, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> ValenceA, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> ValenceB, auto &amp; TensorIndexA, auto &amp; TensorIndexB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::tenex::test_evaluate_rank_2_no_symmetry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate testing of evaluating single rank 2 Tensors on multiple <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> types and dimension combinations. </p>
<p >We test nonsymmetric indices and symmetric indices across two functions to ensure that the code works correctly with symmetries. This function tests one of the following symmetries:</p><ul>
<li>&lt;2, 1&gt; (<code>test_evaluate_rank_2_no_symmetry</code>)</li>
<li>&lt;1, 1&gt; (<code>test_evaluate_rank_2_symmetric</code>)</li>
</ul>
<h3>Details</h3>
<p ><code>TensorIndexA</code> and <code>TensorIndexB</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti::a</code> and <code>ti::b</code>. The "A" and "B" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used and <code>TensorIndexB</code> is the second index used.</p>
<p >Note: <code>test_evaluate_rank_2_symmetric</code> has fewer template parameters due to the two indices having a shared <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> and and valence</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">TensorIndexTypeA</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the first index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeB</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the second index of the RHS Tensor </td></tr>
    <tr><td class="paramname">ValenceA</td><td>the valence of the first index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceB</td><td>the valence of the second index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">TensorIndexA</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti::a</code> </td></tr>
    <tr><td class="paramname">TensorIndexB</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti::B</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad6d7b7cc18b7257bb1d5978b55799763" name="gad6d7b7cc18b7257bb1d5978b55799763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6d7b7cc18b7257bb1d5978b55799763">&#9670;&nbsp;</a></span>test_evaluate_rank_2_symmetric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , template&lt; size_t, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a>, typename &gt; class TensorIndexType, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> Valence, auto &amp; TensorIndexA, auto &amp; TensorIndexB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::tenex::test_evaluate_rank_2_symmetric </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Iterate testing of evaluating single rank 2 Tensors on multiple <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> types and dimension combinations.</p>
<p >We test nonsymmetric indices and symmetric indices across two functions to ensure that the code works correctly with symmetries. This function tests one of the following symmetries:</p><ul>
<li>&lt;2, 1&gt; (<code>test_evaluate_rank_2_no_symmetry</code>)</li>
<li>&lt;1, 1&gt; (<code>test_evaluate_rank_2_symmetric</code>)</li>
</ul>
<h3>Details</h3>
<p ><code>TensorIndexA</code> and <code>TensorIndexB</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti::a</code> and <code>ti::b</code>. The "A" and "B" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used and <code>TensorIndexB</code> is the second index used.</p>
<p >Note: <code>test_evaluate_rank_2_symmetric</code> has fewer template parameters due to the two indices having a shared <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> and and valence</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">TensorIndexTypeA</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the first index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeB</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the second index of the RHS Tensor </td></tr>
    <tr><td class="paramname">ValenceA</td><td>the valence of the first index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceB</td><td>the valence of the second index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">TensorIndexA</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti::a</code> </td></tr>
    <tr><td class="paramname">TensorIndexB</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti::B</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf270dbea08fc80e0c4b38fb1aeef01de" name="gaf270dbea08fc80e0c4b38fb1aeef01de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf270dbea08fc80e0c4b38fb1aeef01de">&#9670;&nbsp;</a></span>test_evaluate_rank_3_ab_symmetry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , template&lt; size_t, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a>, typename &gt; class TensorIndexTypeAB, template&lt; size_t, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a>, typename &gt; class TensorIndexTypeC, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> ValenceAB, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> ValenceC, auto &amp; TensorIndexA, auto &amp; TensorIndexB, auto &amp; TensorIndexC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::tenex::test_evaluate_rank_3_ab_symmetry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Iterate testing of evaluating single rank 3 Tensors on multiple <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> types and dimension combinations.</p>
<p >We test various different symmetries across several functions to ensure that the code works correctly with symmetries. This function tests one of the following symmetries:</p><ul>
<li>&lt;3, 2, 1&gt; (<code>test_evaluate_rank_3_no_symmetry</code>)</li>
<li>&lt;2, 2, 1&gt; (<code>test_evaluate_rank_3_ab_symmetry</code>)</li>
<li>&lt;2, 1, 2&gt; (<code>test_evaluate_rank_3_ac_symmetry</code>)</li>
<li>&lt;2, 1, 1&gt; (<code>test_evaluate_rank_3_bc_symmetry</code>)</li>
<li>&lt;1, 1, 1&gt; (<code>test_evaluate_rank_3_abc_symmetry</code>)</li>
</ul>
<h3>Details</h3>
<p ><code>TensorIndexA</code>, <code>TensorIndexB</code>, and <code>TensorIndexC</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti::a</code>, <code>ti::b</code>, and <code>ti::c</code>. The "A", "B", and "C" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used, <code>TensorIndexB</code> is the second index used, and <code>TensorIndexC</code> is the third index used.</p>
<p >Note: the functions dealing with symmetric indices have fewer template parameters due to the indices having a shared <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> and valence</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">TensorIndexTypeA</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the first index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeB</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the second index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeC</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the third index of the RHS Tensor </td></tr>
    <tr><td class="paramname">ValenceA</td><td>the valence of the first index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceB</td><td>the valence of the second index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceC</td><td>the valence of the third index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">TensorIndexA</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti::a</code> </td></tr>
    <tr><td class="paramname">TensorIndexB</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti::B</code> </td></tr>
    <tr><td class="paramname">TensorIndexC</td><td>the third <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti::c</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6fdc3b3a7f9e815772e06b4ff544f35c" name="ga6fdc3b3a7f9e815772e06b4ff544f35c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fdc3b3a7f9e815772e06b4ff544f35c">&#9670;&nbsp;</a></span>test_evaluate_rank_3_abc_symmetry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , template&lt; size_t, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a>, typename &gt; class TensorIndexType, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> Valence, auto &amp; TensorIndexA, auto &amp; TensorIndexB, auto &amp; TensorIndexC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::tenex::test_evaluate_rank_3_abc_symmetry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Iterate testing of evaluating single rank 3 Tensors on multiple <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> types and dimension combinations.</p>
<p >We test various different symmetries across several functions to ensure that the code works correctly with symmetries. This function tests one of the following symmetries:</p><ul>
<li>&lt;3, 2, 1&gt; (<code>test_evaluate_rank_3_no_symmetry</code>)</li>
<li>&lt;2, 2, 1&gt; (<code>test_evaluate_rank_3_ab_symmetry</code>)</li>
<li>&lt;2, 1, 2&gt; (<code>test_evaluate_rank_3_ac_symmetry</code>)</li>
<li>&lt;2, 1, 1&gt; (<code>test_evaluate_rank_3_bc_symmetry</code>)</li>
<li>&lt;1, 1, 1&gt; (<code>test_evaluate_rank_3_abc_symmetry</code>)</li>
</ul>
<h3>Details</h3>
<p ><code>TensorIndexA</code>, <code>TensorIndexB</code>, and <code>TensorIndexC</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti::a</code>, <code>ti::b</code>, and <code>ti::c</code>. The "A", "B", and "C" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used, <code>TensorIndexB</code> is the second index used, and <code>TensorIndexC</code> is the third index used.</p>
<p >Note: the functions dealing with symmetric indices have fewer template parameters due to the indices having a shared <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> and valence</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">TensorIndexTypeA</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the first index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeB</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the second index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeC</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the third index of the RHS Tensor </td></tr>
    <tr><td class="paramname">ValenceA</td><td>the valence of the first index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceB</td><td>the valence of the second index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceC</td><td>the valence of the third index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">TensorIndexA</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti::a</code> </td></tr>
    <tr><td class="paramname">TensorIndexB</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti::B</code> </td></tr>
    <tr><td class="paramname">TensorIndexC</td><td>the third <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti::c</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4426c46c2fe17a47a23474f2f476cd2e" name="ga4426c46c2fe17a47a23474f2f476cd2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4426c46c2fe17a47a23474f2f476cd2e">&#9670;&nbsp;</a></span>test_evaluate_rank_3_ac_symmetry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , template&lt; size_t, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a>, typename &gt; class TensorIndexTypeAC, template&lt; size_t, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a>, typename &gt; class TensorIndexTypeB, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> ValenceAC, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> ValenceB, auto &amp; TensorIndexA, auto &amp; TensorIndexB, auto &amp; TensorIndexC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::tenex::test_evaluate_rank_3_ac_symmetry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Iterate testing of evaluating single rank 3 Tensors on multiple <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> types and dimension combinations.</p>
<p >We test various different symmetries across several functions to ensure that the code works correctly with symmetries. This function tests one of the following symmetries:</p><ul>
<li>&lt;3, 2, 1&gt; (<code>test_evaluate_rank_3_no_symmetry</code>)</li>
<li>&lt;2, 2, 1&gt; (<code>test_evaluate_rank_3_ab_symmetry</code>)</li>
<li>&lt;2, 1, 2&gt; (<code>test_evaluate_rank_3_ac_symmetry</code>)</li>
<li>&lt;2, 1, 1&gt; (<code>test_evaluate_rank_3_bc_symmetry</code>)</li>
<li>&lt;1, 1, 1&gt; (<code>test_evaluate_rank_3_abc_symmetry</code>)</li>
</ul>
<h3>Details</h3>
<p ><code>TensorIndexA</code>, <code>TensorIndexB</code>, and <code>TensorIndexC</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti::a</code>, <code>ti::b</code>, and <code>ti::c</code>. The "A", "B", and "C" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used, <code>TensorIndexB</code> is the second index used, and <code>TensorIndexC</code> is the third index used.</p>
<p >Note: the functions dealing with symmetric indices have fewer template parameters due to the indices having a shared <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> and valence</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">TensorIndexTypeA</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the first index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeB</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the second index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeC</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the third index of the RHS Tensor </td></tr>
    <tr><td class="paramname">ValenceA</td><td>the valence of the first index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceB</td><td>the valence of the second index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceC</td><td>the valence of the third index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">TensorIndexA</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti::a</code> </td></tr>
    <tr><td class="paramname">TensorIndexB</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti::B</code> </td></tr>
    <tr><td class="paramname">TensorIndexC</td><td>the third <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti::c</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8ca2f4b11b54b8dfb4cba772c9419900" name="ga8ca2f4b11b54b8dfb4cba772c9419900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ca2f4b11b54b8dfb4cba772c9419900">&#9670;&nbsp;</a></span>test_evaluate_rank_3_bc_symmetry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , template&lt; size_t, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a>, typename &gt; class TensorIndexTypeA, template&lt; size_t, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a>, typename &gt; class TensorIndexTypeBC, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> ValenceA, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> ValenceBC, auto &amp; TensorIndexA, auto &amp; TensorIndexB, auto &amp; TensorIndexC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::tenex::test_evaluate_rank_3_bc_symmetry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Iterate testing of evaluating single rank 3 Tensors on multiple <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> types and dimension combinations.</p>
<p >We test various different symmetries across several functions to ensure that the code works correctly with symmetries. This function tests one of the following symmetries:</p><ul>
<li>&lt;3, 2, 1&gt; (<code>test_evaluate_rank_3_no_symmetry</code>)</li>
<li>&lt;2, 2, 1&gt; (<code>test_evaluate_rank_3_ab_symmetry</code>)</li>
<li>&lt;2, 1, 2&gt; (<code>test_evaluate_rank_3_ac_symmetry</code>)</li>
<li>&lt;2, 1, 1&gt; (<code>test_evaluate_rank_3_bc_symmetry</code>)</li>
<li>&lt;1, 1, 1&gt; (<code>test_evaluate_rank_3_abc_symmetry</code>)</li>
</ul>
<h3>Details</h3>
<p ><code>TensorIndexA</code>, <code>TensorIndexB</code>, and <code>TensorIndexC</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti::a</code>, <code>ti::b</code>, and <code>ti::c</code>. The "A", "B", and "C" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used, <code>TensorIndexB</code> is the second index used, and <code>TensorIndexC</code> is the third index used.</p>
<p >Note: the functions dealing with symmetric indices have fewer template parameters due to the indices having a shared <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> and valence</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">TensorIndexTypeA</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the first index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeB</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the second index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeC</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the third index of the RHS Tensor </td></tr>
    <tr><td class="paramname">ValenceA</td><td>the valence of the first index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceB</td><td>the valence of the second index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceC</td><td>the valence of the third index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">TensorIndexA</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti::a</code> </td></tr>
    <tr><td class="paramname">TensorIndexB</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti::B</code> </td></tr>
    <tr><td class="paramname">TensorIndexC</td><td>the third <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti::c</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga72c6d07c6937fa97907624bcd7bab842" name="ga72c6d07c6937fa97907624bcd7bab842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72c6d07c6937fa97907624bcd7bab842">&#9670;&nbsp;</a></span>test_evaluate_rank_3_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename RhsSymmetry , typename RhsTensorIndexTypeList , auto &amp; TensorIndexA, auto &amp; TensorIndexB, auto &amp; TensorIndexC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::tenex::test_evaluate_rank_3_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test that evaluating a right hand side tensor expression containing a single rank 3 tensor correctly assigns the data to the evaluated left hand side tensor. </p>
<h3>Details</h3>
<p ><code>TensorIndexA</code>, <code>TensorIndexB</code>, and <code>TensorIndexC</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti::a</code>, <code>ti::b</code>, and <code>ti::c</code>. The "A", "B", and "C" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used, <code>TensorIndexB</code> is the second index used, and <code>TensorIndexC</code> is the third index used.</p>
<p >If we consider the RHS tensor's generic indices to be (a, b, c), then this test checks that the data in the evaluated LHS tensor is correct according to the index orders of the LHS and RHS. The possible cases that are checked are when the LHS tensor is evaluated with index orders: (a, b, c), (a, c, b), (b, a, c), (b, c, a), (c, a, b), and (c, b, a).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">RhsSymmetry</td><td>the <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9" title="Computes the canonical symmetry from the integers T">Symmetry</a> of the RHS Tensor </td></tr>
    <tr><td class="paramname">RhsTensorIndexTypeList</td><td>the RHS Tensor's typelist of <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a>s </td></tr>
    <tr><td class="paramname">TensorIndexA</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti::a</code> </td></tr>
    <tr><td class="paramname">TensorIndexB</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti::B</code> </td></tr>
    <tr><td class="paramname">TensorIndexC</td><td>the third <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti::c</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaffd8031d31f026abe36d85f5017c99c5" name="gaffd8031d31f026abe36d85f5017c99c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffd8031d31f026abe36d85f5017c99c5">&#9670;&nbsp;</a></span>test_evaluate_rank_3_no_symmetry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , template&lt; size_t, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a>, typename &gt; class TensorIndexTypeA, template&lt; size_t, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a>, typename &gt; class TensorIndexTypeB, template&lt; size_t, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a>, typename &gt; class TensorIndexTypeC, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> ValenceA, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> ValenceB, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> ValenceC, auto &amp; TensorIndexA, auto &amp; TensorIndexB, auto &amp; TensorIndexC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::tenex::test_evaluate_rank_3_no_symmetry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate testing of evaluating single rank 3 Tensors on multiple <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> types and dimension combinations. </p>
<p >We test various different symmetries across several functions to ensure that the code works correctly with symmetries. This function tests one of the following symmetries:</p><ul>
<li>&lt;3, 2, 1&gt; (<code>test_evaluate_rank_3_no_symmetry</code>)</li>
<li>&lt;2, 2, 1&gt; (<code>test_evaluate_rank_3_ab_symmetry</code>)</li>
<li>&lt;2, 1, 2&gt; (<code>test_evaluate_rank_3_ac_symmetry</code>)</li>
<li>&lt;2, 1, 1&gt; (<code>test_evaluate_rank_3_bc_symmetry</code>)</li>
<li>&lt;1, 1, 1&gt; (<code>test_evaluate_rank_3_abc_symmetry</code>)</li>
</ul>
<h3>Details</h3>
<p ><code>TensorIndexA</code>, <code>TensorIndexB</code>, and <code>TensorIndexC</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti::a</code>, <code>ti::b</code>, and <code>ti::c</code>. The "A", "B", and "C" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used, <code>TensorIndexB</code> is the second index used, and <code>TensorIndexC</code> is the third index used.</p>
<p >Note: the functions dealing with symmetric indices have fewer template parameters due to the indices having a shared <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> and valence</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">TensorIndexTypeA</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the first index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeB</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the second index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeC</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the third index of the RHS Tensor </td></tr>
    <tr><td class="paramname">ValenceA</td><td>the valence of the first index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceB</td><td>the valence of the second index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceC</td><td>the valence of the third index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">TensorIndexA</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti::a</code> </td></tr>
    <tr><td class="paramname">TensorIndexB</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti::B</code> </td></tr>
    <tr><td class="paramname">TensorIndexC</td><td>the third <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti::c</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafff0c4391d6169d9357c436b0eff2969" name="gafff0c4391d6169d9357c436b0eff2969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafff0c4391d6169d9357c436b0eff2969">&#9670;&nbsp;</a></span>test_evaluate_rank_4()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename RhsSymmetry , typename RhsTensorIndexTypeList , auto &amp; TensorIndexA, auto &amp; TensorIndexB, auto &amp; TensorIndexC, auto &amp; TensorIndexD&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::tenex::test_evaluate_rank_4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test that evaluating a right hand side tensor expression containing a single rank 4 tensor correctly assigns the data to the evaluated left hand side tensor. </p>
<h3>Details</h3>
<p ><code>TensorIndexA</code>, <code>TensorIndexB</code>, <code>TensorIndexC</code>, and <code>TensorIndexD</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti::a</code>, <code>ti::b</code>, <code>ti::c</code>, and <code>ti::d</code>. The "A", "B", "C", and "D" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used, <code>TensorIndexB</code> is the second index used, <code>TensorIndexC</code> is the third index used, and <code>TensorIndexD</code> is the fourth index used.</p>
<p >If we consider the RHS tensor's generic indices to be (a, b, c, d), then this test checks that the data in the evaluated LHS tensor is correct according to the index orders of the LHS and RHS. The possible cases that are checked are when the LHS tensor is evaluated with index orders of all 24 permutations of (a, b, c, d), e.g. (a, b, d, c), (a, c, b, d), ...</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">RhsSymmetry</td><td>the <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9" title="Computes the canonical symmetry from the integers T">Symmetry</a> of the RHS Tensor </td></tr>
    <tr><td class="paramname">RhsTensorIndexTypeList</td><td>the RHS Tensor's typelist of <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a>s </td></tr>
    <tr><td class="paramname">TensorIndexA</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti::a</code> </td></tr>
    <tr><td class="paramname">TensorIndexB</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti::B</code> </td></tr>
    <tr><td class="paramname">TensorIndexC</td><td>the third <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti::c</code> </td></tr>
    <tr><td class="paramname">TensorIndexD</td><td>the fourth <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti::D</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3783673fa2a65b2d51ac60e4252c9b0c" name="ga3783673fa2a65b2d51ac60e4252c9b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3783673fa2a65b2d51ac60e4252c9b0c">&#9670;&nbsp;</a></span>test_factory_creation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseClass , typename DerivedClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; BaseClass &gt; TestHelpers::test_factory_creation </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>construction_string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a class of a known derived type using a factory. </p>
<p >This is a shorthand for creating a <code>DerivedClass</code> through a <code>BaseClass</code> factory, saving the caller from having to explicitly write metavariables with the appropriate <code>factory_classes</code> alias. The name of the type should be supplied as the first line of the passed string, just as for normal use of a factory.</p>
<p >If multiple factory creatable types must be handled or if metavariables must be passed for some other reason, then the more general <a class="el" href="group__TestingFrameworkGroup.html#ga7dfb31d9c4494e8d552e3cd3ca7eed81" title="Creates an instance of a given option-creatable type.">TestHelpers::test_creation()</a> must be used instead.</p>
<div class="fragment"><div class="line">  CHECK(TestHelpers::test_factory_creation&lt;BaseClass, DerivedClass&gt;(</div>
<div class="line">            <span class="stringliteral">&quot;DerivedClass:\n&quot;</span></div>
<div class="line">            <span class="stringliteral">&quot;  SizeT: 5&quot;</span>)</div>
<div class="line">            -&gt;get_value() == 5);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gafa22edca07de9742e60f55cd0532db34" name="gafa22edca07de9742e60f55cd0532db34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa22edca07de9742e60f55cd0532db34">&#9670;&nbsp;</a></span>test_functions_with_vector_arguments()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__TestingFrameworkGroup.html#ga921a5dbf5f1704e2051d1daf593d0d90">TestKind</a> Test, typename VectorType0 , typename... VectorTypes, typename... FunctionsAndArgumentBounds&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::VectorImpl::test_functions_with_vector_arguments </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; FunctionsAndArgumentBounds... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple_of_functions_and_argument_bounds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General entry function for testing arbitrary math functions on vector types. </p>
<h3>Details</h3>
<p >This utility tests all combinations of the operator on the type arguments, and all combinations of reference or constant reference wrappers on all arguments. In certain test cases (see below), it also tests using the vector type's <code>value_type</code>s in the operators as well (e.g. <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a> + double</code>). This is very useful for quickly generating a lot of tests, but the number of tests scales exponentially in the number of arguments. Therefore, functions with many arguments can be time-consuming to run. 4-or-more-argument functions should be used only if completely necessary and with caution. Any number of vector types may be specified, and tests are run on all unique combinations of the provided. For instance, if only one type is provided, the tests will be run only on combinations of that single type and its <code>value_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple_of_functions_and_argument_bounds</td><td>A tuple of tuples, in which the inner tuple contains first a function object followed by a tuple of 2-element arrays equal to the number of arguments, which represent the bounds for the random generation of the respective arguments. This system is provided for robust testing of operators like <code>/</code>, where the left-hand side has a different valid set of values than the right-hand-side.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Test</td><td>from the <code>TestKind</code> enum, determines whether the tests will be:<ul>
<li><code>TestKind::Normal</code>: executed on all combinations of arguments and value types</li>
<li><code>TestKind::Strict</code>: executed on all combinations of arguments, for only the vector types</li>
<li><code>TestKind::Inplace</code>: executed on all combinations of arguments after the first, so first is always the 'left hand side' of the operator. In this case, at least two <code>VectorTypes</code> must be specified, where the first is used only for the left-hand side.</li>
<li><code>TestKind::GivenOrderOfArgumentsOnly</code>: executed on only the combination of arguments provided, in the order provided. In this case, the number of provided types in <code>typename VectorType0, typename... VectorTypes</code> must precisely match the number of arguments taken by the function.</li>
</ul>
</td></tr>
    <tr><td class="paramname">VectorType0</td><td>The first vector type for which combinations are tested. The first is accepted as a separate template argument for appropriately handling <code>Inplace</code> tests. </td></tr>
    <tr><td class="paramname">VectorTypes</td><td>The remaining types for which combinations are tested. Any number of types may be passed in, and the test will check the appropriate combinations of the vector types and (depending on the <code>Test</code>) the respective <code>value_type</code>s. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga17b631a68906e714104e6c2fbdc2c1d2" name="ga17b631a68906e714104e6c2fbdc2c1d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17b631a68906e714104e6c2fbdc2c1d2">&#9670;&nbsp;</a></span>test_option_tag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OptionTag , typename Metavariables  = NoSuchType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OptionTag::type TestHelpers::test_option_tag </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>construction_string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs the option parser on a given tag. </p>
<p >Runs the option parser with the supplied input on a given tag. The tag name and any groups are handled by this function and should not be supplied in the argument string. If necessary, metavariables can be supplied as the second template argument.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ClassWithoutMetavariables {</div>
<div class="line">  <span class="keyword">struct </span>SizeT {</div>
<div class="line">    <span class="keyword">using</span> type = size_t;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <a class="code hl_typedef" href="namespaceOptions.html#aa61c7f41f21afa7646811456f673be89">Options::String</a> help = {<span class="stringliteral">&quot;SizeT help&quot;</span>};</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">using</span> options = tmpl::list&lt;SizeT&gt;;</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <a class="code hl_typedef" href="namespaceOptions.html#aa61c7f41f21afa7646811456f673be89">Options::String</a> help = {<span class="stringliteral">&quot;Help&quot;</span>};</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">explicit</span> ClassWithoutMetavariables(<span class="keyword">const</span> <span class="keywordtype">size_t</span> in_value) : <a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">value</a>(in_value) {}</div>
<div class="line"> </div>
<div class="line">  ClassWithoutMetavariables() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">size_t</span> <a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">value</a>{0};</div>
<div class="line">};</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">struct </span>ExampleTag {</div>
<div class="line">  <span class="keyword">using</span> type = ClassWithoutMetavariables;</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <a class="code hl_typedef" href="namespaceOptions.html#aa61c7f41f21afa7646811456f673be89">Options::String</a> help = {<span class="stringliteral">&quot;help&quot;</span>};</div>
<div class="line">  <span class="keyword">using</span> group = OptionGroup1;</div>
<div class="line">};</div>
</div><!-- fragment --> <div class="fragment"><div class="line">  CHECK(TestHelpers::test_option_tag&lt;ExampleTag&gt;(<span class="stringliteral">&quot;SizeT: 7&quot;</span>).<a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">value</a> == 7);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TestingFrameworkGroup.html#ga7dfb31d9c4494e8d552e3cd3ca7eed81" title="Creates an instance of a given option-creatable type.">TestHelpers::test_creation()</a> </dd></dl>

</div>
</div>
<a id="gae64239ff57740663c52a2abbdcce8cff" name="gae64239ff57740663c52a2abbdcce8cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae64239ff57740663c52a2abbdcce8cff">&#9670;&nbsp;</a></span>test_option_tag_factory_creation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OptionTag , typename DerivedClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OptionTag::type TestHelpers::test_option_tag_factory_creation </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>construction_string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A wrapper that allows testing an option tag without having to write a Metavariables class. Combines <code><a class="el" href="group__TestingFrameworkGroup.html#ga3783673fa2a65b2d51ac60e4252c9b0c" title="Creates a class of a known derived type using a factory.">TestHelpers::test_factory_creation()</a></code> and <code><a class="el" href="group__TestingFrameworkGroup.html#ga17b631a68906e714104e6c2fbdc2c1d2" title="Runs the option parser on a given tag.">TestHelpers::test_option_tag()</a></code>. </p>
<dl class="section note"><dt>Note</dt><dd>Assumes that the option tag holds a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;BaseClass&gt;</code>.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>OptionTags {</div>
<div class="line"><span class="keyword">struct </span>BaseClass {</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <a class="code hl_typedef" href="namespaceOptions.html#aa61c7f41f21afa7646811456f673be89">Options::String</a> help = <span class="stringliteral">&quot;Halp&quot;</span>;</div>
<div class="line">  <span class="keyword">using</span> type = <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr&lt;::BaseClass&gt;</a>;</div>
<div class="line">};</div>
<div class="line">}  <span class="comment">// namespace OptionTags</span></div>
<div class="ttc" id="aunique_ptr_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a></div></div>
</div><!-- fragment --> <div class="fragment"><div class="line">  CHECK(<a class="code hl_function" href="group__TestingFrameworkGroup.html#gae64239ff57740663c52a2abbdcce8cff">TestHelpers::test_option_tag_factory_creation</a>&lt;OptionTags::BaseClass,</div>
<div class="line">                                                      DerivedClass&gt;(</div>
<div class="line">            <span class="stringliteral">&quot;DerivedClass:\n&quot;</span></div>
<div class="line">            <span class="stringliteral">&quot;  SizeT: 5&quot;</span>)</div>
<div class="line">            -&gt;get_value() == 5);</div>
<div class="ttc" id="agroup__TestingFrameworkGroup_html_gae64239ff57740663c52a2abbdcce8cff"><div class="ttname"><a href="group__TestingFrameworkGroup.html#gae64239ff57740663c52a2abbdcce8cff">TestHelpers::test_option_tag_factory_creation</a></div><div class="ttdeci">OptionTag::type test_option_tag_factory_creation(const std::string &amp;construction_string)</div><div class="ttdoc">A wrapper that allows testing an option tag without having to write a Metavariables class....</div><div class="ttdef"><b>Definition:</b> TestCreation.hpp:152</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga4294de51e79ce048d0a76bd72f80d19a" name="ga4294de51e79ce048d0a76bd72f80d19a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4294de51e79ce048d0a76bd72f80d19a">&#9670;&nbsp;</a></span>test_serialization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void test_serialization </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests the serialization of comparable types. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">  {</div>
<div class="line">    INFO(<span class="stringliteral">&quot;tuple&quot;</span>);</div>
<div class="line">    <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map&lt;std::string, double&gt;</a> um;</div>
<div class="line">    um[<span class="stringliteral">&quot;aaa&quot;</span>] = 1.589;</div>
<div class="line">    um[<span class="stringliteral">&quot;bbb&quot;</span>] = -10.7392;</div>
<div class="line">    <span class="keyword">auto</span> test_tuple = std::make_tuple&lt;int, double, <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>,</div>
<div class="line">                                      <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map&lt;std::string, double&gt;</a>&gt;(</div>
<div class="line">        2, 0.57, <span class="stringliteral">&quot;blah&quot;</span>, std::move(um));</div>
<div class="line">    <a class="code hl_function" href="group__TestingFrameworkGroup.html#ga4294de51e79ce048d0a76bd72f80d19a">test_serialization</a>(test_tuple);</div>
<div class="line">  }</div>
<div class="ttc" id="abasic_string_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a></div></div>
<div class="ttc" id="agroup__TestingFrameworkGroup_html_ga4294de51e79ce048d0a76bd72f80d19a"><div class="ttname"><a href="group__TestingFrameworkGroup.html#ga4294de51e79ce048d0a76bd72f80d19a">test_serialization</a></div><div class="ttdeci">void test_serialization(const T &amp;t)</div><div class="ttdoc">Tests the serialization of comparable types.</div><div class="ttdef"><b>Definition:</b> TestHelpers.hpp:68</div></div>
<div class="ttc" id="aunordered_map_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a></div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga9032f7d7bb3698bab71a49d1df9c2d99" name="ga9032f7d7bb3698bab71a49d1df9c2d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9032f7d7bb3698bab71a49d1df9c2d99">&#9670;&nbsp;</a></span>test_serialization_via_base()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B , typename D , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void test_serialization_via_base </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test the serialization of a derived class via a base class pointer. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">  {</div>
<div class="line">    INFO(<span class="stringliteral">&quot;unique_ptr.abstract_base&quot;</span>);</div>
<div class="line">    <a class="code hl_function" href="group__TestingFrameworkGroup.html#ga9032f7d7bb3698bab71a49d1df9c2d99">test_serialization_via_base</a>&lt;Test_Classes::Base,</div>
<div class="line">                                Test_Classes::DerivedInPupStlCpp11&gt;(</div>
<div class="line">        <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{-1, 12.3, -7, 8});</div>
<div class="line">  }</div>
<div class="ttc" id="agroup__TestingFrameworkGroup_html_ga9032f7d7bb3698bab71a49d1df9c2d99"><div class="ttname"><a href="group__TestingFrameworkGroup.html#ga9032f7d7bb3698bab71a49d1df9c2d99">test_serialization_via_base</a></div><div class="ttdeci">void test_serialization_via_base(Args &amp;&amp;... args)</div><div class="ttdoc">Test the serialization of a derived class via a base class pointer.</div><div class="ttdef"><b>Definition:</b> TestHelpers.hpp:83</div></div>
<div class="ttc" id="avector_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt; double &gt;</a></div></div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">B</td><td>the base class </td></tr>
    <tr><td class="paramname">D</td><td>the derived class </td></tr>
    <tr><td class="paramname">Args</td><td>deduced from <code>args</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>arguments passed to a constructor of the derived class </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae5e273d9f807e8e9e5ae88c8d3035bd2" name="gae5e273d9f807e8e9e5ae88c8d3035bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5e273d9f807e8e9e5ae88c8d3035bd2">&#9670;&nbsp;</a></span>test_tensor_index_transformation_rank_0()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::tenex::test_tensor_index_transformation_rank_0 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the transformation between two rank 0 tensors' generic indices and the subsequent transformed multi-index is correctly computed. </p>
<h3>Details</h3>
<p >The functions tested are:</p><ul>
<li><code><a class="el" href="namespacetenex.html#aeb5a8c04357e897b192841b9782f3cd8" title="Computes a transformation from one generic tensor index order to another.">tenex::compute_tensorindex_transformation</a></code></li>
<li><code><a class="el" href="namespacetenex.html#a9d6117c6b69af07157f8921036a60080" title="Computes the tensor multi-index that is equivalent to a given tensor multi-index, according to the di...">tenex::transform_multi_index</a></code> </li>
</ul>

</div>
</div>
<a id="ga6c7291c51a6f01aeda865dae8ecb873e" name="ga6c7291c51a6f01aeda865dae8ecb873e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c7291c51a6f01aeda865dae8ecb873e">&#9670;&nbsp;</a></span>test_tensor_index_transformation_rank_1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="structTensorIndex.html">TensorIndex</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::tenex::test_tensor_index_transformation_rank_1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTensorIndex.html">TensorIndex</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test that the transformation between two rank 1 tensors' generic indices and the subsequent transformed multi-indices are correctly computed. </p>
<h3>Details</h3>
<p >The functions tested are:</p><ul>
<li><code><a class="el" href="namespacetenex.html#aeb5a8c04357e897b192841b9782f3cd8" title="Computes a transformation from one generic tensor index order to another.">tenex::compute_tensorindex_transformation</a></code></li>
<li><code><a class="el" href="namespacetenex.html#a9d6117c6b69af07157f8921036a60080" title="Computes the tensor multi-index that is equivalent to a given tensor multi-index, according to the di...">tenex::transform_multi_index</a></code></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a></td><td>the first generic tensor index, e.g. type of <code>ti::a</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae2b08ffdd19e622301540b8694a67784" name="gae2b08ffdd19e622301540b8694a67784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2b08ffdd19e622301540b8694a67784">&#9670;&nbsp;</a></span>test_tensor_index_transformation_rank_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorIndexA , typename TensorIndexB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::tenex::test_tensor_index_transformation_rank_2 </td>
          <td>(</td>
          <td class="paramtype">const TensorIndexA &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorIndexB &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test that the transformation between two rank 2 tensors' generic indices and the subsequent transformed multi-indices are correctly computed. </p>
<h3>Details</h3>
<p >The functions tested are:</p><ul>
<li><code><a class="el" href="namespacetenex.html#aeb5a8c04357e897b192841b9782f3cd8" title="Computes a transformation from one generic tensor index order to another.">tenex::compute_tensorindex_transformation</a></code></li>
<li><code><a class="el" href="namespacetenex.html#a9d6117c6b69af07157f8921036a60080" title="Computes the tensor multi-index that is equivalent to a given tensor multi-index, according to the di...">tenex::transform_multi_index</a></code></li>
</ul>
<p >If we consider the first tensor's generic indices to be (a, b), the possible orderings of the second tensor's generic indices are: (a, b) and (b, a). For each of these cases, this test checks that for each multi-index with the first generic index ordering, the equivalent multi-index with the second ordering is correctly computed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TensorIndexA</td><td>the first generic tensor index, e.g. type of <code>ti::a</code> </td></tr>
    <tr><td class="paramname">TensorIndexB</td><td>the second generic tensor index, e.g. type of <code>ti::B</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga76b77b43487b741679c4dc479c9ee8ab" name="ga76b77b43487b741679c4dc479c9ee8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76b77b43487b741679c4dc479c9ee8ab">&#9670;&nbsp;</a></span>test_tensor_index_transformation_rank_3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorIndexA , typename TensorIndexB , typename TensorIndexC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::tenex::test_tensor_index_transformation_rank_3 </td>
          <td>(</td>
          <td class="paramtype">const TensorIndexA &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorIndexB &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorIndexC &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test that the transformation between two rank 3 tensors' generic indices and the subsequent transformed multi-indices are correctly computed. </p>
<h3>Details</h3>
<p >The functions tested are:</p><ul>
<li><code><a class="el" href="namespacetenex.html#aeb5a8c04357e897b192841b9782f3cd8" title="Computes a transformation from one generic tensor index order to another.">tenex::compute_tensorindex_transformation</a></code></li>
<li><code><a class="el" href="namespacetenex.html#a9d6117c6b69af07157f8921036a60080" title="Computes the tensor multi-index that is equivalent to a given tensor multi-index, according to the di...">tenex::transform_multi_index</a></code></li>
</ul>
<p >If we consider the first tensor's generic indices to be (a, b, c), the possible orderings of the second tensor's generic indices are: (a, b, c), (a, c, b), (b, a, c), (b, c, a), (c, a, b), and (c, b, a). For each of these cases, this test checks that for each multi-index with the first generic index ordering, the equivalent multi-index with the second ordering is correctly computed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TensorIndexA</td><td>the first generic tensor index, e.g. type of <code>ti::a</code> </td></tr>
    <tr><td class="paramname">TensorIndexB</td><td>the second generic tensor index, e.g. type of <code>ti::B</code> </td></tr>
    <tr><td class="paramname">TensorIndexC</td><td>the third generic tensor index, e.g. type of <code>ti::c</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga05f460af35fe3e1416e3f5371fccd8bc" name="ga05f460af35fe3e1416e3f5371fccd8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05f460af35fe3e1416e3f5371fccd8bc">&#9670;&nbsp;</a></span>test_tensor_index_transformation_rank_4()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorIndexA , typename TensorIndexB , typename TensorIndexC , typename TensorIndexD &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::tenex::test_tensor_index_transformation_rank_4 </td>
          <td>(</td>
          <td class="paramtype">const TensorIndexA &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorIndexB &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorIndexC &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorIndexD &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test that the transformation between two rank 4 tensors' generic indices and the subsequent transformed multi-indices are correctly computed. </p>
<h3>Details</h3>
<p >The functions tested are:</p><ul>
<li><code><a class="el" href="namespacetenex.html#aeb5a8c04357e897b192841b9782f3cd8" title="Computes a transformation from one generic tensor index order to another.">tenex::compute_tensorindex_transformation</a></code></li>
<li><code><a class="el" href="namespacetenex.html#a9d6117c6b69af07157f8921036a60080" title="Computes the tensor multi-index that is equivalent to a given tensor multi-index, according to the di...">tenex::transform_multi_index</a></code></li>
</ul>
<p >If we consider the first tensor's generic indices to be (a, b, c, d), there are 24 permutations that are possible orderings of the second tensor's generic indices, such as: (a, b, c, d), (a, b, d, c), (a, c, b, d), etc. For each of these cases, this test checks that for each multi-index with the first generic index ordering, the equivalent multi-index with the second ordering is correctly computed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TensorIndexA</td><td>the first generic tensor index, e.g. type of <code>ti::a</code> </td></tr>
    <tr><td class="paramname">TensorIndexB</td><td>the second generic tensor index, e.g. type of <code>ti::B</code> </td></tr>
    <tr><td class="paramname">TensorIndexC</td><td>the third generic tensor index, e.g. type of <code>ti::c</code> </td></tr>
    <tr><td class="paramname">TensorIndexD</td><td>the fourth generic tensor index, e.g. type of <code>ti::D</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga11bc653f483c16da824829fecb5f8a04" name="ga11bc653f483c16da824829fecb5f8a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11bc653f483c16da824829fecb5f8a04">&#9670;&nbsp;</a></span>test_tensor_index_transformation_with_time_indices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::tenex::test_tensor_index_transformation_with_time_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the transformation between two tensors generic indices and the subsequent transformed multi-indices are correctly computed when time indices are used with at least one of the tensors. </p>
<h3>Details</h3>
<p >The functions tested are:</p><ul>
<li><code><a class="el" href="namespacetenex.html#aeb5a8c04357e897b192841b9782f3cd8" title="Computes a transformation from one generic tensor index order to another.">tenex::compute_tensorindex_transformation</a></code></li>
<li><code><a class="el" href="namespacetenex.html#a9d6117c6b69af07157f8921036a60080" title="Computes the tensor multi-index that is equivalent to a given tensor multi-index, according to the di...">tenex::transform_multi_index</a></code> </li>
</ul>

</div>
</div>
<a id="ga809dd7c089188c1c15f847f73cf6d924" name="ga809dd7c089188c1c15f847f73cf6d924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga809dd7c089188c1c15f847f73cf6d924">&#9670;&nbsp;</a></span>test_throw_exception()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Exception , typename ThrowingFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void test_throw_exception </td>
          <td>(</td>
          <td class="paramtype">const ThrowingFunctor &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Exception &amp;&#160;</td>
          <td class="paramname"><em>expected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute <code>func</code> and check that it throws an exception <code>expected</code>. </p>
<dl class="section note"><dt>Note</dt><dd>The <code>.what()</code> strings of the thrown and <code>expected</code> exceptions are compared for a partial match only: the <code>expected.what()</code> string must be contained in (or equal to) the <code>.what()</code> string of the thrown exception. </dd></dl>

</div>
</div>
<a id="gaca8f3c157268ccafd499b96d617766dd" name="gaca8f3c157268ccafd499b96d617766dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca8f3c157268ccafd499b96d617766dd">&#9670;&nbsp;</a></span>vector_ref_test_size_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType , typename ValueType  = typename VectorType::ElementType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::VectorImpl::vector_ref_test_size_error </td>
          <td>(</td>
          <td class="paramtype">RefSizeErrorTestKind&#160;</td>
          <td class="paramname"><em>test_kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tt::get_fundamental_type_t&lt; ValueType &gt;&#160;</td>
          <td class="paramname"><em>low</em> = <code>tt::get_fundamental_type_t&lt;ValueType&gt;{-100.0}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tt::get_fundamental_type_t&lt; ValueType &gt;&#160;</td>
          <td class="paramname"><em>high</em> = <code>tt::get_fundamental_type_t&lt;ValueType&gt;{100.0}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test that assigning to a non-owning <code>VectorType</code> of the wrong size appropriately generates an error. </p>
<h3>Details</h3>
<p >a calling function should be an <code><a class="el" href="group__TestingFrameworkGroup.html#ga4439208ed8accb2887ff47388e91e58b" title="Mark a test to be checking an ASSERT.">ASSERTION_TEST()</a></code> and check for the string "Must copy/move/assign into same size". Three types of tests are provided and one must be provided as the first function argument:</p><ul>
<li><code>RefSizeErrorTestKind::Copy</code>: Checks that copy-assigning to a non-owning <code>VectorType</code> from a <code>VectorType</code> with the wrong size generates an error.</li>
<li><code>RefSizeErrorTestKind::ExpressionAssign</code>: Checks that assigning to a non-owning <code>VectorType</code> from an expression with alias <code>ResultType</code> of <code>VectorType</code> with the wrong size generates an error</li>
<li><code>RefSizeErrorTestKind::Move</code>: Checks that move-assigning to a non-owning <code>VectorType</code> from a <code>VectorType</code> with the wrong size generates an error. </li>
</ul>

</div>
</div>
<a id="gabec6cfa0fc0e149eeaa14ae2dabf4eff" name="gabec6cfa0fc0e149eeaa14ae2dabf4eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabec6cfa0fc0e149eeaa14ae2dabf4eff">&#9670;&nbsp;</a></span>verify_grmhd_solution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Solution &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void verify_grmhd_solution </td>
          <td>(</td>
          <td class="paramtype">const Solution &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlock.html">Block</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>error_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>delta_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the given <code>solution</code> is a solution of the GRMHD equations. </p>
<p >Uses numerical derivatives to compute the solution, on the given <code>mesh</code> of the root <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> of the given <code>block</code> at the given <code>time</code> using a sixth-order derivative in time for the given <code>delta_time</code>. The maximum residual of the GRMHD equations must be zero within <code>error_tolerance</code> </p>

</div>
</div>
<a id="gaac01f40512b0cf3c754268134d19f0dd" name="gaac01f40512b0cf3c754268134d19f0dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac01f40512b0cf3c754268134d19f0dd">&#9670;&nbsp;</a></span>verify_smooth_solution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename System , typename SolutionType , size_t Dim = System::volume_dim, typename... Maps, typename PackageFluxesArgs &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FirstOrderEllipticSolutionsTestHelpers::verify_smooth_solution </td>
          <td>(</td>
          <td class="paramtype">const SolutionType &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdomain_1_1CoordinateMap.html">domain::CoordinateMap</a>&lt; <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, Maps... &gt; &amp;&#160;</td>
          <td class="paramname"><em>coord_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance_scaling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PackageFluxesArgs &amp;&amp;&#160;</td>
          <td class="paramname"><em>package_fluxes_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Test that the <code>solution</code> numerically solves the <code>System</code> on the given grid and that the discretization error decreases as expected for a smooth function.</p>
<h3>Details</h3>
<p >We expect exponential convergence for a smooth solution, so the tolerance is computed as</p>
<p class="formulaDsp">
\begin{equation} C_1 \exp{\left(-C_2 * N_\mathrm{points}\right)} \end{equation}
</p>
<p >where \(C_1\) is the <code>tolerance_offset</code>, \(C_2\) is the <code>tolerance_scaling</code> and \(N_\mathrm{points}\) is the number of grid points per dimension. </p>

</div>
</div>
<a id="ga72787f3b08aa73df7781cff8a5192ea8" name="ga72787f3b08aa73df7781cff8a5192ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72787f3b08aa73df7781cff8a5192ea8">&#9670;&nbsp;</a></span>verify_solution_with_power_law_convergence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename System , typename SolutionType , size_t Dim = System::volume_dim, typename... Maps&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FirstOrderEllipticSolutionsTestHelpers::verify_solution_with_power_law_convergence </td>
          <td>(</td>
          <td class="paramtype">const SolutionType &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdomain_1_1CoordinateMap.html">domain::CoordinateMap</a>&lt; <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, Maps... &gt; &amp;&#160;</td>
          <td class="paramname"><em>coord_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance_pow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Test that the <code>solution</code> numerically solves the <code>System</code> on the given grid and that the discretization error decreases as a power law.</p>
<h3>Details</h3>
<p >The tolerance is computed as</p>
<p class="formulaDsp">
\begin{equation} C \left(N_\mathrm{points}\right)^{-p} \end{equation}
</p>
<p >where \(C\) is the <code>tolerance_offset</code>, \(p\) is the <code>tolerance_pow</code> and \(N_\mathrm{points}\) is the number of grid points per dimension. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
