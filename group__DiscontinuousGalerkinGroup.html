<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: Discontinuous Galerkin</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__DiscontinuousGalerkinGroup.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Discontinuous Galerkin</div></div>
</div><!--header-->
<div class="contents">

<p>Functions and classes specific to the Discontinuous Galerkin algorithm.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLimiters_1_1Tags_1_1LimiterCommunicationTag.html">Limiters::Tags::LimiterCommunicationTag&lt; Metavariables &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inbox tag for limiter communication.  <a href="structLimiters_1_1Tags_1_1LimiterCommunicationTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLimiters_1_1Actions_1_1Limit.html">Limiters::Actions::Limit&lt; Metavariables &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive limiter data from neighbors, then apply limiter.  <a href="structLimiters_1_1Actions_1_1Limit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLimiters_1_1Actions_1_1SendData.html">Limiters::Actions::SendData&lt; Metavariables &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send local data needed for limiting.  <a href="structLimiters_1_1Actions_1_1SendData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdg_1_1SimpleMortarData.html">dg::SimpleMortarData&lt; TemporalId, LocalVars, RemoteVars &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage of boundary data on two sides of a mortar.  <a href="classdg_1_1SimpleMortarData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTags_1_1Mortars.html">Tags::Mortars&lt; Tag, VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data on mortars, indexed by (<a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis.">Direction</a>, <a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a>) pairs.  <a href="structTags_1_1Mortars.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTags_1_1MortarSize.html">Tags::MortarSize&lt; Dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of a mortar, relative to the element face. That is, the part of the face that it covers.  <a href="structTags_1_1MortarSize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilters_1_1Exponential.html">Filters::Exponential&lt; FilterIndex &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cached exponential filter.  <a href="classFilters_1_1Exponential.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdg_1_1Actions_1_1Filter_3_01FilterType_00_01tmpl_1_1list_3_01TagsToFilter_8_8_8_01_4_01_4.html">dg::Actions::Filter&lt; FilterType, tmpl::list&lt; TagsToFilter... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a filter to the specified tags.  <a href="classdg_1_1Actions_1_1Filter_3_01FilterType_00_01tmpl_1_1list_3_01TagsToFilter_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdg_1_1Events_1_1ObserveFields_3_01VolumeDim_00_01ObservationValueTag_00_01tmpl_1_1list_3_01de0fbf4c4efb17826c82b24de4fe12b4.html">dg::Events::ObserveFields&lt; VolumeDim, ObservationValueTag, tmpl::list&lt; Tensors... &gt;, tmpl::list&lt; NonTensorComputeTags... &gt;, ArraySectionIdTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Observe volume tensor fields.  <a href="classdg_1_1Events_1_1ObserveFields_3_01VolumeDim_00_01ObservationValueTag_00_01tmpl_1_1list_3_01de0fbf4c4efb17826c82b24de4fe12b4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdg_1_1Events_1_1ObserveVolumeIntegrals_3_01VolumeDim_00_01ObservationValueTag_00_01tmpl_1_117bbe1a13a15c77c397dbc9477bff9b5.html">dg::Events::ObserveVolumeIntegrals&lt; VolumeDim, ObservationValueTag, tmpl::list&lt; Tensors... &gt;, tmpl::list&lt; NonTensorComputeTags... &gt;, ArraySectionIdTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Observe the volume integrals of the tensors over the domain.  <a href="classdg_1_1Events_1_1ObserveVolumeIntegrals_3_01VolumeDim_00_01ObservationValueTag_00_01tmpl_1_117bbe1a13a15c77c397dbc9477bff9b5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga102ad013b7e4298b4c14c52a39bcd8da"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DiscontinuousGalerkinGroup.html#ga102ad013b7e4298b4c14c52a39bcd8da">dg::Formulation</a> { <b>StrongInertial</b>
, <b>WeakInertial</b>
 }</td></tr>
<tr class="memdesc:ga102ad013b7e4298b4c14c52a39bcd8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">The DG formulation to use.  <a href="group__DiscontinuousGalerkinGroup.html#ga102ad013b7e4298b4c14c52a39bcd8da">More...</a><br /></td></tr>
<tr class="separator:ga102ad013b7e4298b4c14c52a39bcd8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa966d9760b419f933e2e39c32f326715"><td class="memTemplParams" colspan="2">template&lt;typename InboxTag , size_t Dim, typename TemporalIdType , typename... InboxTags&gt; </td></tr>
<tr class="memitem:gaa966d9760b419f933e2e39c32f326715"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DiscontinuousGalerkinGroup.html#gaa966d9760b419f933e2e39c32f326715">dg::has_received_from_all_mortars</a> (const TemporalIdType &amp;temporal_id, const <a class="el" href="classElement.html">Element</a>&lt; Dim &gt; &amp;element, const <a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; InboxTags... &gt; &amp;inboxes)</td></tr>
<tr class="memdesc:gaa966d9760b419f933e2e39c32f326715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if data on all mortars has been received for the <code>InboxTag</code> at time <code>temporal_id</code>.  <a href="group__DiscontinuousGalerkinGroup.html#gaa966d9760b419f933e2e39c32f326715">More...</a><br /></td></tr>
<tr class="separator:gaa966d9760b419f933e2e39c32f326715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c128051a8706e751383fbfed7d91241"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ga6c128051a8706e751383fbfed7d91241"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DiscontinuousGalerkinGroup.html#ga6c128051a8706e751383fbfed7d91241">dg::metric_identity_det_jac_times_inv_jac</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; * &gt; det_jac_times_inverse_jacobian, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &amp;inertial_coords, const Jacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &amp;jacobian)</td></tr>
<tr class="memdesc:ga6c128051a8706e751383fbfed7d91241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Jacobian determinant times the inverse Jacobian so that the result is divergence-free.  <a href="group__DiscontinuousGalerkinGroup.html#ga6c128051a8706e751383fbfed7d91241">More...</a><br /></td></tr>
<tr class="separator:ga6c128051a8706e751383fbfed7d91241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a3fde3477693771bf8a029dd8183e6f"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ga6a3fde3477693771bf8a029dd8183e6f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DiscontinuousGalerkinGroup.html#ga6a3fde3477693771bf8a029dd8183e6f">dg::metric_identity_jacobian_quantities</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; * &gt; det_jac_times_inverse_jacobian, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; * &gt; inverse_jacobian, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Jacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; * &gt; jacobian, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt; det_jacobian, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &amp;inertial_coords)</td></tr>
<tr class="memdesc:ga6a3fde3477693771bf8a029dd8183e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Jacobian, inverse Jacobian, and determinant of the Jacobian so that they satisfy the metric identities.  <a href="group__DiscontinuousGalerkinGroup.html#ga6a3fde3477693771bf8a029dd8183e6f">More...</a><br /></td></tr>
<tr class="separator:ga6a3fde3477693771bf8a029dd8183e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fd98c38b052d23f6f1f7cf5868c5158"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ga6fd98c38b052d23f6f1f7cf5868c5158"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DiscontinuousGalerkinGroup.html#ga6fd98c38b052d23f6f1f7cf5868c5158">dg::mortar_mesh</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;face_mesh1, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;face_mesh2)</td></tr>
<tr class="memdesc:ga6fd98c38b052d23f6f1f7cf5868c5158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a mesh for a mortar capable of representing data from either of two faces.  <a href="group__DiscontinuousGalerkinGroup.html#ga6fd98c38b052d23f6f1f7cf5868c5158">More...</a><br /></td></tr>
<tr class="separator:ga6fd98c38b052d23f6f1f7cf5868c5158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab297ce2a5916fc0078f4bedb04437bb9"><td class="memTemplParams" colspan="2"><a id="gab297ce2a5916fc0078f4bedb04437bb9" name="gab297ce2a5916fc0078f4bedb04437bb9"></a>
template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:gab297ce2a5916fc0078f4bedb04437bb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">MortarSize</a>&lt; Dim - 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dg::mortar_size</b> (const <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &amp;self, const <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &amp;neighbor, size_t dimension, const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; Dim &gt; &amp;orientation)</td></tr>
<tr class="memdesc:gab297ce2a5916fc0078f4bedb04437bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the size of the mortar (i.e., the part of the face it covers) for communicating with a neighbor. This is the size relative to the size of <code>self</code>, and will not generally agree with that determined by <code>neighbor</code>. <br /></td></tr>
<tr class="separator:gab297ce2a5916fc0078f4bedb04437bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72fe2658e89afabf1d99954773b30521"><td class="memTemplParams" colspan="2">template&lt;typename... BoundaryCorrectionTags&gt; </td></tr>
<tr class="memitem:ga72fe2658e89afabf1d99954773b30521"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DiscontinuousGalerkinGroup.html#ga72fe2658e89afabf1d99954773b30521">dg::lift_flux</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; tmpl::list&lt; BoundaryCorrectionTags... &gt; &gt; * &gt; boundary_correction_terms, const size_t extent_perpendicular_to_boundary, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;magnitude_of_face_normal)</td></tr>
<tr class="memdesc:ga72fe2658e89afabf1d99954773b30521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lifts the flux contribution from an interface to the volume.  <a href="group__DiscontinuousGalerkinGroup.html#ga72fe2658e89afabf1d99954773b30521">More...</a><br /></td></tr>
<tr class="separator:ga72fe2658e89afabf1d99954773b30521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3c27a9baa2c03a01b200652e919b34c"><td class="memTemplParams" colspan="2">template&lt;typename... FluxTags&gt; </td></tr>
<tr class="memitem:gab3c27a9baa2c03a01b200652e919b34c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DiscontinuousGalerkinGroup.html#gab3c27a9baa2c03a01b200652e919b34c">dg::lift_flux</a> (Variables&lt; tmpl::list&lt; FluxTags... &gt; &gt; flux, const size_t extent_perpendicular_to_boundary, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;magnitude_of_face_normal) -&gt; Variables&lt; tmpl::list&lt; <a class="el" href="group__DataBoxTagsGroup.html#gae0f7c7c20a2a4908eebcb234302b1b4f">db::remove_tag_prefix</a>&lt; FluxTags &gt;... &gt; &gt;</td></tr>
<tr class="memdesc:gab3c27a9baa2c03a01b200652e919b34c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lifts the flux contribution from an interface to the volume.  <a href="group__DiscontinuousGalerkinGroup.html#gab3c27a9baa2c03a01b200652e919b34c">More...</a><br /></td></tr>
<tr class="separator:gab3c27a9baa2c03a01b200652e919b34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54315caca66d53ea2e27dd8c8f766cf4"><td class="memTemplParams" colspan="2"><a id="ga54315caca66d53ea2e27dd8c8f766cf4" name="ga54315caca66d53ea2e27dd8c8f766cf4"></a>
template&lt;typename Tags , size_t Dim&gt; </td></tr>
<tr class="memitem:ga54315caca66d53ea2e27dd8c8f766cf4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dg::project_to_mortar</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; Tags &gt; * &gt; result, const Variables&lt; Tags &gt; &amp;vars, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;face_mesh, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;<a class="el" href="group__DiscontinuousGalerkinGroup.html#ga6fd98c38b052d23f6f1f7cf5868c5158">mortar_mesh</a>, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">MortarSize</a>&lt; Dim &gt; &amp;<a class="el" href="group__DiscontinuousGalerkinGroup.html#gab297ce2a5916fc0078f4bedb04437bb9">mortar_size</a>)</td></tr>
<tr class="memdesc:ga54315caca66d53ea2e27dd8c8f766cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project variables from a face to a mortar. <br /></td></tr>
<tr class="separator:ga54315caca66d53ea2e27dd8c8f766cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78dd3d6006c20d1a2429caa8f5a42556"><td class="memTemplParams" colspan="2"><a id="ga78dd3d6006c20d1a2429caa8f5a42556" name="ga78dd3d6006c20d1a2429caa8f5a42556"></a>
template&lt;typename Tags , size_t Dim&gt; </td></tr>
<tr class="memitem:ga78dd3d6006c20d1a2429caa8f5a42556"><td class="memTemplItemLeft" align="right" valign="top">Variables&lt; Tags &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dg::project_to_mortar</b> (const Variables&lt; Tags &gt; &amp;vars, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;face_mesh, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;<a class="el" href="group__DiscontinuousGalerkinGroup.html#ga6fd98c38b052d23f6f1f7cf5868c5158">mortar_mesh</a>, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">MortarSize</a>&lt; Dim &gt; &amp;<a class="el" href="group__DiscontinuousGalerkinGroup.html#gab297ce2a5916fc0078f4bedb04437bb9">mortar_size</a>)</td></tr>
<tr class="memdesc:ga78dd3d6006c20d1a2429caa8f5a42556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project variables from a face to a mortar. <br /></td></tr>
<tr class="separator:ga78dd3d6006c20d1a2429caa8f5a42556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37105f2142e21c73ef95e09b946f781e"><td class="memTemplParams" colspan="2"><a id="ga37105f2142e21c73ef95e09b946f781e" name="ga37105f2142e21c73ef95e09b946f781e"></a>
template&lt;typename Tags , size_t Dim&gt; </td></tr>
<tr class="memitem:ga37105f2142e21c73ef95e09b946f781e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dg::project_from_mortar</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; Tags &gt; * &gt; result, const Variables&lt; Tags &gt; &amp;vars, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;face_mesh, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;<a class="el" href="group__DiscontinuousGalerkinGroup.html#ga6fd98c38b052d23f6f1f7cf5868c5158">mortar_mesh</a>, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">MortarSize</a>&lt; Dim &gt; &amp;<a class="el" href="group__DiscontinuousGalerkinGroup.html#gab297ce2a5916fc0078f4bedb04437bb9">mortar_size</a>)</td></tr>
<tr class="memdesc:ga37105f2142e21c73ef95e09b946f781e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project variables from a mortar to a face. <br /></td></tr>
<tr class="separator:ga37105f2142e21c73ef95e09b946f781e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8ac9cf09cb971f4a3039d654d4bb6e4"><td class="memTemplParams" colspan="2"><a id="gaa8ac9cf09cb971f4a3039d654d4bb6e4" name="gaa8ac9cf09cb971f4a3039d654d4bb6e4"></a>
template&lt;typename Tags , size_t Dim&gt; </td></tr>
<tr class="memitem:gaa8ac9cf09cb971f4a3039d654d4bb6e4"><td class="memTemplItemLeft" align="right" valign="top">Variables&lt; Tags &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dg::project_from_mortar</b> (const Variables&lt; Tags &gt; &amp;vars, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;face_mesh, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;<a class="el" href="group__DiscontinuousGalerkinGroup.html#ga6fd98c38b052d23f6f1f7cf5868c5158">mortar_mesh</a>, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">MortarSize</a>&lt; Dim &gt; &amp;<a class="el" href="group__DiscontinuousGalerkinGroup.html#gab297ce2a5916fc0078f4bedb04437bb9">mortar_size</a>)</td></tr>
<tr class="memdesc:gaa8ac9cf09cb971f4a3039d654d4bb6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project variables from a mortar to a face. <br /></td></tr>
<tr class="separator:gaa8ac9cf09cb971f4a3039d654d4bb6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Functions and classes specific to the Discontinuous Galerkin algorithm. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga102ad013b7e4298b4c14c52a39bcd8da" name="ga102ad013b7e4298b4c14c52a39bcd8da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga102ad013b7e4298b4c14c52a39bcd8da">&#9670;&nbsp;</a></span>Formulation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="group__DiscontinuousGalerkinGroup.html#ga102ad013b7e4298b4c14c52a39bcd8da">dg::Formulation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The DG formulation to use. </p>
<ul>
<li>The <code>StrongInertial</code> formulation is also known as the integrate then transform formulation. The "Inertial" part of the name refers to the fact that the integration is done over the physical/inertial coordinates, while the "strong" part refers to the fact that the boundary correction terms are zero if the solution is continuous at the interfaces. See <a class="el" href="citelist.html#CITEREF_Teukolsky2015ega">[158]</a> for an overview.</li>
<li>The <code>WeakInertial</code> formulation is also known as the integrate then transform formulation. The "Inertial" part of the name refers to the fact that the integration is done over the physical/inertial coordinates, while the "weak" part refers to the fact that the boundary correction terms are non-zero even if the solution is continuous at the interfaces. See <a class="el" href="citelist.html#CITEREF_Teukolsky2015ega">[158]</a> for an overview. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa966d9760b419f933e2e39c32f326715" name="gaa966d9760b419f933e2e39c32f326715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa966d9760b419f933e2e39c32f326715">&#9670;&nbsp;</a></span>has_received_from_all_mortars()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InboxTag , size_t Dim, typename TemporalIdType , typename... InboxTags&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool dg::has_received_from_all_mortars </td>
          <td>(</td>
          <td class="paramtype">const TemporalIdType &amp;&#160;</td>
          <td class="paramname"><em>temporal_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; InboxTags... &gt; &amp;&#160;</td>
          <td class="paramname"><em>inboxes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if data on all mortars has been received for the <code>InboxTag</code> at time <code>temporal_id</code>. </p>
<p >The <code>InboxTag</code> must hold a container indexed by the <code>TemporalIdType</code>, representing received neighbor data at a given time. Each element in the container, i.e. the received neighbor data at a given time, must be another container indexed by the <code>dg::MortarId&lt;Dim&gt;</code>. The value it holds is not relevant for this function. Here's an example for such a type:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Dim&gt;</div>
<div class="line"><span class="keyword">struct </span>InboxTag {</div>
<div class="line">  <span class="keyword">using</span> type = <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map&lt;int, dg::MortarMap&lt;Dim, double&gt;</a>&gt;;</div>
<div class="line">};</div>
<div class="ttc" id="aunordered_map_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a></div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga72fe2658e89afabf1d99954773b30521" name="ga72fe2658e89afabf1d99954773b30521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72fe2658e89afabf1d99954773b30521">&#9670;&nbsp;</a></span>lift_flux() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... BoundaryCorrectionTags&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::lift_flux </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; tmpl::list&lt; BoundaryCorrectionTags... &gt; &gt; * &gt;&#160;</td>
          <td class="paramname"><em>boundary_correction_terms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>extent_perpendicular_to_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>magnitude_of_face_normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lifts the flux contribution from an interface to the volume. </p>
<p >The lifting operation takes the (d-1)-dimensional flux term at the interface and computes the corresponding d-dimensional term in the volume. SpECTRE implements an efficient DG method in which each interface grid point contributes only to that same grid point of the volume.</p>
<h3>Details</h3>
<p >SpECTRE implements a DG method with a diagonalized mass matrix (also known as a mass-lumping scheme). This choice gives a large reduction in the computational cost of the lifting operation, however, the scheme is slightly less accurate, especially when the grid is deformed by non-trivial Jacobians. For more details on the diagonalization of the mass matrix and its implications, <a class="el" href="citelist.html#CITEREF_Teukolsky2015ega">[158]</a>, especially Section 3.</p>
<dl class="section note"><dt>Note</dt><dd>The result is still provided only on the boundary grid. The values away from the boundary are zero and are not stored. </dd></dl>

</div>
</div>
<a id="gab3c27a9baa2c03a01b200652e919b34c" name="gab3c27a9baa2c03a01b200652e919b34c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3c27a9baa2c03a01b200652e919b34c">&#9670;&nbsp;</a></span>lift_flux() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... FluxTags&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto dg::lift_flux </td>
          <td>(</td>
          <td class="paramtype">Variables&lt; tmpl::list&lt; FluxTags... &gt; &gt;&#160;</td>
          <td class="paramname"><em>flux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>extent_perpendicular_to_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>magnitude_of_face_normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Variables&lt;tmpl::list&lt;<a class="el" href="group__DataBoxTagsGroup.html#gae0f7c7c20a2a4908eebcb234302b1b4f">db::remove_tag_prefix</a>&lt;FluxTags&gt;...&gt;&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lifts the flux contribution from an interface to the volume. </p>
<p >The lifting operation takes the (d-1)-dimensional flux term at the interface and computes the corresponding d-dimensional term in the volume. SpECTRE implements an efficient DG method in which each interface grid point contributes only to that same grid point of the volume.</p>
<h3>Details</h3>
<p >SpECTRE implements a DG method with a diagonalized mass matrix (also known as a mass-lumping scheme). This choice gives a large reduction in the computational cost of the lifting operation, however, the scheme is slightly less accurate, especially when the grid is deformed by non-trivial Jacobians. For more details on the diagonalization of the mass matrix and its implications, <a class="el" href="citelist.html#CITEREF_Teukolsky2015ega">[158]</a>, especially Section 3.</p>
<dl class="section note"><dt>Note</dt><dd>The result is still provided only on the boundary grid. The values away from the boundary are zero and are not stored. </dd></dl>

</div>
</div>
<a id="ga6c128051a8706e751383fbfed7d91241" name="ga6c128051a8706e751383fbfed7d91241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c128051a8706e751383fbfed7d91241">&#9670;&nbsp;</a></span>metric_identity_det_jac_times_inv_jac()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::metric_identity_det_jac_times_inv_jac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>det_jac_times_inverse_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inertial_coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Jacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>jacobian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Jacobian determinant times the inverse Jacobian so that the result is divergence-free. </p>
<p >The metric identities are given by</p>
<p class="formulaDsp">
\begin{align*} \partial_{\hat{\imath}}\left(J\frac{\partial\xi^{\hat{\imath}}} {\partial x^i}\right)=0. \end{align*}
</p>
<p >We want to compute \(J\partial\xi^{\hat{\imath}}/\partial x^i\) in such a way that the above metric identity is satisfied numerically/discretely. We refer to the inverse Jacobian computed this way as the "metric
indentity-satisfying inverse Jacobian".</p>
<p >The discretized form, with the Jacobian determinant \(J\) expanded, is given by</p>
<p class="formulaDsp">
\begin{align*} 2\left(J\frac{\partial \xi^{\hat{\imath}}}{\partial x^i}\right)_{s} &amp;=\epsilon_{ijk} \sum_{t_{\hat{1}}} \epsilon^{\hat{\imath}\hat{1}\hat{k}} D^{(\hat{1})}_{s t_1} \left(x^j\frac{\partial x^k}{\partial \xi^{\hat{k}}}\right)_{t} \notag \\ &amp;+\epsilon_{ijk} \sum_{t_{\hat{2}}} \epsilon^{\hat{\imath}\hat{2}\hat{k}} D^{(\hat{2})}_{st_2} \left(x^j\frac{\partial x^k}{\partial \xi^{\hat{k}}}\right)_{t} \notag \\ &amp;+\epsilon_{ijk} \sum_{t_{\hat{3}}}\epsilon^{\hat{\imath}\hat{3}\hat{k}} D^{(\hat{3})}_{st_3} \left(x^j\frac{\partial x^k}{\partial \xi^{\hat{k}}}\right)_{t}. \end{align*}
</p>
<p >where indices \(s,t,t_1,t_2\) and \(t_3\) are over grid points. \(t_i\) are the grid points in the particular logical direction.</p>
<p >In 1d we have:</p>
<p class="formulaDsp">
\begin{align*} J\frac{\partial \xi^{\hat{\imath}}}{\partial x^i}= = J\frac{\partial \xi^{\hat{i}}}{\partial x^i} = 1 \end{align*}
</p>
<p >In 2d we have:</p>
<p class="formulaDsp">
\begin{align*} J\frac{\partial \xi^{\hat{1}}}{\partial x^1}&amp;=D^{\hat{(2)}}x^2 &amp; J\frac{\partial \xi^{\hat{2}}}{\partial x^1}&amp;=-D^{\hat{(1)}}x^2 \\ J\frac{\partial \xi^{\hat{1}}}{\partial x^2}&amp;=-D^{\hat{(2)}}x^1 &amp; J\frac{\partial \xi^{\hat{2}}}{\partial x^2}&amp;=D^{\hat{(1)}}x^1 \\ \end{align*}
</p>
<p >In 3d we have:</p>
<p class="formulaDsp">
\begin{align*} 2J\frac{\partial \xi^{\hat{1}}}{\partial x^1}&amp;= D^{(\hat{2})}\left(x^2\frac{\partial x^3}{\partial \xi^{\hat{3}}}\right) -D^{(\hat{2})}\left(x^3\frac{\partial x^2}{\partial \xi^{\hat{3}}}\right) +D^{(\hat{3})}\left(x^3\frac{\partial x^2}{\partial \xi^{\hat{2}}}\right) -D^{(\hat{3})}\left(x^2\frac{\partial x^3}{\partial \xi^{\hat{2}}}\right)\\ 2J\frac{\partial \xi^{\hat{2}}}{\partial x^1}&amp;= D^{(\hat{1})}\left(x^3\frac{\partial x^2}{\partial\xi^{\hat{3}}}\right) -D^{(\hat{1})}\left(x^2\frac{\partial x^3}{\partial\xi^{\hat{3}}}\right) +D^{(\hat{3})}\left(x^2\frac{\partial x^3}{\partial\xi^{\hat{1}}}\right) -D^{(\hat{3})}\left(x^3\frac{\partial x^2}{\partial\xi^{\hat{1}}}\right) \\ 2J\frac{\partial \xi^{\hat{3}}}{\partial x^1}&amp;= D^{(\hat{1})}\left(x^2\frac{\partial x^3}{\partial\xi^{\hat{2}}}\right) -D^{(\hat{1})}\left(x^3\frac{\partial x^2}{\partial\xi^{\hat{2}}}\right) +D^{(\hat{2})}\left(x^3\frac{\partial x^2}{\partial\xi^{\hat{1}}}\right) -D^{(\hat{2})}\left(x^2\frac{\partial x^3}{\partial\xi^{\hat{1}}}\right)\\ 2J\frac{\partial \xi^{\hat{1}}}{\partial x^2}&amp;= D^{(\hat{2})}\left(x^3\frac{\partial x^1}{\partial \xi^{\hat{3}}}\right) -D^{(\hat{2})}\left(x^1\frac{\partial x^3}{\partial \xi^{\hat{3}}}\right) +D^{(\hat{3})}\left(x^1\frac{\partial x^3}{\partial \xi^{\hat{2}}}\right) -D^{(\hat{3})}\left(x^3\frac{\partial x^1}{\partial \xi^{\hat{2}}}\right) \\ 2J\frac{\partial \xi^{\hat{2}}}{\partial x^2}&amp;= D^{(\hat{1})}\left(x^1\frac{\partial x^3}{\partial \xi^{\hat{3}}}\right) -D^{(\hat{1})}\left(x^3\frac{\partial x^1}{\partial \xi^{\hat{3}}}\right) +D^{(\hat{3})}\left(x^3\frac{\partial x^1}{\partial \xi^{\hat{1}}}\right) -D^{(\hat{3})}\left(x^1\frac{\partial x^3}{\partial \xi^{\hat{1}}}\right)\\ 2J\frac{\partial \xi^{\hat{3}}}{\partial x^2}&amp;= D^{(\hat{1})}\left(x^3\frac{\partial x^1}{\partial \xi^{\hat{2}}}\right) -D^{(\hat{1})}\left(x^1\frac{\partial x^3}{\partial \xi^{\hat{2}}}\right) +D^{(\hat{2})}\left(x^1\frac{\partial x^3}{\partial \xi^{\hat{1}}}\right) -D^{(\hat{2})}\left(x^3\frac{\partial x^1}{\partial \xi^{\hat{1}}}\right) \\ 2J\frac{\partial \xi^{\hat{1}}}{\partial x^3}&amp;= D^{(\hat{2})}\left(x^1\frac{\partial x^2}{\partial \xi^{\hat{3}}}\right) -D^{(\hat{2})}\left(x^2\frac{\partial x^1}{\partial \xi^{\hat{3}}}\right) +D^{(\hat{3})}\left(x^2\frac{\partial x^1}{\partial \xi^{\hat{2}}}\right) -D^{(\hat{3})}\left(x^1\frac{\partial x^2}{\partial \xi^{\hat{2}}}\right) \\ 2J\frac{\partial \xi^{\hat{2}}}{\partial x^3}&amp;= D^{(\hat{1})}\left(x^2\frac{\partial x^1}{\partial \xi^{\hat{3}}}\right) -D^{(\hat{1})}\left(x^1\frac{\partial x^2}{\partial \xi^{\hat{3}}}\right) +D^{(\hat{3})}\left(x^1\frac{\partial x^2}{\partial \xi^{\hat{1}}}\right) -D^{(\hat{3})}\left(x^2\frac{\partial x^1}{\partial \xi^{\hat{1}}}\right) \\ 2J\frac{\partial \xi^{\hat{3}}}{\partial x^3}&amp;= D^{(\hat{1})}\left(x^1\frac{\partial x^2}{\partial \xi^{\hat{2}}}\right) -D^{(\hat{1})}\left(x^2\frac{\partial x^1}{\partial \xi^{\hat{2}}}\right) +D^{(\hat{2})}\left(x^2\frac{\partial x^1}{\partial \xi^{\hat{1}}}\right) -D^{(\hat{2})}\left(x^1\frac{\partial x^2}{\partial \xi^{\hat{1}}}\right) \end{align*}
</p>
<p >Again, this ensures that the metric identities are satisfied discretely. That is,</p>
<p class="formulaDsp">
\begin{align*} \partial_{\hat{\imath}}\left(J\frac{\partial\xi^{\hat{\imath}}} {\partial x^i}\right)=0 \end{align*}
</p>
<p >numerically.</p>
<p >The reason for calculating \(J\partial\xi^{\hat{\imath}}/\partial x^i\) in this manner is because in the weak form of DG (and most spectral-type methods can be recast as DG) we effectively evaluate</p>
<p class="formulaDsp">
\begin{align*} \partial_{\hat{\imath}}\left(J\frac{\partial\xi^{\hat{\imath}}} {\partial x^i} F^i\right), \end{align*}
</p>
<p >which should be identically zero if \(F^i\) is constant. This feature of a scheme is referred to as free-stream preserving. Note that another way to achieve free-stream preservation is to subtract off the metric identity violations. That is,</p>
<p class="formulaDsp">
\begin{align*} \partial_{\hat{\imath}}\left(J\frac{\partial\xi^{\hat{\imath}}} {\partial x^i} F^i\right) - F^i \partial_{\hat{\imath}}\left(J\frac{\partial\xi^{\hat{\imath}}} {\partial x^i}\right). \end{align*}
</p>
<p >The subtraction technique is most commonly used in finite difference codes. </p>

</div>
</div>
<a id="ga6a3fde3477693771bf8a029dd8183e6f" name="ga6a3fde3477693771bf8a029dd8183e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a3fde3477693771bf8a029dd8183e6f">&#9670;&nbsp;</a></span>metric_identity_jacobian_quantities()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::metric_identity_jacobian_quantities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>det_jac_times_inverse_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>inverse_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Jacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>det_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inertial_coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Jacobian, inverse Jacobian, and determinant of the Jacobian so that they satisfy the metric identities. </p>
<p >Uses <code>dg::metric_identity_jacobian()</code> to compute the determinant of the Jacobian times the inverse Jacobian. By taking the determinant of this product, we can isolate \(J\), the determinant of the Jacobian. In \(d\) dimensions, we have:</p>
<p class="formulaDsp">
\begin{align} \mathrm{det}\left(J\frac{\partial \xi^{\hat{\imath}}}{\partial x^i}\right) = J^{d-1}. \end{align}
</p>
<p >We assume the determinant of the Jacobian is positive, which means logical and inertial coordinates have the same handedness. With this assumption, we have</p>
<p class="formulaDsp">
\begin{align} J = \sqrt[(d-1)]{\mathrm{det}\left(J\frac{\partial \xi^{\hat{\imath}}}{\partial x^i}\right)} \end{align}
</p>
<p >We can now compute the inverse Jacobian using:</p>
<p class="formulaDsp">
\begin{align} \frac{\partial \xi^{\hat{\imath}}}{\partial x^i}= \frac{1}{J}\left(J\frac{\partial \xi^{\hat{\imath}}}{\partial x^i}\right) \end{align}
</p>
<p >This guarantees that multiplying the determinant of the Jacobian by the inverse Jacobian gives a result that satisfies the metric identities. We also compute the Jacobian by inverting the inverse Jacobian, which guarantees they are (numerical) inverses of each other.</p>
<dl class="section warning"><dt>Warning</dt><dd>on entry <code>jacobian</code> must be the Jacobian to use for computing the determinant of the Jacobian times the inverse Jacobian so that it satisfies the metric identities. The <code>jacobian</code> can be computed analytically or numerically, either is fine. On output the <code>jacobian</code> is the inverse of the inverse Jacobian that satisfies the metric identities. </dd></dl>

</div>
</div>
<a id="ga6fd98c38b052d23f6f1f7cf5868c5158" name="ga6fd98c38b052d23f6f1f7cf5868c5158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fd98c38b052d23f6f1f7cf5868c5158">&#9670;&nbsp;</a></span>mortar_mesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; dg::mortar_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_mesh1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_mesh2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a mesh for a mortar capable of representing data from either of two faces. </p>
<dl class="section warning"><dt>Warning</dt><dd>Make sure the two face meshes are oriented the same, i.e. their dimensions align. This is facilitated by the <code>orientation</code> passed to <code>domain::Initialization::create_initial_mesh</code>, for example. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
