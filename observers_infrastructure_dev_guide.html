<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: Observers Infrastructure</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('observers_infrastructure_dev_guide.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Observers Infrastructure </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><ul><li class="level2"><a href="#autotoc_md116">Reduction Data</a></li>
<li class="level2"><a href="#autotoc_md117">Volume Data</a></li>
<li class="level2"><a href="#autotoc_md118">Threading and NodeLocks</a></li>
<li class="level2"><a href="#autotoc_md119">Future changes</a></li>
</ul>
</ul>
</div>
<div class="textblock"><p ><a class="anchor" id="md_docs_DevGuide_Observers"></a></p>
<p >The observers infrastructure works with two parallel components: a group and a nodegroup. We have two types of observations: <code>Reduction</code> and <code>Volume</code> (see the enum <code>observers::TypeOfObservation</code>). <code>Reduction</code> data is anything that is written once per time/integral identifier per simulation. Some examples of reduction data are integrals or L2 norms over the entire domain, integrals or L2 norms over part of the domain, and integrals over lower-dimensional surfaces such as apparent horizons or slices through the domain. Volume data is anything that has physical extent, such as any of the evolved variables (or derived quantities thereof) across all or part of the domain, or quantities on lower-dimensional surfaces in the domain (e.g. the rest mass density in the xy-plane). Reduction and volume data both use the group and nodegroup for actually getting the data to disk, but do so in a slightly different manner.</p>
<h2><a class="anchor" id="autotoc_md116"></a>
Reduction Data</h2>
<p >Reduction data requires combining information from many or all cores of a supercomputer to get a single value. Reductions are tagged by some temporal value, which for hyperbolic systems is the time and for elliptic systems some combination of linear and non-linear iteration count. The reduction data is stored in an object of type <code>Parallel::ReductionData</code>, which takes as template parameters a series of <code><a class="el" href="structParallel_1_1ReductionDatum.html" title="The data to be reduced, and invokables to be called whenever two reduction messages are combined and ...">Parallel::ReductionDatum</a></code>. A <code><a class="el" href="structParallel_1_1ReductionDatum.html" title="The data to be reduced, and invokables to be called whenever two reduction messages are combined and ...">Parallel::ReductionDatum</a></code> takes as template parameters the type of the data and operators that define how data from the different cores are to be combined to a single value. See the paragraphs below for more detail, and the documentation of <code><a class="el" href="structParallel_1_1ReductionDatum.html" title="The data to be reduced, and invokables to be called whenever two reduction messages are combined and ...">Parallel::ReductionDatum</a></code> for examples.</p>
<p >At the start of a simulation, every component and event that wants to perform a reduction for observation, or will be part of a reduction observation, must register with the <code><a class="el" href="structobservers_1_1Observer.html" title="The group parallel component that is responsible for reducing data to be observed.">observers::Observer</a></code> component. The <code><a class="el" href="structobservers_1_1Observer.html" title="The group parallel component that is responsible for reducing data to be observed.">observers::Observer</a></code> is a group, which means there is one per core. The registration is used so that the <code>Observer</code> knows once all data for a specific reduction (both in time and by name/ID) has been contributed. Reduction data is combined on each core as it is contributed by using the binary operator from <code><a class="el" href="structParallel_1_1ReductionDatum.html" title="The data to be reduced, and invokables to be called whenever two reduction messages are combined and ...">Parallel::ReductionDatum</a></code>'s second template parameter. Once all the data is collected on the core, it is copied to the local <code><a class="el" href="structobservers_1_1ObserverWriter.html" title="The nodegroup parallel component that is responsible for writing data to disk.">observers::ObserverWriter</a></code> nodegroup, which keeps track of how many of the cores on the node will be contributing to a specific observation, and again combines all the data as it is being contributed. Once all the node's data is collected to the nodegroup, the data is sent to node <code>0</code> which combines the reduction data as it arrives using the binary operator from <code><a class="el" href="structParallel_1_1ReductionDatum.html" title="The data to be reduced, and invokables to be called whenever two reduction messages are combined and ...">Parallel::ReductionDatum</a></code>'s second template parameter. Using node <code>0</code> for collecting the final reduction data is an arbitrary choice, but we are always guaranteed to have a node <code>0</code>.</p>
<p >Once all the reductions are received on node <code>0</code>, the <code>ObserverWriter</code> invokes the <code>InvokeFinal</code> (third) template parameter on each <code><a class="el" href="structParallel_1_1ReductionDatum.html" title="The data to be reduced, and invokables to be called whenever two reduction messages are combined and ...">Parallel::ReductionDatum</a></code> (this is the n-ary) in order to finalize the data before writing. This is used, for example, for dividing by the total number of grid points in an L1 or L2 norm. The reduction data is then written to an HDF5 file whose name is set in the input file using the option <code><a class="el" href="structobservers_1_1Tags_1_1ReductionFileName.html" title="The name of the HDF5 file on disk into which reduction data is written.">observers::Tags::ReductionFileName</a></code>. Specifically, the data is written into an <code><a class="el" href="classh5_1_1Dat.html" title="Represents a multicolumn dat file inside an HDF5 file.">h5::Dat</a></code> subfile since, along with the data, the subfile name must be passed through the reductions.</p>
<p >The actions used for registering reductions are <code><a class="el" href="structobservers_1_1Actions_1_1RegisterEventsWithObservers.html" title="Registers this element of a parallel component with the local Observer parallel component for each tr...">observers::Actions::RegisterEventsWithObservers</a></code> and <code><a class="el" href="structobservers_1_1Actions_1_1RegisterWithObservers.html" title="Register an observation ID with the observers.">observers::Actions::RegisterWithObservers</a></code>. There is a separate <code><a class="el" href="namespaceRegistration.html" title="Helpers for derived class registration.">Registration</a></code> phase at the beginning of all simulations where everything must register with the observers. The action <code><a class="el" href="structobservers_1_1Actions_1_1ContributeReductionData.html" title="Send reduction data to the observer group.">observers::Actions::ContributeReductionData</a></code> is used to send data to the <code><a class="el" href="structobservers_1_1Observer.html" title="The group parallel component that is responsible for reducing data to be observed.">observers::Observer</a></code> component in the case where there is a reduction done across an array or subset of an array. If a singleton parallel component or a specific chare needs to write data directly to disk it should use the <code><a class="el" href="structobservers_1_1ThreadedActions_1_1WriteReductionDataRow.html" title="Write a single row of data to the reductions file without the need to register or reduce anything,...">observers::ThreadedActions::WriteReductionDataRow</a></code> action called on the zeroth element of the <code><a class="el" href="structobservers_1_1ObserverWriter.html" title="The nodegroup parallel component that is responsible for writing data to disk.">observers::ObserverWriter</a></code> component.</p>
<h2><a class="anchor" id="autotoc_md117"></a>
Volume Data</h2>
<p >Volume data is vaguely defined as anything that has some extent. For example, in a 3d simulation, data on 2d surfaces is still considered volume data for the purposes of observing data. The spectral coefficients can also be written as volume data, though some care must be taken in that case to correctly identify which mode is associated with which terms in the basis function expansion. Whatever component will contribute volume data to be written must register with the <code><a class="el" href="structobservers_1_1Observer.html" title="The group parallel component that is responsible for reducing data to be observed.">observers::Observer</a></code> component (there currently isn't tested support for directly registering with the <code><a class="el" href="structobservers_1_1ObserverWriter.html" title="The nodegroup parallel component that is responsible for writing data to disk.">observers::ObserverWriter</a></code>). This registration is the same as in the reduction data case.</p>
<p >Once the observers are registered, data is contributed to the <code><a class="el" href="structobservers_1_1Observer.html" title="The group parallel component that is responsible for reducing data to be observed.">observers::Observer</a></code> component using the <code><a class="el" href="structobservers_1_1Actions_1_1ContributeVolumeData.html" title="Send volume tensor data to the observer.">observers::Actions::ContributeVolumeData</a></code> action. The data is packed into an <code><a class="el" href="structElementVolumeData.html" title="Holds tensor components on a grid, to be written into an H5 file.">ElementVolumeData</a></code> object that carries <code><a class="el" href="structTensorComponent.html" title="An untyped tensor component with a name for observation.">TensorComponent</a></code>s on a grid. Information on the grid, such as its extents, basis and quadrature, are stored alongside the <code><a class="el" href="structTensorComponent.html" title="An untyped tensor component with a name for observation.">TensorComponent</a></code>s. Once all the elements on a single core have contributed their volume data to the <code><a class="el" href="structobservers_1_1Observer.html" title="The group parallel component that is responsible for reducing data to be observed.">observers::Observer</a></code> group, the <code><a class="el" href="structobservers_1_1Observer.html" title="The group parallel component that is responsible for reducing data to be observed.">observers::Observer</a></code> group moves its data to the <code><a class="el" href="structobservers_1_1ObserverWriter.html" title="The nodegroup parallel component that is responsible for writing data to disk.">observers::ObserverWriter</a></code> component to be written. We write one file per node, appending the node ID to the HDF5 file name to distinguish between files written by different nodes. The HDF5 file name is specified in the input file using the <code><a class="el" href="structobservers_1_1Tags_1_1VolumeFileName.html" title="The name of the HDF5 file on disk into which volume data is written.">observers::Tags::VolumeFileName</a></code> option. The data is written into a subfile of the HDF5 file using the <code>h5::VolumeFile</code> class.</p>
<p >If a singleton parallel component or a specific chare needs to write volume data directly to disk, such as surface data from an apparent horizon, it should use the <code><a class="el" href="structobservers_1_1ThreadedActions_1_1WriteVolumeData.html" title="Write volume data (such as surface data) at a given time (specified by an ObservationId) without the ...">observers::ThreadedActions::WriteVolumeData</a></code> action called on the zeroth element of the <code><a class="el" href="structobservers_1_1ObserverWriter.html" title="The nodegroup parallel component that is responsible for writing data to disk.">observers::ObserverWriter</a></code> component. For surface data (such as output from horizon finds), this data should be written to a file specified by the <code><a class="el" href="structobservers_1_1Tags_1_1SurfaceFileName.html" title="The name of the HDF5 file on disk into which surface data is written.">observers::Tags::SurfaceFileName</a></code> option.</p>
<h2><a class="anchor" id="autotoc_md118"></a>
Threading and NodeLocks</h2>
<p >Since the <code><a class="el" href="structobservers_1_1ObserverWriter.html" title="The nodegroup parallel component that is responsible for writing data to disk.">observers::ObserverWriter</a></code> class is a nodegroup, its entry methods can be invoked simultaneously on different cores of the node. However, this can lead to race conditions if care isn't taken. The biggest caution is that the <code>DataBox</code> cannot be mutated on one core and simultaneously accessed on another. This is because in order to guarantee a reasonable state for data in the <code>DataBox</code>, it must be impossible to perform a <code><a class="el" href="group__DataBoxGroup.html#gaa36fa9cf94ab1cb05c5a6e23d56f79ae" title="Retrieve the item with tag Tag from the DataBox.">db::get</a></code> on a <code>DataBox</code> from inside or while a <code><a class="el" href="group__DataBoxGroup.html#ga3c45b057d676d9f2cd90cf07185e653e" title="Allows changing the state of one or more non-computed elements in the DataBox.">db::mutate</a></code> is being done. What this means in practice is that all entry methods on a nodegroup must put their <code>DataBox</code> accesses inside of a <code>node_lock.lock()</code> and <code>node_lock.unlock()</code> block. To achieve better parallel performance and threading, the amount of work done while the entire node is locked should be minimized. To this end, we have additional locks. One for the HDF5 files because we do not require a threadsafe HDF5 (<code><a class="el" href="structobservers_1_1Tags_1_1H5FileLock.html" title="Node lock used when needing to read/write to H5 files on disk.">observers::Tags::H5FileLock</a></code>). We also have locks for the objects mutated when contributing reduction data (<code><a class="el" href="structobservers_1_1Tags_1_1ReductionDataLock.html" title="Lock used when contributing reduction data.">observers::Tags::ReductionDataLock</a></code>) and the objects mutated when contributing volume data (<code><a class="el" href="structobservers_1_1Tags_1_1VolumeDataLock.html" title="Lock used when contributing volume data.">observers::Tags::VolumeDataLock</a></code>).</p>
<h2><a class="anchor" id="autotoc_md119"></a>
Future changes</h2>
<ul>
<li>It would be preferable to make the <code>Observer</code> and <code>ObserverWriter</code> parallel components more general and have them act as the core (node)group. Since any simple actions can be run on them, it should be possible to use them for most, if not all cases where we need a (node)group. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dev_guide.html">Developer Guides</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
