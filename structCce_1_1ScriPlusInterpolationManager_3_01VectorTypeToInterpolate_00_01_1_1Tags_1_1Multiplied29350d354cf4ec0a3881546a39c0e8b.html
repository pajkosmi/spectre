<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: Cce::ScriPlusInterpolationManager&lt; VectorTypeToInterpolate, ::Tags::Multiplies&lt; MultipliesLhs, MultipliesRhs &gt; &gt; Struct Template Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structCce_1_1ScriPlusInterpolationManager_3_01VectorTypeToInterpolate_00_01_1_1Tags_1_1Multiplied29350d354cf4ec0a3881546a39c0e8b.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structCce_1_1ScriPlusInterpolationManager_3_01VectorTypeToInterpolate_00_01_1_1Tags_1_1Multiplieb2bfcc2f944056a9ffe1480405a4f186.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Cce::ScriPlusInterpolationManager&lt; VectorTypeToInterpolate, ::Tags::Multiplies&lt; MultipliesLhs, MultipliesRhs &gt; &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Stores necessary data and interpolates on to new time points at scri+, multiplying two results together before supplying the result.  
 <a href="structCce_1_1ScriPlusInterpolationManager_3_01VectorTypeToInterpolate_00_01_1_1Tags_1_1Multiplied29350d354cf4ec0a3881546a39c0e8b.html#details">More...</a></p>

<p><code>#include &lt;ScriPlusInterpolationManager.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a662362ebe972e84326987117195ed168"><td class="memItemLeft" align="right" valign="top"><a id="a662362ebe972e84326987117195ed168" name="a662362ebe972e84326987117195ed168"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ScriPlusInterpolationManager</b> (const size_t target_number_of_points, const size_t vector_size, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classintrp_1_1SpanInterpolator.html">intrp::SpanInterpolator</a> &gt; interpolator)</td></tr>
<tr class="separator:a662362ebe972e84326987117195ed168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742dd290394ed948d6c290067ba536ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ScriPlusInterpolationManager_3_01VectorTypeToInterpolate_00_01_1_1Tags_1_1Multiplied29350d354cf4ec0a3881546a39c0e8b.html#a742dd290394ed948d6c290067ba536ed">insert_data</a> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;u_bondi, const VectorTypeToInterpolate &amp;to_interpolate_lhs, const VectorTypeToInterpolate &amp;to_interpolate_rhs)</td></tr>
<tr class="memdesc:a742dd290394ed948d6c290067ba536ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">provide data to the interpolation manager.  <a href="structCce_1_1ScriPlusInterpolationManager_3_01VectorTypeToInterpolate_00_01_1_1Tags_1_1Multiplied29350d354cf4ec0a3881546a39c0e8b.html#a742dd290394ed948d6c290067ba536ed">More...</a><br /></td></tr>
<tr class="separator:a742dd290394ed948d6c290067ba536ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1b6a2a7e605a970a2ffd102d7e23a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ScriPlusInterpolationManager_3_01VectorTypeToInterpolate_00_01_1_1Tags_1_1Multiplied29350d354cf4ec0a3881546a39c0e8b.html#a7e1b6a2a7e605a970a2ffd102d7e23a8">insert_target_time</a> (const double time)</td></tr>
<tr class="memdesc:a7e1b6a2a7e605a970a2ffd102d7e23a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a target time to be interpolated to when enough data has been accumulated.  <a href="structCce_1_1ScriPlusInterpolationManager_3_01VectorTypeToInterpolate_00_01_1_1Tags_1_1Multiplied29350d354cf4ec0a3881546a39c0e8b.html#a7e1b6a2a7e605a970a2ffd102d7e23a8">More...</a><br /></td></tr>
<tr class="separator:a7e1b6a2a7e605a970a2ffd102d7e23a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7caf1e72f4d740c6eebce13670d3b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ScriPlusInterpolationManager_3_01VectorTypeToInterpolate_00_01_1_1Tags_1_1Multiplied29350d354cf4ec0a3881546a39c0e8b.html#aec7caf1e72f4d740c6eebce13670d3b8">first_time_is_ready_to_interpolate</a> () const</td></tr>
<tr class="memdesc:aec7caf1e72f4d740c6eebce13670d3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether enough data before and after the first time in the target time queue has been provided to interpolate.  <a href="structCce_1_1ScriPlusInterpolationManager_3_01VectorTypeToInterpolate_00_01_1_1Tags_1_1Multiplied29350d354cf4ec0a3881546a39c0e8b.html#aec7caf1e72f4d740c6eebce13670d3b8">More...</a><br /></td></tr>
<tr class="separator:aec7caf1e72f4d740c6eebce13670d3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0927166f9ba221fb08f9aaf8f7d3f0"><td class="memItemLeft" align="right" valign="top"><a id="abd0927166f9ba221fb08f9aaf8f7d3f0" name="abd0927166f9ba221fb08f9aaf8f7d3f0"></a>
const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; double, double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_u_bondi_ranges</b> () const</td></tr>
<tr class="separator:abd0927166f9ba221fb08f9aaf8f7d3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78772e26106f4e807e70e2719cd2ae17"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; double, VectorTypeToInterpolate &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ScriPlusInterpolationManager_3_01VectorTypeToInterpolate_00_01_1_1Tags_1_1Multiplied29350d354cf4ec0a3881546a39c0e8b.html#a78772e26106f4e807e70e2719cd2ae17">interpolate_first_time</a> ()</td></tr>
<tr class="memdesc:a78772e26106f4e807e70e2719cd2ae17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate to the first target time in the queue, returning both the time and the interpolated-and-multiplied data at that time.  <a href="structCce_1_1ScriPlusInterpolationManager_3_01VectorTypeToInterpolate_00_01_1_1Tags_1_1Multiplied29350d354cf4ec0a3881546a39c0e8b.html#a78772e26106f4e807e70e2719cd2ae17">More...</a><br /></td></tr>
<tr class="separator:a78772e26106f4e807e70e2719cd2ae17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e004d2bcef71f324a519fc416126ac"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; double, VectorTypeToInterpolate &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ScriPlusInterpolationManager_3_01VectorTypeToInterpolate_00_01_1_1Tags_1_1Multiplied29350d354cf4ec0a3881546a39c0e8b.html#ae1e004d2bcef71f324a519fc416126ac">interpolate_and_pop_first_time</a> ()</td></tr>
<tr class="memdesc:ae1e004d2bcef71f324a519fc416126ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate to the first target time in the queue, returning both the time and the interpolated-and-multiplied data at that time, and remove the first time from the queue.  <a href="structCce_1_1ScriPlusInterpolationManager_3_01VectorTypeToInterpolate_00_01_1_1Tags_1_1Multiplied29350d354cf4ec0a3881546a39c0e8b.html#ae1e004d2bcef71f324a519fc416126ac">More...</a><br /></td></tr>
<tr class="separator:ae1e004d2bcef71f324a519fc416126ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f8e0623d1ffc6eee93ab6522e85d87"><td class="memItemLeft" align="right" valign="top"><a id="a25f8e0623d1ffc6eee93ab6522e85d87" name="a25f8e0623d1ffc6eee93ab6522e85d87"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>number_of_target_times</b> () const</td></tr>
<tr class="memdesc:a25f8e0623d1ffc6eee93ab6522e85d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of times in the target times queue <br /></td></tr>
<tr class="separator:a25f8e0623d1ffc6eee93ab6522e85d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba5fb1df17a4c1d14677d1e63b94bc9"><td class="memItemLeft" align="right" valign="top"><a id="afba5fb1df17a4c1d14677d1e63b94bc9" name="afba5fb1df17a4c1d14677d1e63b94bc9"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>number_of_data_points</b> () const</td></tr>
<tr class="memdesc:afba5fb1df17a4c1d14677d1e63b94bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of data points that have been provided to the interpolation manager <br /></td></tr>
<tr class="separator:afba5fb1df17a4c1d14677d1e63b94bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9073e6a4513983be755b2a6fee684e47"><td class="memItemLeft" align="right" valign="top"><a id="a9073e6a4513983be755b2a6fee684e47" name="a9073e6a4513983be755b2a6fee684e47"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pup</b> (PUP::er &amp;p)</td></tr>
<tr class="separator:a9073e6a4513983be755b2a6fee684e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename VectorTypeToInterpolate, typename MultipliesLhs, typename MultipliesRhs&gt;<br />
struct Cce::ScriPlusInterpolationManager&lt; VectorTypeToInterpolate, ::Tags::Multiplies&lt; MultipliesLhs, MultipliesRhs &gt; &gt;</div><p >Stores necessary data and interpolates on to new time points at scri+, multiplying two results together before supplying the result. </p>
<h3>Details</h3>
<p >The coordinate time used for the CCE evolution is not the same as the asymptotic inertial retarded time, which is determined through a separate evolution equation. This class manages the two sets of scri+ data passed in (via <code><a class="el" href="structCce_1_1ScriPlusInterpolationManager_3_01VectorTypeToInterpolate_00_01_1_1Tags_1_1Multiplied29350d354cf4ec0a3881546a39c0e8b.html#a742dd290394ed948d6c290067ba536ed" title="provide data to the interpolation manager.">insert_data()</a></code>) along with the set of inertial retarded times associated with that data, and interpolates to a set of inertial requested times (supplied via <code><a class="el" href="structCce_1_1ScriPlusInterpolationManager_3_01VectorTypeToInterpolate_00_01_1_1Tags_1_1Multiplied29350d354cf4ec0a3881546a39c0e8b.html#a7e1b6a2a7e605a970a2ffd102d7e23a8" title="Request a target time to be interpolated to when enough data has been accumulated.">insert_target_time()</a></code>), multiplying the two interpolation results together before returning.</p>
<p >Template parameters:</p><ul>
<li><code>VectorTypeToInterpolate</code>: the vector type associated with the values to interpolate.</li>
<li><code><a class="el" href="structTags_1_1Multiplies.html" title="A prefix tag representing the product of two other tags. Note that if non-spin-weighted types are nee...">Tags::Multiplies</a>&lt;MultipliesLhs, MultipliesRhs&gt;</code>: The tag associated with the interpolation procedure. This determines the behavior of the interpolation return value. The default is just interpolation, if <code>Tag</code> has prefix <code><a class="el" href="structTags_1_1Multiplies.html" title="A prefix tag representing the product of two other tags. Note that if non-spin-weighted types are nee...">Tags::Multiplies</a></code> (this case) or <code><a class="el" href="structCce_1_1Tags_1_1Du.html" title="The derivative with respect to Bondi retarded time .">Tags::Du</a></code>, the interpolator performs the additional multiplication or time derivative as a step in the interpolation procedure. </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aec7caf1e72f4d740c6eebce13670d3b8" name="aec7caf1e72f4d740c6eebce13670d3b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7caf1e72f4d740c6eebce13670d3b8">&#9670;&nbsp;</a></span>first_time_is_ready_to_interpolate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorTypeToInterpolate , typename MultipliesLhs , typename MultipliesRhs &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structCce_1_1ScriPlusInterpolationManager.html">Cce::ScriPlusInterpolationManager</a>&lt; VectorTypeToInterpolate, <a class="el" href="structTags_1_1Multiplies.html">::Tags::Multiplies</a>&lt; MultipliesLhs, MultipliesRhs &gt; &gt;::first_time_is_ready_to_interpolate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether enough data before and after the first time in the target time queue has been provided to interpolate. </p>
<h3>Details</h3>
<p >If possible, this function will require that the target time to be interpolated is reasonably centered on the range, but will settle for non-centered data if the time is too early for the given data, which is necessary to get the first couple of times out of the simulation. This function always returns false if all of the provided data is earlier than the next target time, indicating that the caller should wait until more data has been provided before interpolating. </p>

</div>
</div>
<a id="a742dd290394ed948d6c290067ba536ed" name="a742dd290394ed948d6c290067ba536ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742dd290394ed948d6c290067ba536ed">&#9670;&nbsp;</a></span>insert_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorTypeToInterpolate , typename MultipliesLhs , typename MultipliesRhs &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structCce_1_1ScriPlusInterpolationManager.html">Cce::ScriPlusInterpolationManager</a>&lt; VectorTypeToInterpolate, <a class="el" href="structTags_1_1Multiplies.html">::Tags::Multiplies</a>&lt; MultipliesLhs, MultipliesRhs &gt; &gt;::insert_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>u_bondi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorTypeToInterpolate &amp;&#160;</td>
          <td class="paramname"><em>to_interpolate_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorTypeToInterpolate &amp;&#160;</td>
          <td class="paramname"><em>to_interpolate_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>provide data to the interpolation manager. </p>
<h3>Details</h3>
<p ><code>u_bondi</code> is a vector of inertial times, and <code>to_interpolate_lhs</code> and <code>to_interpolate_rhs</code> are the vector of values that will be interpolated to target times. The interpolation result will be the product of the interpolated lhs and rhs vectors. </p>

</div>
</div>
<a id="a7e1b6a2a7e605a970a2ffd102d7e23a8" name="a7e1b6a2a7e605a970a2ffd102d7e23a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e1b6a2a7e605a970a2ffd102d7e23a8">&#9670;&nbsp;</a></span>insert_target_time()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorTypeToInterpolate , typename MultipliesLhs , typename MultipliesRhs &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structCce_1_1ScriPlusInterpolationManager.html">Cce::ScriPlusInterpolationManager</a>&lt; VectorTypeToInterpolate, <a class="el" href="structTags_1_1Multiplies.html">::Tags::Multiplies</a>&lt; MultipliesLhs, MultipliesRhs &gt; &gt;::insert_target_time </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request a target time to be interpolated to when enough data has been accumulated. </p>
<p >For optimization, we assume that these are inserted in ascending order. </p>

</div>
</div>
<a id="ae1e004d2bcef71f324a519fc416126ac" name="ae1e004d2bcef71f324a519fc416126ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e004d2bcef71f324a519fc416126ac">&#9670;&nbsp;</a></span>interpolate_and_pop_first_time()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorTypeToInterpolate , typename MultipliesLhs , typename MultipliesRhs &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; double, VectorTypeToInterpolate &gt; <a class="el" href="structCce_1_1ScriPlusInterpolationManager.html">Cce::ScriPlusInterpolationManager</a>&lt; VectorTypeToInterpolate, <a class="el" href="structTags_1_1Multiplies.html">::Tags::Multiplies</a>&lt; MultipliesLhs, MultipliesRhs &gt; &gt;::interpolate_and_pop_first_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate to the first target time in the queue, returning both the time and the interpolated-and-multiplied data at that time, and remove the first time from the queue. </p>
<dl class="section note"><dt>Note</dt><dd>If this function is not able to interpolate to the full accuracy using a centered stencil, it will perform the best interpolation available.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function will extrapolate if the target times are outside the range of data the class has been provided. This is intentional to support small extrapolation at the end of a simulation when no further data is available, but for full accuracy, check <code>first_time_is_ready_to_interpolate</code> before calling the interpolation functions </dd></dl>

</div>
</div>
<a id="a78772e26106f4e807e70e2719cd2ae17" name="a78772e26106f4e807e70e2719cd2ae17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78772e26106f4e807e70e2719cd2ae17">&#9670;&nbsp;</a></span>interpolate_first_time()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorTypeToInterpolate , typename MultipliesLhs , typename MultipliesRhs &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; double, VectorTypeToInterpolate &gt; <a class="el" href="structCce_1_1ScriPlusInterpolationManager.html">Cce::ScriPlusInterpolationManager</a>&lt; VectorTypeToInterpolate, <a class="el" href="structTags_1_1Multiplies.html">::Tags::Multiplies</a>&lt; MultipliesLhs, MultipliesRhs &gt; &gt;::interpolate_first_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate to the first target time in the queue, returning both the time and the interpolated-and-multiplied data at that time. </p>
<dl class="section note"><dt>Note</dt><dd>If this function is not able to interpolate to the full accuracy using a centered stencil, it will perform the best interpolation available.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function will extrapolate if the target times are outside the range of data the class has been provided. This is intentional to support small extrapolation at the end of a simulation when no further data is available, but for full accuracy, check <code>first_time_is_ready_to_interpolate</code> before calling the interpolation functions </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>src/Evolution/Systems/Cce/ScriPlusInterpolationManager.hpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceCce.html">Cce</a></li><li class="navelem"><a class="el" href="structCce_1_1ScriPlusInterpolationManager_3_01VectorTypeToInterpolate_00_01_1_1Tags_1_1Multiplied29350d354cf4ec0a3881546a39c0e8b.html">ScriPlusInterpolationManager&lt; VectorTypeToInterpolate, ::Tags::Multiplies&lt; MultipliesLhs, MultipliesRhs &gt; &gt;</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
