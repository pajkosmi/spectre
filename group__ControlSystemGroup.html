<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: Control System</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__ControlSystemGroup.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Control System</div></div>
</div><!--header-->
<div class="contents">

<p>Contains control system elements.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecontrol__system"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecontrol__system.html">control_system</a></td></tr>
<tr class="memdesc:namespacecontrol__system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control systems and related functionality. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecontrol__system_1_1Actions"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecontrol__system_1_1Actions.html">control_system::Actions</a></td></tr>
<tr class="memdesc:namespacecontrol__system_1_1Actions"><td class="mdescLeft">&#160;</td><td class="mdescRight">All <a class="el" href="namespacecontrol__system_1_1Actions.html" title="All Actions related to the control system.">Actions</a> related to the control system. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecontrol__system_1_1ControlErrors"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecontrol__system_1_1ControlErrors.html">control_system::ControlErrors</a></td></tr>
<tr class="memdesc:namespacecontrol__system_1_1ControlErrors"><td class="mdescLeft">&#160;</td><td class="mdescRight">All control errors that will be used in control systems. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecontrol__system_1_1Systems"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecontrol__system_1_1Systems.html">control_system::Systems</a></td></tr>
<tr class="memdesc:namespacecontrol__system_1_1Systems"><td class="mdescLeft">&#160;</td><td class="mdescRight">All control systems. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecontrol__system_1_1size"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecontrol__system_1_1size.html">control_system::size</a></td></tr>
<tr class="memdesc:namespacecontrol__system_1_1size"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classes and functions used in implementation of size control. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecontrol__system_1_1protocols"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecontrol__system_1_1protocols.html">control_system::protocols</a></td></tr>
<tr class="memdesc:namespacecontrol__system_1_1protocols"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protocols for control systems. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecontrol__system_1_1OptionTags"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecontrol__system_1_1OptionTags.html">control_system::OptionTags</a></td></tr>
<tr class="memdesc:namespacecontrol__system_1_1OptionTags"><td class="mdescLeft">&#160;</td><td class="mdescRight">All option tags related to the control system. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecontrol__system_1_1QueueTags"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecontrol__system_1_1QueueTags.html">control_system::QueueTags</a></td></tr>
<tr class="memdesc:namespacecontrol__system_1_1QueueTags"><td class="mdescLeft">&#160;</td><td class="mdescRight">All tags that will be used in the LinkedMessageQueue's within control systems. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecontrol__system_1_1Tags"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecontrol__system_1_1Tags.html">control_system::Tags</a></td></tr>
<tr class="memdesc:namespacecontrol__system_1_1Tags"><td class="mdescLeft">&#160;</td><td class="mdescRight">All DataBox tags related to the control system. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecontrol__system_1_1metafunctions"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecontrol__system_1_1metafunctions.html">control_system::metafunctions</a></td></tr>
<tr class="memdesc:namespacecontrol__system_1_1metafunctions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunctions associated with the control systems. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1Actions_1_1Initialize.html">control_system::Actions::Initialize&lt; Metavariables, ControlSystem &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structcontrol__system_1_1Actions_1_1Initialize.html" title="Initialize items related to the control system.">Initialize</a> items related to the control system.  <a href="structcontrol__system_1_1Actions_1_1Initialize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAverager.html">Averager&lt; DerivOrder &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A weighted exponential averager of \(Q\) and its derivatives implementing Appendix A in <a class="el" href="citelist.html#CITEREF_Hemberger2012jz">[79]</a>.  <a href="classAverager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structControlComponent.html">ControlComponent&lt; Metavariables, ControlSystem &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The singleton parallel component responsible for managing a single control system.  <a href="structControlComponent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classController.html">Controller&lt; DerivOrder &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A PND (proportional to Q and N derivatives of Q) controller that computes the control signal:  <a href="classController.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontrol__system_1_1Event.html">control_system::Event&lt; ControlSystems &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcontrol__system_1_1Event.html" title="Event for running control system measurements.">Event</a> for running control system measurements.  <a href="classcontrol__system_1_1Event.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1measurements_1_1Tags_1_1NeutronStarCenter.html">control_system::measurements::Tags::NeutronStarCenter&lt; Center &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataBox tag for location of neutron star center (or more accurately, center of mass of the matter in the x&gt;0 (label A) or x&lt;0 (label B) region, in grid (distorted) coordinates.  <a href="structcontrol__system_1_1measurements_1_1Tags_1_1NeutronStarCenter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1RunCallbacks.html">control_system::RunCallbacks&lt; Submeasurement, ControlSystems &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the <code>process_measurement</code> struct of each of the <code>ControlSystems</code> to the result of the <code>Submeasurement</code>.  <a href="structcontrol__system_1_1RunCallbacks.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1Tags_1_1FunctionsOfTimeInitialize.html">control_system::Tags::FunctionsOfTimeInitialize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The FunctionsOfTime initialized from a <a class="el" href="classDomainCreator.html" title="Base class for creating Domains from an option string.">DomainCreator</a>, initial time, and control system OptionHolders.  <a href="structcontrol__system_1_1Tags_1_1FunctionsOfTimeInitialize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1Tags_1_1IsActive.html">control_system::Tags::IsActive&lt; ControlSystem &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataBox tag to determine if this control system is active.  <a href="structcontrol__system_1_1Tags_1_1IsActive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1Tags_1_1MeasurementTimescales.html">control_system::Tags::MeasurementTimescales</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The measurement timescales associated with <a class="el" href="structdomain_1_1Tags_1_1FunctionsOfTime.html" title="Tag to retrieve the FunctionsOfTime from the GlobalCache.">domain::Tags::FunctionsOfTime</a>.  <a href="structcontrol__system_1_1Tags_1_1MeasurementTimescales.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1OptionHolder.html">control_system::OptionHolder&lt; ControlSystem &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds all options for a single control system.  <a href="structcontrol__system_1_1OptionHolder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1OptionTags_1_1ControlSystemGroup.html">control_system::OptionTags::ControlSystemGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceOptions.html" title="Utilities for parsing input files.">Options</a> group for all control system options.  <a href="structcontrol__system_1_1OptionTags_1_1ControlSystemGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1OptionTags_1_1ControlSystemInputs.html">control_system::OptionTags::ControlSystemInputs&lt; ControlSystem &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option tag for each individual control system. The name of this option is the name of the <code>ControlSystem</code> struct it is templated on. This way all control systems will have a unique name.  <a href="structcontrol__system_1_1OptionTags_1_1ControlSystemInputs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1OptionTags_1_1WriteDataToDisk.html">control_system::OptionTags::WriteDataToDisk</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option tag on whether to write data to disk.  <a href="structcontrol__system_1_1OptionTags_1_1WriteDataToDisk.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1OptionTags_1_1MeasurementsPerUpdate.html">control_system::OptionTags::MeasurementsPerUpdate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option tag that determines how many measurements will occur per control system update.  <a href="structcontrol__system_1_1OptionTags_1_1MeasurementsPerUpdate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1OptionTags_1_1Verbosity.html">control_system::OptionTags::Verbosity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structcontrol__system_1_1OptionTags_1_1Verbosity.html" title="Verbosity tag for printing diagnostics about the control system algorithm. This does not control when...">Verbosity</a> tag for printing diagnostics about the control system algorithm. This does not control when data is written to disk.  <a href="structcontrol__system_1_1OptionTags_1_1Verbosity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1QueueTags_1_1Center.html">control_system::QueueTags::Center&lt; Horizon &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the centers of each horizon from measurements as DataVectors.  <a href="structcontrol__system_1_1QueueTags_1_1Center.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1QueueTags_1_1Horizon.html">control_system::QueueTags::Horizon&lt; Frame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a full strahlkorper from measurements that represents a horizon.  <a href="structcontrol__system_1_1QueueTags_1_1Horizon.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1QueueTags_1_1ExcisionSurface.html">control_system::QueueTags::ExcisionSurface&lt; Frame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a full strahlkorper from measurements for the excision surface.  <a href="structcontrol__system_1_1QueueTags_1_1ExcisionSurface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1QueueTags_1_1LapseOnExcisionSurface.html">control_system::QueueTags::LapseOnExcisionSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the lapse on the <code><a class="el" href="structcontrol__system_1_1QueueTags_1_1ExcisionSurface.html" title="Holds a full strahlkorper from measurements for the excision surface.">ExcisionSurface</a></code>  <a href="structcontrol__system_1_1QueueTags_1_1LapseOnExcisionSurface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1QueueTags_1_1ShiftyQuantity.html">control_system::QueueTags::ShiftyQuantity&lt; Frame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a quantity that's similar to the shift, but isn't the shift, on the <code><a class="el" href="structcontrol__system_1_1QueueTags_1_1ExcisionSurface.html" title="Holds a full strahlkorper from measurements for the excision surface.">ExcisionSurface</a></code>.  <a href="structcontrol__system_1_1QueueTags_1_1ShiftyQuantity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1QueueTags_1_1SpatialMetricOnExcisionSurface.html">control_system::QueueTags::SpatialMetricOnExcisionSurface&lt; Frame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the spatial metric on the <code><a class="el" href="structcontrol__system_1_1QueueTags_1_1ExcisionSurface.html" title="Holds a full strahlkorper from measurements for the excision surface.">ExcisionSurface</a></code>  <a href="structcontrol__system_1_1QueueTags_1_1SpatialMetricOnExcisionSurface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1QueueTags_1_1InverseSpatialMetricOnExcisionSurface.html">control_system::QueueTags::InverseSpatialMetricOnExcisionSurface&lt; Frame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the inverse spatial metric on the <code><a class="el" href="structcontrol__system_1_1QueueTags_1_1ExcisionSurface.html" title="Holds a full strahlkorper from measurements for the excision surface.">ExcisionSurface</a></code>  <a href="structcontrol__system_1_1QueueTags_1_1InverseSpatialMetricOnExcisionSurface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1Tags_1_1WriteDataToDisk.html">control_system::Tags::WriteDataToDisk</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataBox tag for writing control system data to disk.  <a href="structcontrol__system_1_1Tags_1_1WriteDataToDisk.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1Tags_1_1ObserveCenters.html">control_system::Tags::ObserveCenters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataBox tag for writing the centers of the horizons to disk.  <a href="structcontrol__system_1_1Tags_1_1ObserveCenters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1Tags_1_1Averager.html">control_system::Tags::Averager&lt; ControlSystem &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataBox tag for the averager.  <a href="structcontrol__system_1_1Tags_1_1Averager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1Tags_1_1TimescaleTuner.html">control_system::Tags::TimescaleTuner&lt; ControlSystem &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataBox tag for the timescale tuner.  <a href="structcontrol__system_1_1Tags_1_1TimescaleTuner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1Tags_1_1Controller.html">control_system::Tags::Controller&lt; ControlSystem &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataBox tag for the controller.  <a href="structcontrol__system_1_1Tags_1_1Controller.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1Tags_1_1ControlError.html">control_system::Tags::ControlError&lt; ControlSystem &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataBox tag for the control error.  <a href="structcontrol__system_1_1Tags_1_1ControlError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1Tags_1_1MeasurementsPerUpdate.html">control_system::Tags::MeasurementsPerUpdate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag that determines how many measurements will occur per control system update. This will usually be stored in the global cache.  <a href="structcontrol__system_1_1Tags_1_1MeasurementsPerUpdate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1Tags_1_1CurrentNumberOfMeasurements.html">control_system::Tags::CurrentNumberOfMeasurements</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataBox tag that keeps track of which measurement we are on.  <a href="structcontrol__system_1_1Tags_1_1CurrentNumberOfMeasurements.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1Tags_1_1Verbosity.html">control_system::Tags::Verbosity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataBox tag that holds the verbosity used to print info about the control system algorithm.  <a href="structcontrol__system_1_1Tags_1_1Verbosity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimescaleTuner.html">TimescaleTuner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages control system timescales.  <a href="classTimescaleTuner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1UpdateFunctionOfTime.html">control_system::UpdateFunctionOfTime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a FunctionOfTime in the global cache. Intended to be used in <a class="el" href="group__ParallelGroup.html#ga8fb8fc6f30581c450abecc8258dead3c" title="Mutates non-const data in the cache, by calling Function::apply()">Parallel::mutate</a>.  <a href="structcontrol__system_1_1UpdateFunctionOfTime.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontrol__system_1_1ResetFunctionOfTimeExpirationTime.html">control_system::ResetFunctionOfTimeExpirationTime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the expiration time of a FunctionOfTime in the global cache. Intended to be used in <a class="el" href="group__ParallelGroup.html#ga8fb8fc6f30581c450abecc8258dead3c" title="Mutates non-const data in the cache, by calling Function::apply()">Parallel::mutate</a>.  <a href="structcontrol__system_1_1ResetFunctionOfTimeExpirationTime.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdomain_1_1FunctionsOfTime_1_1FixedSpeedCubic.html">domain::FunctionsOfTime::FixedSpeedCubic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets \(f(t)\) and derivatives using cubic rational functions, such that the first derivative approaches a constant and the second derivative approaches zero.  <a href="classdomain_1_1FunctionsOfTime_1_1FixedSpeedCubic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdomain_1_1FunctionsOfTime_1_1SettleToConstant.html">domain::FunctionsOfTime::SettleToConstant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an initial function of time, transitions the map to a constant-in-time value.  <a href="classdomain_1_1FunctionsOfTime_1_1SettleToConstant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga6ed69fbc3234081d4a0bb84ef176fc62"><td class="memTemplParams" colspan="2"><a id="ga6ed69fbc3234081d4a0bb84ef176fc62" name="ga6ed69fbc3234081d4a0bb84ef176fc62"></a>
template&lt;typename Metavariables , typename ControlSystems &gt; </td></tr>
<tr class="memitem:ga6ed69fbc3234081d4a0bb84ef176fc62"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>control_system::control_components</b> = tmpl::transform&lt; ControlSystems, tmpl::bind&lt; <a class="el" href="structControlComponent.html">ControlComponent</a>, tmpl::pin&lt; Metavariables &gt;, tmpl::_1 &gt; &gt;</td></tr>
<tr class="memdesc:ga6ed69fbc3234081d4a0bb84ef176fc62"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of control componenets to be added to the component list of the metavars. <br /></td></tr>
<tr class="separator:ga6ed69fbc3234081d4a0bb84ef176fc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bbce24937d1c40fb0b87880e9c5d219"><td class="memTemplParams" colspan="2"><a id="ga7bbce24937d1c40fb0b87880e9c5d219" name="ga7bbce24937d1c40fb0b87880e9c5d219"></a>
template&lt;typename ControlSystems &gt; </td></tr>
<tr class="memitem:ga7bbce24937d1c40fb0b87880e9c5d219"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>control_system::control_system_events</b> = tmpl::transform&lt; metafunctions::measurements_t&lt; ControlSystems &gt;, tmpl::bind&lt; <a class="el" href="classcontrol__system_1_1Event.html">Event</a>, <a class="el" href="structcontrol__system_1_1metafunctions_1_1control__systems__with__measurement.html">metafunctions::control_systems_with_measurement</a>&lt; tmpl::pin&lt; ControlSystems &gt;, tmpl::_1 &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga7bbce24937d1c40fb0b87880e9c5d219"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of events needed for measurements for a list of control systems. <br /></td></tr>
<tr class="separator:ga7bbce24937d1c40fb0b87880e9c5d219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b24e33b5fa5b0c5c7e9a05756243d48"><td class="memTemplParams" colspan="2"><a id="ga7b24e33b5fa5b0c5c7e9a05756243d48" name="ga7b24e33b5fa5b0c5c7e9a05756243d48"></a>
template&lt;typename ControlSystems &gt; </td></tr>
<tr class="memitem:ga7b24e33b5fa5b0c5c7e9a05756243d48"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>control_system::inputs</b> = tmpl::transform&lt; ControlSystems, tmpl::bind&lt; <a class="el" href="structcontrol__system_1_1OptionTags_1_1ControlSystemInputs.html">OptionTags::ControlSystemInputs</a>, tmpl::_1 &gt; &gt;</td></tr>
<tr class="memdesc:ga7b24e33b5fa5b0c5c7e9a05756243d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to get all the option holders from a list of control systems. This is useful in the <code>option_tags</code> alias of simple tags for getting all the options from control systems. <br /></td></tr>
<tr class="separator:ga7b24e33b5fa5b0c5c7e9a05756243d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeb170256e21b2454050158aaf51937c"><td class="memTemplParams" colspan="2"><a id="gaaeb170256e21b2454050158aaf51937c" name="gaaeb170256e21b2454050158aaf51937c"></a>
template&lt;typename ControlSystems &gt; </td></tr>
<tr class="memitem:gaaeb170256e21b2454050158aaf51937c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>control_system::control_system_triggers</b> = tmpl::transform&lt; metafunctions::measurements_t&lt; ControlSystems &gt;, tmpl::bind&lt; <a class="el" href="classcontrol__system_1_1Trigger.html">Trigger</a>, <a class="el" href="structcontrol__system_1_1metafunctions_1_1control__systems__with__measurement.html">metafunctions::control_systems_with_measurement</a>&lt; tmpl::pin&lt; ControlSystems &gt;, tmpl::_1 &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gaaeb170256e21b2454050158aaf51937c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of triggers needed for measurements for a list of control systems. <br /></td></tr>
<tr class="separator:gaaeb170256e21b2454050158aaf51937c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga95a72f35fae0171be6fd523305a635d6"><td class="memTemplParams" colspan="2">template&lt;size_t DerivOrder&gt; </td></tr>
<tr class="memitem:ga95a72f35fae0171be6fd523305a635d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDataVector.html">DataVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ControlSystemGroup.html#ga95a72f35fae0171be6fd523305a635d6">control_system::calculate_measurement_timescales</a> (const <a class="el" href="classController.html">::Controller</a>&lt; DerivOrder &gt; &amp;controller, const <a class="el" href="classTimescaleTuner.html">::TimescaleTuner</a> &amp;tuner, const int measurements_per_update)</td></tr>
<tr class="memdesc:ga95a72f35fae0171be6fd523305a635d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the measurement timescale based on the damping timescale, update fraction, and DerivOrder of the control system.  <a href="group__ControlSystemGroup.html#ga95a72f35fae0171be6fd523305a635d6">More...</a><br /></td></tr>
<tr class="separator:ga95a72f35fae0171be6fd523305a635d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5098f75ed02c2d1f0ed6a56cd76e7d9f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ControlSystemGroup.html#ga5098f75ed02c2d1f0ed6a56cd76e7d9f">control_system::function_of_time_expiration_time</a> (const double time, const <a class="el" href="classDataVector.html">DataVector</a> &amp;old_measurement_timescales, const <a class="el" href="classDataVector.html">DataVector</a> &amp;new_measurement_timescales, const int measurements_per_update)</td></tr>
<tr class="memdesc:ga5098f75ed02c2d1f0ed6a56cd76e7d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the next expiration time for the FunctionsOfTime.  <a href="group__ControlSystemGroup.html#ga5098f75ed02c2d1f0ed6a56cd76e7d9f">More...</a><br /></td></tr>
<tr class="separator:ga5098f75ed02c2d1f0ed6a56cd76e7d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbc0f7b981fe84620ab1668ed6dfd907"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ControlSystemGroup.html#gadbc0f7b981fe84620ab1668ed6dfd907">control_system::measurement_expiration_time</a> (const double time, const <a class="el" href="classDataVector.html">DataVector</a> &amp;old_measurement_timescales, const <a class="el" href="classDataVector.html">DataVector</a> &amp;new_measurement_timescales, const int measurements_per_update)</td></tr>
<tr class="memdesc:gadbc0f7b981fe84620ab1668ed6dfd907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the next expiration time for the MeasurementTimescales.  <a href="group__ControlSystemGroup.html#gadbc0f7b981fe84620ab1668ed6dfd907">More...</a><br /></td></tr>
<tr class="separator:gadbc0f7b981fe84620ab1668ed6dfd907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cfe2c0a65ba1d01fb8ea46b70a17817"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename... OptionHolders&gt; </td></tr>
<tr class="memitem:ga1cfe2c0a65ba1d01fb8ea46b70a17817"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ControlSystemGroup.html#ga1cfe2c0a65ba1d01fb8ea46b70a17817">control_system::initial_expiration_times</a> (const double initial_time, const int measurements_per_update, const <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;<a class="el" href="classDomainCreator.html">::DomainCreator</a>&lt; Dim &gt; &gt; &amp;domain_creator, const OptionHolders &amp;... option_holders)</td></tr>
<tr class="memdesc:ga1cfe2c0a65ba1d01fb8ea46b70a17817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the initial expiration times for functions of time that are controlled by a control system.  <a href="group__ControlSystemGroup.html#ga1cfe2c0a65ba1d01fb8ea46b70a17817">More...</a><br /></td></tr>
<tr class="separator:ga1cfe2c0a65ba1d01fb8ea46b70a17817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d20d917bcfa5c782a87018dd0ee29b6"><td class="memTemplParams" colspan="2">template&lt;typename ControlSystem , typename Metavariables &gt; </td></tr>
<tr class="memitem:ga5d20d917bcfa5c782a87018dd0ee29b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ControlSystemGroup.html#ga5d20d917bcfa5c782a87018dd0ee29b6">control_system::write_components_to_disk</a> (const double time, <a class="el" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache</a>&lt; Metavariables &gt; &amp;cache, const <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt; &amp;function_of_time, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2 &gt; &amp;q_and_dtq, const <a class="el" href="classDataVector.html">DataVector</a> &amp;timescales)</td></tr>
<tr class="memdesc:ga5d20d917bcfa5c782a87018dd0ee29b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes all components of a function of time to disk at a specific time from a control system after it updates the functions of time.  <a href="group__ControlSystemGroup.html#ga5d20d917bcfa5c782a87018dd0ee29b6">More...</a><br /></td></tr>
<tr class="separator:ga5d20d917bcfa5c782a87018dd0ee29b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Contains control system elements. </p>
<p >The control system manages the time-dependent mapping between frames, such as the fixed computational frame (grid frame) and the inertial frame. The time-dependent parameters of the mapping are adjusted by a feedback control system in order to follow the dynamical evolution of objects such as horizons of black holes or surfaces of neutron stars. For example, in binary black hole simulations the map is typically a composition of maps that include translation, rotation, scaling, shape, etc. Each map under the governance of the control system has an associated time-dependent map parameter \(\lambda(t)\) that is a piecewise Nth order polynomial. At discrete times (called reset times), the control system resets the Nth time derivative of \(\lambda(t)\) to a new constant value, in order to minimize an error function \(Q(t)\) that is specific to each map. At each reset time, the Nth derivative of \(\lambda(t)\) is set to a function \(U(t)\), called the control signal, that is determined by \(Q(t)\) and its time derivatives and time integral. Note that \(\lambda(t)\), \(U(t)\), and \(Q(t)\) can be vectors.</p>
<p >The key components of the control system are:</p><ul>
<li>FunctionsOfTime: each map has an associated FunctionOfTime that represents the map parameter \(\lambda(t)\) and relevant time derivatives.</li>
<li>ControlError: each map has an associated ControlError that computes the error, \(Q(t)\). Note that for each map, \(Q(t)\) is defined to follow the convention that \(dQ = -d \lambda\) as \(Q \rightarrow 0\).</li>
<li><a class="el" href="classAverager.html" title="A weighted exponential averager of  and its derivatives implementing Appendix A in .">Averager</a>: an averager can be used to average out the noise in the 'raw' \(Q(t)\) returned by the ControlError.</li>
<li><a class="el" href="classController.html" title="A PND (proportional to Q and N derivatives of Q) controller that computes the control signal:">Controller</a>: the map controller computes the control signal \(U(t)\) from \(Q(t)\) and its time integral and time derivatives. The control is accomplished by setting the Nth derivative of \(\lambda(t)\) to \(U(t)\). Two common controllers are PID (proportional/integral/derivative) <p class="formulaDsp">
\[U(t) = a_{0}\int_{t_{0}}^{t} Q(t&#39;) dt&#39;+a_{1}Q(t)+a_{2}\frac{dQ}{dt}\]
</p>
 or PND (proportional/N derivatives) <p class="formulaDsp">
\[ U(t) = \sum_{k=0}^{N} a_{k} \frac{d^kQ}{dt^k} \]
</p>
 The coefficients \( a_{k} \) in the computation of \(U(t)\) are chosen at each time such that the error \(Q(t)\) will be critically damped on a timescale of \(\tau\) (the damping time), i.e. \(Q(t) \propto e^{-t/\tau}\).</li>
<li><a class="el" href="classTimescaleTuner.html" title="Manages control system timescales.">TimescaleTuner</a>: each map has a <a class="el" href="classTimescaleTuner.html" title="Manages control system timescales.">TimescaleTuner</a> that dynamically adjusts the damping timescale \(\tau\) appropriately to keep the error \(Q(t)\) within some specified error bounds. Note that the reset time interval, \(\Delta t\), is a constant fraction of this damping timescale, i.e. \(\Delta t = \alpha \tau\) (empirically, we have found \(\alpha=0.3\) to be a good choice).</li>
</ul>
<p >For additional details describing our control system approach, see <a class="el" href="citelist.html#CITEREF_Hemberger2012jz">[79]</a>. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga95a72f35fae0171be6fd523305a635d6" name="ga95a72f35fae0171be6fd523305a635d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95a72f35fae0171be6fd523305a635d6">&#9670;&nbsp;</a></span>calculate_measurement_timescales()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t DerivOrder&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataVector.html">DataVector</a> control_system::calculate_measurement_timescales </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classController.html">::Controller</a>&lt; DerivOrder &gt; &amp;&#160;</td>
          <td class="paramname"><em>controller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTimescaleTuner.html">::TimescaleTuner</a> &amp;&#160;</td>
          <td class="paramname"><em>tuner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>measurements_per_update</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the measurement timescale based on the damping timescale, update fraction, and DerivOrder of the control system. </p>
<p >The update timescale is \(\tau_\mathrm{update} = \alpha_\mathrm{update} \tau_\mathrm{damp}\) where \(\tau_\mathrm{damp}\) is the damping timescale (from the <a class="el" href="classTimescaleTuner.html" title="Manages control system timescales.">TimescaleTuner</a>) and \(\alpha_\mathrm{update}\) is the update fraction (from the controller). For an Nth order control system, the averager requires at least N measurements in order to perform its finite differencing to calculate the derivatives of the control error. This implies that the largest the measurement timescale can be is \(\tau_\mathrm{m} = \tau_\mathrm{update} / N\). To ensure that we have sufficient measurements, we calculate the measurement timescales as \(\tau_\mathrm{m} = \tau_\mathrm{update} / N\) where \(N\) is <code>measurements_per_update</code>. </p>

</div>
</div>
<a id="ga5098f75ed02c2d1f0ed6a56cd76e7d9f" name="ga5098f75ed02c2d1f0ed6a56cd76e7d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5098f75ed02c2d1f0ed6a56cd76e7d9f">&#9670;&nbsp;</a></span>function_of_time_expiration_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double control_system::function_of_time_expiration_time </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>old_measurement_timescales</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>new_measurement_timescales</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>measurements_per_update</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the next expiration time for the FunctionsOfTime. </p>
<p class="formulaDsp">
\begin{align} T_\mathrm{expr}^\mathrm{FoT} &amp;= t + \tau_\mathrm{m}^\mathrm{old} + N * \tau_\mathrm{m}^\mathrm{new} \\ \end{align}
</p>
<p >where \(T_\mathrm{expr}^\mathrm{FoT}\) is the expiration time for the FunctionsOfTime, \(t\) is the current time, \(\tau_\mathrm{m}^\mathrm{old/new}\) is the measurement timescale, and \(N\) is the number of measurements per update.</p>
<p >The expiration is calculated this way because we update the functions of time one (old) measurement before they actually expire.</p>
<p >The choice of having the functions of time expire exactly one old measurement after they are updated is arbitrary. They could expire any time between the update time and one old measurement after the update. This decision was made to minimize time spent waiting for the functions of time to be valid.</p>
<p >Since functions of time are valid at their expiration time, we are actually able to do the next measurement if the expiration time is at that measurement. Thus we delay any potential waiting that may happen until the subsequent measurement (and by that time, most, if not all, functions of time should have been updated because an entire horizon find happened in the meantime). If the expiration time was earlier than the next measurement, we'd have to pause the Algorithm on the DG elements and wait until all the functions of time have been updated. </p>

</div>
</div>
<a id="ga1cfe2c0a65ba1d01fb8ea46b70a17817" name="ga1cfe2c0a65ba1d01fb8ea46b70a17817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cfe2c0a65ba1d01fb8ea46b70a17817">&#9670;&nbsp;</a></span>initial_expiration_times()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename... OptionHolders&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, double &gt; control_system::initial_expiration_times </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>measurements_per_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;<a class="el" href="classDomainCreator.html">::DomainCreator</a>&lt; Dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>domain_creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OptionHolders &amp;...&#160;</td>
          <td class="paramname"><em>option_holders</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the initial expiration times for functions of time that are controlled by a control system. </p>
<p >The expiration times are constructed using inputs from control system OptionHolders as an unordered map from the name of the function of time being controlled to the expiration time. The expiration time is computed as \(\tau_\mathrm{exp} = \alpha_\mathrm{update} \tau_\mathrm{damp}\) where \(\alpha_\mathrm{update}\) is the update fraction supplied as input to the <a class="el" href="classController.html" title="A PND (proportional to Q and N derivatives of Q) controller that computes the control signal:">Controller</a> and \(\tau_\mathrm{damp}\) is/are the damping timescales supplied from the <a class="el" href="classTimescaleTuner.html" title="Manages control system timescales.">TimescaleTuner</a> ( \(\tau_\mathrm{damp}\) is a <a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a> with as many components as the corresponding function of time, thus \(\tau_\mathrm{exp}\) will also be a <a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a> of the same length).</p>
<p >If the control system isn't active then expiration time is <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits</a>&lt;double&gt;::infinity()</code>. </p>

</div>
</div>
<a id="gadbc0f7b981fe84620ab1668ed6dfd907" name="gadbc0f7b981fe84620ab1668ed6dfd907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbc0f7b981fe84620ab1668ed6dfd907">&#9670;&nbsp;</a></span>measurement_expiration_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double control_system::measurement_expiration_time </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>old_measurement_timescales</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>new_measurement_timescales</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>measurements_per_update</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the next expiration time for the MeasurementTimescales. </p>
<p class="formulaDsp">
\begin{align} T_\mathrm{expr}^\mathrm{m} &amp;= T_\mathrm{expr}^\mathrm{FoT} - \frac{1}{2} \tau_\mathrm{m}^\mathrm{new} \\ \end{align}
</p>
<p >where \(T_\mathrm{expr}^\mathrm{m}\) is the measurement expiration time, \(T_\mathrm{expr}^\mathrm{FoT}\) is the function of time expiration time as calculate from <code><a class="el" href="group__ControlSystemGroup.html#ga5098f75ed02c2d1f0ed6a56cd76e7d9f" title="Calculate the next expiration time for the FunctionsOfTime.">function_of_time_expiration_time()</a></code>, and \(\tau_\mathrm{m}^\mathrm{new}\) is the new measurement timescale. The reason for the factor of a half is as follows:</p>
<p >We update the functions of time one (old) measurement before the expiration time. Based on how dense triggers are set up, which <a class="el" href="classcontrol__system_1_1Trigger.html" title="Trigger for control system measurements.">control_system::Trigger</a> is a dense trigger, you calculate the next trigger (measurement) time at the current measurement time. However, at the function of time expiration time we need updated damping timescales from all control systems in order to calculate when the next measurement is going to be (and in turn, the next measurement expiration time). Thus, at the measurement that occurs at the function of time expiration time, our measurement timescales can't be valid and we must wait for updated ones. To achieve this, we set the measurement expiration time <em>before</em> the function of time expiration time, but <em>after</em> the previous measurement (the update measurement). The factor of one half is just to guarantee we are more than epsilon before the function of time expiration time and more than epsilon after the update measurement. </p>

</div>
</div>
<a id="ga5d20d917bcfa5c782a87018dd0ee29b6" name="ga5d20d917bcfa5c782a87018dd0ee29b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d20d917bcfa5c782a87018dd0ee29b6">&#9670;&nbsp;</a></span>write_components_to_disk()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ControlSystem , typename Metavariables &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void control_system::write_components_to_disk </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache</a>&lt; Metavariables &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>function_of_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_and_dtq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>timescales</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes all components of a function of time to disk at a specific time from a control system after it updates the functions of time. </p>
<h3>Details</h3>
<p >The columns of data written are:</p><ul>
<li>Time</li>
<li>FunctionOfTime</li>
<li>dtFunctionOfTime</li>
<li>d2tFunctionOfTime</li>
<li>ControlError</li>
<li>dtControlError</li>
<li>DampingTimescale</li>
</ul>
<p >Data will be stored in the reduction file. All subfiles for the control system within the H5 file will be under the group "/ControlSystems". Within this group, there will be one group for each control system. The name of each group will be the result of the <code><a class="el" href="group__PrettyTypeGroup.html#gac698d0d763b59b714fca6ed84376eb92" title="Return the result of the name() member of a class. If a class doesn&#39;t have a name() member,...">name()</a></code> function from each control system. An example would look like</p>
<ul>
<li>/ControlSystems/SystemA</li>
<li>/ControlSystems/SystemB</li>
<li>/ControlSystems/SystemC</li>
</ul>
<p >Then, within each system group, there will be one subfile for each component of the function of time that is being controlled. The name of this subfile is the name of the component. The name of each component will be the result of the <code>component_name(i)</code> function from the control system, where <code>i</code> is the index of the component. For example, if "SystemA" has 3 components with names "X", "Y", and "Z", then the subfiles would look like</p>
<ul>
<li>/ControlSystems/SystemA/X.dat</li>
<li>/ControlSystems/SystemA/Y.dat</li>
<li>/ControlSystems/SystemA/Z.dat </li>
</ul>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
