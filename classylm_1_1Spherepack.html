<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: ylm::Spherepack Class Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classylm_1_1Spherepack.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classylm_1_1Spherepack-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ylm::Spherepack Class Reference<div class="ingroups"><a class="el" href="group__SpectralGroup.html">Spectral</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Defines the C++ interface to SPHEREPACK.  
 <a href="classylm_1_1Spherepack.html#details">More...</a></p>

<p><code>#include &lt;Spherepack.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structylm_1_1Spherepack_1_1InterpolationInfo.html">InterpolationInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to hold cached information at a set of target interpolation points.  <a href="structylm_1_1Spherepack_1_1InterpolationInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af9cba299b4fb6b42bb735007486f451a"><td class="memItemLeft" align="right" valign="top"><a id="af9cba299b4fb6b42bb735007486f451a" name="af9cba299b4fb6b42bb735007486f451a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>FirstDeriv</b> = tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt;</td></tr>
<tr class="memdesc:af9cba299b4fb6b42bb735007486f451a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type returned by gradient function. <br /></td></tr>
<tr class="separator:af9cba299b4fb6b42bb735007486f451a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc331980476c964b5da2e7140cb0c5df"><td class="memItemLeft" align="right" valign="top"><a id="adc331980476c964b5da2e7140cb0c5df" name="adc331980476c964b5da2e7140cb0c5df"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SecondDeriv</b> = tnsr::ij&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt;</td></tr>
<tr class="memdesc:adc331980476c964b5da2e7140cb0c5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type returned by second derivative function. <br /></td></tr>
<tr class="separator:adc331980476c964b5da2e7140cb0c5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1ed628d6033386a0ac0e190ffc10d4af"><td class="memItemLeft" align="right" valign="top"><a id="a1ed628d6033386a0ac0e190ffc10d4af" name="a1ed628d6033386a0ac0e190ffc10d4af"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Spherepack</b> (size_t <a class="el" href="classylm_1_1Spherepack.html#afc33c50050efe743292f775cb5765cf8">l_max</a>, size_t <a class="el" href="classylm_1_1Spherepack.html#a49e0212efe967e7f91b07ca5fa796e03">m_max</a>)</td></tr>
<tr class="memdesc:a1ed628d6033386a0ac0e190ffc10d4af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Here l_max and m_max are the largest fully-represented l and m in the Ylm expansion. <br /></td></tr>
<tr class="separator:a1ed628d6033386a0ac0e190ffc10d4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8e1b0017d02b378a3efa3e679c008c"><td class="memItemLeft" align="right" valign="top"><a id="a9e8e1b0017d02b378a3efa3e679c008c" name="a9e8e1b0017d02b378a3efa3e679c008c"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>physical_extents</b> () const</td></tr>
<tr class="separator:a9e8e1b0017d02b378a3efa3e679c008c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4412d43920943c90ee3561a7fc0e38c3"><td class="memItemLeft" align="right" valign="top"><a id="a4412d43920943c90ee3561a7fc0e38c3" name="a4412d43920943c90ee3561a7fc0e38c3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gradient</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double *, 2 &gt; &amp;df, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; const double * &gt; collocation_values, size_t physical_stride=1, size_t physical_offset=0) const</td></tr>
<tr class="memdesc:a4412d43920943c90ee3561a7fc0e38c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes Pfaffian derivative (df/dtheta, csc(theta) df/dphi) at the collocation values. To act on a slice of the input and output arrays, specify stride and offset (assumed to be the same for input and output). <br /></td></tr>
<tr class="separator:a4412d43920943c90ee3561a7fc0e38c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c175dd52385c5ca5cd6418a14d6e86"><td class="memItemLeft" align="right" valign="top"><a id="a70c175dd52385c5ca5cd6418a14d6e86" name="a70c175dd52385c5ca5cd6418a14d6e86"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gradient_from_coefs</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double *, 2 &gt; &amp;df, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; const double * &gt; spectral_coefs, size_t spectral_stride=1, size_t spectral_offset=0, size_t physical_stride=1, size_t physical_offset=0) const</td></tr>
<tr class="memdesc:a70c175dd52385c5ca5cd6418a14d6e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>gradient</code>, but takes the spectral coefficients (rather than collocation values) of the function. This is more efficient if one happens to already have the spectral coefficients. To act on a slice of the input and output arrays, specify strides and offsets. <br /></td></tr>
<tr class="separator:a70c175dd52385c5ca5cd6418a14d6e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fe3a17eece374f75d3bb14131d51de"><td class="memItemLeft" align="right" valign="top"><a id="a47fe3a17eece374f75d3bb14131d51de" name="a47fe3a17eece374f75d3bb14131d51de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scalar_laplacian</b> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; double * &gt; scalar_laplacian, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; const double * &gt; collocation_values, size_t physical_stride=1, size_t physical_offset=0) const</td></tr>
<tr class="memdesc:a47fe3a17eece374f75d3bb14131d51de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes Laplacian in physical space. To act on a slice of the input and output arrays, specify stride and offset (assumed to be the same for input and output). <br /></td></tr>
<tr class="separator:a47fe3a17eece374f75d3bb14131d51de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fb524b09c3a3f6ff7c462e9f7c048c"><td class="memItemLeft" align="right" valign="top"><a id="af6fb524b09c3a3f6ff7c462e9f7c048c" name="af6fb524b09c3a3f6ff7c462e9f7c048c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scalar_laplacian_from_coefs</b> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; double * &gt; <a class="el" href="classylm_1_1Spherepack.html#a47fe3a17eece374f75d3bb14131d51de">scalar_laplacian</a>, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; const double * &gt; spectral_coefs, size_t spectral_stride=1, size_t spectral_offset=0, size_t physical_stride=1, size_t physical_offset=0) const</td></tr>
<tr class="memdesc:af6fb524b09c3a3f6ff7c462e9f7c048c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>scalar_laplacian</code> above, but the input is the spectral coefficients (rather than collocation values) of the function. This is more efficient if one happens to already have the spectral coefficients. To act on a slice of the input and output arrays, specify strides and offsets. <br /></td></tr>
<tr class="separator:af6fb524b09c3a3f6ff7c462e9f7c048c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e155747941f1a7a0d0e60ebe5619c8"><td class="memItemLeft" align="right" valign="top"><a id="a38e155747941f1a7a0d0e60ebe5619c8" name="a38e155747941f1a7a0d0e60ebe5619c8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>second_derivative</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double *, 2 &gt; &amp;df, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classylm_1_1Spherepack.html#adc331980476c964b5da2e7140cb0c5df">SecondDeriv</a> * &gt; ddf, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; const double * &gt; collocation_values, size_t physical_stride=1, size_t physical_offset=0) const</td></tr>
<tr class="memdesc:a38e155747941f1a7a0d0e60ebe5619c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes Pfaffian first and second derivative in physical space. The first derivative is \(df(i) = d_i f\), and the second derivative is \(ddf(i,j) = d_i (d_j f)\), where \(d_0 = d/d\theta\) and \(d_1 = csc(\theta) d/d\phi\). ddf is not symmetric. To act on a slice of the input and output arrays, specify stride and offset (assumed to be the same for input and output). <br /></td></tr>
<tr class="separator:a38e155747941f1a7a0d0e60ebe5619c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc2cc9bdb64c56d86f85c58d8bcf50f"><td class="memItemLeft" align="right" valign="top"><a id="a5fc2cc9bdb64c56d86f85c58d8bcf50f" name="a5fc2cc9bdb64c56d86f85c58d8bcf50f"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classylm_1_1Spherepack.html#af9cba299b4fb6b42bb735007486f451a">FirstDeriv</a>, <a class="el" href="classylm_1_1Spherepack.html#adc331980476c964b5da2e7140cb0c5df">SecondDeriv</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>first_and_second_derivative</b> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;collocation_values) const</td></tr>
<tr class="memdesc:a5fc2cc9bdb64c56d86f85c58d8bcf50f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simpler, less general interface to second_derivative. <br /></td></tr>
<tr class="separator:a5fc2cc9bdb64c56d86f85c58d8bcf50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b3bb8870fe46c0206ea98fad4ce095"><td class="memItemLeft" align="right" valign="top"><a id="ac6b3bb8870fe46c0206ea98fad4ce095" name="ac6b3bb8870fe46c0206ea98fad4ce095"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>definite_integral</b> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; const double * &gt; collocation_values, size_t physical_stride=1, size_t physical_offset=0) const</td></tr>
<tr class="memdesc:ac6b3bb8870fe46c0206ea98fad4ce095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the integral over the sphere. <br /></td></tr>
<tr class="separator:ac6b3bb8870fe46c0206ea98fad4ce095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561a5fea7e55e7ad2d4e8f076302b5c4"><td class="memItemLeft" align="right" valign="top"><a id="a561a5fea7e55e7ad2d4e8f076302b5c4" name="a561a5fea7e55e7ad2d4e8f076302b5c4"></a>
const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>integration_weights</b> () const</td></tr>
<tr class="memdesc:a561a5fea7e55e7ad2d4e8f076302b5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns weights \(w_i\) such that \(sum_i (c_i w_i)\) is the definite integral, where \(c_i\) are collocation values at point i. <br /></td></tr>
<tr class="separator:a561a5fea7e55e7ad2d4e8f076302b5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3fd9e5432aa8614c66687f59568c72"><td class="memTemplParams" colspan="2"><a id="adc3fd9e5432aa8614c66687f59568c72" name="adc3fd9e5432aa8614c66687f59568c72"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adc3fd9e5432aa8614c66687f59568c72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structylm_1_1Spherepack_1_1InterpolationInfo.html">InterpolationInfo</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>set_up_interpolation_info</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 2 &gt; &amp;target_points) const</td></tr>
<tr class="memdesc:adc3fd9e5432aa8614c66687f59568c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the <code><a class="el" href="structylm_1_1Spherepack_1_1InterpolationInfo.html" title="Struct to hold cached information at a set of target interpolation points.">InterpolationInfo</a></code> structure for interpolating onto a set of target \((\theta,\phi)\) points. Does not depend on the function being interpolated. <br /></td></tr>
<tr class="separator:adc3fd9e5432aa8614c66687f59568c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aba8242d5f8af9970140bcbc7c6127c"><td class="memTemplParams" colspan="2"><a id="a1aba8242d5f8af9970140bcbc7c6127c" name="a1aba8242d5f8af9970140bcbc7c6127c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1aba8242d5f8af9970140bcbc7c6127c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>interpolate</b> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; T * &gt; result, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; const double * &gt; collocation_values, const <a class="el" href="structylm_1_1Spherepack_1_1InterpolationInfo.html">InterpolationInfo</a>&lt; T &gt; &amp;interpolation_info, size_t physical_stride=1, size_t physical_offset=0) const</td></tr>
<tr class="memdesc:a1aba8242d5f8af9970140bcbc7c6127c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates from <code>collocation_values</code> onto the points that have been passed into the <code>set_up_interpolation_info</code> function. To interpolate a different function on the same spectral grid, there is no need to recompute <code>interpolation_info</code>. If you specify stride and offset, acts on a slice of the input values. The output has unit stride. <br /></td></tr>
<tr class="separator:a1aba8242d5f8af9970140bcbc7c6127c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951c0a39ff9323c1c3ff3f11358cb941"><td class="memTemplParams" colspan="2"><a id="a951c0a39ff9323c1c3ff3f11358cb941" name="a951c0a39ff9323c1c3ff3f11358cb941"></a>
template&lt;typename T , typename R &gt; </td></tr>
<tr class="memitem:a951c0a39ff9323c1c3ff3f11358cb941"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>interpolate_from_coefs</b> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; T * &gt; result, const R &amp;spectral_coefs, const <a class="el" href="structylm_1_1Spherepack_1_1InterpolationInfo.html">InterpolationInfo</a>&lt; T &gt; &amp;interpolation_info, size_t spectral_stride=1, size_t spectral_offset=0) const</td></tr>
<tr class="memdesc:a951c0a39ff9323c1c3ff3f11358cb941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>interpolate</code>, but assumes you have spectral coefficients. This is more efficient if you already have the spectral coefficients available. If you specify stride and offset, acts on a slice of the input coefs. The output has unit stride. <br /></td></tr>
<tr class="separator:a951c0a39ff9323c1c3ff3f11358cb941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da1fe66e2e430695b739e805fa58a4b"><td class="memTemplParams" colspan="2"><a id="a6da1fe66e2e430695b739e805fa58a4b" name="a6da1fe66e2e430695b739e805fa58a4b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6da1fe66e2e430695b739e805fa58a4b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>interpolate</b> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;collocation_values, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 2 &gt; &amp;target_points) const</td></tr>
<tr class="memdesc:a6da1fe66e2e430695b739e805fa58a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simpler interface to <code>interpolate</code>. If you need to call this repeatedly on different <code>spectral_coefs</code> or <code>collocation_values</code> for the same target points, this is inefficient; instead use <code>set_up_interpolation_info</code> and the functions that use <code><a class="el" href="structylm_1_1Spherepack_1_1InterpolationInfo.html" title="Struct to hold cached information at a set of target interpolation points.">InterpolationInfo</a></code>. <br /></td></tr>
<tr class="separator:a6da1fe66e2e430695b739e805fa58a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b24140b832fb6c2c3d51e205b5cb01"><td class="memTemplParams" colspan="2"><a id="ac9b24140b832fb6c2c3d51e205b5cb01" name="ac9b24140b832fb6c2c3d51e205b5cb01"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac9b24140b832fb6c2c3d51e205b5cb01"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>interpolate_from_coefs</b> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;spectral_coefs, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 2 &gt; &amp;target_points) const</td></tr>
<tr class="separator:ac9b24140b832fb6c2c3d51e205b5cb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e253d261f44e4aeb043c157b8a9333"><td class="memItemLeft" align="right" valign="top"><a id="a39e253d261f44e4aeb043c157b8a9333" name="a39e253d261f44e4aeb043c157b8a9333"></a>
<a class="el" href="classDataVector.html">DataVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>prolong_or_restrict</b> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;spectral_coefs, const <a class="el" href="classylm_1_1Spherepack.html">Spherepack</a> &amp;target) const</td></tr>
<tr class="memdesc:a39e253d261f44e4aeb043c157b8a9333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes spectral coefficients compatible with <code>*this</code>, and either prolongs them or restricts them to be compatible with <code>target</code>. This is done by truncation (restriction) or padding with zeros (prolongation). <br /></td></tr>
<tr class="separator:a39e253d261f44e4aeb043c157b8a9333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afc33c50050efe743292f775cb5765cf8"><td class="memItemLeft" align="right" valign="top"><a id="afc33c50050efe743292f775cb5765cf8" name="afc33c50050efe743292f775cb5765cf8"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>l_max</b> () const</td></tr>
<tr class="memdesc:afc33c50050efe743292f775cb5765cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sizes in physical and spectral space for this instance. <br /></td></tr>
<tr class="separator:afc33c50050efe743292f775cb5765cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e0212efe967e7f91b07ca5fa796e03"><td class="memItemLeft" align="right" valign="top"><a id="a49e0212efe967e7f91b07ca5fa796e03" name="a49e0212efe967e7f91b07ca5fa796e03"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_max</b> () const</td></tr>
<tr class="memdesc:a49e0212efe967e7f91b07ca5fa796e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sizes in physical and spectral space for this instance. <br /></td></tr>
<tr class="separator:a49e0212efe967e7f91b07ca5fa796e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20157adc6e6cf128413cbe125ba97375"><td class="memItemLeft" align="right" valign="top"><a id="a20157adc6e6cf128413cbe125ba97375" name="a20157adc6e6cf128413cbe125ba97375"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>physical_size</b> () const</td></tr>
<tr class="memdesc:a20157adc6e6cf128413cbe125ba97375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sizes in physical and spectral space for this instance. <br /></td></tr>
<tr class="separator:a20157adc6e6cf128413cbe125ba97375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0641a48c1a5082e4e6494402ca3608"><td class="memItemLeft" align="right" valign="top"><a id="aed0641a48c1a5082e4e6494402ca3608" name="aed0641a48c1a5082e4e6494402ca3608"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>spectral_size</b> () const</td></tr>
<tr class="memdesc:aed0641a48c1a5082e4e6494402ca3608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sizes in physical and spectral space for this instance. <br /></td></tr>
<tr class="separator:aed0641a48c1a5082e4e6494402ca3608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9cebab27eefd0c63a913c17fa70c82db"><td class="memItemLeft" align="right" valign="top">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classylm_1_1Spherepack.html#a9cebab27eefd0c63a913c17fa70c82db">theta_points</a> () const</td></tr>
<tr class="memdesc:a9cebab27eefd0c63a913c17fa70c82db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collocation points theta and phi.  <a href="classylm_1_1Spherepack.html#a9cebab27eefd0c63a913c17fa70c82db">More...</a><br /></td></tr>
<tr class="separator:a9cebab27eefd0c63a913c17fa70c82db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40947d8445a66809c6735429d7c3fc7"><td class="memItemLeft" align="right" valign="top">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classylm_1_1Spherepack.html#ab40947d8445a66809c6735429d7c3fc7">phi_points</a> () const</td></tr>
<tr class="memdesc:ab40947d8445a66809c6735429d7c3fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collocation points theta and phi.  <a href="classylm_1_1Spherepack.html#ab40947d8445a66809c6735429d7c3fc7">More...</a><br /></td></tr>
<tr class="separator:ab40947d8445a66809c6735429d7c3fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dee5d0e7be8fcd8aa5b54e035ea49c4"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classylm_1_1Spherepack.html#a6dee5d0e7be8fcd8aa5b54e035ea49c4">theta_phi_points</a> () const</td></tr>
<tr class="memdesc:a6dee5d0e7be8fcd8aa5b54e035ea49c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collocation points theta and phi.  <a href="classylm_1_1Spherepack.html#a6dee5d0e7be8fcd8aa5b54e035ea49c4">More...</a><br /></td></tr>
<tr class="separator:a6dee5d0e7be8fcd8aa5b54e035ea49c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a60ade142317063490b16fa7499fecce8"><td class="memItemLeft" align="right" valign="top"><a id="a60ade142317063490b16fa7499fecce8" name="a60ade142317063490b16fa7499fecce8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>phys_to_spec</b> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; double * &gt; spectral_coefs, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; const double * &gt; collocation_values, size_t physical_stride=1, size_t physical_offset=0, size_t spectral_stride=1, size_t spectral_offset=0) const</td></tr>
<tr class="memdesc:a60ade142317063490b16fa7499fecce8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSpectral.html" title="Functionality associated with a particular choice of basis functions and quadrature for spectral oper...">Spectral</a> transformations. To act on a slice of the input and output arrays, specify strides and offsets. <br /></td></tr>
<tr class="separator:a60ade142317063490b16fa7499fecce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9191498e95ecc3c14214a1e90f33803a"><td class="memItemLeft" align="right" valign="top"><a id="a9191498e95ecc3c14214a1e90f33803a" name="a9191498e95ecc3c14214a1e90f33803a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>spec_to_phys</b> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; double * &gt; collocation_values, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; const double * &gt; spectral_coefs, size_t spectral_stride=1, size_t spectral_offset=0, size_t physical_stride=1, size_t physical_offset=0) const</td></tr>
<tr class="memdesc:a9191498e95ecc3c14214a1e90f33803a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSpectral.html" title="Functionality associated with a particular choice of basis functions and quadrature for spectral oper...">Spectral</a> transformations. To act on a slice of the input and output arrays, specify strides and offsets. <br /></td></tr>
<tr class="separator:a9191498e95ecc3c14214a1e90f33803a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8ac6c0b448a9fc15679667f2107dc125"><td class="memItemLeft" align="right" valign="top"><a id="a8ac6c0b448a9fc15679667f2107dc125" name="a8ac6c0b448a9fc15679667f2107dc125"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>phys_to_spec_all_offsets</b> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; double * &gt; spectral_coefs, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; const double * &gt; collocation_values, size_t stride) const</td></tr>
<tr class="memdesc:a8ac6c0b448a9fc15679667f2107dc125"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSpectral.html" title="Functionality associated with a particular choice of basis functions and quadrature for spectral oper...">Spectral</a> transformations where <code>collocation_values</code> and <code>spectral_coefs</code> are assumed to point to 3-dimensional arrays (I1 x S2 topology), and the transformations are done for all 'radial' points at once by internally looping over all values of the offset from zero to <code>stride</code>-1 (the physical and spectral strides are equal and are called <code>stride</code>). <br /></td></tr>
<tr class="separator:a8ac6c0b448a9fc15679667f2107dc125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76481cea7bfc7c2caca97a65c64b0fec"><td class="memItemLeft" align="right" valign="top"><a id="a76481cea7bfc7c2caca97a65c64b0fec" name="a76481cea7bfc7c2caca97a65c64b0fec"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>spec_to_phys_all_offsets</b> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; double * &gt; collocation_values, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; const double * &gt; spectral_coefs, size_t stride) const</td></tr>
<tr class="memdesc:a76481cea7bfc7c2caca97a65c64b0fec"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSpectral.html" title="Functionality associated with a particular choice of basis functions and quadrature for spectral oper...">Spectral</a> transformations where <code>collocation_values</code> and <code>spectral_coefs</code> are assumed to point to 3-dimensional arrays (I1 x S2 topology), and the transformations are done for all 'radial' points at once by internally looping over all values of the offset from zero to <code>stride</code>-1 (the physical and spectral strides are equal and are called <code>stride</code>). <br /></td></tr>
<tr class="separator:a76481cea7bfc7c2caca97a65c64b0fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aaa30294b569a3674380b9ba03d299ff1"><td class="memItemLeft" align="right" valign="top"><a id="aaa30294b569a3674380b9ba03d299ff1" name="aaa30294b569a3674380b9ba03d299ff1"></a>
<a class="el" href="classDataVector.html">DataVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>phys_to_spec</b> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;collocation_values, size_t physical_stride=1, size_t physical_offset=0) const</td></tr>
<tr class="memdesc:aaa30294b569a3674380b9ba03d299ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simpler, less general interfaces to <code>phys_to_spec</code> and <code>spec_to_phys</code>. Acts on a slice of the input and returns a unit-stride result. <br /></td></tr>
<tr class="separator:aaa30294b569a3674380b9ba03d299ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa619027a5e7c21c6843b70ad7f3bb6d3"><td class="memItemLeft" align="right" valign="top"><a id="aa619027a5e7c21c6843b70ad7f3bb6d3" name="aa619027a5e7c21c6843b70ad7f3bb6d3"></a>
<a class="el" href="classDataVector.html">DataVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>spec_to_phys</b> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;spectral_coefs, size_t spectral_stride=1, size_t spectral_offset=0) const</td></tr>
<tr class="memdesc:aa619027a5e7c21c6843b70ad7f3bb6d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simpler, less general interfaces to <code>phys_to_spec</code> and <code>spec_to_phys</code>. Acts on a slice of the input and returns a unit-stride result. <br /></td></tr>
<tr class="separator:aa619027a5e7c21c6843b70ad7f3bb6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad1e62ce78c278cce4c963ca37fae89d1"><td class="memItemLeft" align="right" valign="top"><a id="ad1e62ce78c278cce4c963ca37fae89d1" name="ad1e62ce78c278cce4c963ca37fae89d1"></a>
<a class="el" href="classDataVector.html">DataVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>phys_to_spec_all_offsets</b> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;collocation_values, size_t stride) const</td></tr>
<tr class="memdesc:ad1e62ce78c278cce4c963ca37fae89d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simpler, less general interfaces to <code>phys_to_spec_all_offsets</code> and <code>spec_to_phys_all_offsets</code>. Result has the same stride as the input. <br /></td></tr>
<tr class="separator:ad1e62ce78c278cce4c963ca37fae89d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92eaa174eface0ca8d4861b1c48d2a4"><td class="memItemLeft" align="right" valign="top"><a id="aa92eaa174eface0ca8d4861b1c48d2a4" name="aa92eaa174eface0ca8d4861b1c48d2a4"></a>
<a class="el" href="classDataVector.html">DataVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>spec_to_phys_all_offsets</b> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;spectral_coefs, size_t stride) const</td></tr>
<tr class="memdesc:aa92eaa174eface0ca8d4861b1c48d2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simpler, less general interfaces to <code>phys_to_spec_all_offsets</code> and <code>spec_to_phys_all_offsets</code>. Result has the same stride as the input. <br /></td></tr>
<tr class="separator:aa92eaa174eface0ca8d4861b1c48d2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a866822b566c73173ac559fd94ed66bc6"><td class="memItemLeft" align="right" valign="top"><a id="a866822b566c73173ac559fd94ed66bc6" name="a866822b566c73173ac559fd94ed66bc6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gradient_all_offsets</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double *, 2 &gt; &amp;df, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; const double * &gt; collocation_values, size_t stride=1) const</td></tr>
<tr class="memdesc:a866822b566c73173ac559fd94ed66bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>gradient</code> but pointers are assumed to point to 3-dimensional arrays (I1 x S2 topology), and the gradient is done for all 'radial' points at once by internally looping over all values of the offset from zero to <code>stride</code>-1. <br /></td></tr>
<tr class="separator:a866822b566c73173ac559fd94ed66bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bed083419052bca86b11d09d54cd3df"><td class="memItemLeft" align="right" valign="top"><a id="a5bed083419052bca86b11d09d54cd3df" name="a5bed083419052bca86b11d09d54cd3df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gradient_from_coefs_all_offsets</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double *, 2 &gt; &amp;df, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; const double * &gt; spectral_coefs, size_t stride=1) const</td></tr>
<tr class="memdesc:a5bed083419052bca86b11d09d54cd3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>gradient</code> but pointers are assumed to point to 3-dimensional arrays (I1 x S2 topology), and the gradient is done for all 'radial' points at once by internally looping over all values of the offset from zero to <code>stride</code>-1. <br /></td></tr>
<tr class="separator:a5bed083419052bca86b11d09d54cd3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7760015071e5469bc122b0cac020ae49"><td class="memItemLeft" align="right" valign="top"><a id="a7760015071e5469bc122b0cac020ae49" name="a7760015071e5469bc122b0cac020ae49"></a>
<a class="el" href="classylm_1_1Spherepack.html#af9cba299b4fb6b42bb735007486f451a">FirstDeriv</a>&#160;</td><td class="memItemRight" valign="bottom"><b>gradient</b> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;collocation_values, size_t physical_stride=1, size_t physical_offset=0) const</td></tr>
<tr class="memdesc:a7760015071e5469bc122b0cac020ae49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simpler, less general interfaces to <code>gradient</code>. Acts on a slice of the input and returns a unit-stride result. <br /></td></tr>
<tr class="separator:a7760015071e5469bc122b0cac020ae49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2745a65c485e613312bd5e7882c91e0"><td class="memItemLeft" align="right" valign="top"><a id="ae2745a65c485e613312bd5e7882c91e0" name="ae2745a65c485e613312bd5e7882c91e0"></a>
<a class="el" href="classylm_1_1Spherepack.html#af9cba299b4fb6b42bb735007486f451a">FirstDeriv</a>&#160;</td><td class="memItemRight" valign="bottom"><b>gradient_from_coefs</b> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;spectral_coefs, size_t spectral_stride=1, size_t spectral_offset=0) const</td></tr>
<tr class="memdesc:ae2745a65c485e613312bd5e7882c91e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simpler, less general interfaces to <code>gradient</code>. Acts on a slice of the input and returns a unit-stride result. <br /></td></tr>
<tr class="separator:ae2745a65c485e613312bd5e7882c91e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5288a14a1d2a78ed9a3d76a7ee0c5bc3"><td class="memItemLeft" align="right" valign="top"><a id="a5288a14a1d2a78ed9a3d76a7ee0c5bc3" name="a5288a14a1d2a78ed9a3d76a7ee0c5bc3"></a>
<a class="el" href="classylm_1_1Spherepack.html#af9cba299b4fb6b42bb735007486f451a">FirstDeriv</a>&#160;</td><td class="memItemRight" valign="bottom"><b>gradient_all_offsets</b> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;collocation_values, size_t stride=1) const</td></tr>
<tr class="memdesc:a5288a14a1d2a78ed9a3d76a7ee0c5bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simpler, less general interfaces to <code>gradient_all_offsets</code>. Result has the same stride as the input. <br /></td></tr>
<tr class="separator:a5288a14a1d2a78ed9a3d76a7ee0c5bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd0abcbd4b06069d716608fda746796"><td class="memItemLeft" align="right" valign="top"><a id="a4cd0abcbd4b06069d716608fda746796" name="a4cd0abcbd4b06069d716608fda746796"></a>
<a class="el" href="classylm_1_1Spherepack.html#af9cba299b4fb6b42bb735007486f451a">FirstDeriv</a>&#160;</td><td class="memItemRight" valign="bottom"><b>gradient_from_coefs_all_offsets</b> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;spectral_coefs, size_t stride=1) const</td></tr>
<tr class="memdesc:a4cd0abcbd4b06069d716608fda746796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simpler, less general interfaces to <code>gradient_all_offsets</code>. Result has the same stride as the input. <br /></td></tr>
<tr class="separator:a4cd0abcbd4b06069d716608fda746796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a94685f7b3760a7802400dae500171ff4"><td class="memItemLeft" align="right" valign="top"><a id="a94685f7b3760a7802400dae500171ff4" name="a94685f7b3760a7802400dae500171ff4"></a>
<a class="el" href="classDataVector.html">DataVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>scalar_laplacian</b> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;collocation_values, size_t physical_stride=1, size_t physical_offset=0) const</td></tr>
<tr class="memdesc:a94685f7b3760a7802400dae500171ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simpler, less general interfaces to <code>scalar_laplacian</code>. Acts on a slice of the input and returns a unit-stride result. <br /></td></tr>
<tr class="separator:a94685f7b3760a7802400dae500171ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7761309c3a06e36c5bddbc4d9307d9"><td class="memItemLeft" align="right" valign="top"><a id="a7f7761309c3a06e36c5bddbc4d9307d9" name="a7f7761309c3a06e36c5bddbc4d9307d9"></a>
<a class="el" href="classDataVector.html">DataVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>scalar_laplacian_from_coefs</b> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;spectral_coefs, size_t spectral_stride=1, size_t spectral_offset=0) const</td></tr>
<tr class="memdesc:a7f7761309c3a06e36c5bddbc4d9307d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simpler, less general interfaces to <code>scalar_laplacian</code>. Acts on a slice of the input and returns a unit-stride result. <br /></td></tr>
<tr class="separator:a7f7761309c3a06e36c5bddbc4d9307d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9c246363b306a45564a6e2120f57a604"><td class="memItemLeft" align="right" valign="top"><a id="a9c246363b306a45564a6e2120f57a604" name="a9c246363b306a45564a6e2120f57a604"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>add_constant</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt; spectral_coefs, const double c)</td></tr>
<tr class="memdesc:a9c246363b306a45564a6e2120f57a604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant (i.e. \(f(\theta,\phi)\) += \(c\)) to the function given by the spectral coefficients, by modifying the coefficients. <br /></td></tr>
<tr class="separator:a9c246363b306a45564a6e2120f57a604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137461a64853e235f195af85463338fd"><td class="memItemLeft" align="right" valign="top"><a id="a137461a64853e235f195af85463338fd" name="a137461a64853e235f195af85463338fd"></a>
static double&#160;</td><td class="memItemRight" valign="bottom"><b>average</b> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;spectral_coefs)</td></tr>
<tr class="memdesc:a137461a64853e235f195af85463338fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the average of \(f(\theta,\phi)\) over \((\theta,\phi)\). <br /></td></tr>
<tr class="separator:a137461a64853e235f195af85463338fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad3743a027fb39e7f176f72dddfacf119"><td class="memItemLeft" align="right" valign="top"><a id="ad3743a027fb39e7f176f72dddfacf119" name="ad3743a027fb39e7f176f72dddfacf119"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>physical_size</b> (const size_t <a class="el" href="classylm_1_1Spherepack.html#afc33c50050efe743292f775cb5765cf8">l_max</a>, const size_t <a class="el" href="classylm_1_1Spherepack.html#a49e0212efe967e7f91b07ca5fa796e03">m_max</a>)</td></tr>
<tr class="memdesc:ad3743a027fb39e7f176f72dddfacf119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static functions to return the correct sizes of vectors of collocation points and spectral coefficients for a given l_max and m_max. Useful for allocating space without having to create a <a class="el" href="classylm_1_1Spherepack.html" title="Defines the C++ interface to SPHEREPACK.">Spherepack</a>. <br /></td></tr>
<tr class="separator:ad3743a027fb39e7f176f72dddfacf119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebd4a37da65427a2748592e92b5f087"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classylm_1_1Spherepack.html#a2ebd4a37da65427a2748592e92b5f087">spectral_size</a> (const size_t <a class="el" href="classylm_1_1Spherepack.html#afc33c50050efe743292f775cb5765cf8">l_max</a>, const size_t <a class="el" href="classylm_1_1Spherepack.html#a49e0212efe967e7f91b07ca5fa796e03">m_max</a>)</td></tr>
<tr class="separator:a2ebd4a37da65427a2748592e92b5f087"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Defines the C++ interface to SPHEREPACK. </p>
<h3>Details</h3>
<p >The class <code><a class="el" href="classylm_1_1Spherepack.html" title="Defines the C++ interface to SPHEREPACK.">Spherepack</a></code> defines the C++ interface to the fortran library SPHEREPACK used for computations on the surface of a sphere.</p>
<p >Given a real-valued, scalar function \(g(\theta, \phi)\), SPHEREPACK expands it as:</p>
<p class="formulaDsp">
\begin{align} g(\theta, \phi) &amp;=\frac{1}{2}\sum_{l=0}^{l_{\max}}\bar P_l^0(\cos\theta) a_{l0} +\sum_{l=1}^{l_{\max}}\sum_{m=1}^{\min(l, m_{\max})}\bar P_l^m(\cos\theta)\{ a_{lm}\cos m\phi -b_{lm}\sin m\phi\}\label{eq:spherepack_expansion} \end{align}
</p>
<p >where \(a_{lm}\) and \(b_{lm}\) are real-valued spectral coefficient arrays used by SPHEREPACK, \(P_l^m(x)\) are defined as</p>
<p class="formulaDsp">
\begin{align} \bar P_l^m(x)&amp;=\sqrt{\frac{(2l+1)(l-m)!}{2(l+m)!}}\;P_{lm}(x) \end{align}
</p>
<p >and \(P_{nm}(x)\) are the associated Legendre polynomials as defined, for example, in Jackson's "Classical Electrodynamics".</p>
<h4><a class="anchor" id="autotoc_md359"></a>
Relationship to standard spherical harmonics</h4>
<p >The standard expansion of \(g(\theta, \phi)\) in terms of scalar spherical harmonics is </p><p class="formulaDsp">
\begin{align} g(\theta, \phi) &amp;= \sum_{l=0}^{l_{\max}}\sum_{m=-\min(l, m_{\max})}^{\min(l, m_{\max})} A_{lm} Y_{lm}(\theta,\phi), \end{align}
</p>
<p> where \(Y_{lm}(\theta,\phi)\) are the usual complex-valued scalar spherical harmonics (as defined, for example, in Jackson's "Classical Electrodynamics") and \(A_{lm}\) are complex coefficients.</p>
<p >The relationship between the complex coefficients \(A_{lm}\) and SPHEREPACK's real-valued \(a_{lm}\) and \(b_{lm}\) is </p><p class="formulaDsp">
\begin{align} a_{l0} &amp; = \sqrt{\frac{2}{\pi}}A_{l0}&amp;\qquad l\geq 0,\\ a_{lm} &amp; = (-1)^m\sqrt{\frac{2}{\pi}} \mathrm{Re}(A_{lm}) &amp;\qquad l\geq 1, m\geq 1, \\ b_{lm} &amp; = (-1)^m\sqrt{\frac{2}{\pi}} \mathrm{Im}(A_{lm}) &amp;\qquad l\geq 1, m\geq 1. \end{align}
</p>
<dl class="section note"><dt>Note</dt><dd>If \(g\) is real, \(A_{lm} = (-1)^m A^\star_{l -m}\) (where \({}^\star\) means a complex conjugate); this is why we don't need to consider \(m&lt;0\) in the previous formulas or in SPHEREPACK's expansion.</dd></dl>
<h4><a class="anchor" id="autotoc_md360"></a>
Relationship to real-valued spherical harmonics</h4>
<p >Sometimes it is useful to expand a real-valued function in the form </p><p class="formulaDsp">
\begin{align} g(\theta, \phi) &amp;= \sum_{l=0}^\infty\sum_{m=0}^l \left[ c_{lm}\mathrm{Re}(Y_{lm}(\theta, \phi))+ d_{nm}\mathrm{Im}(Y_{lm}(\theta, \phi)) \right]. \end{align}
</p>
<p> The coefficients here are therefore </p><p class="formulaDsp">
\begin{align} c_{l0} &amp;= A_{l0},\\ c_{lm} &amp;= 2\mathrm{Re}(A_{lm}) \qquad m\geq 1,\\ d_{lm} &amp;=-2\mathrm{Im}(A_{lm}). \end{align}
</p>
<h4><a class="anchor" id="autotoc_md361"></a>
Modal and nodal representations</h4>
<p >Internally, SPHEREPACK can represent its expansion in two ways which we will refer to as modal and nodal representations:</p>
<ol type="1">
<li>modal: The spectral coefficient arrays \(a_{lm}\) and \(b_{lm}\), referred to as <code>spectral_coefs</code> in the methods below. For this C++ interface, they are saved in a single <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code>. To help you index the coefficients as expected by this interface, use the class <code><a class="el" href="classSpherepackIterator.html" title="Iterates over spectral coefficients stored in SPHEREPACK format.">SpherepackIterator</a></code>.</li>
<li>nodal: The values at certain collocation points, referred to as <code>collocation_values</code> in the methods below. This is an array of the expanded function \(g(\theta,\phi)\) evaluated at collocation values \((\theta_i,\phi_j)\), where \(\theta_i\) are Gauss-Legendre quadrature nodes in the interval \((0, \pi)\) with \(i = 0, ..., l_{\max}\), and \(\phi_j\) is distributed uniformly in \((0, 2\pi)\) with \(i = 0, ..., 2m_{\max}\). The angles of the collocation points can be computed with the method <code>theta_phi_points</code>.</li>
</ol>
<p >To convert between the two representations the methods <code>spec_to_phys</code> and <code>phys_to_spec</code> can be used. For internal calculations SPHEREPACK will usually convert to spectral coefficients first, so it is in general more efficient to use these directly.</p>
<p >Most methods of SPHEREPACK will compute the requested values of e.g. <code>gradient</code> or <code>scalar_laplacian</code> at the collocation points, effectively returning an expansion in nodal form as defined above. To evaluate the function at arbitrary angles \(\theta\), \(\phi\), these values have to be "interpolated" (i.e. the new expansion evaluated) using <code>interpolate</code>.</p>
<p ><a class="el" href="classylm_1_1Spherepack.html" title="Defines the C++ interface to SPHEREPACK.">Spherepack</a> stores two types of quantities:</p><ol type="1">
<li>storage_, which is filled in the constructor and is always const.</li>
<li>memory_pool_, which is dynamic and thread_local, and is overwritten by various member functions that need temporary storage. </li>
</ol>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab40947d8445a66809c6735429d7c3fc7" name="ab40947d8445a66809c6735429d7c3fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab40947d8445a66809c6735429d7c3fc7">&#9670;&nbsp;</a></span>phi_points()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp; ylm::Spherepack::phi_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collocation points theta and phi. </p>
<p >The phi points are uniform in phi, with the first point at phi=0.</p>
<p >The theta points are Gauss-Legendre in \(\cos(\theta)\), so there are no points at the poles. </p>

</div>
</div>
<a id="a2ebd4a37da65427a2748592e92b5f087" name="a2ebd4a37da65427a2748592e92b5f087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebd4a37da65427a2748592e92b5f087">&#9670;&nbsp;</a></span>spectral_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr size_t ylm::Spherepack::spectral_size </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>l_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>m_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd><code>spectral_size</code> is the size of the buffer that holds the coefficients; it is not the number of coefficients (which is \(m_{\rm max}^2+(l_{\rm max}-m_{\rm max})(2m_{\rm max}+1)\)). To simplify its internal indexing, SPHEREPACK uses a buffer with more space than necessary. See <a class="el" href="classSpherepackIterator.html" title="Iterates over spectral coefficients stored in SPHEREPACK format.">SpherepackIterator</a> for how to index the coefficients in the buffer. </dd></dl>

</div>
</div>
<a id="a6dee5d0e7be8fcd8aa5b54e035ea49c4" name="a6dee5d0e7be8fcd8aa5b54e035ea49c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dee5d0e7be8fcd8aa5b54e035ea49c4">&#9670;&nbsp;</a></span>theta_phi_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2 &gt; ylm::Spherepack::theta_phi_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collocation points theta and phi. </p>
<p >The phi points are uniform in phi, with the first point at phi=0.</p>
<p >The theta points are Gauss-Legendre in \(\cos(\theta)\), so there are no points at the poles. </p>

</div>
</div>
<a id="a9cebab27eefd0c63a913c17fa70c82db" name="a9cebab27eefd0c63a913c17fa70c82db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cebab27eefd0c63a913c17fa70c82db">&#9670;&nbsp;</a></span>theta_points()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp; ylm::Spherepack::theta_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collocation points theta and phi. </p>
<p >The phi points are uniform in phi, with the first point at phi=0.</p>
<p >The theta points are Gauss-Legendre in \(\cos(\theta)\), so there are no points at the poles. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/NumericalAlgorithms/SphericalHarmonics/Spherepack.hpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceylm.html">ylm</a></li><li class="navelem"><a class="el" href="classylm_1_1Spherepack.html">Spherepack</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
