<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: evolution::dg::subcell Namespace Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceevolution_1_1dg_1_1subcell.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">evolution::dg::subcell Namespace Reference<div class="ingroups"><a class="el" href="group__DgSubcellGroup.html">DG-Subcell</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Implementation of a generic finite volume/conservative finite difference subcell limiter.  
<a href="namespaceevolution_1_1dg_1_1subcell.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceevolution_1_1dg_1_1subcell_1_1Actions"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell_1_1Actions.html">Actions</a></td></tr>
<tr class="memdesc:namespaceevolution_1_1dg_1_1subcell_1_1Actions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actions for the DG-subcell hybrid solver. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceevolution_1_1dg_1_1subcell_1_1fd"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell_1_1fd.html">fd</a></td></tr>
<tr class="memdesc:namespaceevolution_1_1dg_1_1subcell_1_1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code specific to a conservative finite difference subcell limiter. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceevolution_1_1dg_1_1subcell_1_1fv"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell_1_1fv.html">fv</a></td></tr>
<tr class="memdesc:namespaceevolution_1_1dg_1_1subcell_1_1fv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code specific to a finite volume subcell limiter. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceevolution_1_1dg_1_1subcell_1_1OptionTags"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell_1_1OptionTags.html">OptionTags</a></td></tr>
<tr class="memdesc:namespaceevolution_1_1dg_1_1subcell_1_1OptionTags"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option tags for the DG-subcell solver. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceevolution_1_1dg_1_1subcell_1_1Tags"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell_1_1Tags.html">Tags</a></td></tr>
<tr class="memdesc:namespaceevolution_1_1dg_1_1subcell_1_1Tags"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tags for the DG-subcell solver <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevolution_1_1dg_1_1subcell_1_1GhostData.html">GhostData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevolution_1_1dg_1_1subcell_1_1RdmpTciData.html">RdmpTciData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds data needed for the relaxed discrete maximum principle troubled-cell indicator.  <a href="structevolution_1_1dg_1_1subcell_1_1RdmpTciData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevolution_1_1dg_1_1subcell_1_1SubcellOptions.html">SubcellOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the system-agnostic subcell parameters, such as numbers controlling when to switch between DG and subcell.  <a href="classevolution_1_1dg_1_1subcell_1_1SubcellOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga97fbd926840d2508e331694db731e18a"><td class="memItemLeft" align="right" valign="top"><a id="ga97fbd926840d2508e331694db731e18a" name="ga97fbd926840d2508e331694db731e18a"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DgSubcellGroup.html#ga97fbd926840d2508e331694db731e18a">ActiveGrid</a> { <b>Dg</b>
, <b>Subcell</b>
 }</td></tr>
<tr class="memdesc:ga97fbd926840d2508e331694db731e18a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The grid that is currently being used for the DG-subcell evolution. <br /></td></tr>
<tr class="separator:ga97fbd926840d2508e331694db731e18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a68a7c4286f6d005328c964ab04e36c6c"><td class="memItemLeft" align="right" valign="top"><a id="a68a7c4286f6d005328c964ab04e36c6c" name="a68a7c4286f6d005328c964ab04e36c6c"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, <a class="el" href="group__DgSubcellGroup.html#ga97fbd926840d2508e331694db731e18a">ActiveGrid</a> active_grid)</td></tr>
<tr class="separator:a68a7c4286f6d005328c964ab04e36c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10a738cb43a6a3a7a1a51b269fd44f4"><td class="memTemplParams" colspan="2"><a id="af10a738cb43a6a3a7a1a51b269fd44f4" name="af10a738cb43a6a3a7a1a51b269fd44f4"></a>
template&lt;typename... CorrectionTags, typename BoundaryCorrection , typename... PackageFieldTags&gt; </td></tr>
<tr class="memitem:af10a738cb43a6a3a7a1a51b269fd44f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_boundary_terms</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; tmpl::list&lt; CorrectionTags... &gt; &gt; * &gt; boundary_corrections_on_face, const BoundaryCorrection &amp;boundary_correction, const Variables&lt; tmpl::list&lt; PackageFieldTags... &gt; &gt; &amp;upper_packaged_data, const Variables&lt; tmpl::list&lt; PackageFieldTags... &gt; &gt; &amp;lower_packaged_data)</td></tr>
<tr class="separator:af10a738cb43a6a3a7a1a51b269fd44f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8263c2bbf2b8eb7e43ebcc29a7281559"><td class="memTemplParams" colspan="2">template&lt;bool OverwriteInternalMortarData, size_t Dim, typename DgPackageFieldTags &gt; </td></tr>
<tr class="memitem:a8263c2bbf2b8eb7e43ebcc29a7281559"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#a8263c2bbf2b8eb7e43ebcc29a7281559">correct_package_data</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; DgPackageFieldTags &gt; * &gt; lower_packaged_data, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; DgPackageFieldTags &gt; * &gt; upper_packaged_data, const size_t logical_dimension_to_operate_in, const <a class="el" href="classElement.html">Element</a>&lt; Dim &gt; &amp;element, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;subcell_volume_mesh, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt;, <a class="el" href="classevolution_1_1dg_1_1MortarData.html">evolution::dg::MortarData</a>&lt; Dim &gt;, boost::hash&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt; &gt; &gt; &amp;mortar_data, const size_t variables_to_offset_in_dg_grid)</td></tr>
<tr class="memdesc:a8263c2bbf2b8eb7e43ebcc29a7281559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project the DG package data to the subcells. Data received from a neighboring element doing DG is always projected, while the data we sent to our neighbors before doing a rollback from DG to subcell is only projected if <code>OverwriteInternalMortarData</code> is <code>true</code>.  <a href="namespaceevolution_1_1dg_1_1subcell.html#a8263c2bbf2b8eb7e43ebcc29a7281559">More...</a><br /></td></tr>
<tr class="separator:a8263c2bbf2b8eb7e43ebcc29a7281559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa622ce574be5ed26fa939c64f48e657"><td class="memTemplParams" colspan="2"><a id="afa622ce574be5ed26fa939c64f48e657" name="afa622ce574be5ed26fa939c64f48e657"></a>
template&lt;typename DbTagsList &gt; </td></tr>
<tr class="memitem:afa622ce574be5ed26fa939c64f48e657"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_tci_decision</b> (const db::DataBox&lt; DbTagsList &gt; &amp;box)</td></tr>
<tr class="memdesc:afa622ce574be5ed26fa939c64f48e657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of <a class="el" href="structevolution_1_1dg_1_1subcell_1_1Tags_1_1TciDecision.html" title="Stores the status of the troubled cell indicator in the element as an int.">evolution::dg::subcell::Tags::TciDecision</a>. <br /></td></tr>
<tr class="separator:afa622ce574be5ed26fa939c64f48e657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379ba90849e90c9f4d1b1191b8b4382d"><td class="memItemLeft" align="right" valign="top"><a id="a379ba90849e90c9f4d1b1191b8b4382d" name="a379ba90849e90c9f4d1b1191b8b4382d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classevolution_1_1dg_1_1subcell_1_1GhostData.html">GhostData</a> &amp;lhs, const <a class="el" href="classevolution_1_1dg_1_1subcell_1_1GhostData.html">GhostData</a> &amp;rhs)</td></tr>
<tr class="separator:a379ba90849e90c9f4d1b1191b8b4382d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e9f848a9df407a30c7e624d0369cff"><td class="memItemLeft" align="right" valign="top"><a id="a00e9f848a9df407a30c7e624d0369cff" name="a00e9f848a9df407a30c7e624d0369cff"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="el" href="classevolution_1_1dg_1_1subcell_1_1GhostData.html">GhostData</a> &amp;ghost_data)</td></tr>
<tr class="separator:a00e9f848a9df407a30c7e624d0369cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee609bf42e12844e2fbb439c013c4af3"><td class="memTemplParams" colspan="2">template&lt;bool InsertIntoMap, size_t Dim&gt; </td></tr>
<tr class="memitem:aee609bf42e12844e2fbb439c013c4af3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#aee609bf42e12844e2fbb439c013c4af3">insert_or_update_neighbor_volume_data</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classFixedHashMap.html">FixedHashMap</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#gafa8cb44daebc8f9e080718961530be89">maximum_number_of_neighbors</a>(Dim), <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt;, <a class="el" href="classevolution_1_1dg_1_1subcell_1_1GhostData.html">GhostData</a>, boost::hash&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt; &gt; &gt; * &gt; ghost_data_ptr, const <a class="el" href="classDataVector.html">DataVector</a> &amp;neighbor_subcell_data, const size_t number_of_rdmp_vars_in_buffer, const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt; &amp;directional_element_id, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;neighbor_mesh, const <a class="el" href="classElement.html">Element</a>&lt; Dim &gt; &amp;element, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;subcell_mesh, size_t number_of_ghost_zones)</td></tr>
<tr class="memdesc:aee609bf42e12844e2fbb439c013c4af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether <code>neighbor_subcell_data</code> is FD or DG, and either insert or copy into <code>ghost_data_ptr</code> the FD data (projecting if <code>neighbor_subcell_data</code> is DG data).  <a href="namespaceevolution_1_1dg_1_1subcell.html#aee609bf42e12844e2fbb439c013c4af3">More...</a><br /></td></tr>
<tr class="separator:aee609bf42e12844e2fbb439c013c4af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6998dd72dd08dcd581e9acd53bb0c75a"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:a6998dd72dd08dcd581e9acd53bb0c75a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#a6998dd72dd08dcd581e9acd53bb0c75a">insert_neighbor_rdmp_and_volume_data</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="structevolution_1_1dg_1_1subcell_1_1RdmpTciData.html">RdmpTciData</a> * &gt; rdmp_tci_data_ptr, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classFixedHashMap.html">FixedHashMap</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#gafa8cb44daebc8f9e080718961530be89">maximum_number_of_neighbors</a>(Dim), <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt;, <a class="el" href="classevolution_1_1dg_1_1subcell_1_1GhostData.html">GhostData</a>, boost::hash&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt; &gt; &gt; * &gt; ghost_data_ptr, const <a class="el" href="classDataVector.html">DataVector</a> &amp;received_neighbor_subcell_data, size_t number_of_rdmp_vars, const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt; &amp;directional_element_id, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;neighbor_mesh, const <a class="el" href="classElement.html">Element</a>&lt; Dim &gt; &amp;element, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;subcell_mesh, size_t number_of_ghost_zones)</td></tr>
<tr class="memdesc:a6998dd72dd08dcd581e9acd53bb0c75a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the neighbor sent is DG volume or FD ghost data, and orient project DG volume data if necessary.  <a href="namespaceevolution_1_1dg_1_1subcell.html#a6998dd72dd08dcd581e9acd53bb0c75a">More...</a><br /></td></tr>
<tr class="separator:a6998dd72dd08dcd581e9acd53bb0c75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca182ae940c3ada2e7bc0e3763bab281"><td class="memTemplParams" colspan="2">template&lt;typename Metavariables , typename DbTagsList &gt; </td></tr>
<tr class="memitem:aca182ae940c3ada2e7bc0e3763bab281"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#aca182ae940c3ada2e7bc0e3763bab281">neighbor_reconstructed_face_solution</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; db::DataBox&lt; DbTagsList &gt; * &gt; box, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; const <a class="el" href="classTimeStepId.html">TimeStepId</a>, <a class="el" href="classFixedHashMap.html">FixedHashMap</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#gafa8cb44daebc8f9e080718961530be89">maximum_number_of_neighbors</a>(Metavariables::volume_dim), <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Metavariables::volume_dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Metavariables::volume_dim &gt; &gt;, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; <a class="el" href="classMesh.html">Mesh</a>&lt; Metavariables::volume_dim &gt;, <a class="el" href="classMesh.html">Mesh</a>&lt; Metavariables::volume_dim - 1 &gt;, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt;, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt;, <a class="el" href="classTimeStepId.html">::TimeStepId</a>, int &gt;, boost::hash&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Metavariables::volume_dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Metavariables::volume_dim &gt; &gt; &gt; &gt; &gt; * &gt; received_temporal_id_and_data)</td></tr>
<tr class="memdesc:aca182ae940c3ada2e7bc0e3763bab281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked in directions where the neighbor is doing subcell, this function computes the neighbor data on the mortar via reconstruction on nearest neighbor subcells.  <a href="namespaceevolution_1_1dg_1_1subcell.html#aca182ae940c3ada2e7bc0e3763bab281">More...</a><br /></td></tr>
<tr class="separator:aca182ae940c3ada2e7bc0e3763bab281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab36958d5350e060c6f19ccb15fa01f1"><td class="memTemplParams" colspan="2"><a id="aab36958d5350e060c6f19ccb15fa01f1" name="aab36958d5350e060c6f19ccb15fa01f1"></a>
template&lt;size_t Dim, typename DbTagsList &gt; </td></tr>
<tr class="memitem:aab36958d5350e060c6f19ccb15fa01f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>neighbor_tci_decision</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; db::DataBox&lt; DbTagsList &gt; * &gt; box, const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; const <a class="el" href="classTimeStepId.html">TimeStepId</a>, <a class="el" href="classFixedHashMap.html">FixedHashMap</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#gafa8cb44daebc8f9e080718961530be89">maximum_number_of_neighbors</a>(Dim), <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt;, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt;, <a class="el" href="classMesh.html">Mesh</a>&lt; Dim - 1 &gt;, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt;, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt;, <a class="el" href="classTimeStepId.html">::TimeStepId</a>, int &gt;, boost::hash&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt; &gt; &gt; &gt; &amp;received_temporal_id_and_data)</td></tr>
<tr class="memdesc:aab36958d5350e060c6f19ccb15fa01f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the neighbors' TCI decisions into <code><a class="el" href="structevolution_1_1dg_1_1subcell_1_1Tags_1_1NeighborTciDecisions.html" title="The TCI decision of neighboring elements.">subcell::Tags::NeighborTciDecisions</a>&lt;Dim&gt;</code> <br /></td></tr>
<tr class="separator:aab36958d5350e060c6f19ccb15fa01f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53caeb742f1c7fe2955b833ec3f267f"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename SymmList , typename IndexList &gt; </td></tr>
<tr class="memitem:ab53caeb742f1c7fe2955b833ec3f267f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#ab53caeb742f1c7fe2955b833ec3f267f">persson_tci</a> (const Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, SymmList, IndexList &gt; &amp;tensor, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;dg_mesh, const double alpha)</td></tr>
<tr class="memdesc:ab53caeb742f1c7fe2955b833ec3f267f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Troubled cell indicator using spectral falloff of <a class="el" href="citelist.html#CITEREF_Persson2006sub">[134]</a>.  <a href="namespaceevolution_1_1dg_1_1subcell.html#ab53caeb742f1c7fe2955b833ec3f267f">More...</a><br /></td></tr>
<tr class="separator:ab53caeb742f1c7fe2955b833ec3f267f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f770ea96f73949462bd9dbf0686af20"><td class="memTemplParams" colspan="2">template&lt;typename Metavariables , typename DbTagsList , size_t Dim&gt; </td></tr>
<tr class="memitem:a0f770ea96f73949462bd9dbf0686af20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#a0f770ea96f73949462bd9dbf0686af20">prepare_neighbor_data</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt; all_neighbor_data_for_reconstruction, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; * &gt; ghost_data_mesh, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; db::DataBox&lt; DbTagsList &gt; * &gt; box, const Variables&lt; <a class="el" href="group__DataBoxTagsGroup.html#ga3dda5a16c7f6baccd115de2c8f12394e">db::wrap_tags_in</a>&lt; <a class="el" href="structTags_1_1Flux.html">::Tags::Flux</a>, typename Metavariables::system::flux_variables, tmpl::size_t&lt; Dim &gt;, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &gt; &amp;volume_fluxes)</td></tr>
<tr class="memdesc:a0f770ea96f73949462bd9dbf0686af20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add local data for our and our neighbor's relaxed discrete maximum principle troubled-cell indicator, and for reconstruction.  <a href="namespaceevolution_1_1dg_1_1subcell.html#a0f770ea96f73949462bd9dbf0686af20">More...</a><br /></td></tr>
<tr class="separator:a0f770ea96f73949462bd9dbf0686af20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04bfc6367ec31daa48a01d47f5d0bf1"><td class="memTemplParams" colspan="2">template&lt;typename... EvolvedVarsTags&gt; </td></tr>
<tr class="memitem:ae04bfc6367ec31daa48a01d47f5d0bf1"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#ae04bfc6367ec31daa48a01d47f5d0bf1">rdmp_tci</a> (const Variables&lt; tmpl::list&lt; EvolvedVarsTags... &gt; &gt; &amp;active_grid_candidate_evolved_vars, const Variables&lt; tmpl::list&lt; <a class="el" href="structevolution_1_1dg_1_1subcell_1_1Tags_1_1Inactive.html">Tags::Inactive</a>&lt; EvolvedVarsTags &gt;... &gt; &gt; &amp;inactive_grid_candidate_evolved_vars, const <a class="el" href="classDataVector.html">DataVector</a> &amp;max_of_past_variables, const <a class="el" href="classDataVector.html">DataVector</a> &amp;min_of_past_variables, const double rdmp_delta0, const double rdmp_epsilon)</td></tr>
<tr class="memdesc:ae04bfc6367ec31daa48a01d47f5d0bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Troubled cell indicator using a relaxed discrete maximum principle, comparing the candidate solution with the past solution in the element and its neighbors.  <a href="namespaceevolution_1_1dg_1_1subcell.html#ae04bfc6367ec31daa48a01d47f5d0bf1">More...</a><br /></td></tr>
<tr class="separator:ae04bfc6367ec31daa48a01d47f5d0bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e9fe496939c9920cb09b055e1162ba"><td class="memTemplParams" colspan="2"><a id="a31e9fe496939c9920cb09b055e1162ba" name="a31e9fe496939c9920cb09b055e1162ba"></a>
template&lt;typename... EvolvedVarsTags&gt; </td></tr>
<tr class="memitem:a31e9fe496939c9920cb09b055e1162ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDataVector.html">DataVector</a>, <a class="el" href="classDataVector.html">DataVector</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rdmp_max_min</b> (const Variables&lt; tmpl::list&lt; EvolvedVarsTags... &gt; &gt; &amp;active_grid_evolved_vars, const Variables&lt; tmpl::list&lt; <a class="el" href="structevolution_1_1dg_1_1subcell_1_1Tags_1_1Inactive.html">Tags::Inactive</a>&lt; EvolvedVarsTags &gt;... &gt; &gt; &amp;inactive_grid_evolved_vars, const bool include_inactive_grid)</td></tr>
<tr class="memdesc:a31e9fe496939c9920cb09b055e1162ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the max and min of each component of the active and inactive variables. If <code>include_inactive_grid</code> is <code>false</code> then only the max over the <code>active_grid_evolved_vars</code> for each component is returned. <br /></td></tr>
<tr class="separator:a31e9fe496939c9920cb09b055e1162ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6477f2a8b72046da2cea3af3d2cd321a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#a6477f2a8b72046da2cea3af3d2cd321a">rdmp_tci</a> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;max_of_current_variables, const <a class="el" href="classDataVector.html">DataVector</a> &amp;min_of_current_variables, const <a class="el" href="classDataVector.html">DataVector</a> &amp;max_of_past_variables, const <a class="el" href="classDataVector.html">DataVector</a> &amp;min_of_past_variables, double rdmp_delta0, double rdmp_epsilon)</td></tr>
<tr class="memdesc:a6477f2a8b72046da2cea3af3d2cd321a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the current variables satisfy the RDMP. Returns an integer <code>0</code> if cell is not troubled and an integer <code>i+1</code> if the <code>[i]</code>-th element of the input vector is responsible for failing the RDMP.  <a href="namespaceevolution_1_1dg_1_1subcell.html#a6477f2a8b72046da2cea3af3d2cd321a">More...</a><br /></td></tr>
<tr class="separator:a6477f2a8b72046da2cea3af3d2cd321a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08bd5601a2f8a45020a0560874ec1bee"><td class="memItemLeft" align="right" valign="top"><a id="a08bd5601a2f8a45020a0560874ec1bee" name="a08bd5601a2f8a45020a0560874ec1bee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pup</b> (PUP::er &amp;p, <a class="el" href="structevolution_1_1dg_1_1subcell_1_1RdmpTciData.html">RdmpTciData</a> &amp;rdmp_tci_data)</td></tr>
<tr class="separator:a08bd5601a2f8a45020a0560874ec1bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecbba5504a2b65408db342e144e39d56"><td class="memItemLeft" align="right" valign="top"><a id="aecbba5504a2b65408db342e144e39d56" name="aecbba5504a2b65408db342e144e39d56"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator|</b> (PUP::er &amp;p, <a class="el" href="structevolution_1_1dg_1_1subcell_1_1RdmpTciData.html">RdmpTciData</a> &amp;rdmp_tci_data)</td></tr>
<tr class="separator:aecbba5504a2b65408db342e144e39d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb704aea399becf5a60440cdc0965c1"><td class="memItemLeft" align="right" valign="top"><a id="afdb704aea399becf5a60440cdc0965c1" name="afdb704aea399becf5a60440cdc0965c1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structevolution_1_1dg_1_1subcell_1_1RdmpTciData.html">RdmpTciData</a> &amp;lhs, const <a class="el" href="structevolution_1_1dg_1_1subcell_1_1RdmpTciData.html">RdmpTciData</a> &amp;rhs)</td></tr>
<tr class="separator:afdb704aea399becf5a60440cdc0965c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb97b7990f700e9e8690044b554d50ac"><td class="memItemLeft" align="right" valign="top"><a id="adb97b7990f700e9e8690044b554d50ac" name="adb97b7990f700e9e8690044b554d50ac"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structevolution_1_1dg_1_1subcell_1_1RdmpTciData.html">RdmpTciData</a> &amp;lhs, const <a class="el" href="structevolution_1_1dg_1_1subcell_1_1RdmpTciData.html">RdmpTciData</a> &amp;rhs)</td></tr>
<tr class="separator:adb97b7990f700e9e8690044b554d50ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff1254c4d1a141ffbd17ea0a25fa281"><td class="memItemLeft" align="right" valign="top"><a id="adff1254c4d1a141ffbd17ea0a25fa281" name="adff1254c4d1a141ffbd17ea0a25fa281"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="el" href="structevolution_1_1dg_1_1subcell_1_1RdmpTciData.html">RdmpTciData</a> &amp;t)</td></tr>
<tr class="separator:adff1254c4d1a141ffbd17ea0a25fa281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32e9fb1a1ed647f39f74c569d8a5414"><td class="memTemplParams" colspan="2"><a id="af32e9fb1a1ed647f39f74c569d8a5414" name="af32e9fb1a1ed647f39f74c569d8a5414"></a>
template&lt;size_t Dim, typename DbTagsList &gt; </td></tr>
<tr class="memitem:af32e9fb1a1ed647f39f74c569d8a5414"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>store_reconstruction_order_in_databox</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; db::DataBox&lt; DbTagsList &gt; * &gt; box, const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint8_t</a> &gt;, Dim &gt; &gt; &amp;reconstruction_order)</td></tr>
<tr class="memdesc:af32e9fb1a1ed647f39f74c569d8a5414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the <code>reconstruction_order</code> into the DataBox tag <code><a class="el" href="structevolution_1_1dg_1_1subcell_1_1Tags_1_1ReconstructionOrder.html" title="The reconstruction order.">evolution::dg::subcell::Tags::ReconstructionOrder</a></code> if <code>reconstruction_order</code> has a value. <br /></td></tr>
<tr class="separator:af32e9fb1a1ed647f39f74c569d8a5414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb9fa79f5014399c3bf62ab416f0624"><td class="memTemplParams" colspan="2"><a id="a5bb9fa79f5014399c3bf62ab416f0624" name="a5bb9fa79f5014399c3bf62ab416f0624"></a>
template&lt;size_t Dim, typename VectorType &gt; </td></tr>
<tr class="memitem:a5bb9fa79f5014399c3bf62ab416f0624"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>slice_tensor_for_subcell</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Tensor&lt; VectorType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt;&gt;, index_list&lt;&gt; &gt; * &gt; sliced_scalar, const Tensor&lt; VectorType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt;&gt;, index_list&lt;&gt; &gt; &amp;volume_scalar, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;subcell_extents, size_t number_of_ghost_points, const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;direction)</td></tr>
<tr class="separator:a5bb9fa79f5014399c3bf62ab416f0624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cef1c11c1fb9f3d8bca3ca505cd961"><td class="memItemLeft" align="right" valign="top"><a id="a53cef1c11c1fb9f3d8bca3ca505cd961" name="a53cef1c11c1fb9f3d8bca3ca505cd961"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classevolution_1_1dg_1_1subcell_1_1SubcellOptions.html">SubcellOptions</a> &amp;lhs, const <a class="el" href="classevolution_1_1dg_1_1subcell_1_1SubcellOptions.html">SubcellOptions</a> &amp;rhs)</td></tr>
<tr class="separator:a53cef1c11c1fb9f3d8bca3ca505cd961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c02183663dba6309a17ebfdf336c2ba"><td class="memTemplParams" colspan="2">template&lt;typename... DgEvolvedVarsTags, typename... SubcellEvolvedVarsTags&gt; </td></tr>
<tr class="memitem:a4c02183663dba6309a17ebfdf336c2ba"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#a4c02183663dba6309a17ebfdf336c2ba">two_mesh_rdmp_tci</a> (const Variables&lt; tmpl::list&lt; DgEvolvedVarsTags... &gt; &gt; &amp;dg_evolved_vars, const Variables&lt; tmpl::list&lt; SubcellEvolvedVarsTags... &gt; &gt; &amp;subcell_evolved_vars, const double rdmp_delta0, const double rdmp_epsilon)</td></tr>
<tr class="memdesc:a4c02183663dba6309a17ebfdf336c2ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Troubled cell indicator using a relaxed discrete maximum principle, comparing the solution on two grids at the same point in time.  <a href="namespaceevolution_1_1dg_1_1subcell.html#a4c02183663dba6309a17ebfdf336c2ba">More...</a><br /></td></tr>
<tr class="separator:a4c02183663dba6309a17ebfdf336c2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abe52620b5dcd9ed2e7c0a7bc19abeedb"><td class="memItemLeft" align="right" valign="top"><a id="abe52620b5dcd9ed2e7c0a7bc19abeedb" name="abe52620b5dcd9ed2e7c0a7bc19abeedb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>add_cartesian_flux_divergence</b> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt; dt_var, double one_over_delta, const <a class="el" href="classDataVector.html">DataVector</a> &amp;inv_jacobian, const <a class="el" href="classDataVector.html">DataVector</a> &amp;boundary_correction, const <a class="el" href="classIndex.html">Index</a>&lt; 1 &gt; &amp;subcell_extents, size_t dimension)</td></tr>
<tr class="memdesc:abe52620b5dcd9ed2e7c0a7bc19abeedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and add the 2nd-order flux divergence on a Cartesian mesh to the cell-centered time derivatives. <br /></td></tr>
<tr class="separator:abe52620b5dcd9ed2e7c0a7bc19abeedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8afd602bce8d264d6f5d89f2eaccded"><td class="memItemLeft" align="right" valign="top"><a id="aa8afd602bce8d264d6f5d89f2eaccded" name="aa8afd602bce8d264d6f5d89f2eaccded"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>add_cartesian_flux_divergence</b> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt; dt_var, double one_over_delta, const <a class="el" href="classDataVector.html">DataVector</a> &amp;inv_jacobian, const <a class="el" href="classDataVector.html">DataVector</a> &amp;boundary_correction, const <a class="el" href="classIndex.html">Index</a>&lt; 2 &gt; &amp;subcell_extents, size_t dimension)</td></tr>
<tr class="memdesc:aa8afd602bce8d264d6f5d89f2eaccded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and add the 2nd-order flux divergence on a Cartesian mesh to the cell-centered time derivatives. <br /></td></tr>
<tr class="separator:aa8afd602bce8d264d6f5d89f2eaccded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a57972f935d235591528577c33a08e5"><td class="memItemLeft" align="right" valign="top"><a id="a3a57972f935d235591528577c33a08e5" name="a3a57972f935d235591528577c33a08e5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>add_cartesian_flux_divergence</b> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt; dt_var, double one_over_delta, const <a class="el" href="classDataVector.html">DataVector</a> &amp;inv_jacobian, const <a class="el" href="classDataVector.html">DataVector</a> &amp;boundary_correction, const <a class="el" href="classIndex.html">Index</a>&lt; 3 &gt; &amp;subcell_extents, size_t dimension)</td></tr>
<tr class="memdesc:a3a57972f935d235591528577c33a08e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and add the 2nd-order flux divergence on a Cartesian mesh to the cell-centered time derivatives. <br /></td></tr>
<tr class="separator:a3a57972f935d235591528577c33a08e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6f6039eeca5baad38a155d179da1f899"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:a6f6039eeca5baad38a155d179da1f899"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classDataVector.html">DataVector</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#a6f6039eeca5baad38a155d179da1f899">slice_data</a> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;volume_subcell_vars, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;subcell_extents, const size_t number_of_ghost_points, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &gt; &amp;directions_to_slice, const size_t additional_buffer)</td></tr>
<tr class="memdesc:a6f6039eeca5baad38a155d179da1f899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice the subcell variables needed for neighbors to perform reconstruction.  <a href="namespaceevolution_1_1dg_1_1subcell.html#a6f6039eeca5baad38a155d179da1f899">More...</a><br /></td></tr>
<tr class="separator:a6f6039eeca5baad38a155d179da1f899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3cf2d19b4537e4ed8872ad72d2f88b6"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename TagList &gt; </td></tr>
<tr class="memitem:ae3cf2d19b4537e4ed8872ad72d2f88b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classDataVector.html">DataVector</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#ae3cf2d19b4537e4ed8872ad72d2f88b6">slice_data</a> (const Variables&lt; TagList &gt; &amp;volume_subcell_vars, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;subcell_extents, const size_t number_of_ghost_points, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &gt; &amp;directions_to_slice, const size_t additional_buffer)</td></tr>
<tr class="memdesc:ae3cf2d19b4537e4ed8872ad72d2f88b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice the subcell variables needed for neighbors to perform reconstruction.  <a href="namespaceevolution_1_1dg_1_1subcell.html#ae3cf2d19b4537e4ed8872ad72d2f88b6">More...</a><br /></td></tr>
<tr class="separator:ae3cf2d19b4537e4ed8872ad72d2f88b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab0764d979685439b92d864c698cb94ce"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename VectorType , typename... Structure&gt; </td></tr>
<tr class="memitem:ab0764d979685439b92d864c698cb94ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#ab0764d979685439b92d864c698cb94ce">slice_tensor_for_subcell</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Tensor&lt; VectorType, Structure... &gt; * &gt; sliced_tensor, const Tensor&lt; VectorType, Structure... &gt; &amp;volume_tensor, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;subcell_extents, size_t number_of_ghost_points, const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;direction)</td></tr>
<tr class="memdesc:ab0764d979685439b92d864c698cb94ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice a single volume tensor for a given direction and slicing depth (number of ghost points).  <a href="namespaceevolution_1_1dg_1_1subcell.html#ab0764d979685439b92d864c698cb94ce">More...</a><br /></td></tr>
<tr class="separator:ab0764d979685439b92d864c698cb94ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889fdc939c8993085b769d14bd8abf3f"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename VectorType , typename... Structure&gt; </td></tr>
<tr class="memitem:a889fdc939c8993085b769d14bd8abf3f"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; VectorType, Structure... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#a889fdc939c8993085b769d14bd8abf3f">slice_tensor_for_subcell</a> (const Tensor&lt; VectorType, Structure... &gt; &amp;volume_tensor, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;subcell_extents, size_t number_of_ghost_points, const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;direction)</td></tr>
<tr class="memdesc:a889fdc939c8993085b769d14bd8abf3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice a single volume tensor for a given direction and slicing depth (number of ghost points).  <a href="namespaceevolution_1_1dg_1_1subcell.html#a889fdc939c8993085b769d14bd8abf3f">More...</a><br /></td></tr>
<tr class="separator:a889fdc939c8993085b769d14bd8abf3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac8b7317e7b3e03f813fd59f7274544f0"><td class="memTemplParams" colspan="2"><a id="ac8b7317e7b3e03f813fd59f7274544f0" name="ac8b7317e7b3e03f813fd59f7274544f0"></a>
template&lt;size_t Dim, typename TagList &gt; </td></tr>
<tr class="memitem:ac8b7317e7b3e03f813fd59f7274544f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>slice_variable</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; TagList &gt; * &gt; &amp;sliced_subcell_vars, const Variables&lt; TagList &gt; &amp;volume_subcell_vars, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;subcell_extents, const size_t ghost_zone_size, const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;direction)</td></tr>
<tr class="memdesc:ac8b7317e7b3e03f813fd59f7274544f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice a Variables object on subcell mesh for a given direction and slicing depth (number of ghost points). <br /></td></tr>
<tr class="separator:ac8b7317e7b3e03f813fd59f7274544f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c505ac90c24fe39b6fac3c61e5a790"><td class="memTemplParams" colspan="2"><a id="a15c505ac90c24fe39b6fac3c61e5a790" name="a15c505ac90c24fe39b6fac3c61e5a790"></a>
template&lt;size_t Dim, typename TagList &gt; </td></tr>
<tr class="memitem:a15c505ac90c24fe39b6fac3c61e5a790"><td class="memTemplItemLeft" align="right" valign="top">Variables&lt; TagList &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>slice_variable</b> (const Variables&lt; TagList &gt; &amp;volume_subcell_vars, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;subcell_extents, const size_t ghost_zone_size, const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;direction)</td></tr>
<tr class="memdesc:a15c505ac90c24fe39b6fac3c61e5a790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice a Variables object on subcell mesh for a given direction and slicing depth (number of ghost points). <br /></td></tr>
<tr class="separator:a15c505ac90c24fe39b6fac3c61e5a790"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Implementation of a generic finite volume/conservative finite difference subcell limiter. </p>
<p >Our implementation of a finite volume (FV) or finite difference (FD) subcell limiter (SCL) follows <a class="el" href="citelist.html#CITEREF_Dumbser2014a">[56]</a>. Other implementations of a subcell limiter exist, e.g. <a class="el" href="citelist.html#CITEREF_Sonntag2014">[150]</a> <a class="el" href="citelist.html#CITEREF_Casoni2012">[31]</a> <a class="el" href="citelist.html#CITEREF_Hou2007">[82]</a>. Our implementation and that of <a class="el" href="citelist.html#CITEREF_Dumbser2014a">[56]</a> are a generalization of the Multidimensional Optimal Order Detection (MOOD) algorithm <a class="el" href="citelist.html#CITEREF_CLAIN20114028">[37]</a> <a class="el" href="citelist.html#CITEREF_DIOT201243">[53]</a> <a class="el" href="citelist.html#CITEREF_Diot2013">[54]</a> <a class="el" href="citelist.html#CITEREF_Loubere2014">[109]</a>. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a8263c2bbf2b8eb7e43ebcc29a7281559" name="a8263c2bbf2b8eb7e43ebcc29a7281559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8263c2bbf2b8eb7e43ebcc29a7281559">&#9670;&nbsp;</a></span>correct_package_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool OverwriteInternalMortarData, size_t Dim, typename DgPackageFieldTags &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void evolution::dg::subcell::correct_package_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; DgPackageFieldTags &gt; * &gt;&#160;</td>
          <td class="paramname"><em>lower_packaged_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; DgPackageFieldTags &gt; * &gt;&#160;</td>
          <td class="paramname"><em>upper_packaged_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>logical_dimension_to_operate_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_volume_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt;, <a class="el" href="classevolution_1_1dg_1_1MortarData.html">evolution::dg::MortarData</a>&lt; Dim &gt;, boost::hash&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mortar_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>variables_to_offset_in_dg_grid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project the DG package data to the subcells. Data received from a neighboring element doing DG is always projected, while the data we sent to our neighbors before doing a rollback from DG to subcell is only projected if <code>OverwriteInternalMortarData</code> is <code>true</code>. </p>
<p >In order for the hybrid DG-FD/FV scheme to be conservative between elements using DG and elements using subcell, the boundary terms must be the same on both elements. In practice this means the boundary corrections \(G+D\) must be computed on the same grid. Consider the element doing subcell which receives data from an element doing DG. In this case the DG element's ingredients going into \(G+D\) are projected to the subcells and then \(G+D\) are computed on the subcells. Similarly, for strict conservation the element doing DG must first project the data it sent to the neighbor to the subcells, then compute \(G+D\) on the subcells, and finally reconstrct \(G+D\) back to the DG grid before lifting \(G+D\) to the volume.</p>
<p >This function updates the <code>packaged_data</code> (ingredients into \(G+D\)) received by an element doing subcell by projecting the neighbor's DG data onto the subcells. Note that this is only half of what is required for strict conservation, the DG element must also compute \(G+D\) on the subcells. Note that we currently do not perform the other half of the correction needed to be strictly conservative.</p>
<p >If we are retaking a time step after the DG step failed then maintaining conservation requires additional care. If <code>OverwriteInternalMortarData</code> is <code>true</code> then the local (the element switching from DG to subcell) ingredients into \(G+D\) are projected and overwrite the data computed from the FD reconstruction to the interface. However, even this is insufficient to guarantee conservation. To guarantee conservation (which we do not currently do) the correction \(G+D\) must be computed on the DG grid and then projected to the subcells.</p>
<p >Note that our practical experience shows that since the DG-subcell hybrid scheme switches to the subcell solver <em>before</em> the local solution contains discontinuities, strict conservation is not necessary between DG and FD/FV regions. This was also observed with a block-adaptive finite difference AMR code <a class="el" href="citelist.html#CITEREF_CHEN2016604">[35]</a></p>
<p >The variable <code>variables_to_offset_in_dg_grid</code> is used in cases like the combined generalized harmonic and GRMHD system where the DG grid uses boundary corrections for both GH and GRMHD, but the subcell grid only does GRMHD. </p>

</div>
</div>
<a id="a6998dd72dd08dcd581e9acd53bb0c75a" name="a6998dd72dd08dcd581e9acd53bb0c75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6998dd72dd08dcd581e9acd53bb0c75a">&#9670;&nbsp;</a></span>insert_neighbor_rdmp_and_volume_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void evolution::dg::subcell::insert_neighbor_rdmp_and_volume_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="structevolution_1_1dg_1_1subcell_1_1RdmpTciData.html">RdmpTciData</a> * &gt;&#160;</td>
          <td class="paramname"><em>rdmp_tci_data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classFixedHashMap.html">FixedHashMap</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#gafa8cb44daebc8f9e080718961530be89">maximum_number_of_neighbors</a>(Dim), <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt;, <a class="el" href="classevolution_1_1dg_1_1subcell_1_1GhostData.html">GhostData</a>, boost::hash&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt; &gt; &gt; * &gt;&#160;</td>
          <td class="paramname"><em>ghost_data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>received_neighbor_subcell_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_rdmp_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>directional_element_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbor_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_ghost_zones</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the neighbor sent is DG volume or FD ghost data, and orient project DG volume data if necessary. </p>
<p >This is intended to be used by the <code>ReceiveDataForReconstruction</code> action. </p>

</div>
</div>
<a id="aee609bf42e12844e2fbb439c013c4af3" name="aee609bf42e12844e2fbb439c013c4af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee609bf42e12844e2fbb439c013c4af3">&#9670;&nbsp;</a></span>insert_or_update_neighbor_volume_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool InsertIntoMap, size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void evolution::dg::subcell::insert_or_update_neighbor_volume_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classFixedHashMap.html">FixedHashMap</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#gafa8cb44daebc8f9e080718961530be89">maximum_number_of_neighbors</a>(Dim), <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt;, <a class="el" href="classevolution_1_1dg_1_1subcell_1_1GhostData.html">GhostData</a>, boost::hash&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt; &gt; &gt; * &gt;&#160;</td>
          <td class="paramname"><em>ghost_data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>neighbor_subcell_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>number_of_rdmp_vars_in_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>directional_element_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbor_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_ghost_zones</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether <code>neighbor_subcell_data</code> is FD or DG, and either insert or copy into <code>ghost_data_ptr</code> the FD data (projecting if <code>neighbor_subcell_data</code> is DG data). </p>
<p >This is intended to be used during a rollback from DG to make sure neighbor data is projected to the FD grid. </p>

</div>
</div>
<a id="aca182ae940c3ada2e7bc0e3763bab281" name="aca182ae940c3ada2e7bc0e3763bab281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca182ae940c3ada2e7bc0e3763bab281">&#9670;&nbsp;</a></span>neighbor_reconstructed_face_solution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Metavariables , typename DbTagsList &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void evolution::dg::subcell::neighbor_reconstructed_face_solution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; db::DataBox&lt; DbTagsList &gt; * &gt;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; const <a class="el" href="classTimeStepId.html">TimeStepId</a>, <a class="el" href="classFixedHashMap.html">FixedHashMap</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#gafa8cb44daebc8f9e080718961530be89">maximum_number_of_neighbors</a>(Metavariables::volume_dim), <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Metavariables::volume_dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Metavariables::volume_dim &gt; &gt;, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; <a class="el" href="classMesh.html">Mesh</a>&lt; Metavariables::volume_dim &gt;, <a class="el" href="classMesh.html">Mesh</a>&lt; Metavariables::volume_dim - 1 &gt;, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt;, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt;, <a class="el" href="classTimeStepId.html">::TimeStepId</a>, int &gt;, boost::hash&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Metavariables::volume_dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Metavariables::volume_dim &gt; &gt; &gt; &gt; &gt; * &gt;&#160;</td>
          <td class="paramname"><em>received_temporal_id_and_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoked in directions where the neighbor is doing subcell, this function computes the neighbor data on the mortar via reconstruction on nearest neighbor subcells. </p>
<p >The data needed for reconstruction is copied over into <code><a class="el" href="structevolution_1_1dg_1_1subcell_1_1Tags_1_1GhostDataForReconstruction.html" title="The ghost data used for reconstructing the solution on the interfaces between elements.">subcell::Tags::GhostDataForReconstruction</a></code>. Additionally, the max/min of the evolved variables from neighboring elements that is used for the relaxed discrete maximum principle troubled-cell indicator is combined with the data from the local element and stored in <code><a class="el" href="structevolution_1_1dg_1_1subcell_1_1Tags_1_1DataForRdmpTci.html" title="The data for the RDMP troubled-cell indicator.">subcell::Tags::DataForRdmpTci</a></code>. We handle the RDMP data now because it is sent in the same buffer as the data for reconstruction.</p>
<p >A list of all the directions that are doing subcell is created and then passed to the mutator <code>Metavariables::SubcellOptions::DgComputeSubcellNeighborPackagedData::apply</code>, which must return a</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classFixedHashMap.html">FixedHashMap</a>&lt;</div>
<div class="line">    <a class="code hl_function" href="group__ComputationalDomainGroup.html#gafa8cb44daebc8f9e080718961530be89">maximum_number_of_neighbors</a>(volume_dim),</div>
<div class="line">    <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;Direction&lt;volume_dim&gt;</a>, <a class="code hl_class" href="classElementId.html">ElementId&lt;volume_dim&gt;</a>&gt;,</div>
<div class="line">    <a class="code hl_class" href="classDataVector.html">DataVector</a>,</div>
<div class="line">    boost::hash&lt;std::pair&lt;Direction&lt;volume_dim&gt;, <a class="code hl_class" href="classElementId.html">ElementId&lt;volume_dim&gt;</a>&gt;&gt;&gt;</div>
<div class="ttc" id="aclassDataVector_html"><div class="ttname"><a href="classDataVector.html">DataVector</a></div><div class="ttdoc">Stores a collection of function values.</div><div class="ttdef"><b>Definition:</b> DataVector.hpp:48</div></div>
<div class="ttc" id="aclassElementId_html"><div class="ttname"><a href="classElementId.html">ElementId</a></div><div class="ttdoc">An ElementId uniquely labels an Element.</div><div class="ttdef"><b>Definition:</b> ElementId.hpp:52</div></div>
<div class="ttc" id="aclassFixedHashMap_html"><div class="ttname"><a href="classFixedHashMap.html">FixedHashMap</a></div><div class="ttdoc">A hash table with a compile-time specified maximum size and ability to efficiently handle perfect has...</div><div class="ttdef"><b>Definition:</b> FixedHashMap.hpp:81</div></div>
<div class="ttc" id="agroup__ComputationalDomainGroup_html_gafa8cb44daebc8f9e080718961530be89"><div class="ttname"><a href="group__ComputationalDomainGroup.html#gafa8cb44daebc8f9e080718961530be89">maximum_number_of_neighbors</a></div><div class="ttdeci">constexpr size_t maximum_number_of_neighbors(const size_t dim)</div><div class="ttdoc">Returns the maximum number of neighbors an element can have in dim dimensions.</div><div class="ttdef"><b>Definition:</b> MaxNumberOfNeighbors.hpp:15</div></div>
<div class="ttc" id="apair_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a></div></div>
</div><!-- fragment --><p >which holds the reconstructed <code>dg_packaged_data</code> on the face (stored in the <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code>) for the boundary correction. A <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt;<a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis.">Direction</a>&lt;volume_dim&gt;, <a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a>&lt;volume_dim&gt;&gt;&gt;</code> holding the list of mortars that need to be reconstructed to is passed in as the last argument to <code>Metavariables::SubcellOptions::DgComputeSubcellNeighborPackagedData::apply</code>. </p>

</div>
</div>
<a id="ab53caeb742f1c7fe2955b833ec3f267f" name="ab53caeb742f1c7fe2955b833ec3f267f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab53caeb742f1c7fe2955b833ec3f267f">&#9670;&nbsp;</a></span>persson_tci()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename SymmList , typename IndexList &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool evolution::dg::subcell::persson_tci </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, SymmList, IndexList &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dg_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Troubled cell indicator using spectral falloff of <a class="el" href="citelist.html#CITEREF_Persson2006sub">[134]</a>. </p>
<p >Consider a discontinuity sensing quantity \(U\), which is typically a scalar but could be a tensor of any rank. Let \(U\) have the 1d spectral decomposition (generalization to higher-dimensional tensor product bases is done dimension-by-dimension):</p>
<p class="formulaDsp">
\begin{align*} U(x)=\sum_{i=0}^{N}c_i P_i(x), \end{align*}
</p>
<p >where \(P_i(x)\) are the basis functions, in our case the Legendre polynomials, and \(c_i\) are the spectral coefficients. We then define a filtered solution \(\hat{U}\) as</p>
<p class="formulaDsp">
\begin{align*} \hat{U}(x)=c_N P_N(x). \end{align*}
</p>
<p >Note that when an exponential filter is being used to deal with aliasing, lower modes can be included in \(\hat{U}\). The main goal of \(\hat{U}\) is to measure how much power is in the highest modes, which are the modes responsible for Gibbs phenomena. We define the discontinuity indicator \(s^\Omega\) as</p>
<p class="formulaDsp">
\begin{align*} s^\Omega=\log_{10}\left(\frac{(\hat{U}, \hat{U})}{(U, U)}\right), \end{align*}
</p>
<p >where \((\cdot,\cdot)\) is an inner product, which we take to be the Euclidean \(L_2\) norm (i.e. we do not divide by the number of grid points since that cancels out anyway). A cell is troubled if \(s^\Omega &gt; -\alpha \log_{10}(N)\). Typically, \(\alpha=4\) is a good choice.</p>
<p >The parameter <code>zero_cutoff</code> is used to avoid division and logarithms of small numbers, which can be wildly fluctuating because of roundoff errors. We do not check the TCI for tensor components when \(L_2(\hat{U}) \leq \epsilon L_2(U)\), where \(\epsilon\) is the <code>zero_cutoff</code>. If all components are skipped the TCI returns <code>false</code>, i.e. the cell is not troubled. </p>

</div>
</div>
<a id="a0f770ea96f73949462bd9dbf0686af20" name="a0f770ea96f73949462bd9dbf0686af20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f770ea96f73949462bd9dbf0686af20">&#9670;&nbsp;</a></span>prepare_neighbor_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Metavariables , typename DbTagsList , size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void evolution::dg::subcell::prepare_neighbor_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>all_neighbor_data_for_reconstruction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; * &gt;&#160;</td>
          <td class="paramname"><em>ghost_data_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; db::DataBox&lt; DbTagsList &gt; * &gt;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Variables&lt; <a class="el" href="group__DataBoxTagsGroup.html#ga3dda5a16c7f6baccd115de2c8f12394e">db::wrap_tags_in</a>&lt; <a class="el" href="structTags_1_1Flux.html">::Tags::Flux</a>, typename Metavariables::system::flux_variables, tmpl::size_t&lt; Dim &gt;, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_fluxes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add local data for our and our neighbor's relaxed discrete maximum principle troubled-cell indicator, and for reconstruction. </p>
<p >The local maximum and minimum of the evolved variables is added to <code><a class="el" href="structevolution_1_1dg_1_1subcell_1_1Tags_1_1DataForRdmpTci.html" title="The data for the RDMP troubled-cell indicator.">Tags::DataForRdmpTci</a></code> for the RDMP TCI. Then the data needed by neighbor elements to do reconstruction on the FD grid is sent. The data to be sent is computed in the mutator <code>Metavariables::SubcellOptions::GhostVariables</code>, which returns a <code>Variables</code> of the tensors to send to the neighbors. The main reason for having the mutator <code>GhostVariables</code> is to allow sending primitive or characteristic variables for reconstruction.</p>
<dl class="section note"><dt>Note</dt><dd>If all neighbors are using DG then we send our DG volume data <em>without</em> orienting it. This elides the expense of projection and slicing. If any neighbors are doing FD, we project and slice to all neighbors. A future optimization would be to measure the cost of slicing data, and figure out how many neighbors need to be doing FD before it's worth projecting and slicing vs. just projecting to the ghost cells. Another optimization is to always send DG volume data to neighbors that we think are doing DG, so that we can elide any slicing or projection cost in that direction. </dd></dl>

</div>
</div>
<a id="a6477f2a8b72046da2cea3af3d2cd321a" name="a6477f2a8b72046da2cea3af3d2cd321a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6477f2a8b72046da2cea3af3d2cd321a">&#9670;&nbsp;</a></span>rdmp_tci() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evolution::dg::subcell::rdmp_tci </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>max_of_current_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>min_of_current_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>max_of_past_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>min_of_past_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rdmp_delta0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rdmp_epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the current variables satisfy the RDMP. Returns an integer <code>0</code> if cell is not troubled and an integer <code>i+1</code> if the <code>[i]</code>-th element of the input vector is responsible for failing the RDMP. </p>
<p >Let the candidate solution be denoted by \(u^\star_{\alpha}(t^{n+1})\). Then the RDMP requires that</p>
<p class="formulaDsp">
\begin{align*} \min_{\forall\mathcal{N}}\left(u_{\alpha}(t^n)\right) - \delta_\alpha \le u^\star_{\alpha}(t^{n+1}) \le \max_{\forall\mathcal{N}} \left(u_{\alpha}(t^n)\right) + \delta_\alpha \end{align*}
</p>
<p >where \(\mathcal{N}\) are either the Neumann or Voronoi neighbors and the element itself, and \(\delta_\alpha\) is a parameter defined below that relaxes the discrete maximum principle (DMP). When computing \(\max(u_\alpha)\) and \(\min(u_\alpha)\) over a DG element that is not using subcells we first project the DG solution to the subcells and then compute the maximum and minimum over <em>both</em> the DG grid and the subcell grid. However, when a DG element is using subcells we compute the maximum and minimum of \(u_\alpha(t^n)\) over the subcells only. Note that the maximum and minimum values of \(u^\star_\alpha\) are always computed over both the DG and the subcell grids, even when using the RDMP to check if the reconstructed DG solution would be admissible.</p>
<p >The parameter \(\delta_\alpha\) is given by:</p>
<p class="formulaDsp">
\begin{align*} \delta_\alpha = \max\left(\delta_{0},\epsilon \left(\max_{\forall\mathcal{N}}\left(u_{\alpha}(t^n)\right) - \min_{\forall\mathcal{N}}\left(u_{\alpha}(t^n)\right)\right) \right), \end{align*}
</p>
<p >where we typically take \(\delta_{0}=10^{-4}\) and \(\epsilon=10^{-3}\).</p>
<p >If all checks are passed and cell is not troubled, returns an integer <code>0</code>. Otherwise returns an 1-based index of the element in the input <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code> that fails the check.</p>
<p >e.g. Suppose we have three variables to check RDMP so that <code>max_of_current_variables.size() == 3</code>. If RDMP TCI flags <code>max_of_current_variables[1]</code>, <code>min_of_current_variables[1]</code>, .. (and so on) as troubled, returned integer value is <code>2</code>.</p>
<p >Once cell is marked as troubled, checks for the remaining part of the input <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></code>s are skipped. In the example above, for instance if <code>[1]</code>-th component of inputs is flagged as troubled, checking the remaining index <code>[2]</code> is skipped. </p>

</div>
</div>
<a id="ae04bfc6367ec31daa48a01d47f5d0bf1" name="ae04bfc6367ec31daa48a01d47f5d0bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae04bfc6367ec31daa48a01d47f5d0bf1">&#9670;&nbsp;</a></span>rdmp_tci() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... EvolvedVarsTags&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int evolution::dg::subcell::rdmp_tci </td>
          <td>(</td>
          <td class="paramtype">const Variables&lt; tmpl::list&lt; EvolvedVarsTags... &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>active_grid_candidate_evolved_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Variables&lt; tmpl::list&lt; <a class="el" href="structevolution_1_1dg_1_1subcell_1_1Tags_1_1Inactive.html">Tags::Inactive</a>&lt; EvolvedVarsTags &gt;... &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>inactive_grid_candidate_evolved_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>max_of_past_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>min_of_past_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rdmp_delta0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rdmp_epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Troubled cell indicator using a relaxed discrete maximum principle, comparing the candidate solution with the past solution in the element and its neighbors. </p>
<p >Let the candidate solution be denoted by \(u^\star_{\alpha}(t^{n+1})\). Then the RDMP requires that</p>
<p class="formulaDsp">
\begin{align*} \min_{\forall\mathcal{N}}\left(u_{\alpha}(t^n)\right) - \delta_\alpha \le u^\star_{\alpha}(t^{n+1}) \le \max_{\forall\mathcal{N}} \left(u_{\alpha}(t^n)\right) + \delta_\alpha \end{align*}
</p>
<p >where \(\mathcal{N}\) are either the Neumann or Voronoi neighbors and the element itself, and \(\delta_\alpha\) is a parameter defined below that relaxes the discrete maximum principle (DMP). When computing \(\max(u_\alpha)\) and \(\min(u_\alpha)\) over a DG element that is not using subcells we first project the DG solution to the subcells and then compute the maximum and minimum over <em>both</em> the DG grid and the subcell grid. However, when a DG element is using subcells we compute the maximum and minimum of \(u_\alpha(t^n)\) over the subcells only. Note that the maximum and minimum values of \(u^\star_\alpha\) are always computed over both the DG and the subcell grids, even when using the RDMP to check if the reconstructed DG solution would be admissible.</p>
<p >The parameter \(\delta_\alpha\) is given by:</p>
<p class="formulaDsp">
\begin{align*} \delta_\alpha = \max\left(\delta_{0},\epsilon \left(\max_{\forall\mathcal{N}}\left(u_{\alpha}(t^n)\right) - \min_{\forall\mathcal{N}}\left(u_{\alpha}(t^n)\right)\right) \right), \end{align*}
</p>
<p >where we typically take \(\delta_{0}=10^{-4}\) and \(\epsilon=10^{-3}\).</p>
<p >If all checks are passed and cell is not troubled, returns an integer <code>0</code>. Otherwise returns 1-based index of the tag in the input Variables that fails the check. For instance, if we have following two Variables objects as candidate solutions on active and inactive grids</p>
<ul>
<li><code>Variables&lt;tmpl::list&lt;DgVar1, DgVar2, DgVar3&gt;&gt;</code></li>
<li><code>Variables&lt;tmpl::list&lt;SubVar1, SubVar2, SubVar3&gt;&gt;</code></li>
</ul>
<p >and TCI flags the second pair <code>DgVar2</code> and <code>SubVar2</code> not satisfying two-mesh RDMP criteria, returned value is <code>2</code> since the second pair of tags failed the check.</p>
<dl class="section note"><dt>Note</dt><dd>Once a single pair of tags fails to satisfy the check, checks for the remaining part of the input variables are skipped. In the example above, for instance if the second pair (<code>DgVar2</code>,<code>SubVar2</code>) is flagged as troubled, the third pair (<code>DgVar3</code>,<code>SubVar3</code>) is ignored and not checked. </dd></dl>

</div>
</div>
<a id="a6f6039eeca5baad38a155d179da1f899" name="a6f6039eeca5baad38a155d179da1f899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f6039eeca5baad38a155d179da1f899">&#9670;&nbsp;</a></span>slice_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classDataVector.html">DataVector</a> &gt; evolution::dg::subcell::slice_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>volume_subcell_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>number_of_ghost_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>directions_to_slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>additional_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slice the subcell variables needed for neighbors to perform reconstruction. </p>
<p >Note that we slice to a grid that is against the boundary of the element but is several ghost points deep. This is in contrast to the slicing used in the DG method which is to the boundary of the element only.</p>
<p >The <code>number_of_ghost_points</code> will depend on the number of neighboring points the reconstruction method needs that is used on the subcell. The <code>directions_to_slice</code> determines in which directions data is sliced. Generally this will be the directions in which the element has neighbors.</p>
<p >The data always has the same ordering as the volume data (tags have the same ordering, grid points are x-varies-fastest).</p>
<p >The <code>additional_buffer</code> argument is used to add extra padding to the result storage to be used for example for sending the RDMP TCI data. This eliminates expensive data copying. </p>

</div>
</div>
<a id="ae3cf2d19b4537e4ed8872ad72d2f88b6" name="ae3cf2d19b4537e4ed8872ad72d2f88b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3cf2d19b4537e4ed8872ad72d2f88b6">&#9670;&nbsp;</a></span>slice_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename TagList &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classDataVector.html">DataVector</a> &gt; evolution::dg::subcell::slice_data </td>
          <td>(</td>
          <td class="paramtype">const Variables&lt; TagList &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_subcell_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>number_of_ghost_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>directions_to_slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>additional_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slice the subcell variables needed for neighbors to perform reconstruction. </p>
<p >Note that we slice to a grid that is against the boundary of the element but is several ghost points deep. This is in contrast to the slicing used in the DG method which is to the boundary of the element only.</p>
<p >The <code>number_of_ghost_points</code> will depend on the number of neighboring points the reconstruction method needs that is used on the subcell. The <code>directions_to_slice</code> determines in which directions data is sliced. Generally this will be the directions in which the element has neighbors.</p>
<p >The data always has the same ordering as the volume data (tags have the same ordering, grid points are x-varies-fastest).</p>
<p >The <code>additional_buffer</code> argument is used to add extra padding to the result storage to be used for example for sending the RDMP TCI data. This eliminates expensive data copying. </p>

</div>
</div>
<a id="ab0764d979685439b92d864c698cb94ce" name="ab0764d979685439b92d864c698cb94ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0764d979685439b92d864c698cb94ce">&#9670;&nbsp;</a></span>slice_tensor_for_subcell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename VectorType , typename... Structure&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void evolution::dg::subcell::slice_tensor_for_subcell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Tensor&lt; VectorType, Structure... &gt; * &gt;&#160;</td>
          <td class="paramname"><em>sliced_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; VectorType, Structure... &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_ghost_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slice a single volume tensor for a given direction and slicing depth (number of ghost points). </p>
<p >Note that the last argument has the type <code><a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis.">Direction</a>&lt;Dim&gt;</code>, not a <a class="el" href="classDirectionMap.html" title="An optimized map with Direction keys.">DirectionMap</a> (cf. <code><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#a6f6039eeca5baad38a155d179da1f899" title="Slice the subcell variables needed for neighbors to perform reconstruction.">evolution::dg::subcell::slice_data</a></code>) </p>

</div>
</div>
<a id="a889fdc939c8993085b769d14bd8abf3f" name="a889fdc939c8993085b769d14bd8abf3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889fdc939c8993085b769d14bd8abf3f">&#9670;&nbsp;</a></span>slice_tensor_for_subcell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename VectorType , typename... Structure&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt; VectorType, Structure... &gt; evolution::dg::subcell::slice_tensor_for_subcell </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; VectorType, Structure... &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_ghost_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slice a single volume tensor for a given direction and slicing depth (number of ghost points). </p>
<p >Note that the last argument has the type <code><a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis.">Direction</a>&lt;Dim&gt;</code>, not a <a class="el" href="classDirectionMap.html" title="An optimized map with Direction keys.">DirectionMap</a> (cf. <code><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#a6f6039eeca5baad38a155d179da1f899" title="Slice the subcell variables needed for neighbors to perform reconstruction.">evolution::dg::subcell::slice_data</a></code>) </p>

</div>
</div>
<a id="a4c02183663dba6309a17ebfdf336c2ba" name="a4c02183663dba6309a17ebfdf336c2ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c02183663dba6309a17ebfdf336c2ba">&#9670;&nbsp;</a></span>two_mesh_rdmp_tci()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... DgEvolvedVarsTags, typename... SubcellEvolvedVarsTags&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int evolution::dg::subcell::two_mesh_rdmp_tci </td>
          <td>(</td>
          <td class="paramtype">const Variables&lt; tmpl::list&lt; DgEvolvedVarsTags... &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>dg_evolved_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Variables&lt; tmpl::list&lt; SubcellEvolvedVarsTags... &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_evolved_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rdmp_delta0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rdmp_epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Troubled cell indicator using a relaxed discrete maximum principle, comparing the solution on two grids at the same point in time. </p>
<p >Checks that the subcell solution \(\underline{u}\) and the DG solution \(u\) satisfy</p>
<p class="formulaDsp">
\begin{align*} \min(u)-\delta \le \underline{u} \le \max(u)+\delta \end{align*}
</p>
<p >where</p>
<p class="formulaDsp">
\begin{align*} \delta = \max\left[\delta_0, \epsilon(\max(u) - \min(u))\right] \end{align*}
</p>
<p >where \(\delta_0\) and \(\epsilon\) are constants controlling the maximum absolute and relative change allowed when projecting the DG solution to the subcell grid. We currently specify one value of \(\delta_0\) and \(\epsilon\) for all variables, but this could be generalized to choosing the allowed variation in a variable-specific manner.</p>
<p >If all checks are passed and cell is not troubled, returns an integer <code>0</code>. Otherwise returns 1-based index of the tag in the input Variables that fails the check. For instance, if we have</p>
<ul>
<li><code>Variables&lt;tmpl::list&lt;DgVar1, DgVar2, DgVar3&gt;&gt;</code> for <code>dg_evolved_vars</code></li>
<li><code>Variables&lt;tmpl::list&lt;SubVar1, SubVar2, SubVar3&gt;&gt;</code> for <code>subcell_evolved_vars</code></li>
</ul>
<p >as inputs and TCI flags the second pair <code>DgVar2</code> and <code>SubVar2</code> not satisfying two-mesh RDMP criteria, returned value is <code>2</code> since the second pair of tags failed the check.</p>
<dl class="section note"><dt>Note</dt><dd>Once a single pair of tags fails to satisfy the check, checks for the remaining part of the input variables are skipped. In the example above, for instance if the second pair (<code>DgVar2</code>,<code>SubVar2</code>) is flagged, the third pair (<code>DgVar3</code>,<code>SubVar3</code>) is ignored and not checked. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceevolution.html">evolution</a></li><li class="navelem"><a class="el" href="namespaceevolution_1_1dg.html">dg</a></li><li class="navelem"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html">subcell</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
