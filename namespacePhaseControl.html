<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: PhaseControl Namespace Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacePhaseControl.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">PhaseControl Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Contains utilities for determining control-flow among phases.  
<a href="namespacePhaseControl.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPhaseControl_1_1CheckpointAndExitAfterWallclock.html">CheckpointAndExitAfterWallclock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Phase control object that runs the WriteCheckpoint and Exit phases after a specified amount of wallclock time has elapsed.  <a href="structPhaseControl_1_1CheckpointAndExitAfterWallclock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPhaseControl_1_1TagAndCombine.html">TagAndCombine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type for denoting a piece of data for deciding a phase change.  <a href="structPhaseControl_1_1TagAndCombine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPhaseControl_1_1TaggedTupleCombine.html">TaggedTupleCombine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A flexible combine invokable that combines into a <code><a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs.">tuples::TaggedTuple</a></code> a new <code><a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs.">tuples::TaggedTuple</a></code>, and combines according to type aliases <code>combination_method</code>s that are required to be defined in each tag.  <a href="structPhaseControl_1_1TaggedTupleCombine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPhaseControl_1_1TaggedTupleMainCombine.html">TaggedTupleMainCombine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A flexible combine invokable that combines into a <code><a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs.">tuples::TaggedTuple</a></code> a new <code><a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs.">tuples::TaggedTuple</a></code> with a subset of the original tags, and combines according to type aliases <code>main_combine_method</code>s that are required to be defined in each tag.  <a href="structPhaseControl_1_1TaggedTupleMainCombine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPhaseControl_1_1TriggerAndPhaseChanges.html">TriggerAndPhaseChanges</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option-creatable pair of a trigger and associated phase change objects.  <a href="structPhaseControl_1_1TriggerAndPhaseChanges.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPhaseControl_1_1VisitAndReturn.html">VisitAndReturn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Phase control object for temporarily visiting <code>TargetPhase</code>, until the algorithm halts again, then returning to the original phase.  <a href="structPhaseControl_1_1VisitAndReturn.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:afca404b8d4c7fbb0cf2f88e7bb8bd7cc"><td class="memItemLeft" align="right" valign="top"><a id="afca404b8d4c7fbb0cf2f88e7bb8bd7cc" name="afca404b8d4c7fbb0cf2f88e7bb8bd7cc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>factory_creatable_classes</b> = tmpl::list&lt; <a class="el" href="structPhaseControl_1_1VisitAndReturn.html">VisitAndReturn</a>&lt; <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a5fb96ac8b4e030b4e88bd71b95460d02">Parallel::Phase::LoadBalancing</a> &gt;, <a class="el" href="structPhaseControl_1_1VisitAndReturn.html">VisitAndReturn</a>&lt; <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a667488c55c3abca96b02755bfe193681">Parallel::Phase::WriteCheckpoint</a> &gt;, <a class="el" href="structPhaseControl_1_1CheckpointAndExitAfterWallclock.html">CheckpointAndExitAfterWallclock</a> &gt;</td></tr>
<tr class="separator:afca404b8d4c7fbb0cf2f88e7bb8bd7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55ceff438cf688e929c3f83f82f9a16"><td class="memTemplParams" colspan="2"><a id="ad55ceff438cf688e929c3f83f82f9a16" name="ad55ceff438cf688e929c3f83f82f9a16"></a>
template&lt;typename Metavariables &gt; </td></tr>
<tr class="memitem:ad55ceff438cf688e929c3f83f82f9a16"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_phase_change_tags</b> = tmpl::push_back&lt; tmpl::flatten&lt; tmpl::transform&lt; typename detail::phase_change_derived_classes&lt; Metavariables &gt;::type, detail::get_phase_change_tags_and_combines&lt; tmpl::_1 &gt; &gt; &gt;, <a class="el" href="structPhaseControl_1_1TagsAndCombines_1_1UsePhaseChangeArbitration.html">TagsAndCombines::UsePhaseChangeArbitration</a>, <a class="el" href="structParallel_1_1Tags_1_1ExitCode.html">Parallel::Tags::ExitCode</a> &gt;</td></tr>
<tr class="memdesc:ad55ceff438cf688e929c3f83f82f9a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction for determining the merged collection of tags in <code>phase_change_tags_and_combines</code>s from all <code><a class="el" href="structPhaseChange.html" title="PhaseChange objects determine the storage types and logic for moving between phases based on runtime ...">PhaseChange</a></code> derived classes in <code>Metavariables::factory_creation</code> <br /></td></tr>
<tr class="separator:ad55ceff438cf688e929c3f83f82f9a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32e3c999be8835381696c3e9985f326"><td class="memTemplParams" colspan="2">template&lt;typename TagsAndCombinesPresent , typename TagsAndCombines &gt; </td></tr>
<tr class="memitem:ae32e3c999be8835381696c3e9985f326"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacePhaseControl.html#ae32e3c999be8835381696c3e9985f326">reduction_data</a> = Parallel::ReductionData&lt; <a class="el" href="structParallel_1_1ReductionDatum.html">Parallel::ReductionDatum</a>&lt; tuples::tagged_tuple_from_typelist&lt; TagsAndCombinesPresent &gt;, <a class="el" href="structPhaseControl_1_1TaggedTupleCombine.html">TaggedTupleCombine</a> &gt; &gt;</td></tr>
<tr class="memdesc:ae32e3c999be8835381696c3e9985f326"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code>Parallel::ReductionData</code> with a single <code><a class="el" href="structParallel_1_1ReductionDatum.html" title="The data to be reduced, and invokables to be called whenever two reduction messages are combined and ...">Parallel::ReductionDatum</a></code> for a given tagged tuple type determined by <code>TagsPresent</code>, and performs the combine according to <code>TagsAndCombines</code>, which must be a <code>tmpl::list</code> of <code><a class="el" href="structPhaseControl_1_1TagAndCombine.html" title="A type for denoting a piece of data for deciding a phase change.">PhaseControl::TagAndCombine</a></code>s.  <a href="namespacePhaseControl.html#ae32e3c999be8835381696c3e9985f326">More...</a><br /></td></tr>
<tr class="separator:ae32e3c999be8835381696c3e9985f326"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aca18e7afb80938d20c0a73b2efd903e0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePhaseControl.html#aca18e7afb80938d20c0a73b2efd903e0">ArbitrationStrategy</a> { <a class="el" href="namespacePhaseControl.html#aca18e7afb80938d20c0a73b2efd903e0a318dbdf61cd457cf811853f1c68ca063">RunPhaseImmediately</a>
, <a class="el" href="namespacePhaseControl.html#aca18e7afb80938d20c0a73b2efd903e0ab335f67499c3154e8a054723809a2a11">PermitAdditionalJumps</a>
 }</td></tr>
<tr class="memdesc:aca18e7afb80938d20c0a73b2efd903e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible options for instructing the Main chare in deciding the next phase to jump to.  <a href="namespacePhaseControl.html#aca18e7afb80938d20c0a73b2efd903e0">More...</a><br /></td></tr>
<tr class="separator:aca18e7afb80938d20c0a73b2efd903e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a85d9ce3ab28babaf420e054bedc59711"><td class="memTemplParams" colspan="2">template&lt;typename... DecisionTags, typename Metavariables &gt; </td></tr>
<tr class="memitem:a85d9ce3ab28babaf420e054bedc59711"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="el" href="group__ParallelGroup.html#ga027a2e60b10898507f92ba7290f0ba61">Parallel::Phase</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacePhaseControl.html#a85d9ce3ab28babaf420e054bedc59711">arbitrate_phase_change</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; DecisionTags... &gt; * &gt; phase_change_decision_data, <a class="el" href="group__ParallelGroup.html#ga027a2e60b10898507f92ba7290f0ba61">Parallel::Phase</a> current_phase, const <a class="el" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache</a>&lt; Metavariables &gt; &amp;cache)</td></tr>
<tr class="memdesc:a85d9ce3ab28babaf420e054bedc59711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the runtime data aggregated in <code>phase_change_decision_data</code> to decide which phase to execute next.  <a href="namespacePhaseControl.html#a85d9ce3ab28babaf420e054bedc59711">More...</a><br /></td></tr>
<tr class="separator:a85d9ce3ab28babaf420e054bedc59711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29844f252a4dc6224f8f46bc2d6e6fe6"><td class="memTemplParams" colspan="2"><a id="a29844f252a4dc6224f8f46bc2d6e6fe6" name="a29844f252a4dc6224f8f46bc2d6e6fe6"></a>
template&lt;typename... DecisionTags, typename Metavariables &gt; </td></tr>
<tr class="memitem:a29844f252a4dc6224f8f46bc2d6e6fe6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>initialize_phase_change_decision_data</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; DecisionTags... &gt; * &gt; phase_change_decision_data, const <a class="el" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache</a>&lt; Metavariables &gt; &amp;cache)</td></tr>
<tr class="memdesc:a29844f252a4dc6224f8f46bc2d6e6fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the Main chare's <code>phase_change_decision_data</code> for the option-selected <code><a class="el" href="structPhaseChange.html" title="PhaseChange objects determine the storage types and logic for moving between phases based on runtime ...">PhaseChange</a></code>s. <br /></td></tr>
<tr class="separator:a29844f252a4dc6224f8f46bc2d6e6fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Contains utilities for determining control-flow among phases. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ae32e3c999be8835381696c3e9985f326" name="ae32e3c999be8835381696c3e9985f326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae32e3c999be8835381696c3e9985f326">&#9670;&nbsp;</a></span>reduction_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TagsAndCombinesPresent , typename TagsAndCombines &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacePhaseControl.html#ae32e3c999be8835381696c3e9985f326">PhaseControl::reduction_data</a> = typedef Parallel::ReductionData&lt;<a class="el" href="structParallel_1_1ReductionDatum.html">Parallel::ReductionDatum</a>&lt; tuples::tagged_tuple_from_typelist&lt;TagsAndCombinesPresent&gt;, <a class="el" href="structPhaseControl_1_1TaggedTupleCombine.html">TaggedTupleCombine</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <code>Parallel::ReductionData</code> with a single <code><a class="el" href="structParallel_1_1ReductionDatum.html" title="The data to be reduced, and invokables to be called whenever two reduction messages are combined and ...">Parallel::ReductionDatum</a></code> for a given tagged tuple type determined by <code>TagsPresent</code>, and performs the combine according to <code>TagsAndCombines</code>, which must be a <code>tmpl::list</code> of <code><a class="el" href="structPhaseControl_1_1TagAndCombine.html" title="A type for denoting a piece of data for deciding a phase change.">PhaseControl::TagAndCombine</a></code>s. </p>
<p >Each tag in the <code>TagsAndCombinesPresent</code> may either be a <code>TagsAndCombines</code> or otherise define all three type traits <code>type</code>, <code>combine_method</code>, and <code>main_combine_method</code>. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aca18e7afb80938d20c0a73b2efd903e0" name="aca18e7afb80938d20c0a73b2efd903e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca18e7afb80938d20c0a73b2efd903e0">&#9670;&nbsp;</a></span>ArbitrationStrategy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacePhaseControl.html#aca18e7afb80938d20c0a73b2efd903e0">PhaseControl::ArbitrationStrategy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The possible options for instructing the Main chare in deciding the next phase to jump to. </p>
<p >An object of this enum type is packaged with a requested phase in the <code><a class="el" href="structPhaseChange.html#a8dd70e823884c684b9e96f4fe96a1383" title="Determine a phase request and PhaseControl::ArbitrationStrategy based on aggregated phase_change_deci...">PhaseChange::arbitrate_phase_change</a></code> function. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aca18e7afb80938d20c0a73b2efd903e0a318dbdf61cd457cf811853f1c68ca063" name="aca18e7afb80938d20c0a73b2efd903e0a318dbdf61cd457cf811853f1c68ca063"></a>RunPhaseImmediately&#160;</td><td class="fielddoc"><p >Jump to the requested phase immediately, before considering other requested phases. </p>
<p >This will ensure that the requested phase is always run, where alternative methods could have 'double-jumps' where the Main chare replaces a requested phase immediately without actually entering the phase. </p>
</td></tr>
<tr><td class="fieldname"><a id="aca18e7afb80938d20c0a73b2efd903e0ab335f67499c3154e8a054723809a2a11" name="aca18e7afb80938d20c0a73b2efd903e0ab335f67499c3154e8a054723809a2a11"></a>PermitAdditionalJumps&#160;</td><td class="fielddoc"><p >After the requested phase is considered, continue considering other requests, potentially replacing this request. </p>
<p >This will permit reprocessing the phase-jumps to help with cases where multiple phases are simultaneously requested. The <code>PermitAdditionalJumps</code> permits 'double-jumps' where a requested phase is immediately replaced by another phase to jump to. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a85d9ce3ab28babaf420e054bedc59711" name="a85d9ce3ab28babaf420e054bedc59711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d9ce3ab28babaf420e054bedc59711">&#9670;&nbsp;</a></span>arbitrate_phase_change()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... DecisionTags, typename Metavariables &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="el" href="group__ParallelGroup.html#ga027a2e60b10898507f92ba7290f0ba61">Parallel::Phase</a> &gt; PhaseControl::arbitrate_phase_change </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; DecisionTags... &gt; * &gt;&#160;</td>
          <td class="paramname"><em>phase_change_decision_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ParallelGroup.html#ga027a2e60b10898507f92ba7290f0ba61">Parallel::Phase</a>&#160;</td>
          <td class="paramname"><em>current_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache</a>&lt; Metavariables &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the runtime data aggregated in <code>phase_change_decision_data</code> to decide which phase to execute next. </p>
<h3>Details</h3>
<p >This function will iterate through each of the option-created pairs of <code><a class="el" href="structPhaseChange.html" title="PhaseChange objects determine the storage types and logic for moving between phases based on runtime ...">PhaseChange</a></code>s, and obtain from each a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt;<a class="el" href="group__ParallelGroup.html#ga027a2e60b10898507f92ba7290f0ba61" title="The possible phases of an executable.">Parallel::Phase</a>, <a class="el" href="namespacePhaseControl.html#aca18e7afb80938d20c0a73b2efd903e0" title="The possible options for instructing the Main chare in deciding the next phase to jump to.">PhaseControl::ArbitrationStrategy</a>&gt;</code>. Any <code>std::nullopt</code> is skipped. If all <code><a class="el" href="structPhaseChange.html" title="PhaseChange objects determine the storage types and logic for moving between phases based on runtime ...">PhaseChange</a></code>s provide <code>std::nullopt</code>, the phase will either keep its current value (if the halt was caused by one of the triggers associated with an option-created <code><a class="el" href="structPhaseChange.html" title="PhaseChange objects determine the storage types and logic for moving between phases based on runtime ...">PhaseChange</a></code>), or this function will return a <code>std::nullopt</code> as well (otherwise), indicating that the phase should proceed according to other information, such as global ordering.</p>
<p >In the case of a <code>PhaseControl::ArbitrationStrategy::RunPhaseImmediately</code>, the first such return value is immediately run, and no further <code><a class="el" href="structPhaseChange.html" title="PhaseChange objects determine the storage types and logic for moving between phases based on runtime ...">PhaseChange</a></code>s are queried for their input.</p>
<dl class="section note"><dt>Note</dt><dd>There can be cases where multiple triggers activate, and/or multiple <code><a class="el" href="structPhaseChange.html" title="PhaseChange objects determine the storage types and logic for moving between phases based on runtime ...">PhaseChange</a></code> objects have data in a state for which they would request a specific phase. When multiple phases are requested, arbitration will proceed in order of appearance in the <code>PhaseChangeAndTriggers</code>, determined from the input file options. Therefore, if that order of execution is important for the logic of the executable, the input file ordering and <code>ArbitrationStrategy</code> must be chosen carefully. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacePhaseControl.html">PhaseControl</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
