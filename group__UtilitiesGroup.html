<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: Utilities</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__UtilitiesGroup.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Utilities</div></div>
</div><!--header-->
<div class="contents">

<p>A collection of useful classes, functions and metafunctions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacealg"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealg.html">alg</a></td></tr>
<tr class="memdesc:namespacealg"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility functions wrapping STL algorithms and additional algorithms. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceformaline"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceformaline.html">formaline</a></td></tr>
<tr class="memdesc:namespaceformaline"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions for retrieving system and source tree information. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacefuncl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefuncl.html">funcl</a></td></tr>
<tr class="memdesc:namespacefuncl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Higher order function objects similar to <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/plus.html">std::plus</a></code>, etc. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacegsl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegsl.html">gsl</a></td></tr>
<tr class="memdesc:namespacegsl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations from the Guideline Support Library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRegistration"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRegistration.html">Registration</a></td></tr>
<tr class="memdesc:namespaceRegistration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helpers for derived class registration. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetmpl2"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetmpl2.html">tmpl2</a></td></tr>
<tr class="memdesc:namespacetmpl2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metaprogramming things that are not planned to be submitted to Brigand. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGetContainerSize.html">GetContainerSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callable struct which retrieves the <code>t.size()</code> for operand <code>t</code>. This will cause a compiler error if no such function exists.  <a href="structGetContainerSize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGetContainerElement.html">GetContainerElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callable struct for the subscript operator. Returns <code>t[i]</code>  <a href="structGetContainerElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structContainerDestructiveResize.html">ContainerDestructiveResize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callable struct which applies the <code>t.destructive_resize()</code> for operand <code>t</code>. This will cause a compiler error if no such function exists.  <a href="structContainerDestructiveResize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContinuedFraction.html">ContinuedFraction&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the continued fraction representation of a number.  <a href="classContinuedFraction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContinuedFractionSummer.html">ContinuedFractionSummer&lt; Fraction &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum a continued fraction.  <a href="classContinuedFractionSummer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require a pointer to not be a <code>nullptr</code>  <a href="classgsl_1_1not__null.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgsl_1_1span.html">gsl::span&lt; ElementType, Extent &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a span/view on a range, which is cheap to copy (one pointer).  <a href="classgsl_1_1span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMakeString.html">MakeString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a string by streaming into object.  <a href="classMakeString.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNoSuchType.html">NoSuchType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to mark "no type" or "bad state" for metaprogramming.  <a href="structNoSuchType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOverloader.html">Overloader&lt; Fs &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for overloading lambdas, useful for lambda-SFINAE.  <a href="structOverloader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRational.html">Rational</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A rational number.  <a href="classRational.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCacheRange.html">CacheRange&lt; Start, End &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range of integral values for <a class="el" href="classStaticCache.html" title="A cache of objects intended to be stored in a static variable.">StaticCache</a> indices. The <code>Start</code> is inclusive and the <code>End</code> is exclusive. The range must not be empty.  <a href="structCacheRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCacheEnumeration.html">CacheEnumeration&lt; EnumerationType, Enums &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible enumeration values for the <a class="el" href="classStaticCache.html" title="A cache of objects intended to be stored in a static variable.">StaticCache</a>. Only values specified here are retrievable.  <a href="structCacheEnumeration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticCache.html">StaticCache&lt; Generator, T, Ranges &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cache of objects intended to be stored in a static variable.  <a href="classStaticCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple&lt; Tags &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An associative container that is indexed by structs.  <a href="classtuples_1_1TaggedTuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtmpl2_1_1value__list.html">tmpl2::value_list&lt; T,... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compile-time list of values of the same type.  <a href="structtmpl2_1_1value__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTypeDisplayer.html">TypeDisplayer&lt;... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get compiler error with type of template parameter.  <a href="structTypeDisplayer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmake__list.html">make_list&lt; Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction to turn a parameter pack into a typelist.  <a href="structmake__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga9d571cd642604cb7bd87bb039ca3760f"><td class="memItemLeft" align="right" valign="top"><a id="ga9d571cd642604cb7bd87bb039ca3760f" name="ga9d571cd642604cb7bd87bb039ca3760f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPECTRE_ALWAYS_INLINE</b>&#160;&#160;&#160;inline</td></tr>
<tr class="memdesc:ga9d571cd642604cb7bd87bb039ca3760f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always inline a function. Only use this if you benchmarked the code. <br /></td></tr>
<tr class="separator:ga9d571cd642604cb7bd87bb039ca3760f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7b776398a66e9a6bd561c8decf08b47"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a>(INSTANTIATION_MACRO, ...)</td></tr>
<tr class="memdesc:gad7b776398a66e9a6bd561c8decf08b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro useful for generating many explicit instantiations of function or class templates.  <a href="group__UtilitiesGroup.html#gad7b776398a66e9a6bd561c8decf08b47">More...</a><br /></td></tr>
<tr class="separator:gad7b776398a66e9a6bd561c8decf08b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffde14445f49f65ff4f5b592e44ee71a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaffde14445f49f65ff4f5b592e44ee71a">LIKELY</a>(x)&#160;&#160;&#160;(x)</td></tr>
<tr class="separator:gaffde14445f49f65ff4f5b592e44ee71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab10d0a221f4d7a706701b806c8135fd7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gab10d0a221f4d7a706701b806c8135fd7">UNLIKELY</a>(x)&#160;&#160;&#160;(x)</td></tr>
<tr class="separator:gab10d0a221f4d7a706701b806c8135fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee1c0cc775bf58891fab30b95a3ac51f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaee1c0cc775bf58891fab30b95a3ac51f">DEFINE_STD_ARRAY_BINOP</a>(RESULT_TYPE,  LTYPE,  RTYPE,  OP_FUNCTION_NAME,  BINARY_OP)</td></tr>
<tr class="memdesc:gaee1c0cc775bf58891fab30b95a3ac51f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a binary function on an array, intended for binary operators such as <code>+</code>  <a href="group__UtilitiesGroup.html#gaee1c0cc775bf58891fab30b95a3ac51f">More...</a><br /></td></tr>
<tr class="separator:gaee1c0cc775bf58891fab30b95a3ac51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4409dfaeeba8ef49967a7c98e4709c98"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga4409dfaeeba8ef49967a7c98e4709c98">DEFINE_STD_ARRAY_INPLACE_BINOP</a>(LTYPE,  RTYPE,  OP_FUNCTION_NAME,  BINARY_OP)</td></tr>
<tr class="memdesc:ga4409dfaeeba8ef49967a7c98e4709c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares an in-place binary function on an array, intended for operations such as <code>+=</code>  <a href="group__UtilitiesGroup.html#ga4409dfaeeba8ef49967a7c98e4709c98">More...</a><br /></td></tr>
<tr class="separator:ga4409dfaeeba8ef49967a7c98e4709c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga902d1cefbb10846eb8f5be9f6be5c340"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga902d1cefbb10846eb8f5be9f6be5c340">EXPAND_PACK_LEFT_TO_RIGHT</a>(...)&#160;&#160;&#160;  (void)<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt;char&gt; { ((void)(__VA_ARGS__), '0')... }</td></tr>
<tr class="memdesc:ga902d1cefbb10846eb8f5be9f6be5c340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a parameter pack evaluating the terms from left to right.  <a href="group__UtilitiesGroup.html#ga902d1cefbb10846eb8f5be9f6be5c340">More...</a><br /></td></tr>
<tr class="separator:ga902d1cefbb10846eb8f5be9f6be5c340"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gae57946a2ff8730c87f1e47d636dd5b57"><td class="memTemplParams" colspan="2">template&lt;class T , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_pointer.html">std::is_pointer</a>&lt; T &gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a> &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:gae57946a2ff8730c87f1e47d636dd5b57"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gae57946a2ff8730c87f1e47d636dd5b57">gsl::owner</a> = typename detail::owner_impl&lt; T &gt;::type</td></tr>
<tr class="memdesc:gae57946a2ff8730c87f1e47d636dd5b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a raw pointer as owning its data.  <a href="group__UtilitiesGroup.html#gae57946a2ff8730c87f1e47d636dd5b57">More...</a><br /></td></tr>
<tr class="separator:gae57946a2ff8730c87f1e47d636dd5b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga084d535585c18d4e80f8ec6052d341a3"><td class="memTemplParams" colspan="2">template&lt;bool B&gt; </td></tr>
<tr class="memitem:ga084d535585c18d4e80f8ec6052d341a3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a> = typename Requires_detail::requires_impl&lt; B &gt;::template_error_type_failed_to_meet_requirements_on_template_parameters</td></tr>
<tr class="memdesc:ga084d535585c18d4e80f8ec6052d341a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Express requirements on the template parameters of a function or class, replaces <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/enable_if.html">std::enable_if_t</a></code>  <a href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">More...</a><br /></td></tr>
<tr class="separator:ga084d535585c18d4e80f8ec6052d341a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab28f70a6916977ab004146c9ad07cf5f"><td class="memTemplParams" colspan="2"><a id="gab28f70a6916977ab004146c9ad07cf5f" name="gab28f70a6916977ab004146c9ad07cf5f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab28f70a6916977ab004146c9ad07cf5f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tuples::tagged_tuple_from_typelist</b> = typename TaggedTuple_detail::tagged_tuple_typelist_impl&lt; T &gt;::type</td></tr>
<tr class="separator:gab28f70a6916977ab004146c9ad07cf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01ee1794935080949a6995ae7d5e08cc"><td class="memTemplParams" colspan="2">template&lt;bool... Bs&gt; </td></tr>
<tr class="memitem:ga01ee1794935080949a6995ae7d5e08cc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga01ee1794935080949a6995ae7d5e08cc">tmpl2::flat_all</a> = <a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same</a>&lt; <a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt; bool, Bs... &gt;, <a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt; bool,(static_cast&lt; void &gt;(Bs), true)... &gt; &gt;</td></tr>
<tr class="memdesc:ga01ee1794935080949a6995ae7d5e08cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-short-circuiting logical AND between bools 'B"".  <a href="group__UtilitiesGroup.html#ga01ee1794935080949a6995ae7d5e08cc">More...</a><br /></td></tr>
<tr class="separator:ga01ee1794935080949a6995ae7d5e08cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e25dbfa539ff4513329969dbcd81c40"><td class="memTemplParams" colspan="2">template&lt;bool... Bs&gt; </td></tr>
<tr class="memitem:ga6e25dbfa539ff4513329969dbcd81c40"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga6e25dbfa539ff4513329969dbcd81c40">tmpl2::flat_any</a> = <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a>&lt; bool, not <a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same</a>&lt; <a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt; bool, Bs... &gt;, <a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt; bool,(static_cast&lt; void &gt;(Bs), false)... &gt; &gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a> &gt;</td></tr>
<tr class="memdesc:ga6e25dbfa539ff4513329969dbcd81c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-short-circuiting logical OR between bools 'B"".  <a href="group__UtilitiesGroup.html#ga6e25dbfa539ff4513329969dbcd81c40">More...</a><br /></td></tr>
<tr class="separator:ga6e25dbfa539ff4513329969dbcd81c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cfcae98148ede1e9ba0d836c47b2f49"><td class="memTemplParams" colspan="2">template&lt;typename Sequence &gt; </td></tr>
<tr class="memitem:ga1cfcae98148ede1e9ba0d836c47b2f49"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga1cfcae98148ede1e9ba0d836c47b2f49">brigand::make_std_variant_over</a> = typename detail::make_std_variant_over_impl&lt; tmpl::remove_duplicates&lt; Sequence &gt; &gt;::type</td></tr>
<tr class="memdesc:ga1cfcae98148ede1e9ba0d836c47b2f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/variant.html">std::variant</a> with all all the types inside the typelist Sequence.  <a href="group__UtilitiesGroup.html#ga1cfcae98148ede1e9ba0d836c47b2f49">More...</a><br /></td></tr>
<tr class="separator:ga1cfcae98148ede1e9ba0d836c47b2f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cc9e917f4629191b41c8950542aa1a3"><td class="memTemplParams" colspan="2"><a id="ga4cc9e917f4629191b41c8950542aa1a3" name="ga4cc9e917f4629191b41c8950542aa1a3"></a>
template&lt;class Graph , class S , class D &gt; </td></tr>
<tr class="memitem:ga4cc9e917f4629191b41c8950542aa1a3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>brigand::has_edge</b> = typename ::brigand::lazy::has_edge&lt; Graph, S, D &gt;::type</td></tr>
<tr class="memdesc:ga4cc9e917f4629191b41c8950542aa1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a digraph has an edge with source <code>S</code> and destination <code>D</code> <br /></td></tr>
<tr class="separator:ga4cc9e917f4629191b41c8950542aa1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9a0c6b8252068496aac93344cca7d1f3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga9a0c6b8252068496aac93344cca7d1f3"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga9a0c6b8252068496aac93344cca7d1f3">cpp20::swap</a> (T &amp;a, T &amp;b)</td></tr>
<tr class="separator:ga9a0c6b8252068496aac93344cca7d1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f41a812c1350575cf0e202b59902983"><td class="memTemplParams" colspan="2">template&lt;class ForwardIt1 , class ForwardIt2 &gt; </td></tr>
<tr class="memitem:ga2f41a812c1350575cf0e202b59902983"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga2f41a812c1350575cf0e202b59902983">cpp20::iter_swap</a> (ForwardIt1 a, ForwardIt2 b)</td></tr>
<tr class="separator:ga2f41a812c1350575cf0e202b59902983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0465ea9937545d1d3404c6ab6e71b15c"><td class="memTemplParams" colspan="2">template&lt;class BidirectionalIterator &gt; </td></tr>
<tr class="memitem:ga0465ea9937545d1d3404c6ab6e71b15c"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga0465ea9937545d1d3404c6ab6e71b15c">cpp20::reverse</a> (BidirectionalIterator first, BidirectionalIterator last)</td></tr>
<tr class="separator:ga0465ea9937545d1d3404c6ab6e71b15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4ff3f48d2db8cb4a7101602d5f6ed3d"><td class="memTemplParams" colspan="2">template&lt;class Compare , class BidirectionalIterator &gt; </td></tr>
<tr class="memitem:gac4ff3f48d2db8cb4a7101602d5f6ed3d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gac4ff3f48d2db8cb4a7101602d5f6ed3d">cpp20::next_permutation</a> (BidirectionalIterator first, BidirectionalIterator last, Compare comp)</td></tr>
<tr class="separator:gac4ff3f48d2db8cb4a7101602d5f6ed3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0a66c125713e4158f86b06644a309eb"><td class="memTemplParams" colspan="2">template&lt;class BidirectionalIterator &gt; </td></tr>
<tr class="memitem:gaf0a66c125713e4158f86b06644a309eb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaf0a66c125713e4158f86b06644a309eb">cpp20::next_permutation</a> (BidirectionalIterator first, BidirectionalIterator last)</td></tr>
<tr class="separator:gaf0a66c125713e4158f86b06644a309eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac84a6c0bd8692c342b9ddf4ba63601e2"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class T &gt; </td></tr>
<tr class="memitem:gac84a6c0bd8692c342b9ddf4ba63601e2"><td class="memTemplItemLeft" align="right" valign="top">constexpr InputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gac84a6c0bd8692c342b9ddf4ba63601e2">cpp20::find</a> (InputIt first, InputIt last, const T &amp;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">value</a>)</td></tr>
<tr class="separator:gac84a6c0bd8692c342b9ddf4ba63601e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9f222044f3284747287f0c3b5089ccd"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:gad9f222044f3284747287f0c3b5089ccd"><td class="memTemplItemLeft" align="right" valign="top">constexpr InputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gad9f222044f3284747287f0c3b5089ccd">cpp20::find_if</a> (InputIt first, InputIt last, UnaryPredicate p)</td></tr>
<tr class="separator:gad9f222044f3284747287f0c3b5089ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77bc48018339ff6ac9402f49a5cd2068"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:ga77bc48018339ff6ac9402f49a5cd2068"><td class="memTemplItemLeft" align="right" valign="top">constexpr InputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga77bc48018339ff6ac9402f49a5cd2068">cpp20::find_if_not</a> (InputIt first, InputIt last, UnaryPredicate q)</td></tr>
<tr class="separator:ga77bc48018339ff6ac9402f49a5cd2068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa46a305d87ee4ae9fede9d55c373286"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaaa46a305d87ee4ae9fede9d55c373286">ddot_</a> (const size_t &amp;N, const double *X, const size_t &amp;INCX, const double *Y, const size_t &amp;INCY)</td></tr>
<tr class="separator:gaaa46a305d87ee4ae9fede9d55c373286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67f6e9c4ea9ecffbf3ff9143f080b595"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Classes , typename Base , typename Callable &gt; </td></tr>
<tr class="memitem:ga67f6e9c4ea9ecffbf3ff9143f080b595"><td class="memTemplItemLeft" align="right" valign="top">Result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga67f6e9c4ea9ecffbf3ff9143f080b595">call_with_dynamic_type</a> (Base *const obj, Callable &amp;&amp;f)</td></tr>
<tr class="memdesc:ga67f6e9c4ea9ecffbf3ff9143f080b595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a functor with the derived type of a base class pointer.  <a href="group__UtilitiesGroup.html#ga67f6e9c4ea9ecffbf3ff9143f080b595">More...</a><br /></td></tr>
<tr class="separator:ga67f6e9c4ea9ecffbf3ff9143f080b595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bface2d122a6251e4758f089f49ff11"><td class="memTemplParams" colspan="2">template&lt;class OutputIterator , class... InputIterator&gt; </td></tr>
<tr class="memitem:ga1bface2d122a6251e4758f089f49ff11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga1bface2d122a6251e4758f089f49ff11">cartesian_product</a> (OutputIterator result, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; InputIterator, InputIterator &gt;... dimensions)</td></tr>
<tr class="memdesc:ga1bface2d122a6251e4758f089f49ff11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the <code>result</code> iterator with the Cartesian product of a sequence of iterators.  <a href="group__UtilitiesGroup.html#ga1bface2d122a6251e4758f089f49ff11">More...</a><br /></td></tr>
<tr class="separator:ga1bface2d122a6251e4758f089f49ff11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac33fd10b88a1b820b271212bd78e4375"><td class="memTemplParams" colspan="2">template&lt;typename... Ts, size_t... Lens&gt; </td></tr>
<tr class="memitem:gac33fd10b88a1b820b271212bd78e4375"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Ts... &gt;,(... *Lens)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gac33fd10b88a1b820b271212bd78e4375">cartesian_product</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; Ts, Lens &gt; &amp;... dimensions)</td></tr>
<tr class="memdesc:gac33fd10b88a1b820b271212bd78e4375"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Cartesian product of a sequence of arrays.  <a href="group__UtilitiesGroup.html#gac33fd10b88a1b820b271212bd78e4375">More...</a><br /></td></tr>
<tr class="separator:gac33fd10b88a1b820b271212bd78e4375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0094d830a844c3b7cf3cce89b01caf5"><td class="memTemplParams" colspan="2">template&lt;typename... Containers&gt; </td></tr>
<tr class="memitem:gab0094d830a844c3b7cf3cce89b01caf5"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; typename Containers::value_type... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gab0094d830a844c3b7cf3cce89b01caf5">cartesian_product</a> (const Containers &amp;... containers)</td></tr>
<tr class="memdesc:gab0094d830a844c3b7cf3cce89b01caf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Cartesian product of several containers.  <a href="group__UtilitiesGroup.html#gab0094d830a844c3b7cf3cce89b01caf5">More...</a><br /></td></tr>
<tr class="separator:gab0094d830a844c3b7cf3cce89b01caf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fbd1063f5e80a635763171f810b4a7a"><td class="memTemplParams" colspan="2"><a id="ga1fbd1063f5e80a635763171f810b4a7a" name="ga1fbd1063f5e80a635763171f810b4a7a"></a>
template&lt;typename KeyType , typename T &gt; </td></tr>
<tr class="memitem:ga1fbd1063f5e80a635763171f810b4a7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; KeyType, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>clone_unique_ptrs</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; KeyType, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; T &gt; &gt; &amp;map)</td></tr>
<tr class="memdesc:ga1fbd1063f5e80a635763171f810b4a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a map of <code><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a></code> returns a copy of the map by invoking <code>get_clone()</code> on each element of the input map. <br /></td></tr>
<tr class="separator:ga1fbd1063f5e80a635763171f810b4a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2deb3672a2f80678677eae879787cc0"><td class="memTemplParams" colspan="2"><a id="gac2deb3672a2f80678677eae879787cc0" name="gac2deb3672a2f80678677eae879787cc0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac2deb3672a2f80678677eae879787cc0"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>clone_unique_ptrs</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; T &gt; &gt; &amp;vector)</td></tr>
<tr class="memdesc:gac2deb3672a2f80678677eae879787cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector of <code><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a></code> returns a copy of the vector by invoking <code>get_clone()</code> on each element of the input vector. <br /></td></tr>
<tr class="separator:gac2deb3672a2f80678677eae879787cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca6b4f1a7abad3fc072345574ef1561e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename SubscriptFunction  = GetContainerElement&gt; </td></tr>
<tr class="memitem:gaca6b4f1a7abad3fc072345574ef1561e"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaca6b4f1a7abad3fc072345574ef1561e">get_element</a> (T &amp;t, const size_t i, SubscriptFunction at=<a class="el" href="structGetContainerElement.html">GetContainerElement</a>{})</td></tr>
<tr class="memdesc:gaca6b4f1a7abad3fc072345574ef1561e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>i</code>th element if <code>T</code> has a subscript operator, otherwise if <code>T</code> is fundamental or a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a></code> of a fundamental type, returns <code>t</code>.  <a href="group__UtilitiesGroup.html#gaca6b4f1a7abad3fc072345574ef1561e">More...</a><br /></td></tr>
<tr class="separator:gaca6b4f1a7abad3fc072345574ef1561e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2de7f13b6110865c3bbeb1df89adb694"><td class="memTemplParams" colspan="2">template&lt;typename T , typename SizeFunction  = GetContainerSize&gt; </td></tr>
<tr class="memitem:ga2de7f13b6110865c3bbeb1df89adb694"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga2de7f13b6110865c3bbeb1df89adb694">get_size</a> (const T &amp;t, SizeFunction size=<a class="el" href="structGetContainerSize.html">GetContainerSize</a>{})</td></tr>
<tr class="memdesc:ga2de7f13b6110865c3bbeb1df89adb694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the size of <code>t</code> if <code>t.size()</code> is a valid expression, otherwise if <code>T</code> is fundamental or a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a></code> of a fundamental type, returns 1.  <a href="group__UtilitiesGroup.html#ga2de7f13b6110865c3bbeb1df89adb694">More...</a><br /></td></tr>
<tr class="separator:ga2de7f13b6110865c3bbeb1df89adb694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f599f1aca8c3f97acaad209e5531b86"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename DestructiveResizeFunction  = ContainerDestructiveResize&gt; </td></tr>
<tr class="memitem:ga4f599f1aca8c3f97acaad209e5531b86"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga4f599f1aca8c3f97acaad209e5531b86">destructive_resize_components</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Container * &gt; container, const size_t new_size, DestructiveResizeFunction destructive_resize=<a class="el" href="structContainerDestructiveResize.html">ContainerDestructiveResize</a>{})</td></tr>
<tr class="memdesc:ga4f599f1aca8c3f97acaad209e5531b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the size of each component of the container, and resizes if necessary.  <a href="group__UtilitiesGroup.html#ga4f599f1aca8c3f97acaad209e5531b86">More...</a><br /></td></tr>
<tr class="separator:ga4f599f1aca8c3f97acaad209e5531b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccb7d5132ccd60f32c504c51f9d7fb3c"><td class="memTemplParams" colspan="2"><a id="gaccb7d5132ccd60f32c504c51f9d7fb3c" name="gaccb7d5132ccd60f32c504c51f9d7fb3c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaccb7d5132ccd60f32c504c51f9d7fb3c"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dereference_wrapper</b> (T &amp;&amp;t)</td></tr>
<tr class="memdesc:gaccb7d5132ccd60f32c504c51f9d7fb3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reference object held by a reference wrapper, if a non-reference_wrapper type is passed in then the object is returned. <br /></td></tr>
<tr class="separator:gaccb7d5132ccd60f32c504c51f9d7fb3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e03094c14176d1db9be6a830f503d7f"><td class="memTemplParams" colspan="2">template&lt;typename Lhs , typename Rhs &gt; </td></tr>
<tr class="memitem:ga3e03094c14176d1db9be6a830f503d7f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga3e03094c14176d1db9be6a830f503d7f">equal_within_roundoff</a> (const Lhs &amp;lhs, const Rhs &amp;rhs, const double eps=<a class="elRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits</a>&lt; double &gt;::epsilon() *100.0, const double scale=1.0)</td></tr>
<tr class="memdesc:ga3e03094c14176d1db9be6a830f503d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two values <code>lhs</code> and <code>rhs</code> are equal within roundoff, by comparing <code>abs(lhs - rhs) &lt; (max(abs(lhs), abs(rhs)) + scale) * eps</code>.  <a href="group__UtilitiesGroup.html#ga3e03094c14176d1db9be6a830f503d7f">More...</a><br /></td></tr>
<tr class="separator:ga3e03094c14176d1db9be6a830f503d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba5094035e076188c950ee97d1751a79"><td class="memTemplParams" colspan="2">template&lt;typename Fraction , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaba5094035e076188c950ee97d1751a79"><td class="memTemplItemLeft" align="right" valign="top">Fraction&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaba5094035e076188c950ee97d1751a79">simplest_fraction_in_interval</a> (const T1 &amp;end1, const T2 &amp;end2)</td></tr>
<tr class="memdesc:gaba5094035e076188c950ee97d1751a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the fraction in the supplied interval with the smallest denominator.  <a href="group__UtilitiesGroup.html#gaba5094035e076188c950ee97d1751a79">More...</a><br /></td></tr>
<tr class="separator:gaba5094035e076188c950ee97d1751a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33d34466f4af7586b5cbe764edd3f122"><td class="memTemplParams" colspan="2"><a id="ga33d34466f4af7586b5cbe764edd3f122" name="ga33d34466f4af7586b5cbe764edd3f122"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga33d34466f4af7586b5cbe764edd3f122"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_output</b> (const T &amp;t)</td></tr>
<tr class="memdesc:ga33d34466f4af7586b5cbe764edd3f122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the streamed output of <code>t</code> as a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a></code> <br /></td></tr>
<tr class="separator:ga33d34466f4af7586b5cbe764edd3f122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f52ec5898ec59c0d483f9cdbeecc3cd"><td class="memTemplParams" colspan="2"><a id="ga1f52ec5898ec59c0d483f9cdbeecc3cd" name="ga1f52ec5898ec59c0d483f9cdbeecc3cd"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ga1f52ec5898ec59c0d483f9cdbeecc3cd"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gsl::narrow_cast</b> (U &amp;&amp;u)</td></tr>
<tr class="memdesc:ga1f52ec5898ec59c0d483f9cdbeecc3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <code>u</code> to a type <code>T</code> where the cast may result in narrowing. <br /></td></tr>
<tr class="separator:ga1f52ec5898ec59c0d483f9cdbeecc3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaf6db75ede2a9bc2fa4b6b17b8ef128"><td class="memTemplParams" colspan="2"><a id="gafaf6db75ede2a9bc2fa4b6b17b8ef128" name="gafaf6db75ede2a9bc2fa4b6b17b8ef128"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:gafaf6db75ede2a9bc2fa4b6b17b8ef128"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gsl::narrow</b> (U u)</td></tr>
<tr class="memdesc:gafaf6db75ede2a9bc2fa4b6b17b8ef128"><td class="mdescLeft">&#160;</td><td class="mdescRight">A checked version of <a class="el" href="group__UtilitiesGroup.html#ga1f52ec5898ec59c0d483f9cdbeecc3cd" title="Cast u to a type T where the cast may result in narrowing.">narrow_cast()</a> that ERRORs if the cast changed the value. <br /></td></tr>
<tr class="separator:gafaf6db75ede2a9bc2fa4b6b17b8ef128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9fcbbaa07506a5df5379b64772333d9"><td class="memItemLeft" align="right" valign="top"><a id="gaf9fcbbaa07506a5df5379b64772333d9" name="gaf9fcbbaa07506a5df5379b64772333d9"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>operator&quot;&quot;_st</b> (const unsigned long long n)</td></tr>
<tr class="memdesc:gaf9fcbbaa07506a5df5379b64772333d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the _st size_t suffix. <br /></td></tr>
<tr class="separator:gaf9fcbbaa07506a5df5379b64772333d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0d14339a15c6913c09fb2baeffe72be"><td class="memTemplParams" colspan="2">template&lt;size_t Size, typename T , typename... Args&gt; </td></tr>
<tr class="memitem:gad0d14339a15c6913c09fb2baeffe72be"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gad0d14339a15c6913c09fb2baeffe72be">make_array</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gad0d14339a15c6913c09fb2baeffe72be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;T, Size&gt;{{T(args...), T(args...), ...}}</code>  <a href="group__UtilitiesGroup.html#gad0d14339a15c6913c09fb2baeffe72be">More...</a><br /></td></tr>
<tr class="separator:gad0d14339a15c6913c09fb2baeffe72be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6af8c749c81a51b45fc748a81b1b301c"><td class="memTemplParams" colspan="2">template&lt;size_t Size, typename T &gt; </td></tr>
<tr class="memitem:ga6af8c749c81a51b45fc748a81b1b301c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga6af8c749c81a51b45fc748a81b1b301c">make_array</a> (T &amp;&amp;t) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt; T &gt;, Size &gt;</td></tr>
<tr class="memdesc:ga6af8c749c81a51b45fc748a81b1b301c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt;T&gt;, Size&gt;{{t, t, ...}}</code>  <a href="group__UtilitiesGroup.html#ga6af8c749c81a51b45fc748a81b1b301c">More...</a><br /></td></tr>
<tr class="separator:ga6af8c749c81a51b45fc748a81b1b301c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c78c1a7f8c11385d83d3141fca15510"><td class="memTemplParams" colspan="2"><a id="ga0c78c1a7f8c11385d83d3141fca15510" name="ga0c78c1a7f8c11385d83d3141fca15510"></a>
template&lt;typename T , typename... V, <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt;(sizeof...(V) &gt; 0)&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ga0c78c1a7f8c11385d83d3141fca15510"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_array</b> (T &amp;&amp;t, V &amp;&amp;... values) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; typename <a class="elRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt; T &gt;, sizeof...(V)+1 &gt;</td></tr>
<tr class="memdesc:ga0c78c1a7f8c11385d83d3141fca15510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to initialize a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a> with varying number of arguments. <br /></td></tr>
<tr class="separator:ga0c78c1a7f8c11385d83d3141fca15510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef51773ec780d16fddcda8e5094f2a21"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t size, typename Seq &gt; </td></tr>
<tr class="memitem:gaef51773ec780d16fddcda8e5094f2a21"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaef51773ec780d16fddcda8e5094f2a21">make_array</a> (Seq &amp;&amp;seq)</td></tr>
<tr class="memdesc:gaef51773ec780d16fddcda8e5094f2a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;T, size&gt;</code> from the first <code>size</code> values of <code>seq</code>  <a href="group__UtilitiesGroup.html#gaef51773ec780d16fddcda8e5094f2a21">More...</a><br /></td></tr>
<tr class="separator:gaef51773ec780d16fddcda8e5094f2a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eed7cb45692393b257c3987070d1da2"><td class="memTemplParams" colspan="2"><a id="ga1eed7cb45692393b257c3987070d1da2" name="ga1eed7cb45692393b257c3987070d1da2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1eed7cb45692393b257c3987070d1da2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>number_of_digits</b> (const T number)</td></tr>
<tr class="memdesc:ga1eed7cb45692393b257c3987070d1da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of digits in an integer number. <br /></td></tr>
<tr class="separator:ga1eed7cb45692393b257c3987070d1da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa19830f18b8c64d7a574263578108a9c"><td class="memTemplParams" colspan="2">template&lt;typename CoeffsIterable , typename DataType &gt; </td></tr>
<tr class="memitem:gaa19830f18b8c64d7a574263578108a9c"><td class="memTemplItemLeft" align="right" valign="top">DataType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaa19830f18b8c64d7a574263578108a9c">evaluate_polynomial</a> (const CoeffsIterable &amp;coeffs, const DataType &amp;x)</td></tr>
<tr class="memdesc:gaa19830f18b8c64d7a574263578108a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a polynomial \(\sum_{p=0}^N c_p x^p\) with Horner's rule.  <a href="group__UtilitiesGroup.html#gaa19830f18b8c64d7a574263578108a9c">More...</a><br /></td></tr>
<tr class="separator:gaa19830f18b8c64d7a574263578108a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac28c69595cc4f96fb0d5c2b736371405"><td class="memTemplParams" colspan="2"><a id="gac28c69595cc4f96fb0d5c2b736371405" name="gac28c69595cc4f96fb0d5c2b736371405"></a>
template&lt;typename T , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_arithmetic.html">std::is_arithmetic</a>&lt; T &gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a> &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:gac28c69595cc4f96fb0d5c2b736371405"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>step_function</b> (const T &amp;arg)</td></tr>
<tr class="memdesc:gac28c69595cc4f96fb0d5c2b736371405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the Heaviside step function \(\Theta\) for arithmetic types. \(\Theta(0) = 1\). <br /></td></tr>
<tr class="separator:gac28c69595cc4f96fb0d5c2b736371405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafce557042e1335e19b1bf3dbb7a75d79"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename DataType &gt; </td></tr>
<tr class="memitem:gafce557042e1335e19b1bf3dbb7a75d79"><td class="memTemplItemLeft" align="right" valign="top">DataType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gafce557042e1335e19b1bf3dbb7a75d79">smoothstep</a> (const double lower_edge, const double upper_edge, const DataType &amp;arg)</td></tr>
<tr class="memdesc:gafce557042e1335e19b1bf3dbb7a75d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smoothly interpolates from 0 to 1 between <code>lower_edge</code> and <code>upper_edge</code> with a Hermite polynomial of degree <code>2 * N + 1</code>.  <a href="group__UtilitiesGroup.html#gafce557042e1335e19b1bf3dbb7a75d79">More...</a><br /></td></tr>
<tr class="separator:gafce557042e1335e19b1bf3dbb7a75d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1222c86f57e2404ffed96e343098c0ed"><td class="memTemplParams" colspan="2"><a id="ga1222c86f57e2404ffed96e343098c0ed" name="ga1222c86f57e2404ffed96e343098c0ed"></a>
template&lt;typename T , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_arithmetic.html">std::is_arithmetic</a>&lt; T &gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a> or <a class="el" href="group__TypeTraitsGroup.html#ga49687f7a9a5e01a848db388e0f2e398f">tt::is_a_v</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>, T &gt; &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ga1222c86f57e2404ffed96e343098c0ed"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invsqrt</b> (const T &amp;arg)</td></tr>
<tr class="memdesc:ga1222c86f57e2404ffed96e343098c0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the inverse square-root ( \(1/\sqrt{x}\)) for arithmetic and complex types. <br /></td></tr>
<tr class="separator:ga1222c86f57e2404ffed96e343098c0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab20b25c208c01a9cda030bd61fc3339c"><td class="memTemplParams" colspan="2"><a id="gab20b25c208c01a9cda030bd61fc3339c" name="gab20b25c208c01a9cda030bd61fc3339c"></a>
template&lt;typename T , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_arithmetic.html">std::is_arithmetic</a>&lt; T &gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a> &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:gab20b25c208c01a9cda030bd61fc3339c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invcbrt</b> (const T &amp;arg)</td></tr>
<tr class="memdesc:gab20b25c208c01a9cda030bd61fc3339c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the inverse cube-root ( \(1/\sqrt[3]{x}\)) for arithmetic types. <br /></td></tr>
<tr class="separator:gab20b25c208c01a9cda030bd61fc3339c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefa85f57d55db5a442b55b5b40f8d138"><td class="memTemplParams" colspan="2"><a id="gaefa85f57d55db5a442b55b5b40f8d138" name="gaefa85f57d55db5a442b55b5b40f8d138"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaefa85f57d55db5a442b55b5b40f8d138"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sgn</b> (const T &amp;val)</td></tr>
<tr class="memdesc:gaefa85f57d55db5a442b55b5b40f8d138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sign function of <code>val</code> defined as <code>1</code> if <code>val &gt; 0</code>, <code>0</code> if <code>val == 0</code>, and <code>-1</code> if <code>val &lt; 0</code>. <br /></td></tr>
<tr class="separator:gaefa85f57d55db5a442b55b5b40f8d138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga218ddc950e1c70d86bf6455664d0b5f1"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class T &gt; </td></tr>
<tr class="memitem:ga218ddc950e1c70d86bf6455664d0b5f1"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga218ddc950e1c70d86bf6455664d0b5f1">cpp2b::iota</a> (ForwardIterator first, ForwardIterator last, T <a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">value</a>)</td></tr>
<tr class="separator:ga218ddc950e1c70d86bf6455664d0b5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3be3b8a2b80d0c3837f82d82e5f25f5"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class T &gt; </td></tr>
<tr class="memitem:gaa3be3b8a2b80d0c3837f82d82e5f25f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaa3be3b8a2b80d0c3837f82d82e5f25f5">cpp2b::accumulate</a> (InputIt first, InputIt last, T init)</td></tr>
<tr class="separator:gaa3be3b8a2b80d0c3837f82d82e5f25f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0290d0a5f4e2c35f05579d13a635ba64"><td class="memTemplParams" colspan="2"><a id="ga0290d0a5f4e2c35f05579d13a635ba64" name="ga0290d0a5f4e2c35f05579d13a635ba64"></a>
template&lt;typename ForwardIt , typename Func &gt; </td></tr>
<tr class="memitem:ga0290d0a5f4e2c35f05579d13a635ba64"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequence_print_helper</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;out, ForwardIt &amp;&amp;begin, ForwardIt &amp;&amp;end, Func f)</td></tr>
<tr class="memdesc:ga0290d0a5f4e2c35f05579d13a635ba64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function f(out, it) to each item from begin to end, separated by commas and surrounded by parens. <br /></td></tr>
<tr class="separator:ga0290d0a5f4e2c35f05579d13a635ba64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4806b29ae2fce566ff7644ad25be7af5"><td class="memTemplParams" colspan="2"><a id="ga4806b29ae2fce566ff7644ad25be7af5" name="ga4806b29ae2fce566ff7644ad25be7af5"></a>
template&lt;typename ForwardIt &gt; </td></tr>
<tr class="memitem:ga4806b29ae2fce566ff7644ad25be7af5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequence_print_helper</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;out, ForwardIt &amp;&amp;begin, ForwardIt &amp;&amp;end)</td></tr>
<tr class="memdesc:ga4806b29ae2fce566ff7644ad25be7af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints all the items as a comma separated list surrounded by parens. <br /></td></tr>
<tr class="separator:ga4806b29ae2fce566ff7644ad25be7af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1541dbda312fab70456958fe923586fc"><td class="memTemplParams" colspan="2"><a id="ga1541dbda312fab70456958fe923586fc" name="ga1541dbda312fab70456958fe923586fc"></a>
template&lt;typename... Ranges, typename Generator &gt; </td></tr>
<tr class="memitem:ga1541dbda312fab70456958fe923586fc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_static_cache</b> (Generator &amp;&amp;generator)</td></tr>
<tr class="memdesc:ga1541dbda312fab70456958fe923586fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classStaticCache.html" title="A cache of objects intended to be stored in a static variable.">StaticCache</a>, inferring the cached type from the generator. <br /></td></tr>
<tr class="separator:ga1541dbda312fab70456958fe923586fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade85e9b85646fb7b4602301bd9111362"><td class="memTemplParams" colspan="2"><a id="gade85e9b85646fb7b4602301bd9111362" name="gade85e9b85646fb7b4602301bd9111362"></a>
template&lt;typename T , size_t Dim&gt; </td></tr>
<tr class="memitem:gade85e9b85646fb7b4602301bd9111362"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim - 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>all_but_specified_element_of</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim &gt; &amp;a, const size_t element_to_remove)</td></tr>
<tr class="memdesc:gade85e9b85646fb7b4602301bd9111362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an array from an existing array omitting one element. <br /></td></tr>
<tr class="separator:gade85e9b85646fb7b4602301bd9111362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92ac396e6a01ed750c2a4d7b912ac32d"><td class="memTemplParams" colspan="2"><a id="ga92ac396e6a01ed750c2a4d7b912ac32d" name="ga92ac396e6a01ed750c2a4d7b912ac32d"></a>
template&lt;typename T , size_t Dim&gt; </td></tr>
<tr class="memitem:ga92ac396e6a01ed750c2a4d7b912ac32d"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim+1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_element</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim &gt; a, const size_t element_to_add, T <a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">value</a>)</td></tr>
<tr class="memdesc:ga92ac396e6a01ed750c2a4d7b912ac32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an array from an existing array adding one element. <br /></td></tr>
<tr class="separator:ga92ac396e6a01ed750c2a4d7b912ac32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd53ed69eb4287bdb1743e7fc48084ea"><td class="memTemplParams" colspan="2"><a id="gabd53ed69eb4287bdb1743e7fc48084ea" name="gabd53ed69eb4287bdb1743e7fc48084ea"></a>
template&lt;typename T , size_t Dim&gt; </td></tr>
<tr class="memitem:gabd53ed69eb4287bdb1743e7fc48084ea"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim+1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>prepend</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim &gt; &amp;a, T <a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">value</a>)</td></tr>
<tr class="memdesc:gabd53ed69eb4287bdb1743e7fc48084ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an array from an existing array prepending a value. <br /></td></tr>
<tr class="separator:gabd53ed69eb4287bdb1743e7fc48084ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4148bd5d08da0ff2c36a0283d27b7cbf"><td class="memTemplParams" colspan="2"><a id="ga4148bd5d08da0ff2c36a0283d27b7cbf" name="ga4148bd5d08da0ff2c36a0283d27b7cbf"></a>
template&lt;typename T , size_t Dim1, size_t Dim2&gt; </td></tr>
<tr class="memitem:ga4148bd5d08da0ff2c36a0283d27b7cbf"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim1+Dim2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>concatenate</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim1 &gt; a, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim2 &gt; b)</td></tr>
<tr class="memdesc:ga4148bd5d08da0ff2c36a0283d27b7cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an array from the contents of two other arrays. <br /></td></tr>
<tr class="separator:ga4148bd5d08da0ff2c36a0283d27b7cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06908ed84b351c57a03ddea7a70c52d8"><td class="memTemplParams" colspan="2"><a id="ga06908ed84b351c57a03ddea7a70c52d8" name="ga06908ed84b351c57a03ddea7a70c52d8"></a>
template&lt;typename T , size_t Dim, typename F &gt; </td></tr>
<tr class="memitem:ga06908ed84b351c57a03ddea7a70c52d8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_array</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim &gt; &amp;array, const F &amp;f)</td></tr>
<tr class="memdesc:ga06908ed84b351c57a03ddea7a70c52d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function to each element of an array, producing a new array of the results. The elements of the new array are constructed in place, so they need not be default constructible. <br /></td></tr>
<tr class="separator:ga06908ed84b351c57a03ddea7a70c52d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cf400a7fc974ca1c9f8d44ca8b9b464"><td class="memTemplParams" colspan="2"><a id="ga5cf400a7fc974ca1c9f8d44ca8b9b464" name="ga5cf400a7fc974ca1c9f8d44ca8b9b464"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5cf400a7fc974ca1c9f8d44ca8b9b464"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ga5cf400a7fc974ca1c9f8d44ca8b9b464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the items of a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>. <br /></td></tr>
<tr class="separator:ga5cf400a7fc974ca1c9f8d44ca8b9b464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf2944052a36661fbd47b4de13aa56f0"><td class="memTemplParams" colspan="2"><a id="gaaf2944052a36661fbd47b4de13aa56f0" name="gaaf2944052a36661fbd47b4de13aa56f0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaaf2944052a36661fbd47b4de13aa56f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:gaaf2944052a36661fbd47b4de13aa56f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the items of a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>. <br /></td></tr>
<tr class="separator:gaaf2944052a36661fbd47b4de13aa56f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga029042b6367e373d5409fc811900dfc3"><td class="memTemplParams" colspan="2"><a id="ga029042b6367e373d5409fc811900dfc3" name="ga029042b6367e373d5409fc811900dfc3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga029042b6367e373d5409fc811900dfc3"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ga029042b6367e373d5409fc811900dfc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the items of a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>. <br /></td></tr>
<tr class="separator:ga029042b6367e373d5409fc811900dfc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26a6f400c242b723c98ccd06f363c1f5"><td class="memTemplParams" colspan="2"><a id="ga26a6f400c242b723c98ccd06f363c1f5" name="ga26a6f400c242b723c98ccd06f363c1f5"></a>
template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:ga26a6f400c242b723c98ccd06f363c1f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:ga26a6f400c242b723c98ccd06f363c1f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the items of a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>. <br /></td></tr>
<tr class="separator:ga26a6f400c242b723c98ccd06f363c1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5db4d5889223c91ebf666c5c7ac4566f"><td class="memTemplParams" colspan="2"><a id="ga5db4d5889223c91ebf666c5c7ac4566f" name="ga5db4d5889223c91ebf666c5c7ac4566f"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ga5db4d5889223c91ebf666c5c7ac4566f"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Args... &gt; &amp;t)</td></tr>
<tr class="memdesc:ga5db4d5889223c91ebf666c5c7ac4566f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for tuples. <br /></td></tr>
<tr class="separator:ga5db4d5889223c91ebf666c5c7ac4566f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7304c287ef62ae6e9ef2ad3474880e3"><td class="memTemplParams" colspan="2"><a id="gac7304c287ef62ae6e9ef2ad3474880e3" name="gac7304c287ef62ae6e9ef2ad3474880e3"></a>
template&lt;typename K , typename V , typename H &gt; </td></tr>
<tr class="memitem:gac7304c287ef62ae6e9ef2ad3474880e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; K, V, H &gt; &amp;m)</td></tr>
<tr class="memdesc:gac7304c287ef62ae6e9ef2ad3474880e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output all the key, value pairs of a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>. <br /></td></tr>
<tr class="separator:gac7304c287ef62ae6e9ef2ad3474880e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5fc4d25c31d2778c56fbbda24e9e8d1"><td class="memTemplParams" colspan="2"><a id="gac5fc4d25c31d2778c56fbbda24e9e8d1" name="gac5fc4d25c31d2778c56fbbda24e9e8d1"></a>
template&lt;typename K , typename V , typename C &gt; </td></tr>
<tr class="memitem:gac5fc4d25c31d2778c56fbbda24e9e8d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>&lt; K, V, C &gt; &amp;m)</td></tr>
<tr class="memdesc:gac5fc4d25c31d2778c56fbbda24e9e8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output all the key, value pairs of a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>. <br /></td></tr>
<tr class="separator:gac5fc4d25c31d2778c56fbbda24e9e8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddf9f3384dd51cd10dc93d36a9820b56"><td class="memTemplParams" colspan="2"><a id="gaddf9f3384dd51cd10dc93d36a9820b56" name="gaddf9f3384dd51cd10dc93d36a9820b56"></a>
template&lt;typename T , typename H &gt; </td></tr>
<tr class="memitem:gaddf9f3384dd51cd10dc93d36a9820b56"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; T, H &gt; &amp;v)</td></tr>
<tr class="memdesc:gaddf9f3384dd51cd10dc93d36a9820b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the items of a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>. <br /></td></tr>
<tr class="separator:gaddf9f3384dd51cd10dc93d36a9820b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c746f9bfce45cb3d450801f1394c1b5"><td class="memTemplParams" colspan="2"><a id="ga9c746f9bfce45cb3d450801f1394c1b5" name="ga9c746f9bfce45cb3d450801f1394c1b5"></a>
template&lt;typename T , typename H &gt; </td></tr>
<tr class="memitem:ga9c746f9bfce45cb3d450801f1394c1b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_multiset.html">std::unordered_multiset</a>&lt; T, H &gt; &amp;v)</td></tr>
<tr class="memdesc:ga9c746f9bfce45cb3d450801f1394c1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the items of a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_multiset.html">std::unordered_multiset</a>. <br /></td></tr>
<tr class="separator:ga9c746f9bfce45cb3d450801f1394c1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga811aedf08c5e812a32def14015d8e77f"><td class="memTemplParams" colspan="2"><a id="ga811aedf08c5e812a32def14015d8e77f" name="ga811aedf08c5e812a32def14015d8e77f"></a>
template&lt;typename T , typename C &gt; </td></tr>
<tr class="memitem:ga811aedf08c5e812a32def14015d8e77f"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/set.html">std::set</a>&lt; T, C &gt; &amp;v)</td></tr>
<tr class="memdesc:ga811aedf08c5e812a32def14015d8e77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the items of a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/set.html">std::set</a>. <br /></td></tr>
<tr class="separator:ga811aedf08c5e812a32def14015d8e77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0540d72496ba6270d5dbf9f6602647ed"><td class="memTemplParams" colspan="2"><a id="ga0540d72496ba6270d5dbf9f6602647ed" name="ga0540d72496ba6270d5dbf9f6602647ed"></a>
template&lt;typename T , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; <a class="el" href="structtt_1_1is__streamable.html">tt::is_streamable</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a>, T &gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a> &gt; &gt; </td></tr>
<tr class="memitem:ga0540d72496ba6270d5dbf9f6602647ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:ga0540d72496ba6270d5dbf9f6602647ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>. <br /></td></tr>
<tr class="separator:ga0540d72496ba6270d5dbf9f6602647ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeea5bbc87e78950572b0f2df76b65ed7"><td class="memTemplParams" colspan="2"><a id="gaeea5bbc87e78950572b0f2df76b65ed7" name="gaeea5bbc87e78950572b0f2df76b65ed7"></a>
template&lt;typename T , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; <a class="el" href="structtt_1_1is__streamable.html">tt::is_streamable</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a>, T &gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a> &gt; &gt; </td></tr>
<tr class="memitem:gaeea5bbc87e78950572b0f2df76b65ed7"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:gaeea5bbc87e78950572b0f2df76b65ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>. <br /></td></tr>
<tr class="separator:gaeea5bbc87e78950572b0f2df76b65ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6495f2cbb3dd3fb3a66e8f3eeaf3889"><td class="memTemplParams" colspan="2"><a id="gaf6495f2cbb3dd3fb3a66e8f3eeaf3889" name="gaf6495f2cbb3dd3fb3a66e8f3eeaf3889"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaf6495f2cbb3dd3fb3a66e8f3eeaf3889"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; T, U &gt; &amp;t)</td></tr>
<tr class="memdesc:gaf6495f2cbb3dd3fb3a66e8f3eeaf3889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>. <br /></td></tr>
<tr class="separator:gaf6495f2cbb3dd3fb3a66e8f3eeaf3889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7440f6b198d43eec2ea363cf1b60cae3"><td class="memTemplParams" colspan="2"><a id="ga7440f6b198d43eec2ea363cf1b60cae3" name="ga7440f6b198d43eec2ea363cf1b60cae3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7440f6b198d43eec2ea363cf1b60cae3"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:ga7440f6b198d43eec2ea363cf1b60cae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>. <br /></td></tr>
<tr class="separator:ga7440f6b198d43eec2ea363cf1b60cae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga495b431a620b10beb24f1afc90b77e20"><td class="memTemplParams" colspan="2"><a id="ga495b431a620b10beb24f1afc90b77e20" name="ga495b431a620b10beb24f1afc90b77e20"></a>
template&lt;typename K , typename V , typename H &gt; </td></tr>
<tr class="memitem:ga495b431a620b10beb24f1afc90b77e20"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keys_of</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; K, V, H &gt; &amp;m)</td></tr>
<tr class="memdesc:ga495b431a620b10beb24f1afc90b77e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string containing the keys of a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>. <br /></td></tr>
<tr class="separator:ga495b431a620b10beb24f1afc90b77e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf707b57628e9425c91d92eb278a52c99"><td class="memTemplParams" colspan="2"><a id="gaf707b57628e9425c91d92eb278a52c99" name="gaf707b57628e9425c91d92eb278a52c99"></a>
template&lt;typename K , typename V , typename C &gt; </td></tr>
<tr class="memitem:gaf707b57628e9425c91d92eb278a52c99"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keys_of</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>&lt; K, V, C &gt; &amp;m)</td></tr>
<tr class="memdesc:gaf707b57628e9425c91d92eb278a52c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string containing the keys of a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>. <br /></td></tr>
<tr class="separator:gaf707b57628e9425c91d92eb278a52c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a7c7ee897f581360154a3676d5f7ab9"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ga9a7c7ee897f581360154a3676d5f7ab9"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga9a7c7ee897f581360154a3676d5f7ab9">formatted_string</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;fmt, Args... args)</td></tr>
<tr class="memdesc:ga9a7c7ee897f581360154a3676d5f7ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a string like printf.  <a href="group__UtilitiesGroup.html#ga9a7c7ee897f581360154a3676d5f7ab9">More...</a><br /></td></tr>
<tr class="separator:ga9a7c7ee897f581360154a3676d5f7ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9e9df95875a2fa4b6ec2acfe7fa26ff"><td class="memItemLeft" align="right" valign="top"><a id="gaa9e9df95875a2fa4b6ec2acfe7fa26ff" name="gaa9e9df95875a2fa4b6ec2acfe7fa26ff"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><b>current_date_and_time</b> ()</td></tr>
<tr class="memdesc:gaa9e9df95875a2fa4b6ec2acfe7fa26ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current date and time. <br /></td></tr>
<tr class="separator:gaa9e9df95875a2fa4b6ec2acfe7fa26ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcaff64325163219ed806601dd690afd"><td class="memItemLeft" align="right" valign="top"><a id="gafcaff64325163219ed806601dd690afd" name="gafcaff64325163219ed806601dd690afd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sys::exit</b> (const int exit_code=0)</td></tr>
<tr class="memdesc:gafcaff64325163219ed806601dd690afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit the program normally. This should only be called once over all processors. <br /></td></tr>
<tr class="separator:gafcaff64325163219ed806601dd690afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3812e1c88bcdd6044142a1a46758fad5"><td class="memItemLeft" align="right" valign="top"><a id="ga3812e1c88bcdd6044142a1a46758fad5" name="ga3812e1c88bcdd6044142a1a46758fad5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>sys::number_of_procs</b> ()</td></tr>
<tr class="memdesc:ga3812e1c88bcdd6044142a1a46758fad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of processing elements. <br /></td></tr>
<tr class="separator:ga3812e1c88bcdd6044142a1a46758fad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6cb8f4ed12e04398b0dd332f00eaa43"><td class="memItemLeft" align="right" valign="top"><a id="gae6cb8f4ed12e04398b0dd332f00eaa43" name="gae6cb8f4ed12e04398b0dd332f00eaa43"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>sys::my_proc</b> ()</td></tr>
<tr class="memdesc:gae6cb8f4ed12e04398b0dd332f00eaa43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of my processing element. <br /></td></tr>
<tr class="separator:gae6cb8f4ed12e04398b0dd332f00eaa43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2307a2aa3f5e2bd0966cb44998699e7"><td class="memItemLeft" align="right" valign="top"><a id="gaf2307a2aa3f5e2bd0966cb44998699e7" name="gaf2307a2aa3f5e2bd0966cb44998699e7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>sys::number_of_nodes</b> ()</td></tr>
<tr class="memdesc:gaf2307a2aa3f5e2bd0966cb44998699e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes. <br /></td></tr>
<tr class="separator:gaf2307a2aa3f5e2bd0966cb44998699e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c8dd7c6e5e0ddbb32ad0a8a2c013d4c"><td class="memItemLeft" align="right" valign="top"><a id="ga3c8dd7c6e5e0ddbb32ad0a8a2c013d4c" name="ga3c8dd7c6e5e0ddbb32ad0a8a2c013d4c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>sys::my_node</b> ()</td></tr>
<tr class="memdesc:ga3c8dd7c6e5e0ddbb32ad0a8a2c013d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of my node. <br /></td></tr>
<tr class="separator:ga3c8dd7c6e5e0ddbb32ad0a8a2c013d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf35e6f8438abe39c69ac27862905dd75"><td class="memItemLeft" align="right" valign="top"><a id="gaf35e6f8438abe39c69ac27862905dd75" name="gaf35e6f8438abe39c69ac27862905dd75"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>sys::procs_on_node</b> (const int node_index)</td></tr>
<tr class="memdesc:gaf35e6f8438abe39c69ac27862905dd75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of processing elements on the given node. <br /></td></tr>
<tr class="separator:gaf35e6f8438abe39c69ac27862905dd75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f485bc3177d668164e09e033e17c213"><td class="memItemLeft" align="right" valign="top"><a id="ga3f485bc3177d668164e09e033e17c213" name="ga3f485bc3177d668164e09e033e17c213"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>sys::my_local_rank</b> ()</td></tr>
<tr class="memdesc:ga3f485bc3177d668164e09e033e17c213"><td class="mdescLeft">&#160;</td><td class="mdescRight">The local index of my processing element on my node. This is in the interval 0, ..., procs_on_node(my_node()) - 1. <br /></td></tr>
<tr class="separator:ga3f485bc3177d668164e09e033e17c213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf51d86b84db4f6d761d734b190a245f2"><td class="memItemLeft" align="right" valign="top"><a id="gaf51d86b84db4f6d761d734b190a245f2" name="gaf51d86b84db4f6d761d734b190a245f2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>sys::first_proc_on_node</b> (const int node_index)</td></tr>
<tr class="memdesc:gaf51d86b84db4f6d761d734b190a245f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of first processing element on the given node. <br /></td></tr>
<tr class="separator:gaf51d86b84db4f6d761d734b190a245f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf65446d43ae0203e1c0987cb0684431"><td class="memItemLeft" align="right" valign="top"><a id="gadf65446d43ae0203e1c0987cb0684431" name="gadf65446d43ae0203e1c0987cb0684431"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>sys::node_of</b> (const int proc_index)</td></tr>
<tr class="memdesc:gadf65446d43ae0203e1c0987cb0684431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the node for the given processing element. <br /></td></tr>
<tr class="separator:gadf65446d43ae0203e1c0987cb0684431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaff3721fc69dc4f436fc4befc1c55a85"><td class="memItemLeft" align="right" valign="top"><a id="gaaff3721fc69dc4f436fc4befc1c55a85" name="gaaff3721fc69dc4f436fc4befc1c55a85"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>sys::local_rank_of</b> (const int proc_index)</td></tr>
<tr class="memdesc:gaaff3721fc69dc4f436fc4befc1c55a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">The local index for the given processing element on its node. <br /></td></tr>
<tr class="separator:gaaff3721fc69dc4f436fc4befc1c55a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8852629860f09d0d0423ab122331b5f"><td class="memItemLeft" align="right" valign="top"><a id="gab8852629860f09d0d0423ab122331b5f" name="gab8852629860f09d0d0423ab122331b5f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>sys::wall_time</b> ()</td></tr>
<tr class="memdesc:gab8852629860f09d0d0423ab122331b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The elapsed wall time in seconds. <br /></td></tr>
<tr class="separator:gab8852629860f09d0d0423ab122331b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5159b836743fab01c35f4676bbf3e36"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gac5159b836743fab01c35f4676bbf3e36"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gac5159b836743fab01c35f4676bbf3e36">expand_pack</a> (Ts &amp;&amp;...)</td></tr>
<tr class="memdesc:gac5159b836743fab01c35f4676bbf3e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows zero-cost unordered expansion of a parameter.  <a href="group__UtilitiesGroup.html#gac5159b836743fab01c35f4676bbf3e36">More...</a><br /></td></tr>
<tr class="separator:gac5159b836743fab01c35f4676bbf3e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga664bacfa79b2af6e52ed8bde211cca79"><td class="memTemplParams" colspan="2"><a id="ga664bacfa79b2af6e52ed8bde211cca79" name="ga664bacfa79b2af6e52ed8bde211cca79"></a>
template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:ga664bacfa79b2af6e52ed8bde211cca79"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_first_argument</b> (T &amp;&amp;t, Ts &amp;&amp;...)</td></tr>
<tr class="memdesc:ga664bacfa79b2af6e52ed8bde211cca79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first argument of a parameter pack. <br /></td></tr>
<tr class="separator:ga664bacfa79b2af6e52ed8bde211cca79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbfc4adcbade2ec4aad9f0ab878e696e"><td class="memTemplParams" colspan="2">template&lt;bool ReverseIteration = false, typename... Elements, typename N_aryOp , typename... Args&gt; </td></tr>
<tr class="memitem:gabbfc4adcbade2ec4aad9f0ab878e696e"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gabbfc4adcbade2ec4aad9f0ab878e696e">tuple_transform</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Elements... &gt; &amp;tuple, N_aryOp &amp;&amp;op, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gabbfc4adcbade2ec4aad9f0ab878e696e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a transform over a <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>.  <a href="group__UtilitiesGroup.html#gabbfc4adcbade2ec4aad9f0ab878e696e">More...</a><br /></td></tr>
<tr class="separator:gabbfc4adcbade2ec4aad9f0ab878e696e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3b35f256bcf0f88729f2afad81ae6b5"><td class="memTemplParams" colspan="2"><a id="gab3b35f256bcf0f88729f2afad81ae6b5" name="gab3b35f256bcf0f88729f2afad81ae6b5"></a>
template&lt;size_t Start, size_t Stop, typename Tuple &gt; </td></tr>
<tr class="memitem:gab3b35f256bcf0f88729f2afad81ae6b5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tuple_slice</b> (Tuple &amp;&amp;tuple)</td></tr>
<tr class="memdesc:gab3b35f256bcf0f88729f2afad81ae6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The subset of elements in <code>tuple</code> from index <code>Start</code> to (excluding) <code>Stop</code> <br /></td></tr>
<tr class="separator:gab3b35f256bcf0f88729f2afad81ae6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga450f26c91437786cae37b0f084df019a"><td class="memTemplParams" colspan="2"><a id="ga450f26c91437786cae37b0f084df019a" name="ga450f26c91437786cae37b0f084df019a"></a>
template&lt;size_t Size, typename Tuple &gt; </td></tr>
<tr class="memitem:ga450f26c91437786cae37b0f084df019a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tuple_head</b> (Tuple &amp;&amp;tuple)</td></tr>
<tr class="memdesc:ga450f26c91437786cae37b0f084df019a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first <code>Size</code> elements in <code>tuple</code> <br /></td></tr>
<tr class="separator:ga450f26c91437786cae37b0f084df019a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad557cda22886a7e63154ba0aa963b844"><td class="memTemplParams" colspan="2"><a id="gad557cda22886a7e63154ba0aa963b844" name="gad557cda22886a7e63154ba0aa963b844"></a>
template&lt;size_t Size, typename Tuple &gt; </td></tr>
<tr class="memitem:gad557cda22886a7e63154ba0aa963b844"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tuple_tail</b> (Tuple &amp;&amp;tuple)</td></tr>
<tr class="memdesc:gad557cda22886a7e63154ba0aa963b844"><td class="mdescLeft">&#160;</td><td class="mdescRight">The last <code>Size</code> elements in <code>tuple</code> <br /></td></tr>
<tr class="separator:gad557cda22886a7e63154ba0aa963b844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a9d2f32c8b4153f8bcd7c4d17c2af54"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga1a9d2f32c8b4153f8bcd7c4d17c2af54">wrap_text</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> str, size_t line_length, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;indentation=&quot;&quot;)</td></tr>
<tr class="memdesc:ga1a9d2f32c8b4153f8bcd7c4d17c2af54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap the string <code>str</code> so that it is no longer than <code>line_length</code> and indent each new line with <code>indentation</code>. The first line is also indented.  <a href="group__UtilitiesGroup.html#ga1a9d2f32c8b4153f8bcd7c4d17c2af54">More...</a><br /></td></tr>
<tr class="separator:ga1a9d2f32c8b4153f8bcd7c4d17c2af54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gab78389fadf763e3693ce893fad5d7fba"><td class="memTemplParams" colspan="2">template&lt;bool... Bs&gt; </td></tr>
<tr class="memitem:gab78389fadf763e3693ce893fad5d7fba"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gab78389fadf763e3693ce893fad5d7fba">tmpl2::flat_all_v</a> = <a class="el" href="group__UtilitiesGroup.html#ga01ee1794935080949a6995ae7d5e08cc">flat_all</a>&lt;Bs...&gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a></td></tr>
<tr class="memdesc:gab78389fadf763e3693ce893fad5d7fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-short-circuiting logical AND between bools 'B"".  <a href="group__UtilitiesGroup.html#gab78389fadf763e3693ce893fad5d7fba">More...</a><br /></td></tr>
<tr class="separator:gab78389fadf763e3693ce893fad5d7fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a328cb983ebb1947b0eb9d924f40253"><td class="memTemplParams" colspan="2">template&lt;bool... Bs&gt; </td></tr>
<tr class="memitem:ga8a328cb983ebb1947b0eb9d924f40253"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga8a328cb983ebb1947b0eb9d924f40253">tmpl2::flat_any_v</a> = <a class="el" href="group__UtilitiesGroup.html#ga6e25dbfa539ff4513329969dbcd81c40">flat_any</a>&lt;Bs...&gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a></td></tr>
<tr class="memdesc:ga8a328cb983ebb1947b0eb9d924f40253"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-short-circuiting logical OR between bools 'B"".  <a href="group__UtilitiesGroup.html#ga8a328cb983ebb1947b0eb9d924f40253">More...</a><br /></td></tr>
<tr class="separator:ga8a328cb983ebb1947b0eb9d924f40253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac932a44b57087d32ce5341314437dbbd"><td class="memTemplParams" colspan="2">template&lt;bool UseLibXsmm = false&gt; </td></tr>
<tr class="memitem:gac932a44b57087d32ce5341314437dbbd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gac932a44b57087d32ce5341314437dbbd">dgemm_</a> (const char &amp;TRANSA, const char &amp;TRANSB, const size_t &amp;M, const size_t &amp;N, const size_t &amp;K, const double &amp;ALPHA, const double *A, const size_t &amp;LDA, const double *B, const size_t &amp;LDB, const double &amp;BETA, double *C, const size_t &amp;LDC)</td></tr>
<tr class="memdesc:gac932a44b57087d32ce5341314437dbbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a matrix-matrix multiplication.  <a href="group__UtilitiesGroup.html#gac932a44b57087d32ce5341314437dbbd">More...</a><br /></td></tr>
<tr class="separator:gac932a44b57087d32ce5341314437dbbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba62a62589ffc7b8b85a7722390f7ce0"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:gaba62a62589ffc7b8b85a7722390f7ce0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaba62a62589ffc7b8b85a7722390f7ce0">dgemm_&lt; true &gt;</a> (const char &amp;TRANSA, const char &amp;TRANSB, const size_t &amp;M, const size_t &amp;N, const size_t &amp;K, const double &amp;ALPHA, const double *A, const size_t &amp;LDA, const double *B, const size_t &amp;LDB, const double &amp;BETA, double *C, const size_t &amp;LDC)</td></tr>
<tr class="memdesc:gaba62a62589ffc7b8b85a7722390f7ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a matrix-matrix multiplication.  <a href="group__UtilitiesGroup.html#gaba62a62589ffc7b8b85a7722390f7ce0">More...</a><br /></td></tr>
<tr class="separator:gaba62a62589ffc7b8b85a7722390f7ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4d31316e0975f0a66a60d9ac92756a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gad4d31316e0975f0a66a60d9ac92756a8">dgemv_</a> (const char &amp;TRANS, const size_t &amp;M, const size_t &amp;N, const double &amp;ALPHA, const double *A, const size_t &amp;LDA, const double *X, const size_t &amp;INCX, const double &amp;BETA, double *Y, const size_t &amp;INCY)</td></tr>
<tr class="memdesc:gad4d31316e0975f0a66a60d9ac92756a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a matrix-vector multiplication.  <a href="group__UtilitiesGroup.html#gad4d31316e0975f0a66a60d9ac92756a8">More...</a><br /></td></tr>
<tr class="separator:gad4d31316e0975f0a66a60d9ac92756a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga203011436ba65fd9d4f7098d83d4f66b"><td class="memTemplParams" colspan="2"><a id="ga203011436ba65fd9d4f7098d83d4f66b" name="ga203011436ba65fd9d4f7098d83d4f66b"></a>
template&lt;class T , <a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">std::size_t</a> N, typename Size &gt; </td></tr>
<tr class="memitem:ga203011436ba65fd9d4f7098d83d4f66b"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gsl::at</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, N &gt; &amp;arr, Size index)</td></tr>
<tr class="memdesc:ga203011436ba65fd9d4f7098d83d4f66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a entry from a container, with checks in Debug mode that the index being retrieved is valid. <br /></td></tr>
<tr class="separator:ga203011436ba65fd9d4f7098d83d4f66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga549be68ca2f04dc16c4f4cd9c0568a08"><td class="memTemplParams" colspan="2"><a id="ga549be68ca2f04dc16c4f4cd9c0568a08" name="ga549be68ca2f04dc16c4f4cd9c0568a08"></a>
template&lt;class Cont , typename Size &gt; </td></tr>
<tr class="memitem:ga549be68ca2f04dc16c4f4cd9c0568a08"><td class="memTemplItemLeft" align="right" valign="top">constexpr const Cont::value_type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gsl::at</b> (const Cont &amp;cont, Size index)</td></tr>
<tr class="memdesc:ga549be68ca2f04dc16c4f4cd9c0568a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a entry from a container, with checks in Debug mode that the index being retrieved is valid. <br /></td></tr>
<tr class="separator:ga549be68ca2f04dc16c4f4cd9c0568a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac19904746e57d44e824c8473ff267e8"><td class="memTemplParams" colspan="2"><a id="gaac19904746e57d44e824c8473ff267e8" name="gaac19904746e57d44e824c8473ff267e8"></a>
template&lt;class T , typename Size &gt; </td></tr>
<tr class="memitem:gaac19904746e57d44e824c8473ff267e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gsl::at</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; T &gt; cont, Size index)</td></tr>
<tr class="memdesc:gaac19904746e57d44e824c8473ff267e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a entry from a container, with checks in Debug mode that the index being retrieved is valid. <br /></td></tr>
<tr class="separator:gaac19904746e57d44e824c8473ff267e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ff63efe047a2c7fdc595dab121c8bc8"><td class="memTemplParams" colspan="2"><a id="ga0ff63efe047a2c7fdc595dab121c8bc8" name="ga0ff63efe047a2c7fdc595dab121c8bc8"></a>
template&lt;class ElementType &gt; </td></tr>
<tr class="memitem:ga0ff63efe047a2c7fdc595dab121c8bc8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgsl_1_1span.html">span</a>&lt; ElementType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gsl::make_span</b> (ElementType *ptr, typename <a class="el" href="classgsl_1_1span.html">span</a>&lt; ElementType &gt;::index_type count)</td></tr>
<tr class="memdesc:ga0ff63efe047a2c7fdc595dab121c8bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for creating spans. <br /></td></tr>
<tr class="separator:ga0ff63efe047a2c7fdc595dab121c8bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfa7ef048efe905ff24845a71e1a1246"><td class="memTemplParams" colspan="2"><a id="gacfa7ef048efe905ff24845a71e1a1246" name="gacfa7ef048efe905ff24845a71e1a1246"></a>
template&lt;class ElementType &gt; </td></tr>
<tr class="memitem:gacfa7ef048efe905ff24845a71e1a1246"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgsl_1_1span.html">span</a>&lt; ElementType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gsl::make_span</b> (ElementType *firstElem, ElementType *lastElem)</td></tr>
<tr class="memdesc:gacfa7ef048efe905ff24845a71e1a1246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for creating spans. <br /></td></tr>
<tr class="separator:gacfa7ef048efe905ff24845a71e1a1246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5c8016784c1ca983e9f3c51535a9070"><td class="memTemplParams" colspan="2"><a id="gad5c8016784c1ca983e9f3c51535a9070" name="gad5c8016784c1ca983e9f3c51535a9070"></a>
template&lt;class ElementType , <a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">std::size_t</a> N&gt; </td></tr>
<tr class="memitem:gad5c8016784c1ca983e9f3c51535a9070"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgsl_1_1span.html">span</a>&lt; ElementType, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gsl::make_span</b> (ElementType(&amp;arr)[N])</td></tr>
<tr class="memdesc:gad5c8016784c1ca983e9f3c51535a9070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for creating spans. <br /></td></tr>
<tr class="separator:gad5c8016784c1ca983e9f3c51535a9070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf00c2d2a50a3f5d0c0389b76d5312857"><td class="memTemplParams" colspan="2"><a id="gaf00c2d2a50a3f5d0c0389b76d5312857" name="gaf00c2d2a50a3f5d0c0389b76d5312857"></a>
template&lt;class Container &gt; </td></tr>
<tr class="memitem:gaf00c2d2a50a3f5d0c0389b76d5312857"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgsl_1_1span.html">span</a>&lt; typename Container::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gsl::make_span</b> (Container &amp;cont)</td></tr>
<tr class="memdesc:gaf00c2d2a50a3f5d0c0389b76d5312857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for creating spans. <br /></td></tr>
<tr class="separator:gaf00c2d2a50a3f5d0c0389b76d5312857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d192c98f68f8e40a7be81e8a251b288"><td class="memTemplParams" colspan="2"><a id="ga9d192c98f68f8e40a7be81e8a251b288" name="ga9d192c98f68f8e40a7be81e8a251b288"></a>
template&lt;class Container &gt; </td></tr>
<tr class="memitem:ga9d192c98f68f8e40a7be81e8a251b288"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgsl_1_1span.html">span</a>&lt; const typename Container::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gsl::make_span</b> (const Container &amp;cont)</td></tr>
<tr class="memdesc:ga9d192c98f68f8e40a7be81e8a251b288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for creating spans. <br /></td></tr>
<tr class="separator:ga9d192c98f68f8e40a7be81e8a251b288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58441b154d7c15ffbcb2b42a0281feb2"><td class="memTemplParams" colspan="2"><a id="ga58441b154d7c15ffbcb2b42a0281feb2" name="ga58441b154d7c15ffbcb2b42a0281feb2"></a>
template&lt;class Ptr &gt; </td></tr>
<tr class="memitem:ga58441b154d7c15ffbcb2b42a0281feb2"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgsl_1_1span.html">span</a>&lt; typename Ptr::element_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gsl::make_span</b> (Ptr &amp;cont, <a class="elRef" href="http://en.cppreference.com/w/cpp/types/ptrdiff_t.html">std::ptrdiff_t</a> count)</td></tr>
<tr class="memdesc:ga58441b154d7c15ffbcb2b42a0281feb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for creating spans. <br /></td></tr>
<tr class="separator:ga58441b154d7c15ffbcb2b42a0281feb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27cf9cef44a0e842d0f3d009ea9a960c"><td class="memTemplParams" colspan="2"><a id="ga27cf9cef44a0e842d0f3d009ea9a960c" name="ga27cf9cef44a0e842d0f3d009ea9a960c"></a>
template&lt;class Ptr &gt; </td></tr>
<tr class="memitem:ga27cf9cef44a0e842d0f3d009ea9a960c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgsl_1_1span.html">span</a>&lt; typename Ptr::element_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gsl::make_span</b> (Ptr &amp;cont)</td></tr>
<tr class="memdesc:ga27cf9cef44a0e842d0f3d009ea9a960c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for creating spans. <br /></td></tr>
<tr class="separator:ga27cf9cef44a0e842d0f3d009ea9a960c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf84a0c15b325953da81c651387b3fc00"><td class="memTemplParams" colspan="2"><a id="gaf84a0c15b325953da81c651387b3fc00" name="gaf84a0c15b325953da81c651387b3fc00"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf84a0c15b325953da81c651387b3fc00"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_signaling_NaN</b> (const T &amp;)</td></tr>
<tr class="memdesc:gaf84a0c15b325953da81c651387b3fc00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an appropriate signaling NaN for fundamantal or multi-field types (such as <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a></code>). <br /></td></tr>
<tr class="separator:gaf84a0c15b325953da81c651387b3fc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a9c70171fccdadb48b3ea408d8ff7a1"><td class="memTemplParams" colspan="2"><a id="ga7a9c70171fccdadb48b3ea408d8ff7a1" name="ga7a9c70171fccdadb48b3ea408d8ff7a1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7a9c70171fccdadb48b3ea408d8ff7a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_signaling_NaN</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>&lt; T &gt; &amp;)</td></tr>
<tr class="memdesc:ga7a9c70171fccdadb48b3ea408d8ff7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an appropriate signaling NaN for fundamantal or multi-field types (such as <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a></code>). <br /></td></tr>
<tr class="separator:ga7a9c70171fccdadb48b3ea408d8ff7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac6dff602fd9dbc5dd22f9b1c62f89c8"><td class="memTemplParams" colspan="2"><a id="gaac6dff602fd9dbc5dd22f9b1c62f89c8" name="gaac6dff602fd9dbc5dd22f9b1c62f89c8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaac6dff602fd9dbc5dd22f9b1c62f89c8"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_signaling_NaN</b> ()</td></tr>
<tr class="memdesc:gaac6dff602fd9dbc5dd22f9b1c62f89c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an appropriate signaling NaN for fundamantal or multi-field types (such as <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a></code>). <br /></td></tr>
<tr class="separator:gaac6dff602fd9dbc5dd22f9b1c62f89c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac295bd38803716821a7546a117dc550b"><td class="memTemplParams" colspan="2"><a id="gac295bd38803716821a7546a117dc550b" name="gac295bd38803716821a7546a117dc550b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac295bd38803716821a7546a117dc550b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_value</b> (const T &amp;)</td></tr>
<tr class="memdesc:gac295bd38803716821a7546a117dc550b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>t.has_value()</code> if <code>t</code> is a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a></code> otherwise returns <code>true</code>. <br /></td></tr>
<tr class="separator:gac295bd38803716821a7546a117dc550b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga706f00a52f19244d669b91ebd347175d"><td class="memTemplParams" colspan="2"><a id="ga706f00a52f19244d669b91ebd347175d" name="ga706f00a52f19244d669b91ebd347175d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga706f00a52f19244d669b91ebd347175d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_value</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:ga706f00a52f19244d669b91ebd347175d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>t.has_value()</code> if <code>t</code> is a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a></code> otherwise returns <code>true</code>. <br /></td></tr>
<tr class="separator:ga706f00a52f19244d669b91ebd347175d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4316f2ea7fb92cf4a3c5cf53bf36fb82"><td class="memTemplParams" colspan="2"><a id="ga4316f2ea7fb92cf4a3c5cf53bf36fb82" name="ga4316f2ea7fb92cf4a3c5cf53bf36fb82"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4316f2ea7fb92cf4a3c5cf53bf36fb82"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>value</b> (T &amp;t)</td></tr>
<tr class="memdesc:ga4316f2ea7fb92cf4a3c5cf53bf36fb82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>t.value()</code> if <code>t</code> is a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a></code> otherwise returns <code>t</code>. <br /></td></tr>
<tr class="separator:ga4316f2ea7fb92cf4a3c5cf53bf36fb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52278bc22aa0a3e874f83fc0a48da363"><td class="memTemplParams" colspan="2"><a id="ga52278bc22aa0a3e874f83fc0a48da363" name="ga52278bc22aa0a3e874f83fc0a48da363"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga52278bc22aa0a3e874f83fc0a48da363"><td class="memTemplItemLeft" align="right" valign="top">constexpr const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>value</b> (const T &amp;t)</td></tr>
<tr class="memdesc:ga52278bc22aa0a3e874f83fc0a48da363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>t.value()</code> if <code>t</code> is a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a></code> otherwise returns <code>t</code>. <br /></td></tr>
<tr class="separator:ga52278bc22aa0a3e874f83fc0a48da363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga077584c6a9bbe723e048e251e57c5b2b"><td class="memTemplParams" colspan="2"><a id="ga077584c6a9bbe723e048e251e57c5b2b" name="ga077584c6a9bbe723e048e251e57c5b2b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga077584c6a9bbe723e048e251e57c5b2b"><td class="memTemplItemLeft" align="right" valign="top">constexpr const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>value</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:ga077584c6a9bbe723e048e251e57c5b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>t.value()</code> if <code>t</code> is a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a></code> otherwise returns <code>t</code>. <br /></td></tr>
<tr class="separator:ga077584c6a9bbe723e048e251e57c5b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cb8822c810d5eec9a7ecc6d271bda8f"><td class="memTemplParams" colspan="2"><a id="ga2cb8822c810d5eec9a7ecc6d271bda8f" name="ga2cb8822c810d5eec9a7ecc6d271bda8f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2cb8822c810d5eec9a7ecc6d271bda8f"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>value</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:ga2cb8822c810d5eec9a7ecc6d271bda8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>t.value()</code> if <code>t</code> is a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a></code> otherwise returns <code>t</code>. <br /></td></tr>
<tr class="separator:ga2cb8822c810d5eec9a7ecc6d271bda8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c0f4bd567ade345d958281f4c51311e"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Func &gt; </td></tr>
<tr class="memitem:ga3c0f4bd567ade345d958281f4c51311e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga3c0f4bd567ade345d958281f4c51311e">unordered_print_helper</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;out, ForwardIt &amp;&amp;begin, ForwardIt &amp;&amp;end, Func f)</td></tr>
<tr class="separator:ga3c0f4bd567ade345d958281f4c51311e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2510b0047d38d00d44cc1eda26c327f3"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt &gt; </td></tr>
<tr class="memitem:ga2510b0047d38d00d44cc1eda26c327f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga2510b0047d38d00d44cc1eda26c327f3">unordered_print_helper</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;out, ForwardIt &amp;&amp;begin, ForwardIt &amp;&amp;end)</td></tr>
<tr class="separator:ga2510b0047d38d00d44cc1eda26c327f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e9bfc1b0a96c9df21035b121c713c62"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0e9bfc1b0a96c9df21035b121c713c62"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga0e9bfc1b0a96c9df21035b121c713c62">magnitude</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 1 &gt; &amp;a)</td></tr>
<tr class="memdesc:ga0e9bfc1b0a96c9df21035b121c713c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean magnitude of the elements of the array.  <a href="group__UtilitiesGroup.html#ga0e9bfc1b0a96c9df21035b121c713c62">More...</a><br /></td></tr>
<tr class="separator:ga0e9bfc1b0a96c9df21035b121c713c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a75bb0e498b9c41a295ee606e63f8cd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3a75bb0e498b9c41a295ee606e63f8cd"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga3a75bb0e498b9c41a295ee606e63f8cd">magnitude</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 2 &gt; &amp;a)</td></tr>
<tr class="memdesc:ga3a75bb0e498b9c41a295ee606e63f8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean magnitude of the elements of the array.  <a href="group__UtilitiesGroup.html#ga3a75bb0e498b9c41a295ee606e63f8cd">More...</a><br /></td></tr>
<tr class="separator:ga3a75bb0e498b9c41a295ee606e63f8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9b05708ddf66db6b5b14b179d78f4bf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab9b05708ddf66db6b5b14b179d78f4bf"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gab9b05708ddf66db6b5b14b179d78f4bf">magnitude</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 3 &gt; &amp;a)</td></tr>
<tr class="memdesc:gab9b05708ddf66db6b5b14b179d78f4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean magnitude of the elements of the array.  <a href="group__UtilitiesGroup.html#gab9b05708ddf66db6b5b14b179d78f4bf">More...</a><br /></td></tr>
<tr class="separator:gab9b05708ddf66db6b5b14b179d78f4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2205f7b4b505b2c8c5f50555bf2725bd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R &gt; </td></tr>
<tr class="memitem:ga2205f7b4b505b2c8c5f50555bf2725bd"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga2205f7b4b505b2c8c5f50555bf2725bd">dot</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 1 &gt; &amp;first, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; R, 1 &gt; &amp;second)</td></tr>
<tr class="memdesc:ga2205f7b4b505b2c8c5f50555bf2725bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product between two arrays.  <a href="group__UtilitiesGroup.html#ga2205f7b4b505b2c8c5f50555bf2725bd">More...</a><br /></td></tr>
<tr class="separator:ga2205f7b4b505b2c8c5f50555bf2725bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga825f09807dc021897b0879bc1469061c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R &gt; </td></tr>
<tr class="memitem:ga825f09807dc021897b0879bc1469061c"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga825f09807dc021897b0879bc1469061c">dot</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 2 &gt; &amp;first, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; R, 2 &gt; &amp;second)</td></tr>
<tr class="memdesc:ga825f09807dc021897b0879bc1469061c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product between two arrays.  <a href="group__UtilitiesGroup.html#ga825f09807dc021897b0879bc1469061c">More...</a><br /></td></tr>
<tr class="separator:ga825f09807dc021897b0879bc1469061c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0847cf84cbbb471fc0499a5d4a1cb96"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R &gt; </td></tr>
<tr class="memitem:gad0847cf84cbbb471fc0499a5d4a1cb96"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gad0847cf84cbbb471fc0499a5d4a1cb96">dot</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 3 &gt; &amp;first, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; R, 3 &gt; &amp;second)</td></tr>
<tr class="memdesc:gad0847cf84cbbb471fc0499a5d4a1cb96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product between two arrays.  <a href="group__UtilitiesGroup.html#gad0847cf84cbbb471fc0499a5d4a1cb96">More...</a><br /></td></tr>
<tr class="separator:gad0847cf84cbbb471fc0499a5d4a1cb96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac200e3caf061b50d5a490b14ea1e1311"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gac200e3caf061b50d5a490b14ea1e1311">sys::pretty_wall_time</a> (double total_seconds)</td></tr>
<tr class="memdesc:gac200e3caf061b50d5a490b14ea1e1311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format the wall time in DD-HH:MM:SS format.  <a href="group__UtilitiesGroup.html#gac200e3caf061b50d5a490b14ea1e1311">More...</a><br /></td></tr>
<tr class="separator:gac200e3caf061b50d5a490b14ea1e1311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga940a5cb08e0c8176b0734c0560fccac9"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga940a5cb08e0c8176b0734c0560fccac9">sys::pretty_wall_time</a> ()</td></tr>
<tr class="memdesc:ga940a5cb08e0c8176b0734c0560fccac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format the wall time in DD-HH:MM:SS format.  <a href="group__UtilitiesGroup.html#ga940a5cb08e0c8176b0734c0560fccac9">More...</a><br /></td></tr>
<tr class="separator:ga940a5cb08e0c8176b0734c0560fccac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e41f4f4a505c3e588fdfe2b64741c71"><td class="memTemplParams" colspan="2"><a id="ga1e41f4f4a505c3e588fdfe2b64741c71" name="ga1e41f4f4a505c3e588fdfe2b64741c71"></a>
template&lt;class Tag , class... Tags&gt; </td></tr>
<tr class="memitem:ga1e41f4f4a505c3e588fdfe2b64741c71"><td class="memTemplItemLeft" align="right" valign="top">constexpr const Tag::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tuples::get</b> (const <a class="el" href="classtuples_1_1TaggedTuple.html">TaggedTuple</a>&lt; Tags... &gt; &amp;t)</td></tr>
<tr class="memdesc:ga1e41f4f4a505c3e588fdfe2b64741c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the element of <code>Tag</code> in the <a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs.">TaggedTuple</a>. <br /></td></tr>
<tr class="separator:ga1e41f4f4a505c3e588fdfe2b64741c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae7e69f496957574affe0f09e4442dd2"><td class="memTemplParams" colspan="2"><a id="gaae7e69f496957574affe0f09e4442dd2" name="gaae7e69f496957574affe0f09e4442dd2"></a>
template&lt;class Tag , class... Tags&gt; </td></tr>
<tr class="memitem:gaae7e69f496957574affe0f09e4442dd2"><td class="memTemplItemLeft" align="right" valign="top">constexpr Tag::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tuples::get</b> (<a class="el" href="classtuples_1_1TaggedTuple.html">TaggedTuple</a>&lt; Tags... &gt; &amp;t)</td></tr>
<tr class="memdesc:gaae7e69f496957574affe0f09e4442dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the element of <code>Tag</code> in the <a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs.">TaggedTuple</a>. <br /></td></tr>
<tr class="separator:gaae7e69f496957574affe0f09e4442dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ee2114d2307481d15e10f2acbdbeda9"><td class="memTemplParams" colspan="2"><a id="ga2ee2114d2307481d15e10f2acbdbeda9" name="ga2ee2114d2307481d15e10f2acbdbeda9"></a>
template&lt;class Tag , class... Tags&gt; </td></tr>
<tr class="memitem:ga2ee2114d2307481d15e10f2acbdbeda9"><td class="memTemplItemLeft" align="right" valign="top">constexpr const Tag::type &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tuples::get</b> (const <a class="el" href="classtuples_1_1TaggedTuple.html">TaggedTuple</a>&lt; Tags... &gt; &amp;&amp;t)</td></tr>
<tr class="memdesc:ga2ee2114d2307481d15e10f2acbdbeda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the element of <code>Tag</code> in the <a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs.">TaggedTuple</a>. <br /></td></tr>
<tr class="separator:ga2ee2114d2307481d15e10f2acbdbeda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6791fd8d940a267793b14e50db07a7a4"><td class="memTemplParams" colspan="2"><a id="ga6791fd8d940a267793b14e50db07a7a4" name="ga6791fd8d940a267793b14e50db07a7a4"></a>
template&lt;class Tag , class... Tags&gt; </td></tr>
<tr class="memitem:ga6791fd8d940a267793b14e50db07a7a4"><td class="memTemplItemLeft" align="right" valign="top">constexpr Tag::type &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tuples::get</b> (<a class="el" href="classtuples_1_1TaggedTuple.html">TaggedTuple</a>&lt; Tags... &gt; &amp;&amp;t)</td></tr>
<tr class="memdesc:ga6791fd8d940a267793b14e50db07a7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the element of <code>Tag</code> in the <a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs.">TaggedTuple</a>. <br /></td></tr>
<tr class="separator:ga6791fd8d940a267793b14e50db07a7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0d5e7fa5e0aa31f06200f691d74300b"><td class="memTemplParams" colspan="2">template&lt;typename ApplyTags , typename F , typename... Tags&gt; </td></tr>
<tr class="memitem:gab0d5e7fa5e0aa31f06200f691d74300b"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gab0d5e7fa5e0aa31f06200f691d74300b">tuples::apply</a> (F &amp;&amp;f, const <a class="el" href="classtuples_1_1TaggedTuple.html">TaggedTuple</a>&lt; Tags... &gt; &amp;t)</td></tr>
<tr class="memdesc:gab0d5e7fa5e0aa31f06200f691d74300b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke <code>f</code> with the <code>ApplyTags</code> taken from <code>t</code> expanded in a parameter pack.  <a href="group__UtilitiesGroup.html#gab0d5e7fa5e0aa31f06200f691d74300b">More...</a><br /></td></tr>
<tr class="separator:gab0d5e7fa5e0aa31f06200f691d74300b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7faaf4800d1d5784ee29134600dd11d"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Tags&gt; </td></tr>
<tr class="memitem:gaf7faaf4800d1d5784ee29134600dd11d"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaf7faaf4800d1d5784ee29134600dd11d">tuples::apply</a> (F &amp;&amp;f, const <a class="el" href="classtuples_1_1TaggedTuple.html">TaggedTuple</a>&lt; Tags... &gt; &amp;t)</td></tr>
<tr class="memdesc:gaf7faaf4800d1d5784ee29134600dd11d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke <code>f</code> with the <code>ApplyTags</code> taken from <code>t</code> expanded in a parameter pack.  <a href="group__UtilitiesGroup.html#gaf7faaf4800d1d5784ee29134600dd11d">More...</a><br /></td></tr>
<tr class="separator:gaf7faaf4800d1d5784ee29134600dd11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaeb211c58335d67859ac2e506f6e617"><td class="memTemplParams" colspan="2">template&lt;bool ReverseIteration = false, typename... Elements, typename N_aryOp , typename... Args&gt; </td></tr>
<tr class="memitem:gacaeb211c58335d67859ac2e506f6e617"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gacaeb211c58335d67859ac2e506f6e617">tuple_fold</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Elements... &gt; &amp;tuple, N_aryOp &amp;&amp;op, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gacaeb211c58335d67859ac2e506f6e617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a fold over a <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>.  <a href="group__UtilitiesGroup.html#gacaeb211c58335d67859ac2e506f6e617">More...</a><br /></td></tr>
<tr class="separator:gacaeb211c58335d67859ac2e506f6e617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ae1fc4fc42ed12ea47af23969583227"><td class="memTemplParams" colspan="2">template&lt;bool ReverseIteration = false, typename... Elements, typename N_aryOp , typename... Args&gt; </td></tr>
<tr class="memitem:ga2ae1fc4fc42ed12ea47af23969583227"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga2ae1fc4fc42ed12ea47af23969583227">tuple_counted_fold</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Elements... &gt; &amp;tuple, N_aryOp &amp;&amp;op, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga2ae1fc4fc42ed12ea47af23969583227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a fold over a <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>.  <a href="group__UtilitiesGroup.html#ga2ae1fc4fc42ed12ea47af23969583227">More...</a><br /></td></tr>
<tr class="separator:ga2ae1fc4fc42ed12ea47af23969583227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22191cd0e4e0947bdc6427fb31f26c7a"><td class="memTemplParams" colspan="2">template&lt;typename LhsVectorType , typename RhsVectorType , typename ResultVectorType  = typename blaze::MultTrait&lt;LhsVectorType, RhsVectorType&gt;::Type&gt; </td></tr>
<tr class="memitem:ga22191cd0e4e0947bdc6427fb31f26c7a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga22191cd0e4e0947bdc6427fb31f26c7a">outer_product</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; ResultVectorType * &gt; result, const LhsVectorType &amp;lhs, const RhsVectorType &amp;rhs)</td></tr>
<tr class="memdesc:ga22191cd0e4e0947bdc6427fb31f26c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the outer product between two vectors.  <a href="group__UtilitiesGroup.html#ga22191cd0e4e0947bdc6427fb31f26c7a">More...</a><br /></td></tr>
<tr class="separator:ga22191cd0e4e0947bdc6427fb31f26c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8081baf300ab4b2cae7551d6e3860c49"><td class="memTemplParams" colspan="2">template&lt;typename LhsVectorType , typename RhsVectorType , typename ResultVectorType  = typename blaze::MultTrait&lt;LhsVectorType, RhsVectorType&gt;::Type&gt; </td></tr>
<tr class="memitem:ga8081baf300ab4b2cae7551d6e3860c49"><td class="memTemplItemLeft" align="right" valign="top">ResultVectorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga8081baf300ab4b2cae7551d6e3860c49">outer_product</a> (const LhsVectorType &amp;lhs, const RhsVectorType &amp;rhs)</td></tr>
<tr class="memdesc:ga8081baf300ab4b2cae7551d6e3860c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the outer product between two vectors.  <a href="group__UtilitiesGroup.html#ga8081baf300ab4b2cae7551d6e3860c49">More...</a><br /></td></tr>
<tr class="separator:ga8081baf300ab4b2cae7551d6e3860c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa048e7dccecfa01916acafb634db4e70"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:gaa048e7dccecfa01916acafb634db4e70"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaa048e7dccecfa01916acafb634db4e70">fill_with_n_copies</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; VectorType * &gt; result, const VectorType &amp;to_copy, const size_t times_to_copy)</td></tr>
<tr class="memdesc:gaa048e7dccecfa01916acafb634db4e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates or fills a vector with data from <code>to_repeat</code> copied <code>times_to_repeat</code> times in sequence.  <a href="group__UtilitiesGroup.html#gaa048e7dccecfa01916acafb634db4e70">More...</a><br /></td></tr>
<tr class="separator:gaa048e7dccecfa01916acafb634db4e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d2165f76f750a3ca7e4444462451d87"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:ga6d2165f76f750a3ca7e4444462451d87"><td class="memTemplItemLeft" align="right" valign="top">VectorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga6d2165f76f750a3ca7e4444462451d87">create_vector_of_n_copies</a> (const VectorType &amp;to_copy, const size_t times_to_copy)</td></tr>
<tr class="memdesc:ga6d2165f76f750a3ca7e4444462451d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates or fills a vector with data from <code>to_repeat</code> copied <code>times_to_repeat</code> times in sequence.  <a href="group__UtilitiesGroup.html#ga6d2165f76f750a3ca7e4444462451d87">More...</a><br /></td></tr>
<tr class="separator:ga6d2165f76f750a3ca7e4444462451d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >A collection of useful classes, functions and metafunctions. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaee1c0cc775bf58891fab30b95a3ac51f" name="gaee1c0cc775bf58891fab30b95a3ac51f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee1c0cc775bf58891fab30b95a3ac51f">&#9670;&nbsp;</a></span>DEFINE_STD_ARRAY_BINOP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFINE_STD_ARRAY_BINOP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RESULT_TYPE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">LTYPE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RTYPE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">OP_FUNCTION_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BINARY_OP&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Dim&gt;                                                       \</div>
<div class="line">  std::array&lt;RESULT_TYPE, Dim&gt; OP_FUNCTION_NAME(                              \</div>
<div class="line">      <span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;LTYPE, Dim&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;RTYPE, Dim&gt;</a>&amp; rhs) { \</div>
<div class="line">    std::array&lt;RESULT_TYPE, Dim&gt; result; <span class="comment">/*NOLINT*/</span>                           \</div>
<div class="line">    std::transform(lhs.begin(), lhs.end(), rhs.begin(), result.begin(),       \</div>
<div class="line">                   BINARY_OP);                                                \</div>
<div class="line">    return result;                                                            \</div>
<div class="line">  }</div>
<div class="ttc" id="aarray_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a></div></div>
</div><!-- fragment -->
<p>Declares a binary function on an array, intended for binary operators such as <code>+</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">RESULT_TYPE</td><td>the <code>value_type</code> that is the result of the operation (e.g. <code>A</code> for resulting <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;A,2&gt;</code>)</td></tr>
    <tr><td class="paramname">LTYPE</td><td>the <code>value_type</code> of the first argument of the function (so the left value if the function is an operator overload)</td></tr>
    <tr><td class="paramname">RTYPE</td><td>the <code>value_type</code> of the second argument of the function</td></tr>
    <tr><td class="paramname">OP_FUNCTION_NAME</td><td>the function which should be declared (e.g. <code>operator+</code>)</td></tr>
    <tr><td class="paramname">BINARY_OP</td><td>the binary function which should be applied elementwise to the pair of arrays. (e.g. <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/plus.html">std::plus</a>&lt;&gt;()</code>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4409dfaeeba8ef49967a7c98e4709c98" name="ga4409dfaeeba8ef49967a7c98e4709c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4409dfaeeba8ef49967a7c98e4709c98">&#9670;&nbsp;</a></span>DEFINE_STD_ARRAY_INPLACE_BINOP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFINE_STD_ARRAY_INPLACE_BINOP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">LTYPE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RTYPE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">OP_FUNCTION_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BINARY_OP&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Dim&gt;                                                 \</div>
<div class="line">  std::array&lt;LTYPE, Dim&gt;&amp; OP_FUNCTION_NAME(                             \</div>
<div class="line">      <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;LTYPE, Dim&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;RTYPE, Dim&gt;</a>&amp; rhs) { \</div>
<div class="line">    std::transform(lhs.begin(), lhs.end(), rhs.begin(), lhs.begin(),    \</div>
<div class="line">                   BINARY_OP);                                          \</div>
<div class="line">    return lhs;                                                         \</div>
<div class="line">  }</div>
</div><!-- fragment -->
<p>Declares an in-place binary function on an array, intended for operations such as <code>+=</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LTYPE</td><td>the <code>value_type</code> of the first argument of the function which is also the result <code>value_tye</code> of the operation (so the left value if the function is an operator overload)</td></tr>
    <tr><td class="paramname">RTYPE</td><td>the <code>value_type</code> of the second argument of the function</td></tr>
    <tr><td class="paramname">OP_FUNCTION_NAME</td><td>the function which should be declared (e.g. <code>operator+=</code>)</td></tr>
    <tr><td class="paramname">BINARY_OP</td><td>the binary function which should be applied elementwise to the pair of arrays. (e.g. <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/plus.html">std::plus</a>&lt;&gt;()</code>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga902d1cefbb10846eb8f5be9f6be5c340" name="ga902d1cefbb10846eb8f5be9f6be5c340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga902d1cefbb10846eb8f5be9f6be5c340">&#9670;&nbsp;</a></span>EXPAND_PACK_LEFT_TO_RIGHT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EXPAND_PACK_LEFT_TO_RIGHT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;  (void)<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt;char&gt; { ((void)(__VA_ARGS__), '0')... }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand a parameter pack evaluating the terms from left to right. </p>
<p >The parameter pack inside the argument to the macro must not be expanded since the macro will do the expansion correctly for you. In the below example a parameter pack of <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a>&lt;size_t, I&gt;</code> is passed to the function. The closure <code>lambda</code> is used to sum up the values of all the <code>Ts</code>. Note that the <code>Ts</code> passed to <code>EXPAND_PACK_LEFT_TO_RIGHT</code> is not expanded.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</div>
<div class="line"><span class="keywordtype">void</span> test_expand_pack_left_to_right(<span class="keyword">const</span> <span class="keywordtype">size_t</span> expected,</div>
<div class="line">                                    tmpl::list&lt;Ts...&gt; <span class="comment">/*meta*/</span>) {</div>
<div class="line">  <span class="keywordtype">size_t</span> sum = 0;</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> lambda = [&amp;sum](<span class="keyword">auto</span> tag) { sum += <span class="keyword">decltype</span>(tag)<a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">::value</a>; };</div>
<div class="line">  <a class="code hl_define" href="group__UtilitiesGroup.html#ga902d1cefbb10846eb8f5be9f6be5c340">EXPAND_PACK_LEFT_TO_RIGHT</a>(lambda(Ts{}));</div>
<div class="line">  CHECK(sum == expected);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__UtilitiesGroup_html_ga4316f2ea7fb92cf4a3c5cf53bf36fb82"><div class="ttname"><a href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">value</a></div><div class="ttdeci">constexpr T &amp; value(T &amp;t)</div><div class="ttdoc">Returns t.value() if t is a std::optional otherwise returns t.</div><div class="ttdef"><b>Definition:</b> OptionalHelpers.hpp:32</div></div>
<div class="ttc" id="agroup__UtilitiesGroup_html_ga902d1cefbb10846eb8f5be9f6be5c340"><div class="ttname"><a href="group__UtilitiesGroup.html#ga902d1cefbb10846eb8f5be9f6be5c340">EXPAND_PACK_LEFT_TO_RIGHT</a></div><div class="ttdeci">#define EXPAND_PACK_LEFT_TO_RIGHT(...)</div><div class="ttdoc">Expand a parameter pack evaluating the terms from left to right.</div><div class="ttdef"><b>Definition:</b> TMPL.hpp:596</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__UtilitiesGroup.html#gacaeb211c58335d67859ac2e506f6e617" title="Perform a fold over a std::tuple.">tuple_fold</a> <a class="el" href="group__UtilitiesGroup.html#ga2ae1fc4fc42ed12ea47af23969583227" title="Perform a fold over a std::tuple.">tuple_counted_fold</a> <a class="el" href="group__UtilitiesGroup.html#gabbfc4adcbade2ec4aad9f0ab878e696e" title="Perform a transform over a std::tuple.">tuple_transform</a> <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> <a class="el" href="group__UtilitiesGroup.html#gac5159b836743fab01c35f4676bbf3e36" title="Allows zero-cost unordered expansion of a parameter.">expand_pack</a> </dd></dl>

</div>
</div>
<a id="gad7b776398a66e9a6bd561c8decf08b47" name="gad7b776398a66e9a6bd561c8decf08b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7b776398a66e9a6bd561c8decf08b47">&#9670;&nbsp;</a></span>GENERATE_INSTANTIATIONS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GENERATE_INSTANTIATIONS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">INSTANTIATION_MACRO, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  GENERATE_INSTANTIATIONS_DO_PRODUCT(                                    \</div>
<div class="line">      INSTANTIATION_MACRO,                                               \</div>
<div class="line">      BOOST_PP_LIST_TRANSFORM(GENERATE_INSTANTIATION_TUPLES_TO_LISTS, _, \</div>
<div class="line">                              BOOST_PP_VARIADIC_TO_LIST(__VA_ARGS__)))</div>
</div><!-- fragment -->
<p>Macro useful for generating many explicit instantiations of function or class templates. </p>
<p >It is often necessary to generate explicit instantiations of function or class templates. Since the total number of explicit instantiations scales as the product of the number of possible number of parameter values of each template parameter, this quickly becomes tedious. This macro allows you to easily generate hundreds of explicit instantiations.</p>
<p >The first argument to the macro is a macro that takes two arguments and is described below. The remaining arguments are macro-tuples, e.g. <code>(1, 2, 3)</code>. The Cartesian product of the macro-tuples is then computed and each term is passed as a tuple as the second argument to the <code>INSTANTIATION_MACRO</code>. The first argument to the <code>INSTANTIATION_MACRO</code> is a Boost.Preprocessor internal variable so just make it <code>_</code>. The <code>INSTANTIATION(_, data)</code> macro below serves as an example. A concrete example is generating explicit instantiations of the class <code><a class="el" href="classIndex.html" title="An integer multi-index.">Index</a>&lt;Dim&gt;</code> for <code>Dim = 0,1,2,3</code>, which you would do as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define GET_DIM(data) BOOST_PP_TUPLE_ELEM(0, data)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define INSTANTIATION(_, data)         \</span></div>
<div class="line"><span class="preprocessor">  template class Index&lt;GET_DIM(data)&gt;;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__UtilitiesGroup.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a>(INSTANTIATION, (0, 1, 2, 3))</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#undef GET_DIM</span></div>
<div class="line"><span class="preprocessor">#undef INSTANTIATION</span></div>
<div class="ttc" id="agroup__UtilitiesGroup_html_gad7b776398a66e9a6bd561c8decf08b47"><div class="ttname"><a href="group__UtilitiesGroup.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a></div><div class="ttdeci">#define GENERATE_INSTANTIATIONS(INSTANTIATION_MACRO,...)</div><div class="ttdoc">Macro useful for generating many explicit instantiations of function or class templates.</div><div class="ttdef"><b>Definition:</b> GenerateInstantiations.hpp:160</div></div>
</div><!-- fragment --><p >This will generate:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code hl_class" href="classIndex.html">Index&lt;0&gt;</a>;</div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code hl_class" href="classIndex.html">Index&lt;1&gt;</a>;</div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code hl_class" href="classIndex.html">Index&lt;2&gt;</a>;</div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code hl_class" href="classIndex.html">Index&lt;3&gt;</a>;</div>
<div class="ttc" id="aclassIndex_html"><div class="ttname"><a href="classIndex.html">Index</a></div><div class="ttdoc">An integer multi-index.</div><div class="ttdef"><b>Definition:</b> Index.hpp:31</div></div>
</div><!-- fragment --><p >It is also possible to generate explicit instantiations for multiple classes or functions in a single call to <code>GENERATE_INSTANTIATIONS</code>. For example, the (in)equivalence operators can be generated using:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define GET_DIM(data) BOOST_PP_TUPLE_ELEM(0, data)</span></div>
<div class="line"><span class="preprocessor">#define GEN_OP(op, dim)                            \</span></div>
<div class="line"><span class="preprocessor">  template bool operator op(const Index&lt;dim&gt;&amp; lhs, \</span></div>
<div class="line"><span class="preprocessor">                            const Index&lt;dim&gt;&amp; rhs);</span></div>
<div class="line"><span class="preprocessor">#define INSTANTIATION(_, data)         \</span></div>
<div class="line"><span class="preprocessor">  template class Index&lt;GET_DIM(data)&gt;; \</span></div>
<div class="line"><span class="preprocessor">  GEN_OP(==, GET_DIM(data))            \</span></div>
<div class="line"><span class="preprocessor">  GEN_OP(!=, GET_DIM(data))</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__UtilitiesGroup.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a>(INSTANTIATION, (0, 1, 2, 3))</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#undef GET_DIM</span></div>
<div class="line"><span class="preprocessor">#undef GEN_OP</span></div>
<div class="line"><span class="preprocessor">#undef INSTANTIATION</span></div>
</div><!-- fragment --><p >which will result in the instantiations:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code hl_class" href="classIndex.html">Index&lt;0&gt;</a>;</div>
<div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> <a class="code hl_class" href="classIndex.html">Index&lt;0&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code hl_class" href="classIndex.html">Index&lt;0&gt;</a>&amp; rhs);</div>
<div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/utility/rel_ops/operator_cmp.html">operator!=</a>(<span class="keyword">const</span> <a class="code hl_class" href="classIndex.html">Index&lt;0&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code hl_class" href="classIndex.html">Index&lt;0&gt;</a>&amp; rhs);</div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code hl_class" href="classIndex.html">Index&lt;1&gt;</a>;</div>
<div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> <a class="code hl_class" href="classIndex.html">Index&lt;1&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code hl_class" href="classIndex.html">Index&lt;1&gt;</a>&amp; rhs);</div>
<div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/utility/rel_ops/operator_cmp.html">operator!=</a>(<span class="keyword">const</span> <a class="code hl_class" href="classIndex.html">Index&lt;1&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code hl_class" href="classIndex.html">Index&lt;1&gt;</a>&amp; rhs);</div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code hl_class" href="classIndex.html">Index&lt;2&gt;</a>;</div>
<div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> <a class="code hl_class" href="classIndex.html">Index&lt;2&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code hl_class" href="classIndex.html">Index&lt;2&gt;</a>&amp; rhs);</div>
<div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/utility/rel_ops/operator_cmp.html">operator!=</a>(<span class="keyword">const</span> <a class="code hl_class" href="classIndex.html">Index&lt;2&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code hl_class" href="classIndex.html">Index&lt;2&gt;</a>&amp; rhs);</div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code hl_class" href="classIndex.html">Index&lt;3&gt;</a>;</div>
<div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> <a class="code hl_class" href="classIndex.html">Index&lt;3&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code hl_class" href="classIndex.html">Index&lt;3&gt;</a>&amp; rhs);</div>
<div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/utility/rel_ops/operator_cmp.html">operator!=</a>(<span class="keyword">const</span> <a class="code hl_class" href="classIndex.html">Index&lt;3&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code hl_class" href="classIndex.html">Index&lt;3&gt;</a>&amp; rhs);</div>
<div class="ttc" id="aoperator_cmp_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/utility/rel_ops/operator_cmp.html">std::rel_ops::operator!=</a></div><div class="ttdeci">T operator!=(T... args)</div></div>
</div><!-- fragment --><p >Now let's look at generating instantiations of member function templates of class templates, which will be a common use case. In this example we generate explicit instantiations of all the member function templates of the class <code><a class="el" href="classScalarWave_1_1Solutions_1_1PlaneWave.html" title="A plane wave solution to the Euclidean wave equation.">ScalarWave::Solutions::PlaneWave</a></code>. In total, for <code>Dim = 1,2,3</code> and types <code>double</code> and <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code> this is about 42 explicit instantiations, which would be extremely annoying to write by hand. The macro code is surprisingly simple:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define DIM(data) BOOST_PP_TUPLE_ELEM(0, data)</span></div>
<div class="line"><span class="preprocessor">#define DTYPE(data) BOOST_PP_TUPLE_ELEM(1, data)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define INSTANTIATE(_, data)                                              \</span></div>
<div class="line"><span class="preprocessor">  template Scalar&lt;DTYPE(data)&gt;                                            \</span></div>
<div class="line"><span class="preprocessor">  ScalarWave::Solutions::PlaneWave&lt;DIM(data)&gt;::psi(                       \</span></div>
<div class="line"><span class="preprocessor">      const tnsr::I&lt;DTYPE(data), DIM(data)&gt;&amp; x, double t) const; \</span></div>
<div class="line"><span class="preprocessor">  template Scalar&lt;DTYPE(data)&gt;                                            \</span></div>
<div class="line"><span class="preprocessor">  ScalarWave::Solutions::PlaneWave&lt;DIM(data)&gt;::dpsi_dt(                   \</span></div>
<div class="line"><span class="preprocessor">      const tnsr::I&lt;DTYPE(data), DIM(data)&gt;&amp; x, double t) const;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__UtilitiesGroup.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a>(INSTANTIATE, (1, 2, 3), (<span class="keywordtype">double</span>, <a class="code hl_class" href="classDataVector.html">DataVector</a>))</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#undef DIM</span></div>
<div class="line"><span class="preprocessor">#undef DTYPE</span></div>
<div class="line"><span class="preprocessor">#undef INSTANTIATE</span></div>
<div class="ttc" id="aclassDataVector_html"><div class="ttname"><a href="classDataVector.html">DataVector</a></div><div class="ttdoc">Stores a collection of function values.</div><div class="ttdef"><b>Definition:</b> DataVector.hpp:48</div></div>
</div><!-- fragment --><p >We don't show the result from preprocessor since for all of the member functions of <code>PlaneWave</code> the total output is approximately 150 lines, but you can hopefully see the benefits of generating explicit instantiations using the <code>GENERATE_INSTANTIATIONS</code> way.</p>
<p >One thing that can be difficult is debugging metaprograms (be they template or macro-based). To this end we provide a make target <code>DebugPreprocessor</code> which prints the output of running the preprocessor on the file <code>src/Executables/DebugPreprocessor/DebugPreprocessor.cpp</code>. Note that the output of the <code>GENERATE_INSTANTIATIONS</code> macro will be on a single line, so it often proves useful to copy-paste the output into an editor and run clang-format over the code so it's easier to reason about. </p>

</div>
</div>
<a id="gaffde14445f49f65ff4f5b592e44ee71a" name="gaffde14445f49f65ff4f5b592e44ee71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffde14445f49f65ff4f5b592e44ee71a">&#9670;&nbsp;</a></span>LIKELY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LIKELY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(x)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The if statement is expected to evaluate true most of the time </p>

</div>
</div>
<a id="gab10d0a221f4d7a706701b806c8135fd7" name="gab10d0a221f4d7a706701b806c8135fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab10d0a221f4d7a706701b806c8135fd7">&#9670;&nbsp;</a></span>UNLIKELY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNLIKELY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(x)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The if statement is expected to evaluate false most of the time </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga01ee1794935080949a6995ae7d5e08cc" name="ga01ee1794935080949a6995ae7d5e08cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01ee1794935080949a6995ae7d5e08cc">&#9670;&nbsp;</a></span>flat_all</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool... Bs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__UtilitiesGroup.html#ga01ee1794935080949a6995ae7d5e08cc">tmpl2::flat_all</a> = typedef <a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same</a>&lt;<a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt;bool, Bs...&gt;, <a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt;bool, (static_cast&lt;void&gt;(Bs), true)...&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A non-short-circuiting logical AND between bools 'B"". </p>
<p >Useful when arbitrarily large parameter packs need to be evaluated, since <a class="elRef" href="http://en.cppreference.com/w/cpp/types/conjunction.html">std::conjunction</a> and <a class="elRef" href="http://en.cppreference.com/w/cpp/types/disjunction.html">std::disjunction</a> use recursion </p>

</div>
</div>
<a id="ga6e25dbfa539ff4513329969dbcd81c40" name="ga6e25dbfa539ff4513329969dbcd81c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e25dbfa539ff4513329969dbcd81c40">&#9670;&nbsp;</a></span>flat_any</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool... Bs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__UtilitiesGroup.html#ga6e25dbfa539ff4513329969dbcd81c40">tmpl2::flat_any</a> = typedef <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a>&lt; bool, not <a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same</a>&lt; <a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt;bool, Bs...&gt;, <a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt;bool, (static_cast&lt;void&gt;(Bs), false)...&gt; &gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A non-short-circuiting logical OR between bools 'B"". </p>
<p >Useful when arbitrarily large parameter packs need to be evaluated, since <a class="elRef" href="http://en.cppreference.com/w/cpp/types/conjunction.html">std::conjunction</a> and <a class="elRef" href="http://en.cppreference.com/w/cpp/types/disjunction.html">std::disjunction</a> use recursion </p>

</div>
</div>
<a id="ga1cfcae98148ede1e9ba0d836c47b2f49" name="ga1cfcae98148ede1e9ba0d836c47b2f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cfcae98148ede1e9ba0d836c47b2f49">&#9670;&nbsp;</a></span>make_std_variant_over</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__UtilitiesGroup.html#ga1cfcae98148ede1e9ba0d836c47b2f49">brigand::make_std_variant_over</a> = typedef typename detail::make_std_variant_over_impl&lt; tmpl::remove_duplicates&lt;Sequence&gt; &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/variant.html">std::variant</a> with all all the types inside the typelist Sequence. </p>
<p ><em>Returns:</em> <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/variant.html">std::variant</a> of all types inside <code>Sequence</code> </p>

</div>
</div>
<a id="gae57946a2ff8730c87f1e47d636dd5b57" name="gae57946a2ff8730c87f1e47d636dd5b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae57946a2ff8730c87f1e47d636dd5b57">&#9670;&nbsp;</a></span>owner</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_pointer.html">std::is_pointer</a>&lt; T &gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a> &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__UtilitiesGroup.html#gae57946a2ff8730c87f1e47d636dd5b57">gsl::owner</a> = typedef typename detail::owner_impl&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a raw pointer as owning its data. </p>
<dl class="section warning"><dt>Warning</dt><dd>You should never actually use <code><a class="el" href="group__UtilitiesGroup.html#gae57946a2ff8730c87f1e47d636dd5b57" title="Mark a raw pointer as owning its data.">gsl::owner</a></code>. Instead you should use <code><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a></code>, and if shared ownership is required, <code><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a></code>. </dd></dl>

</div>
</div>
<a id="ga084d535585c18d4e80f8ec6052d341a3" name="ga084d535585c18d4e80f8ec6052d341a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga084d535585c18d4e80f8ec6052d341a3">&#9670;&nbsp;</a></span>Requires</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool B&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a> =  typename Requires_detail::requires_impl&lt; B&gt;::template_error_type_failed_to_meet_requirements_on_template_parameters</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Express requirements on the template parameters of a function or class, replaces <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/enable_if.html">std::enable_if_t</a></code> </p>
<p >Replacement for <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/enable_if.html">std::enable_if_t</a></code> and Concepts for expressing requirements on template parameters. This does not require merging of the Concepts TS (whose merit is debatable) and provides an "error message" if substitution of a template parameter failed. Specifically, the compiler error will contain "template_error_type_failed_to_meet_requirements_on_template_parameters", aiding the user of a function or class in tracking down the list of requirements on the deduced type.</p>
<p >For example, if a function <code>foo</code> is defined as: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, Requires&lt;tt::is_a_v&lt;std::vector, T&gt;&gt; = <span class="keywordtype">nullptr</span>&gt;</div>
<div class="line"><a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> foo(<span class="keyword">const</span> T&amp; <span class="comment">/*unused*/</span>) {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="stringliteral">&quot;vector&quot;</span>;</div>
<div class="line">}</div>
<div class="ttc" id="abasic_string_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a></div></div>
</div><!-- fragment --><p> then calling the function with a list, <code>foo(<a class="elRef" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>&lt;double&gt;{});</code> results in the following compilation error from clang: </p><div class="fragment"><div class="line">./tests/Unit/Utilities/Test_Requires.cpp:29:3: error: no matching function</div>
<div class="line">   <span class="keywordflow">for</span> <a class="code hl_function" href="namespacepypp.html#a0b8520e3e6d5c1abb3110b134c10683f">call</a> to <span class="stringliteral">&#39;foo&#39;</span></div>
<div class="line">  foo(<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/list.html">std::list&lt;double&gt;</a>{});</div>
<div class="line">  ^~~</div>
<div class="line">./tests/Unit/Utilities/Test_Requires.cpp:15:13: note: candidate</div>
<div class="line">    <span class="keyword">template</span> ignored: substitution failure [with T = std::__1::list&lt;double,</div>
<div class="line">    std::__1::allocator&lt;double&gt; &gt;]: no type named</div>
<div class="line">    <span class="stringliteral">&#39;template_error_type_failed_to_meet_requirements_on_template_parameters&#39;</span></div>
<div class="line">    in <span class="stringliteral">&#39;Requires_detail::requires_impl&lt;false&gt;&#39;</span></div>
<div class="line"><a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> foo(<span class="keyword">const</span> T&amp;) {</div>
<div class="line">            ^</div>
<div class="line">1 error generated.</div>
<div class="ttc" id="alist_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a></div></div>
<div class="ttc" id="anamespacepypp_html_a0b8520e3e6d5c1abb3110b134c10683f"><div class="ttname"><a href="namespacepypp.html#a0b8520e3e6d5c1abb3110b134c10683f">pypp::call</a></div><div class="ttdeci">ReturnType call(const std::string &amp;module_name, const std::string &amp;function_name, const Args &amp;... t)</div><div class="ttdoc">Calls a Python function from a module/file with given parameters.</div><div class="ttdef"><b>Definition:</b> Pypp.hpp:495</div></div>
</div><!-- fragment --><p >Here is an example of how write function overloads using <code>Requires</code> or to express constraints on the template parameters: </p><div class="fragment"><div class="line"><span class="comment">// [foo_definition]</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, Requires&lt;tt::is_a_v&lt;std::vector, T&gt;&gt; = <span class="keywordtype">nullptr</span>&gt;</div>
<div class="line"><a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> foo(<span class="keyword">const</span> T&amp; <span class="comment">/*unused*/</span>) {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="stringliteral">&quot;vector&quot;</span>;</div>
<div class="line">}</div>
<div class="line"><span class="comment">// [foo_definition]</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, Requires&lt;tt::is_a_v&lt;std::list, T&gt;&gt; = <span class="keywordtype">nullptr</span>&gt;</div>
<div class="line"><a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> foo(<span class="keyword">const</span> T&amp; <span class="comment">/*unused*/</span>) {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="stringliteral">&quot;list&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Using <code>Requires</code> is safer than using <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/enable_if.html">std::enable_if_t</a></code> because the nested type alias is of type <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/nullptr_t.html">std::nullptr_t</a></code> and so usage is always: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, Requires&lt;(<span class="keywordtype">bool</span> depending on T)&gt; = <span class="keywordtype">nullptr</span>&gt;</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa3be3b8a2b80d0c3837f82d82e5f25f5" name="gaa3be3b8a2b80d0c3837f82d82e5f25f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3be3b8a2b80d0c3837f82d82e5f25f5">&#9670;&nbsp;</a></span>accumulate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T cpp2b::accumulate </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reimplementation of std::accumulate that is constexpr; taken from the LLVM source at <a href="https://github.com/llvm-mirror/libcxx/blob/master/include/numeric">https://github.com/llvm-mirror/libcxx/blob/master/include/numeric</a> </p>

</div>
</div>
<a id="gab0d5e7fa5e0aa31f06200f691d74300b" name="gab0d5e7fa5e0aa31f06200f691d74300b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0d5e7fa5e0aa31f06200f691d74300b">&#9670;&nbsp;</a></span>apply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ApplyTags , typename F , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) tuples::apply </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtuples_1_1TaggedTuple.html">TaggedTuple</a>&lt; Tags... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke <code>f</code> with the <code>ApplyTags</code> taken from <code>t</code> expanded in a parameter pack. </p>
<p ><code>ApplyTags</code> defaults to the full list of tags in <code>t</code>.</p>
<p >Here is an example how to use the function:</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> extra_factor = 3.;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> result = <a class="code hl_function" href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">tuples::apply</a>(</div>
<div class="line">        [&amp;extra_factor](<span class="keyword">const</span> <span class="keyword">auto</span>&amp;... expanded_args) {</div>
<div class="line">          <span class="keywordflow">return</span> extra_factor * test_function(expanded_args...);</div>
<div class="line">        },</div>
<div class="line">        <a class="code hl_class" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple&lt;FirstArg, SecondArg&gt;</a>{1, 2.});</div>
<div class="ttc" id="aclasstuples_1_1TaggedTuple_html"><div class="ttname"><a href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a></div><div class="ttdoc">An associative container that is indexed by structs.</div><div class="ttdef"><b>Definition:</b> TaggedTuple.hpp:261</div></div>
<div class="ttc" id="agroup__DataStructuresGroup_html_ga058ade0497757606713948256728c6db"><div class="ttname"><a href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">apply</a></div><div class="ttdeci">auto apply(F &amp;&amp;f, const ObservationBox&lt; ComputeTagsList, DataBoxType &gt; &amp;observation_box, Args &amp;&amp;... args)</div><div class="ttdoc">Apply the function object f using its nested argument_tags list of tags.</div><div class="ttdef"><b>Definition:</b> ObservationBox.hpp:182</div></div>
</div><!-- fragment --><p >This is the function being called in the above example:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>FirstArg {</div>
<div class="line">  <span class="keyword">using</span> type = int;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>SecondArg {</div>
<div class="line">  <span class="keyword">using</span> type = double;</div>
<div class="line">};</div>
<div class="line"><span class="keywordtype">double</span> test_function(<span class="keyword">const</span> <span class="keywordtype">int</span> first_arg, <span class="keyword">const</span> <span class="keywordtype">double</span> second_arg) {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(first_arg) + second_arg;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>std::apply </dd></dl>

</div>
</div>
<a id="gaf7faaf4800d1d5784ee29134600dd11d" name="gaf7faaf4800d1d5784ee29134600dd11d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7faaf4800d1d5784ee29134600dd11d">&#9670;&nbsp;</a></span>apply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) tuples::apply </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtuples_1_1TaggedTuple.html">TaggedTuple</a>&lt; Tags... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke <code>f</code> with the <code>ApplyTags</code> taken from <code>t</code> expanded in a parameter pack. </p>
<p ><code>ApplyTags</code> defaults to the full list of tags in <code>t</code>.</p>
<p >Here is an example how to use the function:</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> extra_factor = 3.;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> result = <a class="code hl_function" href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">tuples::apply</a>(</div>
<div class="line">        [&amp;extra_factor](<span class="keyword">const</span> <span class="keyword">auto</span>&amp;... expanded_args) {</div>
<div class="line">          <span class="keywordflow">return</span> extra_factor * test_function(expanded_args...);</div>
<div class="line">        },</div>
<div class="line">        <a class="code hl_class" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple&lt;FirstArg, SecondArg&gt;</a>{1, 2.});</div>
</div><!-- fragment --><p >This is the function being called in the above example:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>FirstArg {</div>
<div class="line">  <span class="keyword">using</span> type = int;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>SecondArg {</div>
<div class="line">  <span class="keyword">using</span> type = double;</div>
<div class="line">};</div>
<div class="line"><span class="keywordtype">double</span> test_function(<span class="keyword">const</span> <span class="keywordtype">int</span> first_arg, <span class="keyword">const</span> <span class="keywordtype">double</span> second_arg) {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(first_arg) + second_arg;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>std::apply </dd></dl>

</div>
</div>
<a id="ga67f6e9c4ea9ecffbf3ff9143f080b595" name="ga67f6e9c4ea9ecffbf3ff9143f080b595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67f6e9c4ea9ecffbf3ff9143f080b595">&#9670;&nbsp;</a></span>call_with_dynamic_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Result , typename Classes , typename Base , typename Callable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Result call_with_dynamic_type </td>
          <td>(</td>
          <td class="paramtype">Base *const&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a functor with the derived type of a base class pointer. </p>
<h3>Details</h3>
<p >Calls functor with obj cast to type <code>T*</code> where T is the dynamic type of <code>*obj</code>. The decay type of <code>T</code> must be in the provided list of classes.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Result</td><td>the return type </td></tr>
    <tr><td class="paramname">Classes</td><td>the typelist of derived classes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab0094d830a844c3b7cf3cce89b01caf5" name="gab0094d830a844c3b7cf3cce89b01caf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0094d830a844c3b7cf3cce89b01caf5">&#9670;&nbsp;</a></span>cartesian_product() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Containers&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; typename Containers::value_type... &gt; &gt; cartesian_product </td>
          <td>(</td>
          <td class="paramtype">const Containers &amp;...&#160;</td>
          <td class="paramname"><em>containers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Cartesian product of several containers. </p>
<p >Returns a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></code> with all possible combinations of the values of the input containers. The value of the last container varies fastest. </p>

</div>
</div>
<a id="gac33fd10b88a1b820b271212bd78e4375" name="gac33fd10b88a1b820b271212bd78e4375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac33fd10b88a1b820b271212bd78e4375">&#9670;&nbsp;</a></span>cartesian_product() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts, size_t... Lens&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Ts... &gt;,(... *Lens)&gt; cartesian_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; Ts, Lens &gt; &amp;...&#160;</td>
          <td class="paramname"><em>dimensions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Cartesian product of a sequence of arrays. </p>
<p >Returns a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a></code> with all possible combinations of the input arrays. The last dimension varies fastest.</p>
<h3>Example</h3>
<p >Here's an example using this function to replace a nested for loop: </p><div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [halves, orientation, with_equiangular_map,</div>
<div class="line">                    radial_distribution] :</div>
<div class="line">       random_sample&lt;5&gt;(</div>
<div class="line">           <a class="code hl_function" href="group__UtilitiesGroup.html#ga1bface2d122a6251e4758f089f49ff11">cartesian_product</a>(</div>
<div class="line">               halves_array, <a class="code hl_function" href="group__TestingFrameworkGroup.html#ga87ebb39e2d7d2d90f670baccc873c5b8">all_wedge_directions</a>(), <a class="code hl_function" href="group__UtilitiesGroup.html#gad0d14339a15c6913c09fb2baeffe72be">make_array</a>(<span class="keyword">true</span>, <span class="keyword">false</span>),</div>
<div class="line">               <a class="code hl_function" href="group__UtilitiesGroup.html#gad0d14339a15c6913c09fb2baeffe72be">make_array</a>(CoordinateMaps::Distribution::Linear,</div>
<div class="line">                          CoordinateMaps::Distribution::Logarithmic,</div>
<div class="line">                          CoordinateMaps::Distribution::Inverse)),</div>
<div class="line">           make_not_null(&amp;gen))) {</div>
<div class="ttc" id="agroup__TestingFrameworkGroup_html_ga87ebb39e2d7d2d90f670baccc873c5b8"><div class="ttname"><a href="group__TestingFrameworkGroup.html#ga87ebb39e2d7d2d90f670baccc873c5b8">all_wedge_directions</a></div><div class="ttdeci">std::array&lt; OrientationMap&lt; 3 &gt;, 6 &gt; all_wedge_directions()</div><div class="ttdoc">Wedge OrientationMap in each of the six directions used in the Sphere domain creator.</div><div class="ttdef"><b>Definition:</b> TestMapHelpers.hpp:726</div></div>
<div class="ttc" id="agroup__UtilitiesGroup_html_ga1bface2d122a6251e4758f089f49ff11"><div class="ttname"><a href="group__UtilitiesGroup.html#ga1bface2d122a6251e4758f089f49ff11">cartesian_product</a></div><div class="ttdeci">void cartesian_product(OutputIterator result, std::pair&lt; InputIterator, InputIterator &gt;... dimensions)</div><div class="ttdoc">Fill the result iterator with the Cartesian product of a sequence of iterators.</div><div class="ttdef"><b>Definition:</b> CartesianProduct.hpp:49</div></div>
<div class="ttc" id="agroup__UtilitiesGroup_html_gad0d14339a15c6913c09fb2baeffe72be"><div class="ttname"><a href="group__UtilitiesGroup.html#gad0d14339a15c6913c09fb2baeffe72be">make_array</a></div><div class="ttdeci">constexpr std::array&lt; T, Size &gt; make_array(Args &amp;&amp;... args)</div><div class="ttdoc">Create a std::array&lt;T, Size&gt;{{T(args...), T(args...), ...}}</div><div class="ttdef"><b>Definition:</b> MakeArray.hpp:65</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga1bface2d122a6251e4758f089f49ff11" name="ga1bface2d122a6251e4758f089f49ff11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bface2d122a6251e4758f089f49ff11">&#9670;&nbsp;</a></span>cartesian_product() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OutputIterator , class... InputIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cartesian_product </td>
          <td>(</td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; InputIterator, InputIterator &gt;...&#160;</td>
          <td class="paramname"><em>dimensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the <code>result</code> iterator with the Cartesian product of a sequence of iterators. </p>
<p >The <code>result</code> will hold all possible combinations of the input iterators. The last dimension varies fastest. </p>

</div>
</div>
<a id="ga6d2165f76f750a3ca7e4444462451d87" name="ga6d2165f76f750a3ca7e4444462451d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d2165f76f750a3ca7e4444462451d87">&#9670;&nbsp;</a></span>create_vector_of_n_copies()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorType create_vector_of_n_copies </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>to_copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>times_to_copy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates or fills a vector with data from <code>to_repeat</code> copied <code>times_to_repeat</code> times in sequence. </p>
<h3>Details</h3>
<p >This can be useful for generating data that consists of the same block of values duplicated a number of times. For instance, this can be used to create a vector representing three-dimensional volume data from a corresponding two-dimensional vector data, if the two-dimensional data corresponds to the two fastest-varying directions of the desired three-dimensional representation. The result would then be uniform in the slowest-varying direction of the three dimensional grid. </p>

</div>
</div>
<a id="gaaa46a305d87ee4ae9fede9d55c373286" name="gaaa46a305d87ee4ae9fede9d55c373286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa46a305d87ee4ae9fede9d55c373286">&#9670;&nbsp;</a></span>ddot_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ddot_ </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>INCX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>INCY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >The dot product of two vectors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>the length of the vectors. </td></tr>
    <tr><td class="paramname">X</td><td>a pointer to the first element of the first vector. </td></tr>
    <tr><td class="paramname">INCX</td><td>the stride for the elements of the first vector. </td></tr>
    <tr><td class="paramname">Y</td><td>a pointer to the first element of the second vector. </td></tr>
    <tr><td class="paramname">INCY</td><td>the stride for the elements of the second vector. </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the dot product of the given vectors. </p>

</div>
</div>
<a id="ga4f599f1aca8c3f97acaad209e5531b86" name="ga4f599f1aca8c3f97acaad209e5531b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f599f1aca8c3f97acaad209e5531b86">&#9670;&nbsp;</a></span>destructive_resize_components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename DestructiveResizeFunction  = ContainerDestructiveResize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void destructive_resize_components </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Container * &gt;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DestructiveResizeFunction&#160;</td>
          <td class="paramname"><em>destructive_resize</em> = <code><a class="el" href="structContainerDestructiveResize.html">ContainerDestructiveResize</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the size of each component of the container, and resizes if necessary. </p>
<h3>Details</h3>
<p >This operation is not permitted when any of the components of the tensor is non-owning (see <code><a class="el" href="classVectorImpl.html" title="Base class template for various DataVector and related types.">VectorImpl</a></code> for ownership details). </p><dl class="section note"><dt>Note</dt><dd>This utility should NOT be used when it is anticipated that the components will be the wrong size. In that case, suggest either manual checking or restructuring so that resizing is less common. The internal call uses <code>UNLIKELY</code> to perform the checks most quickly when resizing is unnecessary.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is typically to be called on <code>Tensor</code>s, NOT (for instance) <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code>s. For derived classes of <code><a class="el" href="classVectorImpl.html" title="Base class template for various DataVector and related types.">VectorImpl</a></code>, this function will cause no resize. Instead, use the <code><a class="el" href="classVectorImpl.html" title="Base class template for various DataVector and related types.">VectorImpl</a></code> member function <code><a class="el" href="classVectorImpl.html#ad55c34f0c923e4d76ad94638c469c417" title="A common operation for checking the size and resizing a memory buffer if needed to ensure that it has...">VectorImpl::destructive_resize()</a></code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This assumes that a range-based iterator will appropriately loop over the elements to resize, and that each resized element is either a fundamental type or a derived class of <code><a class="el" href="classVectorImpl.html" title="Base class template for various DataVector and related types.">VectorImpl</a></code>. If either of those assumptions needs to be relaxed, this function will need to be generalized. </dd></dl>

</div>
</div>
<a id="gac932a44b57087d32ce5341314437dbbd" name="gac932a44b57087d32ce5341314437dbbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac932a44b57087d32ce5341314437dbbd">&#9670;&nbsp;</a></span>dgemm_()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool UseLibXsmm = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dgemm_ </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>TRANSA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>TRANSB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>LDC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a matrix-matrix multiplication. </p>
<p >Perform the matrix-matrix multiplication </p><p class="formulaDsp">
\[ C = \alpha \mathrm{op}(A) \mathrm{op}(B) + \beta \mathrm{op}(C) \]
</p>
<p >where \(\mathrm{op}(A)\) represents either \(A\) or \(A^{T}\) (transpose of \(A\)).</p>
<p >LIBXSMM, which is much faster than BLAS for small matrices, can be called instead of BLAS by passing the template parameter <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TRANSA</td><td>either 'N', 'T' or 'C', transposition of matrix A </td></tr>
    <tr><td class="paramname">TRANSB</td><td>either 'N', 'T' or 'C', transposition of matrix B </td></tr>
    <tr><td class="paramname">M</td><td>Number of rows in \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">N</td><td>Number of columns in \(\mathrm{op}(B)\) and \(\mathrm{op}(C)\) </td></tr>
    <tr><td class="paramname">K</td><td>Number of columns in \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">ALPHA</td><td>specifies \(\alpha\) </td></tr>
    <tr><td class="paramname">A</td><td><a class="el" href="classMatrix.html" title="A dynamically sized matrix of doubles with column-major storage.">Matrix</a> \(A\) </td></tr>
    <tr><td class="paramname">LDA</td><td>Specifies first dimension of \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">B</td><td><a class="el" href="classMatrix.html" title="A dynamically sized matrix of doubles with column-major storage.">Matrix</a> \(B\) </td></tr>
    <tr><td class="paramname">LDB</td><td>Specifies first dimension of \(\mathrm{op}(B)\) </td></tr>
    <tr><td class="paramname">BETA</td><td>specifies \(\beta\) </td></tr>
    <tr><td class="paramname">C</td><td><a class="el" href="classMatrix.html" title="A dynamically sized matrix of doubles with column-major storage.">Matrix</a> \(C\) </td></tr>
    <tr><td class="paramname">LDC</td><td>Specifies first dimension of \(\mathrm{op}(C)\) </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UseLibXsmm</td><td>if <code>true</code> then use LIBXSMM </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaba62a62589ffc7b8b85a7722390f7ce0" name="gaba62a62589ffc7b8b85a7722390f7ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba62a62589ffc7b8b85a7722390f7ce0">&#9670;&nbsp;</a></span>dgemm_&lt; true &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__UtilitiesGroup.html#gac932a44b57087d32ce5341314437dbbd">dgemm_</a>&lt; true &gt; </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>TRANSA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>TRANSB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>LDC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a matrix-matrix multiplication. </p>
<p >Perform the matrix-matrix multiplication </p><p class="formulaDsp">
\[ C = \alpha \mathrm{op}(A) \mathrm{op}(B) + \beta \mathrm{op}(C) \]
</p>
<p >where \(\mathrm{op}(A)\) represents either \(A\) or \(A^{T}\) (transpose of \(A\)).</p>
<p >LIBXSMM, which is much faster than BLAS for small matrices, can be called instead of BLAS by passing the template parameter <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TRANSA</td><td>either 'N', 'T' or 'C', transposition of matrix A </td></tr>
    <tr><td class="paramname">TRANSB</td><td>either 'N', 'T' or 'C', transposition of matrix B </td></tr>
    <tr><td class="paramname">M</td><td>Number of rows in \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">N</td><td>Number of columns in \(\mathrm{op}(B)\) and \(\mathrm{op}(C)\) </td></tr>
    <tr><td class="paramname">K</td><td>Number of columns in \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">ALPHA</td><td>specifies \(\alpha\) </td></tr>
    <tr><td class="paramname">A</td><td><a class="el" href="classMatrix.html" title="A dynamically sized matrix of doubles with column-major storage.">Matrix</a> \(A\) </td></tr>
    <tr><td class="paramname">LDA</td><td>Specifies first dimension of \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">B</td><td><a class="el" href="classMatrix.html" title="A dynamically sized matrix of doubles with column-major storage.">Matrix</a> \(B\) </td></tr>
    <tr><td class="paramname">LDB</td><td>Specifies first dimension of \(\mathrm{op}(B)\) </td></tr>
    <tr><td class="paramname">BETA</td><td>specifies \(\beta\) </td></tr>
    <tr><td class="paramname">C</td><td><a class="el" href="classMatrix.html" title="A dynamically sized matrix of doubles with column-major storage.">Matrix</a> \(C\) </td></tr>
    <tr><td class="paramname">LDC</td><td>Specifies first dimension of \(\mathrm{op}(C)\) </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UseLibXsmm</td><td>if <code>true</code> then use LIBXSMM </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad4d31316e0975f0a66a60d9ac92756a8" name="gad4d31316e0975f0a66a60d9ac92756a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4d31316e0975f0a66a60d9ac92756a8">&#9670;&nbsp;</a></span>dgemv_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dgemv_ </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>TRANS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>INCX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>INCY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a matrix-vector multiplication. </p>
<p class="formulaDsp">
\[ y = \alpha \mathrm{op}(A) x + \beta y \]
</p>
<p >where \(\mathrm{op}(A)\) represents either \(A\) or \(A^{T}\) (transpose of \(A\)).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TRANS</td><td>either 'N', 'T' or 'C', transposition of matrix A </td></tr>
    <tr><td class="paramname">M</td><td>Number of rows in \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">N</td><td>Number of columns in \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">ALPHA</td><td>specifies \(\alpha\) </td></tr>
    <tr><td class="paramname">A</td><td><a class="el" href="classMatrix.html" title="A dynamically sized matrix of doubles with column-major storage.">Matrix</a> \(A\) </td></tr>
    <tr><td class="paramname">LDA</td><td>Specifies first dimension of \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">X</td><td>Vector \(x\) </td></tr>
    <tr><td class="paramname">INCX</td><td>Specifies the increment for the elements of \(x\) </td></tr>
    <tr><td class="paramname">BETA</td><td>Specifies \(\beta\) </td></tr>
    <tr><td class="paramname">Y</td><td>Vector \(y\) </td></tr>
    <tr><td class="paramname">INCY</td><td>Specifies the increment for the elements of \(y\) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2205f7b4b505b2c8c5f50555bf2725bd" name="ga2205f7b4b505b2c8c5f50555bf2725bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2205f7b4b505b2c8c5f50555bf2725bd">&#9670;&nbsp;</a></span>dot() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; R, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dot product between two arrays. </p>
<h3>Details</h3>
<p >This also works elementwise if T is a container and R is a float or the other way round. The return type will always be the same as the return type of the multiplication which may be a blaze expression template. </p>

</div>
</div>
<a id="ga825f09807dc021897b0879bc1469061c" name="ga825f09807dc021897b0879bc1469061c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga825f09807dc021897b0879bc1469061c">&#9670;&nbsp;</a></span>dot() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; R, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dot product between two arrays. </p>
<h3>Details</h3>
<p >This also works elementwise if T is a container and R is a float or the other way round. The return type will always be the same as the return type of the multiplication which may be a blaze expression template. </p>

</div>
</div>
<a id="gad0847cf84cbbb471fc0499a5d4a1cb96" name="gad0847cf84cbbb471fc0499a5d4a1cb96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0847cf84cbbb471fc0499a5d4a1cb96">&#9670;&nbsp;</a></span>dot() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; R, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dot product between two arrays. </p>
<h3>Details</h3>
<p >This also works elementwise if T is a container and R is a float or the other way round. The return type will always be the same as the return type of the multiplication which may be a blaze expression template. </p>

</div>
</div>
<a id="ga3e03094c14176d1db9be6a830f503d7f" name="ga3e03094c14176d1db9be6a830f503d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e03094c14176d1db9be6a830f503d7f">&#9670;&nbsp;</a></span>equal_within_roundoff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lhs , typename Rhs &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool equal_within_roundoff </td>
          <td>(</td>
          <td class="paramtype">const Lhs &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Rhs &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>eps</em> = <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits</a>&lt;double&gt;::epsilon()&#160;*&#160;100.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two values <code>lhs</code> and <code>rhs</code> are equal within roundoff, by comparing <code>abs(lhs - rhs) &lt; (max(abs(lhs), abs(rhs)) + scale) * eps</code>. </p>
<p >The two values can be floating-point numbers, or any types for which <code><a class="el" href="structEqualWithinRoundoffImpls_1_1EqualWithinRoundoffImpl.html" title="Specialize this class to add support for the equal_within_roundoff function.">EqualWithinRoundoffImpls::EqualWithinRoundoffImpl</a></code> has been specialized. For example, a default implementation exists for the case where <code>lhs</code>, <code>rhs</code>, or both, are iterable, and compares the values point-wise. </p>

</div>
</div>
<a id="gaa19830f18b8c64d7a574263578108a9c" name="gaa19830f18b8c64d7a574263578108a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa19830f18b8c64d7a574263578108a9c">&#9670;&nbsp;</a></span>evaluate_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoeffsIterable , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DataType evaluate_polynomial </td>
          <td>(</td>
          <td class="paramtype">const CoeffsIterable &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a polynomial \(\sum_{p=0}^N c_p x^p\) with Horner's rule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coeffs</td><td>The polynomial coefficients \(c_p\) ordered from constant to largest power </td></tr>
    <tr><td class="paramname">x</td><td>The polynomial variable \(x\)</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CoeffsIterable</td><td>The type of the polynomial coefficients <code>coeffs</code>. Can be a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;double&gt;</code> or <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;double&gt;</code>, which means the coefficients are constant for all values in <code>x</code>. Each coefficient can also be a vector type of typically the same size as <code>x</code>, which means the coefficients vary with the elements in <code>x</code>. </td></tr>
    <tr><td class="paramname">DataType</td><td>The type of the polynomial variable <code>x</code>. Must support <code>make_with_value&lt;DataType, DataType&gt;</code>, as well as (elementwise) addition with <code>CoeffsIterable::value_type</code> and multiplication with <code>DataType</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac5159b836743fab01c35f4676bbf3e36" name="gac5159b836743fab01c35f4676bbf3e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5159b836743fab01c35f4676bbf3e36">&#9670;&nbsp;</a></span>expand_pack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void expand_pack </td>
          <td>(</td>
          <td class="paramtype">Ts &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows zero-cost unordered expansion of a parameter. </p>
<h3>Details</h3>
<p >Expands a parameter pack, typically useful for runtime evaluation via a Callable such as a lambda, function, or function object. For example, an unordered transform of a <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> can be implemented as: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Elements, <span class="keywordtype">size_t</span>... Is&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_namespace" href="namespacetransform.html">transform</a>(<span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;Elements...&gt;</a>&amp; tupull,</div>
<div class="line">               <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;Elements...&gt;</a>&amp; out_tupull,</div>
<div class="line">               <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::index_sequence&lt;Is...&gt;</a> <span class="comment">/*meta*/</span>) {</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> func = [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; in, <span class="keyword">auto</span>&amp; out) {</div>
<div class="line">    out = in * <span class="keyword">static_cast&lt;</span>decltype(in)<span class="keyword">&gt;</span>(2);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">  };</div>
<div class="line">  <a class="code hl_function" href="group__UtilitiesGroup.html#gac5159b836743fab01c35f4676bbf3e36">expand_pack</a>(func(std::get&lt;Is&gt;(tupull), std::get&lt;Is&gt;(out_tupull))...);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> test_expand_pack() {</div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;int, double, float&gt;</a> my_tupull = std::make_tuple(3, 2.7, 8.2);</div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;int, double, float&gt;</a> my_tupull_output;</div>
<div class="line">  <a class="code hl_namespace" href="namespacetransform.html">transform</a>(my_tupull, my_tupull_output, <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::make_index_sequence&lt;3&gt;</a>{});</div>
<div class="line">  CHECK(std::get&lt;0&gt;(my_tupull_output) == 6);</div>
<div class="line">  CHECK(std::get&lt;1&gt;(my_tupull_output) == 5.4);</div>
<div class="line">  CHECK(std::get&lt;2&gt;(my_tupull_output) == 16.4f);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__UtilitiesGroup_html_gac5159b836743fab01c35f4676bbf3e36"><div class="ttname"><a href="group__UtilitiesGroup.html#gac5159b836743fab01c35f4676bbf3e36">expand_pack</a></div><div class="ttdeci">constexpr void expand_pack(Ts &amp;&amp;...)</div><div class="ttdoc">Allows zero-cost unordered expansion of a parameter.</div><div class="ttdef"><b>Definition:</b> TMPL.hpp:580</div></div>
<div class="ttc" id="ainteger_sequence_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::index_sequence</a></div></div>
<div class="ttc" id="anamespacetransform_html"><div class="ttname"><a href="namespacetransform.html">transform</a></div><div class="ttdoc">Holds functions related to transforming between frames.</div><div class="ttdef"><b>Definition:</b> Transform.hpp:17</div></div>
<div class="ttc" id="atuple_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a></div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__UtilitiesGroup.html#gacaeb211c58335d67859ac2e506f6e617" title="Perform a fold over a std::tuple.">tuple_fold</a> <a class="el" href="group__UtilitiesGroup.html#ga2ae1fc4fc42ed12ea47af23969583227" title="Perform a fold over a std::tuple.">tuple_counted_fold</a> <a class="el" href="group__UtilitiesGroup.html#gabbfc4adcbade2ec4aad9f0ab878e696e" title="Perform a transform over a std::tuple.">tuple_transform</a> <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> <a class="el" href="group__UtilitiesGroup.html#ga902d1cefbb10846eb8f5be9f6be5c340" title="Expand a parameter pack evaluating the terms from left to right.">EXPAND_PACK_LEFT_TO_RIGHT</a> </dd></dl>

</div>
</div>
<a id="gaa048e7dccecfa01916acafb634db4e70" name="gaa048e7dccecfa01916acafb634db4e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa048e7dccecfa01916acafb634db4e70">&#9670;&nbsp;</a></span>fill_with_n_copies()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fill_with_n_copies </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; VectorType * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>to_copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>times_to_copy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates or fills a vector with data from <code>to_repeat</code> copied <code>times_to_repeat</code> times in sequence. </p>
<h3>Details</h3>
<p >This can be useful for generating data that consists of the same block of values duplicated a number of times. For instance, this can be used to create a vector representing three-dimensional volume data from a corresponding two-dimensional vector data, if the two-dimensional data corresponds to the two fastest-varying directions of the desired three-dimensional representation. The result would then be uniform in the slowest-varying direction of the three dimensional grid. </p>

</div>
</div>
<a id="gac84a6c0bd8692c342b9ddf4ba63601e2" name="gac84a6c0bd8692c342b9ddf4ba63601e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac84a6c0bd8692c342b9ddf4ba63601e2">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr InputIt cpp20::find </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reimplementation of std::find that is constexpr </p>

</div>
</div>
<a id="gad9f222044f3284747287f0c3b5089ccd" name="gad9f222044f3284747287f0c3b5089ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9f222044f3284747287f0c3b5089ccd">&#9670;&nbsp;</a></span>find_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr InputIt cpp20::find_if </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reimplementation of std::find_if that is constexpr </p>

</div>
</div>
<a id="ga77bc48018339ff6ac9402f49a5cd2068" name="ga77bc48018339ff6ac9402f49a5cd2068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77bc48018339ff6ac9402f49a5cd2068">&#9670;&nbsp;</a></span>find_if_not()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr InputIt cpp20::find_if_not </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reimplementation of std::find_if_not that is constexpr </p>

</div>
</div>
<a id="ga9a7c7ee897f581360154a3676d5f7ab9" name="ga9a7c7ee897f581360154a3676d5f7ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a7c7ee897f581360154a3676d5f7ab9">&#9670;&nbsp;</a></span>formatted_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> formatted_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format a string like printf. </p>
<p >Given a formatting string and arguments this returns the corresponding string. Similar to printf but using std::strings. </p>

</div>
</div>
<a id="gaca6b4f1a7abad3fc072345574ef1561e" name="gaca6b4f1a7abad3fc072345574ef1561e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca6b4f1a7abad3fc072345574ef1561e">&#9670;&nbsp;</a></span>get_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SubscriptFunction  = GetContainerElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) get_element </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SubscriptFunction&#160;</td>
          <td class="paramname"><em>at</em> = <code><a class="el" href="structGetContainerElement.html">GetContainerElement</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <code>i</code>th element if <code>T</code> has a subscript operator, otherwise if <code>T</code> is fundamental or a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a></code> of a fundamental type, returns <code>t</code>. </p>
<h3>Details</h3>
<p >This function also optionally takes the user-defined subscript function <code>at</code>, which can be used to specify a custom indexing function. For instance, for a type which is a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a></code> of a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a></code>s, the indexing function could be the below callable struct: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>ArrayOfArraysIndexFunctor {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> OuterArraySize, <span class="keywordtype">size_t</span> InnerArraySize, <span class="keyword">typename</span> T&gt;</div>
<div class="line">  T&amp; operator()(<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;T, InnerArraySize&gt;</a>, OuterArraySize&gt;&amp;</div>
<div class="line">                    array_of_arrays,</div>
<div class="line">                <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> array_of_arrays.at(index % OuterArraySize)</div>
<div class="line">        .at(index / OuterArraySize);</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p >which would index the data structure in a manner in which the outer array index varies fastest. The indexing function must take as arguments the applicable container and a <code>size_t</code> index, in that order. This follows the convention of <code><a class="el" href="group__UtilitiesGroup.html#ga203011436ba65fd9d4f7098d83d4f66b" title="Retrieve a entry from a container, with checks in Debug mode that the index being retrieved is valid.">gsl::at</a></code>. </p><dl class="section note"><dt>Note</dt><dd><code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a></code> are regarded as non-indexable (despite a predictable memory layout), so this function acts as the identity on <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a></code> of fundamental types </dd></dl>

</div>
</div>
<a id="ga2de7f13b6110865c3bbeb1df89adb694" name="ga2de7f13b6110865c3bbeb1df89adb694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2de7f13b6110865c3bbeb1df89adb694">&#9670;&nbsp;</a></span>get_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeFunction  = GetContainerSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) get_size </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeFunction&#160;</td>
          <td class="paramname"><em>size</em> = <code><a class="el" href="structGetContainerSize.html">GetContainerSize</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the size of <code>t</code> if <code>t.size()</code> is a valid expression, otherwise if <code>T</code> is fundamental or a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a></code> of a fundamental type, returns 1. </p>
<h3>Details</h3>
<p >This function also optionally takes the user-defined <code>size</code> function, which can be used to specify a custom size function. For instance, for a type which is a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a></code> of a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a></code>, the size function could be the below callable struct: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>ArrayOfArraysSizeFunctor {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> OuterArraySize, <span class="keywordtype">size_t</span> InnerArraySize, <span class="keyword">typename</span> T&gt;</div>
<div class="line">  <span class="keywordtype">size_t</span> operator()(</div>
<div class="line">      <span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;T, InnerArraySize&gt;</a>, OuterArraySize&gt;&amp;</div>
<div class="line">      <span class="comment">/*array_of_arrays*/</span>) {</div>
<div class="line">    <span class="keywordflow">return</span> OuterArraySize * InnerArraySize;</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p >The <code>size</code> function must take the single argument of the applicable container, and should return a <code>size_t</code>. This follows the convention of <code>std::size()</code> as of C++17. </p><dl class="section note"><dt>Note</dt><dd><code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a></code> are regarded as non-indexable (despite a predictable memory layout), so this function will return 1 for a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a></code> of a fundamental type </dd></dl>

</div>
</div>
<a id="ga218ddc950e1c70d86bf6455664d0b5f1" name="ga218ddc950e1c70d86bf6455664d0b5f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga218ddc950e1c70d86bf6455664d0b5f1">&#9670;&nbsp;</a></span>iota()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void cpp2b::iota </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reimplementation of std::iota that is constexpr; taken from the LLVM source at <a href="https://github.com/llvm-mirror/libcxx/blob/master/include/numeric">https://github.com/llvm-mirror/libcxx/blob/master/include/numeric</a> </p>

</div>
</div>
<a id="ga2f41a812c1350575cf0e202b59902983" name="ga2f41a812c1350575cf0e202b59902983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f41a812c1350575cf0e202b59902983">&#9670;&nbsp;</a></span>iter_swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIt1 , class ForwardIt2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void cpp20::iter_swap </td>
          <td>(</td>
          <td class="paramtype">ForwardIt1&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reimplementation of std::iter_swap that is constexpr; taken from the LLVM source at <a href="https://github.com/llvm-mirror/libcxx/blob/master/include/type_traits">https://github.com/llvm-mirror/libcxx/blob/master/include/type_traits</a> </p>

</div>
</div>
<a id="ga0e9bfc1b0a96c9df21035b121c713c62" name="ga0e9bfc1b0a96c9df21035b121c713c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e9bfc1b0a96c9df21035b121c713c62">&#9670;&nbsp;</a></span>magnitude() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) magnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean magnitude of the elements of the array. </p>
<h3>Details</h3>
<p >If T is a container the magnitude is computed separately for each element of the container.</p>
<p ><em>Requires:</em> If T is a container, T must have following mathematical operators: abs(), <a class="el" href="group__TensorExpressionsGroup.html#ga68e742f6a0919a54715253d91318d7bb" title="Returns the tensor expression representing the square root of a tensor expression that evaluates to a...">sqrt()</a>, and element-wise addition and multiplication. In addition, each T in the array must have the same size. </p>

</div>
</div>
<a id="ga3a75bb0e498b9c41a295ee606e63f8cd" name="ga3a75bb0e498b9c41a295ee606e63f8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a75bb0e498b9c41a295ee606e63f8cd">&#9670;&nbsp;</a></span>magnitude() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) magnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean magnitude of the elements of the array. </p>
<h3>Details</h3>
<p >If T is a container the magnitude is computed separately for each element of the container.</p>
<p ><em>Requires:</em> If T is a container, T must have following mathematical operators: abs(), <a class="el" href="group__TensorExpressionsGroup.html#ga68e742f6a0919a54715253d91318d7bb" title="Returns the tensor expression representing the square root of a tensor expression that evaluates to a...">sqrt()</a>, and element-wise addition and multiplication. In addition, each T in the array must have the same size. </p>

</div>
</div>
<a id="gab9b05708ddf66db6b5b14b179d78f4bf" name="gab9b05708ddf66db6b5b14b179d78f4bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9b05708ddf66db6b5b14b179d78f4bf">&#9670;&nbsp;</a></span>magnitude() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) magnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean magnitude of the elements of the array. </p>
<h3>Details</h3>
<p >If T is a container the magnitude is computed separately for each element of the container.</p>
<p ><em>Requires:</em> If T is a container, T must have following mathematical operators: abs(), <a class="el" href="group__TensorExpressionsGroup.html#ga68e742f6a0919a54715253d91318d7bb" title="Returns the tensor expression representing the square root of a tensor expression that evaluates to a...">sqrt()</a>, and element-wise addition and multiplication. In addition, each T in the array must have the same size. </p>

</div>
</div>
<a id="gad0d14339a15c6913c09fb2baeffe72be" name="gad0d14339a15c6913c09fb2baeffe72be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0d14339a15c6913c09fb2baeffe72be">&#9670;&nbsp;</a></span>make_array() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Size &gt; make_array </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;T, Size&gt;{{T(args...), T(args...), ...}}</code> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Size</td><td>the size of the array </td></tr>
    <tr><td class="paramname">T</td><td>the type of the element in the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaef51773ec780d16fddcda8e5094f2a21" name="gaef51773ec780d16fddcda8e5094f2a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef51773ec780d16fddcda8e5094f2a21">&#9670;&nbsp;</a></span>make_array() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t size, typename Seq &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, size &gt; make_array </td>
          <td>(</td>
          <td class="paramtype">Seq &amp;&amp;&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;T, size&gt;</code> from the first <code>size</code> values of <code>seq</code> </p>
<p ><em>Requires:</em> <code>Seq</code> has a <code>begin</code> function </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type held by the array </td></tr>
    <tr><td class="paramname">size</td><td>the size of the created array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6af8c749c81a51b45fc748a81b1b301c" name="ga6af8c749c81a51b45fc748a81b1b301c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6af8c749c81a51b45fc748a81b1b301c">&#9670;&nbsp;</a></span>make_array() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto make_array </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt;T&gt;, Size&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt;T&gt;, Size&gt;{{t, t, ...}}</code> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Size</td><td>the size of the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf0a66c125713e4158f86b06644a309eb" name="gaf0a66c125713e4158f86b06644a309eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0a66c125713e4158f86b06644a309eb">&#9670;&nbsp;</a></span>next_permutation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BidirectionalIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cpp20::next_permutation </td>
          <td>(</td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reimplementation of std::next_permutation that is constexpr, with less as the comparator; taken from the LLVM source at <a href="https://github.com/llvm-mirror/libcxx/blob/master/include/algorithm">https://github.com/llvm-mirror/libcxx/blob/master/include/algorithm</a> </p>

</div>
</div>
<a id="gac4ff3f48d2db8cb4a7101602d5f6ed3d" name="gac4ff3f48d2db8cb4a7101602d5f6ed3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4ff3f48d2db8cb4a7101602d5f6ed3d">&#9670;&nbsp;</a></span>next_permutation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Compare , class BidirectionalIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cpp20::next_permutation </td>
          <td>(</td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reimplementation of std::next_permutation that is constexpr, for a generic comparator; taken from the LLVM source at <a href="https://github.com/llvm-mirror/libcxx/blob/master/include/algorithm">https://github.com/llvm-mirror/libcxx/blob/master/include/algorithm</a> </p>

</div>
</div>
<a id="ga22191cd0e4e0947bdc6427fb31f26c7a" name="ga22191cd0e4e0947bdc6427fb31f26c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22191cd0e4e0947bdc6427fb31f26c7a">&#9670;&nbsp;</a></span>outer_product() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LhsVectorType , typename RhsVectorType , typename ResultVectorType  = typename blaze::MultTrait&lt;LhsVectorType, RhsVectorType&gt;::Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void outer_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; ResultVectorType * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LhsVectorType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RhsVectorType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the outer product between two vectors. </p>
<h3>Details</h3>
<p >For vectors \(A\) and \(B\), the resulting outer product is \(\{A_1 B_1,\, A_2 B_1\, \dots\, A_N B_1,\, A_1 B_2\, \dots\, A_N B_M\}\). This is useful for generating separable volume data from its constituent inputs. </p>

</div>
</div>
<a id="ga8081baf300ab4b2cae7551d6e3860c49" name="ga8081baf300ab4b2cae7551d6e3860c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8081baf300ab4b2cae7551d6e3860c49">&#9670;&nbsp;</a></span>outer_product() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LhsVectorType , typename RhsVectorType , typename ResultVectorType  = typename blaze::MultTrait&lt;LhsVectorType, RhsVectorType&gt;::Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ResultVectorType outer_product </td>
          <td>(</td>
          <td class="paramtype">const LhsVectorType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RhsVectorType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the outer product between two vectors. </p>
<h3>Details</h3>
<p >For vectors \(A\) and \(B\), the resulting outer product is \(\{A_1 B_1,\, A_2 B_1\, \dots\, A_N B_1,\, A_1 B_2\, \dots\, A_N B_M\}\). This is useful for generating separable volume data from its constituent inputs. </p>

</div>
</div>
<a id="ga940a5cb08e0c8176b0734c0560fccac9" name="ga940a5cb08e0c8176b0734c0560fccac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga940a5cb08e0c8176b0734c0560fccac9">&#9670;&nbsp;</a></span>pretty_wall_time() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> sys::pretty_wall_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format the wall time in DD-HH:MM:SS format. </p>
<p >If the walltime is shorter than a day, omit the <code>DD-</code> part. </p>

</div>
</div>
<a id="gac200e3caf061b50d5a490b14ea1e1311" name="gac200e3caf061b50d5a490b14ea1e1311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac200e3caf061b50d5a490b14ea1e1311">&#9670;&nbsp;</a></span>pretty_wall_time() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> sys::pretty_wall_time </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>total_seconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format the wall time in DD-HH:MM:SS format. </p>
<p >If the walltime is shorter than a day, omit the <code>DD-</code> part. </p>

</div>
</div>
<a id="ga0465ea9937545d1d3404c6ab6e71b15c" name="ga0465ea9937545d1d3404c6ab6e71b15c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0465ea9937545d1d3404c6ab6e71b15c">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BidirectionalIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void cpp20::reverse </td>
          <td>(</td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reimplementation of std::reverse that is constexpr; taken from the LLVM source at <a href="https://github.com/llvm-mirror/libcxx/blob/master/include/algorithm">https://github.com/llvm-mirror/libcxx/blob/master/include/algorithm</a> </p>

</div>
</div>
<a id="gaba5094035e076188c950ee97d1751a79" name="gaba5094035e076188c950ee97d1751a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba5094035e076188c950ee97d1751a79">&#9670;&nbsp;</a></span>simplest_fraction_in_interval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fraction , typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Fraction simplest_fraction_in_interval </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>end2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the fraction in the supplied interval with the smallest denominator. </p>
<p >The endpoints are considered to be in the interval. The order of the arguments is not significant. The answer is unique as long as the interval has length less than 1; for longer intervals, an integer in the range will be returned. </p>

</div>
</div>
<a id="gafce557042e1335e19b1bf3dbb7a75d79" name="gafce557042e1335e19b1bf3dbb7a75d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafce557042e1335e19b1bf3dbb7a75d79">&#9670;&nbsp;</a></span>smoothstep()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DataType smoothstep </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lower_edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>upper_edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smoothly interpolates from 0 to 1 between <code>lower_edge</code> and <code>upper_edge</code> with a Hermite polynomial of degree <code>2 * N + 1</code>. </p>
<p >The smoothstep function is</p>
<p class="formulaDsp">
\begin{align*} S_N(x) = \begin{cases} 0 &amp;\quad \text{for} \quad x\leq x_0 \\ \tilde{S}_N((x - x_0) / (x_1 - x_0)) &amp;\quad \text{for} \quad x_0 \leq x\leq x_1 \\ 1 &amp;\quad \text{for} \quad x_1\leq x \\ \end{cases} \end{align*}
</p>
<p >where \(x_0\) is <code>lower_edge</code>, \(x_1\) is <code>upper_edge</code>, and, up to \(N=3\),</p>
<p class="formulaDsp">
\begin{align*} \tilde{S}_0(x) &amp;= x \\ \tilde{S}_1(x) &amp;= 3x^2 - 2x^3 \\ \tilde{S}_2(x) &amp;= 10x^3 - 15x^4 + 6x^5 \\ \tilde{S}_3(x) &amp;= 35x^4 - 84x^5 + 70x^6 - 20x^7 \text{.} \end{align*}
</p>
 
</div>
</div>
<a id="ga9a0c6b8252068496aac93344cca7d1f3" name="ga9a0c6b8252068496aac93344cca7d1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a0c6b8252068496aac93344cca7d1f3">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void cpp20::swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reimplementation of std::swap that is constexpr; taken from the LLVM source at <a href="https://github.com/llvm-mirror/libcxx/blob/master/include/type_traits">https://github.com/llvm-mirror/libcxx/blob/master/include/type_traits</a> </p>

</div>
</div>
<a id="ga2ae1fc4fc42ed12ea47af23969583227" name="ga2ae1fc4fc42ed12ea47af23969583227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ae1fc4fc42ed12ea47af23969583227">&#9670;&nbsp;</a></span>tuple_counted_fold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ReverseIteration = false, typename... Elements, typename N_aryOp , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void tuple_counted_fold </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Elements... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N_aryOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a fold over a <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>. </p>
<h3>Details</h3>
<p >Iterates over the elements in a <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> <code>tuple</code> from left to right (left fold) calling <code>op(element, args...)</code> on each element in <code>tuple</code>. A right fold can be done by explicitly setting the first template parameter to true. Folds are easily implemented using <code>tuple_fold</code> by updating one of the <code>args...</code> at each iteration. If you need the index of the current element you can use the <code>tuple_counted_fold</code> variant. <code>tuple_counted_fold</code> passes the current index as the second argument to the Callable <code>op</code>. That is, <code>op(element, index, args...)</code>.</p>
<h3>Example</h3>
<p >The sum of a <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> of Arithmetics can be computed in several ways. First, you can use a lambda: </p><div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> my_tupull = std::make_tuple(2, 7, -3.8, 20.9);</div>
<div class="line">    <span class="keywordtype">double</span> sum_value = 0.0;</div>
<div class="line">    <a class="code hl_function" href="group__UtilitiesGroup.html#gacaeb211c58335d67859ac2e506f6e617">tuple_fold</a>(my_tupull,</div>
<div class="line">               [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; element, <span class="keywordtype">double</span>&amp; state) { state += element; },</div>
<div class="line">               sum_value);</div>
<div class="line">    CHECK(sum_value == approx(26.1));</div>
<div class="ttc" id="agroup__UtilitiesGroup_html_gacaeb211c58335d67859ac2e506f6e617"><div class="ttname"><a href="group__UtilitiesGroup.html#gacaeb211c58335d67859ac2e506f6e617">tuple_fold</a></div><div class="ttdeci">constexpr void tuple_fold(const std::tuple&lt; Elements... &gt; &amp;tuple, N_aryOp &amp;&amp;op, Args &amp;&amp;... args)</div><div class="ttdoc">Perform a fold over a std::tuple.</div><div class="ttdef"><b>Definition:</b> Tuple.hpp:90</div></div>
</div><!-- fragment --><p> You'll notice that <code>state</code> is taken by reference and mutated.</p>
<p >You can do the same thing with a struct defined as </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>tuple_fold_plus {</div>
<div class="line">  T <a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">value</a> = 0.0;</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> S&gt;</div>
<div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> S&amp; element) {</div>
<div class="line">    <a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">value</a> += element;</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p> and then using an instance of the struct </p><div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> my_tupull = std::make_tuple(2, 7, -3.8, 20.9);</div>
<div class="line">    tuple_fold_plus&lt;double&gt; sum_value{};</div>
<div class="line">    <a class="code hl_function" href="group__UtilitiesGroup.html#gacaeb211c58335d67859ac2e506f6e617">tuple_fold</a>(my_tupull, sum_value);</div>
<div class="line">    CHECK(sum_value.value == approx(26.1));</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>You are not able to pass a function pointer to <code>tuple_fold</code> or <code>tuple_counted_fold</code> because you cannot pass a pointer to a function template, only a function.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__UtilitiesGroup.html#gac5159b836743fab01c35f4676bbf3e36" title="Allows zero-cost unordered expansion of a parameter.">expand_pack</a> <a class="el" href="group__UtilitiesGroup.html#gabbfc4adcbade2ec4aad9f0ab878e696e" title="Perform a transform over a std::tuple.">tuple_transform</a> <a class="el" href="group__UtilitiesGroup.html#gacaeb211c58335d67859ac2e506f6e617" title="Perform a fold over a std::tuple.">tuple_fold</a> <a class="el" href="group__UtilitiesGroup.html#ga2ae1fc4fc42ed12ea47af23969583227" title="Perform a fold over a std::tuple.">tuple_counted_fold</a> <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> </dd></dl>

</div>
</div>
<a id="gacaeb211c58335d67859ac2e506f6e617" name="gacaeb211c58335d67859ac2e506f6e617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacaeb211c58335d67859ac2e506f6e617">&#9670;&nbsp;</a></span>tuple_fold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ReverseIteration = false, typename... Elements, typename N_aryOp , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void tuple_fold </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Elements... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N_aryOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a fold over a <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>. </p>
<h3>Details</h3>
<p >Iterates over the elements in a <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> <code>tuple</code> from left to right (left fold) calling <code>op(element, args...)</code> on each element in <code>tuple</code>. A right fold can be done by explicitly setting the first template parameter to true. Folds are easily implemented using <code>tuple_fold</code> by updating one of the <code>args...</code> at each iteration. If you need the index of the current element you can use the <code>tuple_counted_fold</code> variant. <code>tuple_counted_fold</code> passes the current index as the second argument to the Callable <code>op</code>. That is, <code>op(element, index, args...)</code>.</p>
<h3>Example</h3>
<p >The sum of a <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> of Arithmetics can be computed in several ways. First, you can use a lambda: </p><div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> my_tupull = std::make_tuple(2, 7, -3.8, 20.9);</div>
<div class="line">    <span class="keywordtype">double</span> sum_value = 0.0;</div>
<div class="line">    <a class="code hl_function" href="group__UtilitiesGroup.html#gacaeb211c58335d67859ac2e506f6e617">tuple_fold</a>(my_tupull,</div>
<div class="line">               [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; element, <span class="keywordtype">double</span>&amp; state) { state += element; },</div>
<div class="line">               sum_value);</div>
<div class="line">    CHECK(sum_value == approx(26.1));</div>
</div><!-- fragment --><p> You'll notice that <code>state</code> is taken by reference and mutated.</p>
<p >You can do the same thing with a struct defined as </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>tuple_fold_plus {</div>
<div class="line">  T <a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">value</a> = 0.0;</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> S&gt;</div>
<div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> S&amp; element) {</div>
<div class="line">    <a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">value</a> += element;</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p> and then using an instance of the struct </p><div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> my_tupull = std::make_tuple(2, 7, -3.8, 20.9);</div>
<div class="line">    tuple_fold_plus&lt;double&gt; sum_value{};</div>
<div class="line">    <a class="code hl_function" href="group__UtilitiesGroup.html#gacaeb211c58335d67859ac2e506f6e617">tuple_fold</a>(my_tupull, sum_value);</div>
<div class="line">    CHECK(sum_value.value == approx(26.1));</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>You are not able to pass a function pointer to <code>tuple_fold</code> or <code>tuple_counted_fold</code> because you cannot pass a pointer to a function template, only a function.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__UtilitiesGroup.html#gac5159b836743fab01c35f4676bbf3e36" title="Allows zero-cost unordered expansion of a parameter.">expand_pack</a> <a class="el" href="group__UtilitiesGroup.html#gabbfc4adcbade2ec4aad9f0ab878e696e" title="Perform a transform over a std::tuple.">tuple_transform</a> <a class="el" href="group__UtilitiesGroup.html#gacaeb211c58335d67859ac2e506f6e617" title="Perform a fold over a std::tuple.">tuple_fold</a> <a class="el" href="group__UtilitiesGroup.html#ga2ae1fc4fc42ed12ea47af23969583227" title="Perform a fold over a std::tuple.">tuple_counted_fold</a> <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> </dd></dl>

</div>
</div>
<a id="gabbfc4adcbade2ec4aad9f0ab878e696e" name="gabbfc4adcbade2ec4aad9f0ab878e696e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbfc4adcbade2ec4aad9f0ab878e696e">&#9670;&nbsp;</a></span>tuple_transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ReverseIteration = false, typename... Elements, typename N_aryOp , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void tuple_transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Elements... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N_aryOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a transform over a <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>. </p>
<h3>Details</h3>
<p >Iterates over the elements in a <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> <code>tuple</code> from left to right calling <code>op.operator()(element, index, args...)</code> on each element in <code>tuple</code>. A right-to-left transform can be done by explicitly setting the first template parameter to true. The second argument of the invokable will be a deduced <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a>&lt;size_t, value&gt;</code>, from which the current index can be extracted by using <code>decltype(index)::value</code>. For a function object the <code>decltype(index)</code> can be replaced by the deduced type of <code>index</code>. For example, </p><div class="fragment"><div class="line"><span class="keyword">struct </span>negate {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Index, <span class="keyword">typename</span> S&gt;</div>
<div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> T&amp; element, <a class="code hl_class" href="classIndex.html">Index</a> <span class="comment">/*index*/</span>,</div>
<div class="line">                  S&amp; second_tuple_element)<span class="keyword"> const </span>{</div>
<div class="line">    std::get&lt;Index::value&gt;(second_tuple_element) = -element;</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p >Using <code>tuple_transform</code> with a generic lambda goes as follows, </p><div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> my_tupull = std::make_tuple(2, 7, -3.8, 20.9);</div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt;<span class="keyword">decltype</span>(my_tupull)&gt; out_tupull;</div>
<div class="line">  <a class="code hl_function" href="group__UtilitiesGroup.html#gabbfc4adcbade2ec4aad9f0ab878e696e">tuple_transform</a>(my_tupull,</div>
<div class="line">                  [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; element, <span class="keyword">auto</span> index, <span class="keyword">auto</span>&amp; out_tuple) {</div>
<div class="line">                    <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> index_v = <span class="keyword">decltype</span>(index)<a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">::value</a>;</div>
<div class="line">                    std::get&lt;index_v&gt;(out_tuple) = -element;</div>
<div class="line">                  },</div>
<div class="line">                  out_tupull);</div>
<div class="line"> </div>
<div class="line">  CHECK(std::get&lt;0&gt;(out_tupull) == -2);</div>
<div class="line">  CHECK(std::get&lt;1&gt;(out_tupull) == -7);</div>
<div class="line">  CHECK(std::get&lt;2&gt;(out_tupull) == 3.8);</div>
<div class="line">  CHECK(std::get&lt;3&gt;(out_tupull) == -20.9);</div>
<div class="ttc" id="adecay_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a></div></div>
<div class="ttc" id="agroup__UtilitiesGroup_html_gabbfc4adcbade2ec4aad9f0ab878e696e"><div class="ttname"><a href="group__UtilitiesGroup.html#gabbfc4adcbade2ec4aad9f0ab878e696e">tuple_transform</a></div><div class="ttdeci">constexpr void tuple_transform(const std::tuple&lt; Elements... &gt; &amp;tuple, N_aryOp &amp;&amp;op, Args &amp;&amp;... args)</div><div class="ttdoc">Perform a transform over a std::tuple.</div><div class="ttdef"><b>Definition:</b> Tuple.hpp:129</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__UtilitiesGroup.html#gac5159b836743fab01c35f4676bbf3e36" title="Allows zero-cost unordered expansion of a parameter.">expand_pack</a> <a class="el" href="group__UtilitiesGroup.html#gacaeb211c58335d67859ac2e506f6e617" title="Perform a fold over a std::tuple.">tuple_fold</a> <a class="el" href="group__UtilitiesGroup.html#ga2ae1fc4fc42ed12ea47af23969583227" title="Perform a fold over a std::tuple.">tuple_counted_fold</a> <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> </dd></dl>

</div>
</div>
<a id="ga2510b0047d38d00d44cc1eda26c327f3" name="ga2510b0047d38d00d44cc1eda26c327f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2510b0047d38d00d44cc1eda26c327f3">&#9670;&nbsp;</a></span>unordered_print_helper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void unordered_print_helper </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt &amp;&amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt &amp;&amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Like sequence_print_helper, but sorts the string representations. </p>

</div>
</div>
<a id="ga3c0f4bd567ade345d958281f4c51311e" name="ga3c0f4bd567ade345d958281f4c51311e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c0f4bd567ade345d958281f4c51311e">&#9670;&nbsp;</a></span>unordered_print_helper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void unordered_print_helper </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt &amp;&amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt &amp;&amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Like sequence_print_helper, but sorts the string representations. </p>

</div>
</div>
<a id="ga1a9d2f32c8b4153f8bcd7c4d17c2af54" name="ga1a9d2f32c8b4153f8bcd7c4d17c2af54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a9d2f32c8b4153f8bcd7c4d17c2af54">&#9670;&nbsp;</a></span>wrap_text()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> wrap_text </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>line_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>indentation</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap the string <code>str</code> so that it is no longer than <code>line_length</code> and indent each new line with <code>indentation</code>. The first line is also indented. </p>
<p >Single words longer than <code>line_length</code> are hyphenated. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gab78389fadf763e3693ce893fad5d7fba" name="gab78389fadf763e3693ce893fad5d7fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab78389fadf763e3693ce893fad5d7fba">&#9670;&nbsp;</a></span>flat_all_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool... Bs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tmpl2::flat_all_v = <a class="el" href="group__UtilitiesGroup.html#ga01ee1794935080949a6995ae7d5e08cc">flat_all</a>&lt;Bs...&gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A non-short-circuiting logical AND between bools 'B"". </p>
<p >Useful when arbitrarily large parameter packs need to be evaluated, since <a class="elRef" href="http://en.cppreference.com/w/cpp/types/conjunction.html">std::conjunction</a> and <a class="elRef" href="http://en.cppreference.com/w/cpp/types/disjunction.html">std::disjunction</a> use recursion </p>

</div>
</div>
<a id="ga8a328cb983ebb1947b0eb9d924f40253" name="ga8a328cb983ebb1947b0eb9d924f40253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a328cb983ebb1947b0eb9d924f40253">&#9670;&nbsp;</a></span>flat_any_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool... Bs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tmpl2::flat_any_v = <a class="el" href="group__UtilitiesGroup.html#ga6e25dbfa539ff4513329969dbcd81c40">flat_any</a>&lt;Bs...&gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A non-short-circuiting logical OR between bools 'B"". </p>
<p >Useful when arbitrarily large parameter packs need to be evaluated, since <a class="elRef" href="http://en.cppreference.com/w/cpp/types/conjunction.html">std::conjunction</a> and <a class="elRef" href="http://en.cppreference.com/w/cpp/types/disjunction.html">std::disjunction</a> use recursion </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
