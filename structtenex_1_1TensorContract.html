<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: tenex::TensorContract&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt; Struct Template Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structtenex_1_1TensorContract.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="structtenex_1_1TensorContract-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tenex::TensorContract&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__TensorExpressionsGroup.html">Tensor Expressions</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7bbed4cdad471ae4db5011320634bb4a"><td class="memItemLeft" align="right" valign="top"><a id="a7bbed4cdad471ae4db5011320634bb4a" name="a7bbed4cdad471ae4db5011320634bb4a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>contracted_type</b> = typename detail::ContractedType&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices,(tmpl::size&lt; Symm &gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a> - NumContractedIndices)/2 &gt;</td></tr>
<tr class="memdesc:a7bbed4cdad471ae4db5011320634bb4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores internally useful information regarding the contraction. See <code>detail::ContractedType</code> for more details. <br /></td></tr>
<tr class="separator:a7bbed4cdad471ae4db5011320634bb4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d76082bcf5238ac8364196665be8ecb"><td class="memItemLeft" align="right" valign="top"><a id="a7d76082bcf5238ac8364196665be8ecb" name="a7d76082bcf5238ac8364196665be8ecb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>new_type</b> = typename contracted_type::type</td></tr>
<tr class="memdesc:a7d76082bcf5238ac8364196665be8ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>TensorExpression</code> type that results from performing the contraction. <br /></td></tr>
<tr class="separator:a7d76082bcf5238ac8364196665be8ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac287f5ce6e976e52c6e9b54b1815ae0b"><td class="memItemLeft" align="right" valign="top"><a id="ac287f5ce6e976e52c6e9b54b1815ae0b" name="ac287f5ce6e976e52c6e9b54b1815ae0b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>type</b> = X</td></tr>
<tr class="memdesc:ac287f5ce6e976e52c6e9b54b1815ae0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the data being stored in the result of the expression. <br /></td></tr>
<tr class="separator:ac287f5ce6e976e52c6e9b54b1815ae0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff67360e20386ee3b540072778dbfd7"><td class="memItemLeft" align="right" valign="top"><a id="acff67360e20386ee3b540072778dbfd7" name="acff67360e20386ee3b540072778dbfd7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>symmetry</b> = typename new_type::symmetry</td></tr>
<tr class="memdesc:acff67360e20386ee3b540072778dbfd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9" title="Computes the canonical symmetry from the integers T">Symmetry</a> of the result of the expression. <br /></td></tr>
<tr class="separator:acff67360e20386ee3b540072778dbfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a06aabc370346ffce384d30c9085e7"><td class="memItemLeft" align="right" valign="top"><a id="a39a06aabc370346ffce384d30c9085e7" name="a39a06aabc370346ffce384d30c9085e7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>index_list</b> = typename new_type::index_list</td></tr>
<tr class="memdesc:a39a06aabc370346ffce384d30c9085e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a>s of the result of the expression. <br /></td></tr>
<tr class="separator:a39a06aabc370346ffce384d30c9085e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cb9e50d2c773154c18856a5c95d7b6"><td class="memItemLeft" align="right" valign="top"><a id="ae2cb9e50d2c773154c18856a5c95d7b6" name="ae2cb9e50d2c773154c18856a5c95d7b6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>args_list</b> = typename new_type::args_list</td></tr>
<tr class="memdesc:ae2cb9e50d2c773154c18856a5c95d7b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of generic <code><a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a></code>s of the result of the expression. <br /></td></tr>
<tr class="separator:ae2cb9e50d2c773154c18856a5c95d7b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa3f3e868b5cf8ef4ecb5473fe2d69733"><td class="memItemLeft" align="right" valign="top"><a id="aa3f3e868b5cf8ef4ecb5473fe2d69733" name="aa3f3e868b5cf8ef4ecb5473fe2d69733"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TensorContract</b> (const TensorExpression&lt; T, X, Symm, IndexList, ArgsList &gt; &amp;t)</td></tr>
<tr class="separator:aa3f3e868b5cf8ef4ecb5473fe2d69733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa459c61d3c1b9bd991fdb4df175d22da"><td class="memTemplParams" colspan="2"><a id="aa459c61d3c1b9bd991fdb4df175d22da" name="aa459c61d3c1b9bd991fdb4df175d22da"></a>
template&lt;typename LhsTensor &gt; </td></tr>
<tr class="memitem:aa459c61d3c1b9bd991fdb4df175d22da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assert_lhs_tensor_not_in_rhs_expression</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; LhsTensor * &gt; lhs_tensor) const</td></tr>
<tr class="memdesc:aa459c61d3c1b9bd991fdb4df175d22da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert that the LHS tensor of the equation does not also appear in this expression's subtree. <br /></td></tr>
<tr class="separator:aa459c61d3c1b9bd991fdb4df175d22da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67e84496c192c3e87d0fd58d35b25e5"><td class="memTemplParams" colspan="2">template&lt;typename LhsTensorIndices , typename LhsTensor &gt; </td></tr>
<tr class="memitem:ac67e84496c192c3e87d0fd58d35b25e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#ac67e84496c192c3e87d0fd58d35b25e5">assert_lhs_tensorindices_same_in_rhs</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; LhsTensor * &gt; lhs_tensor) const</td></tr>
<tr class="memdesc:ac67e84496c192c3e87d0fd58d35b25e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert that each instance of the LHS tensor in the RHS tensor expression uses the same generic index order that the LHS uses.  <a href="structtenex_1_1TensorContract.html#ac67e84496c192c3e87d0fd58d35b25e5">More...</a><br /></td></tr>
<tr class="separator:ac67e84496c192c3e87d0fd58d35b25e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae836df8365793a2bba993919ed58e58a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#ae836df8365793a2bba993919ed58e58a">get_rhs_tensor_component_size</a> () const</td></tr>
<tr class="memdesc:ae836df8365793a2bba993919ed58e58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of a component from a <code>Tensor</code> in this expression's subtree of the RHS <code>TensorExpression</code>  <a href="structtenex_1_1TensorContract.html#ae836df8365793a2bba993919ed58e58a">More...</a><br /></td></tr>
<tr class="separator:ae836df8365793a2bba993919ed58e58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc90cf79e41bec9e1e45268f5ca5408"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#aafc90cf79e41bec9e1e45268f5ca5408">get</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#a299115d18ecdc589107bbdeb975b0094">num_tensor_indices</a> &gt; &amp;contracted_multi_index) const</td></tr>
<tr class="memdesc:aafc90cf79e41bec9e1e45268f5ca5408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the component of the resultant contracted tensor at a given multi-index.  <a href="structtenex_1_1TensorContract.html#aafc90cf79e41bec9e1e45268f5ca5408">More...</a><br /></td></tr>
<tr class="separator:aafc90cf79e41bec9e1e45268f5ca5408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ea0072fd3ccdc59d26012559c37a7a"><td class="memTemplParams" colspan="2">template&lt;typename ResultType &gt; </td></tr>
<tr class="memitem:a40ea0072fd3ccdc59d26012559c37a7a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#a40ea0072fd3ccdc59d26012559c37a7a">get_primary</a> (const ResultType &amp;result_component, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#a299115d18ecdc589107bbdeb975b0094">num_tensor_indices</a> &gt; &amp;contracted_multi_index) const</td></tr>
<tr class="memdesc:a40ea0072fd3ccdc59d26012559c37a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the component of the resultant contracted tensor at a given multi-index.  <a href="structtenex_1_1TensorContract.html#a40ea0072fd3ccdc59d26012559c37a7a">More...</a><br /></td></tr>
<tr class="separator:a40ea0072fd3ccdc59d26012559c37a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfca0b93ea1cf89b9dd104714337916"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#abcfca0b93ea1cf89b9dd104714337916">evaluate_primary_contraction</a> (<a class="el" href="structtenex_1_1TensorContract.html#ac287f5ce6e976e52c6e9b54b1815ae0b">type</a> &amp;result_component, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#a299115d18ecdc589107bbdeb975b0094">num_tensor_indices</a> &gt; &amp;contracted_multi_index, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#afe0e19a8be1a98e2c629e77c491a0802">num_uncontracted_tensor_indices</a> &gt; &amp;lowest_multi_index) const</td></tr>
<tr class="memdesc:abcfca0b93ea1cf89b9dd104714337916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Successively evaluate the LHS Tensor's result component at each leg of summations within the contraction expression.  <a href="structtenex_1_1TensorContract.html#abcfca0b93ea1cf89b9dd104714337916">More...</a><br /></td></tr>
<tr class="separator:abcfca0b93ea1cf89b9dd104714337916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe14efcececb354346da54593d4e4fd"><td class="memTemplParams" colspan="2">template&lt;typename ResultType &gt; </td></tr>
<tr class="memitem:a2fe14efcececb354346da54593d4e4fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#a2fe14efcececb354346da54593d4e4fd">evaluate_primary_subtree</a> (ResultType &amp;result_component, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#a299115d18ecdc589107bbdeb975b0094">num_tensor_indices</a> &gt; &amp;contracted_multi_index) const</td></tr>
<tr class="memdesc:a2fe14efcececb354346da54593d4e4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Successively evaluate the LHS Tensor's result component at each leg in this expression's subtree.  <a href="structtenex_1_1TensorContract.html#a2fe14efcececb354346da54593d4e4fd">More...</a><br /></td></tr>
<tr class="separator:a2fe14efcececb354346da54593d4e4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a60f97bc70614459da6a2cc6501cfaa01"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#afe0e19a8be1a98e2c629e77c491a0802">num_uncontracted_tensor_indices</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#a60f97bc70614459da6a2cc6501cfaa01">get_highest_multi_index_to_sum</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#a299115d18ecdc589107bbdeb975b0094">num_tensor_indices</a> &gt; &amp;contracted_multi_index)</td></tr>
<tr class="memdesc:a60f97bc70614459da6a2cc6501cfaa01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the highest multi-index between the components being summed in the contraction.  <a href="structtenex_1_1TensorContract.html#a60f97bc70614459da6a2cc6501cfaa01">More...</a><br /></td></tr>
<tr class="separator:a60f97bc70614459da6a2cc6501cfaa01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678cb923cf6b5ed240a6b36382da2a64"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#afe0e19a8be1a98e2c629e77c491a0802">num_uncontracted_tensor_indices</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#a678cb923cf6b5ed240a6b36382da2a64">get_lowest_multi_index_to_sum</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#a299115d18ecdc589107bbdeb975b0094">num_tensor_indices</a> &gt; &amp;contracted_multi_index)</td></tr>
<tr class="memdesc:a678cb923cf6b5ed240a6b36382da2a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lowest multi-index between the components being summed in the contraction.  <a href="structtenex_1_1TensorContract.html#a678cb923cf6b5ed240a6b36382da2a64">More...</a><br /></td></tr>
<tr class="separator:a678cb923cf6b5ed240a6b36382da2a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2197ff6df3cf7b23bc41c2d44b2e29ed"><td class="memItemLeft" align="right" valign="top">static <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#afe0e19a8be1a98e2c629e77c491a0802">num_uncontracted_tensor_indices</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#a2197ff6df3cf7b23bc41c2d44b2e29ed">get_next_highest_multi_index_to_sum</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#afe0e19a8be1a98e2c629e77c491a0802">num_uncontracted_tensor_indices</a> &gt; &amp;uncontracted_multi_index)</td></tr>
<tr class="memdesc:a2197ff6df3cf7b23bc41c2d44b2e29ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the multi-index of one term being summed in the contraction, return the next highest multi-index of a component being summed.  <a href="structtenex_1_1TensorContract.html#a2197ff6df3cf7b23bc41c2d44b2e29ed">More...</a><br /></td></tr>
<tr class="separator:a2197ff6df3cf7b23bc41c2d44b2e29ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de8e91823579b9646ea7f24616eef20"><td class="memItemLeft" align="right" valign="top">static <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#afe0e19a8be1a98e2c629e77c491a0802">num_uncontracted_tensor_indices</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#a3de8e91823579b9646ea7f24616eef20">get_next_lowest_multi_index_to_sum</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#afe0e19a8be1a98e2c629e77c491a0802">num_uncontracted_tensor_indices</a> &gt; &amp;uncontracted_multi_index)</td></tr>
<tr class="memdesc:a3de8e91823579b9646ea7f24616eef20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the multi-index of one term being summed in the contraction, return the next lowest multi-index of a component being summed.  <a href="structtenex_1_1TensorContract.html#a3de8e91823579b9646ea7f24616eef20">More...</a><br /></td></tr>
<tr class="separator:a3de8e91823579b9646ea7f24616eef20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48becd8ea1f78b14e02993f5c776ed4d"><td class="memTemplParams" colspan="2">template&lt;size_t Iteration&gt; </td></tr>
<tr class="memitem:a48becd8ea1f78b14e02993f5c776ed4d"><td class="memTemplItemLeft" align="right" valign="top">static decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#a48becd8ea1f78b14e02993f5c776ed4d">compute_contraction</a> (const T &amp;t, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#afe0e19a8be1a98e2c629e77c491a0802">num_uncontracted_tensor_indices</a> &gt; &amp;current_multi_index)</td></tr>
<tr class="memdesc:a48becd8ea1f78b14e02993f5c776ed4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of a component in the resultant contracted tensor.  <a href="structtenex_1_1TensorContract.html#a48becd8ea1f78b14e02993f5c776ed4d">More...</a><br /></td></tr>
<tr class="separator:a48becd8ea1f78b14e02993f5c776ed4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe96b9cb1c1327e727b6664182280df"><td class="memTemplParams" colspan="2">template&lt;size_t Iteration&gt; </td></tr>
<tr class="memitem:a6fe96b9cb1c1327e727b6664182280df"><td class="memTemplItemLeft" align="right" valign="top">static decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#a6fe96b9cb1c1327e727b6664182280df">compute_contraction_leg</a> (const T &amp;t, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#afe0e19a8be1a98e2c629e77c491a0802">num_uncontracted_tensor_indices</a> &gt; &amp;current_multi_index, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#afe0e19a8be1a98e2c629e77c491a0802">num_uncontracted_tensor_indices</a> &gt; &amp;next_leg_starting_multi_index)</td></tr>
<tr class="memdesc:a6fe96b9cb1c1327e727b6664182280df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the result of an internal leg of the contraction.  <a href="structtenex_1_1TensorContract.html#a6fe96b9cb1c1327e727b6664182280df">More...</a><br /></td></tr>
<tr class="separator:a6fe96b9cb1c1327e727b6664182280df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae702153e6acdf215a6c63d2fa089c75a"><td class="memTemplParams" colspan="2">template&lt;size_t Iteration&gt; </td></tr>
<tr class="memitem:ae702153e6acdf215a6c63d2fa089c75a"><td class="memTemplItemLeft" align="right" valign="top">static decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#ae702153e6acdf215a6c63d2fa089c75a">compute_contraction_primary</a> (const T &amp;t, const <a class="el" href="structtenex_1_1TensorContract.html#ac287f5ce6e976e52c6e9b54b1815ae0b">type</a> &amp;result_component, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#afe0e19a8be1a98e2c629e77c491a0802">num_uncontracted_tensor_indices</a> &gt; &amp;current_multi_index)</td></tr>
<tr class="memdesc:ae702153e6acdf215a6c63d2fa089c75a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of a component in the resultant contracted tensor.  <a href="structtenex_1_1TensorContract.html#ae702153e6acdf215a6c63d2fa089c75a">More...</a><br /></td></tr>
<tr class="separator:ae702153e6acdf215a6c63d2fa089c75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a299115d18ecdc589107bbdeb975b0094"><td class="memItemLeft" align="right" valign="top"><a id="a299115d18ecdc589107bbdeb975b0094" name="a299115d18ecdc589107bbdeb975b0094"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_tensor_indices</b> = NumContractedIndices</td></tr>
<tr class="memdesc:a299115d18ecdc589107bbdeb975b0094"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of tensor indices in the result of the expression. <br /></td></tr>
<tr class="separator:a299115d18ecdc589107bbdeb975b0094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0e19a8be1a98e2c629e77c491a0802"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#afe0e19a8be1a98e2c629e77c491a0802">num_uncontracted_tensor_indices</a></td></tr>
<tr class="memdesc:afe0e19a8be1a98e2c629e77c491a0802"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of tensor indices in the operand expression being contracted.  <a href="structtenex_1_1TensorContract.html#afe0e19a8be1a98e2c629e77c491a0802">More...</a><br /></td></tr>
<tr class="separator:afe0e19a8be1a98e2c629e77c491a0802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65af8321f8051a4bcc12727fb44470bd"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#a65af8321f8051a4bcc12727fb44470bd">num_indices_to_contract</a></td></tr>
<tr class="memdesc:a65af8321f8051a4bcc12727fb44470bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of tensor indices in the operand expression that will be contracted.  <a href="structtenex_1_1TensorContract.html#a65af8321f8051a4bcc12727fb44470bd">More...</a><br /></td></tr>
<tr class="separator:a65af8321f8051a4bcc12727fb44470bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996a6c997204ab446e1135b9d4977a09"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#a996a6c997204ab446e1135b9d4977a09">num_contracted_index_pairs</a></td></tr>
<tr class="memdesc:a996a6c997204ab446e1135b9d4977a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of tensor index pairs in the operand expression that will be contracted.  <a href="structtenex_1_1TensorContract.html#a996a6c997204ab446e1135b9d4977a09">More...</a><br /></td></tr>
<tr class="separator:a996a6c997204ab446e1135b9d4977a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac946a1bf8541c32197dbc23b907ebab9"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, NumContractedIndices &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#ac946a1bf8541c32197dbc23b907ebab9">index_transformation</a></td></tr>
<tr class="memdesc:ac946a1bf8541c32197dbc23b907ebab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping from the positions of indices in the resultant contracted tensor to their positions in the operand uncontracted tensor.  <a href="structtenex_1_1TensorContract.html#ac946a1bf8541c32197dbc23b907ebab9">More...</a><br /></td></tr>
<tr class="separator:ac946a1bf8541c32197dbc23b907ebab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8968e4870f4bd94bb7db361a1c02ef2b"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; size_t, size_t &gt;, <a class="el" href="structtenex_1_1TensorContract.html#a996a6c997204ab446e1135b9d4977a09">num_contracted_index_pairs</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#a8968e4870f4bd94bb7db361a1c02ef2b">contracted_index_pair_positions</a></td></tr>
<tr class="memdesc:a8968e4870f4bd94bb7db361a1c02ef2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positions of the index pairs in the operand uncontracted tensor that we wish to contract.  <a href="structtenex_1_1TensorContract.html#a8968e4870f4bd94bb7db361a1c02ef2b">More...</a><br /></td></tr>
<tr class="separator:a8968e4870f4bd94bb7db361a1c02ef2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9b1b8096d7e917345dacc43706ee15"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; size_t, size_t &gt;, <a class="el" href="structtenex_1_1TensorContract.html#a996a6c997204ab446e1135b9d4977a09">num_contracted_index_pairs</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#a1a9b1b8096d7e917345dacc43706ee15">contracted_index_first_values</a></td></tr>
<tr class="memdesc:a1a9b1b8096d7e917345dacc43706ee15"><td class="mdescLeft">&#160;</td><td class="mdescRight">First concrete values of contracted indices to sum. This is to handle cases when we have generic spatial <code><a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a></code>s used for spacetime indices, as the first concrete index value to contract will be 1 (first spatial index) instead of 0 (the time index). Contracted index pairs will have different "starting" concrete indices when one index in the pair is a spatial spacetime index and the other is not.  <a href="structtenex_1_1TensorContract.html#a1a9b1b8096d7e917345dacc43706ee15">More...</a><br /></td></tr>
<tr class="separator:a1a9b1b8096d7e917345dacc43706ee15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35f0672900dcdbad6497ac7eb7035b6"><td class="memItemLeft" align="right" valign="top"><a id="ad35f0672900dcdbad6497ac7eb7035b6" name="ad35f0672900dcdbad6497ac7eb7035b6"></a>
static constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#afe0e19a8be1a98e2c629e77c491a0802">num_uncontracted_tensor_indices</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>uncontracted_index_dims</b> = contracted_type::uncontracted_index_dims</td></tr>
<tr class="memdesc:ad35f0672900dcdbad6497ac7eb7035b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dimensions of the indices in the uncontracted operand expression. <br /></td></tr>
<tr class="separator:ad35f0672900dcdbad6497ac7eb7035b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6f95bd240ee1bbc862e561aa6f95f7"><td class="memItemLeft" align="right" valign="top"><a id="add6f95bd240ee1bbc862e561aa6f95f7" name="add6f95bd240ee1bbc862e561aa6f95f7"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_terms_summed</b> = contracted_type::num_terms_summed</td></tr>
<tr class="memdesc:add6f95bd240ee1bbc862e561aa6f95f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of terms to sum for this expression's contraction. <br /></td></tr>
<tr class="separator:add6f95bd240ee1bbc862e561aa6f95f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5f59c27080e6914d32034c3823c0a1"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#a9c5f59c27080e6914d32034c3823c0a1">num_ops_left_child</a></td></tr>
<tr class="memdesc:a9c5f59c27080e6914d32034c3823c0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of arithmetic tensor operations done in the subtree for the left operand.  <a href="structtenex_1_1TensorContract.html#a9c5f59c27080e6914d32034c3823c0a1">More...</a><br /></td></tr>
<tr class="separator:a9c5f59c27080e6914d32034c3823c0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14adaff56facee149ef7d191eac5a147"><td class="memItemLeft" align="right" valign="top"><a id="a14adaff56facee149ef7d191eac5a147" name="a14adaff56facee149ef7d191eac5a147"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_ops_right_child</b> = 0</td></tr>
<tr class="memdesc:a14adaff56facee149ef7d191eac5a147"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of arithmetic tensor operations done in the subtree for the right operand. This is 0 because this expression represents a unary operation. <br /></td></tr>
<tr class="separator:a14adaff56facee149ef7d191eac5a147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1015d0a46c130bb2fd6816c80af0ca"><td class="memItemLeft" align="right" valign="top"><a id="acc1015d0a46c130bb2fd6816c80af0ca" name="acc1015d0a46c130bb2fd6816c80af0ca"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_ops_subtree</b> = <a class="el" href="structtenex_1_1TensorContract.html#a9c5f59c27080e6914d32034c3823c0a1">num_ops_left_child</a></td></tr>
<tr class="memdesc:acc1015d0a46c130bb2fd6816c80af0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of arithmetic tensor operations done in this expression's whole subtree. <br /></td></tr>
<tr class="separator:acc1015d0a46c130bb2fd6816c80af0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a3a1256579136d50ff92849b430062"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#ac2a3a1256579136d50ff92849b430062">height_relative_to_closest_tensor_leaf_in_subtree</a></td></tr>
<tr class="memdesc:ac2a3a1256579136d50ff92849b430062"><td class="mdescLeft">&#160;</td><td class="mdescRight">The height of this expression's node in the expression tree relative to the closest <code><a class="el" href="structtenex_1_1TensorAsExpression.html" title="Defines an expression representing a Tensor.">TensorAsExpression</a></code> leaf in its subtree.  <a href="structtenex_1_1TensorContract.html#ac2a3a1256579136d50ff92849b430062">More...</a><br /></td></tr>
<tr class="separator:ac2a3a1256579136d50ff92849b430062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1279515329d570be0940ac15e5535149"><td class="memItemLeft" align="right" valign="top"><a id="a1279515329d570be0940ac15e5535149" name="a1279515329d570be0940ac15e5535149"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_primary_end</b> = T::is_primary_start</td></tr>
<tr class="memdesc:a1279515329d570be0940ac15e5535149"><td class="mdescLeft">&#160;</td><td class="mdescRight">If on the primary path, whether or not the expression is an ending point of a leg. <br /></td></tr>
<tr class="separator:a1279515329d570be0940ac15e5535149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46ab8c2ed4dd3cad2a1f48b44d96347"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#ac46ab8c2ed4dd3cad2a1f48b44d96347">num_ops_to_evaluate_primary_left_child</a></td></tr>
<tr class="memdesc:ac46ab8c2ed4dd3cad2a1f48b44d96347"><td class="mdescLeft">&#160;</td><td class="mdescRight">If on the primary path, this is the remaining number of arithmetic tensor operations that need to be done in the subtree of the child along the primary path, given that we will have already computed the whole subtree at the next lowest leg's starting point.  <a href="structtenex_1_1TensorContract.html#ac46ab8c2ed4dd3cad2a1f48b44d96347">More...</a><br /></td></tr>
<tr class="separator:ac46ab8c2ed4dd3cad2a1f48b44d96347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666d832ac274fdf924964ff222bb0299"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#a666d832ac274fdf924964ff222bb0299">num_ops_to_evaluate_primary_right_child</a></td></tr>
<tr class="memdesc:a666d832ac274fdf924964ff222bb0299"><td class="mdescLeft">&#160;</td><td class="mdescRight">If on the primary path, this is the remaining number of arithmetic tensor operations that need to be done in the right operand's subtree. No splitting is currently done, so this is just <code>num_ops_right_child</code>.  <a href="structtenex_1_1TensorContract.html#a666d832ac274fdf924964ff222bb0299">More...</a><br /></td></tr>
<tr class="separator:a666d832ac274fdf924964ff222bb0299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2ef74a937690548f061089176815d6"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#a1f2ef74a937690548f061089176815d6">num_ops_to_evaluate_primary_subtree</a></td></tr>
<tr class="memdesc:a1f2ef74a937690548f061089176815d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">If on the primary path, this is the remaining number of arithmetic tensor operations that need to be done for this expression's subtree, given that we will have already computed the subtree at the next lowest leg's starting point.  <a href="structtenex_1_1TensorContract.html#a1f2ef74a937690548f061089176815d6">More...</a><br /></td></tr>
<tr class="separator:a1f2ef74a937690548f061089176815d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd8a9b2e8b1244fb5b49ac1d5e67821"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#aabd8a9b2e8b1244fb5b49ac1d5e67821">is_primary_start</a></td></tr>
<tr class="memdesc:aabd8a9b2e8b1244fb5b49ac1d5e67821"><td class="mdescLeft">&#160;</td><td class="mdescRight">If on the primary path, whether or not the expression is a starting point of a leg.  <a href="structtenex_1_1TensorContract.html#aabd8a9b2e8b1244fb5b49ac1d5e67821">More...</a><br /></td></tr>
<tr class="separator:aabd8a9b2e8b1244fb5b49ac1d5e67821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f31b481d0a87a693867af80de9f1d1"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#a21f31b481d0a87a693867af80de9f1d1">primary_child_subtree_contains_primary_start</a></td></tr>
<tr class="memdesc:a21f31b481d0a87a693867af80de9f1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If on the primary path, whether or not the expression's child along the primary path is a subtree that contains a starting point of a leg along the primary path.  <a href="structtenex_1_1TensorContract.html#a21f31b481d0a87a693867af80de9f1d1">More...</a><br /></td></tr>
<tr class="separator:a21f31b481d0a87a693867af80de9f1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3b49477f07bae3dd5401cac7c14e85"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#a3b3b49477f07bae3dd5401cac7c14e85">primary_subtree_contains_primary_start</a></td></tr>
<tr class="memdesc:a3b3b49477f07bae3dd5401cac7c14e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">If on the primary path, whether or not this subtree contains a starting point of a leg along the primary path.  <a href="structtenex_1_1TensorContract.html#a3b3b49477f07bae3dd5401cac7c14e85">More...</a><br /></td></tr>
<tr class="separator:a3b3b49477f07bae3dd5401cac7c14e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a5c1a599590a45c620d70e846f3f10"><td class="memItemLeft" align="right" valign="top"><a id="a27a5c1a599590a45c620d70e846f3f10" name="a27a5c1a599590a45c620d70e846f3f10"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_ops_subexpression</b> = T::num_ops_subtree</td></tr>
<tr class="memdesc:a27a5c1a599590a45c620d70e846f3f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of arithmetic tensor operations done in the subtree of the operand expression being contracted. <br /></td></tr>
<tr class="separator:a27a5c1a599590a45c620d70e846f3f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4acd5225b70ae909891cae7da4819c"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#abf4acd5225b70ae909891cae7da4819c">leg_length</a></td></tr>
<tr class="memdesc:abf4acd5225b70ae909891cae7da4819c"><td class="mdescLeft">&#160;</td><td class="mdescRight">In the subtree for this contraction, how many terms we sum together for each leg of the contraction.  <a href="structtenex_1_1TensorContract.html#abf4acd5225b70ae909891cae7da4819c">More...</a><br /></td></tr>
<tr class="separator:abf4acd5225b70ae909891cae7da4819c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34feacff1ecf39075edb8a62012aebc"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#ae34feacff1ecf39075edb8a62012aebc">num_full_legs</a></td></tr>
<tr class="memdesc:ae34feacff1ecf39075edb8a62012aebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">After dividing up the contraction subtree into legs, the number of legs whose length is equal to <code>leg_length</code>  <a href="structtenex_1_1TensorContract.html#ae34feacff1ecf39075edb8a62012aebc">More...</a><br /></td></tr>
<tr class="separator:ae34feacff1ecf39075edb8a62012aebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7b25f3f47a4c007d2bab59c1604b64"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html#a6a7b25f3f47a4c007d2bab59c1604b64">last_leg_length</a></td></tr>
<tr class="memdesc:a6a7b25f3f47a4c007d2bab59c1604b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">After dividing up the contraction subtree into legs of even length, the number of terms we still have left to sum.  <a href="structtenex_1_1TensorContract.html#a6a7b25f3f47a4c007d2bab59c1604b64">More...</a><br /></td></tr>
<tr class="separator:a6a7b25f3f47a4c007d2bab59c1604b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ccf4a65e8f258e6236f6ae6c14c0f3e"><td class="memItemLeft" align="right" valign="top"><a id="a9ccf4a65e8f258e6236f6ae6c14c0f3e" name="a9ccf4a65e8f258e6236f6ae6c14c0f3e"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>evaluate_terms_separately</b> = <a class="el" href="structtenex_1_1TensorContract.html#abf4acd5225b70ae909891cae7da4819c">leg_length</a> == 0</td></tr>
<tr class="memdesc:a9ccf4a65e8f258e6236f6ae6c14c0f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">When evaluating along a primary path, whether each term's subtrees should be evaluated separately. Since <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code> expression runtime scales poorly with increased number of operations, evaluating individual terms' subtrees separately like this is beneficial when each term, itself, involves many tensor operations. <br /></td></tr>
<tr class="separator:a9ccf4a65e8f258e6236f6ae6c14c0f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac67e84496c192c3e87d0fd58d35b25e5" name="ac67e84496c192c3e87d0fd58d35b25e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67e84496c192c3e87d0fd58d35b25e5">&#9670;&nbsp;</a></span>assert_lhs_tensorindices_same_in_rhs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<div class="memtemplate">
template&lt;typename LhsTensorIndices , typename LhsTensor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::assert_lhs_tensorindices_same_in_rhs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; LhsTensor * &gt;&#160;</td>
          <td class="paramname"><em>lhs_tensor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assert that each instance of the LHS tensor in the RHS tensor expression uses the same generic index order that the LHS uses. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LhsTensorIndices</td><td>the list of generic <code><a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a></code>s of the LHS result <code>Tensor</code> being computed </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs_tensor</td><td>the LHS result <code>Tensor</code> being computed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48becd8ea1f78b14e02993f5c776ed4d" name="a48becd8ea1f78b14e02993f5c776ed4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48becd8ea1f78b14e02993f5c776ed4d">&#9670;&nbsp;</a></span>compute_contraction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<div class="memtemplate">
template&lt;size_t Iteration&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static decltype(auto) <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::compute_contraction </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#afe0e19a8be1a98e2c629e77c491a0802">num_uncontracted_tensor_indices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>current_multi_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the value of a component in the resultant contracted tensor. </p>
<h3>Details</h3>
<p >The contraction is computed by recursively adding up each component in the summation, across all index pairs being contracted in the operand expression. This function is called <code>Iteration = num_terms_summed</code> times, once for each uncontracted tensor component being summed. It should externally be called for the first time with <code>Iteration == 0</code> and <code>current_multi_index == &lt;highest multi index to sum&gt;</code> (see <code>get_next_highest_multi_index_to_sum</code> for details).</p>
<p >In performing the recursive summation, the recursion is specifically done "to the left," in that this function returns <code>compute_contraction(next index) + get(this_index)</code> as opposed to <code>get(this_index) + compute_contraction</code>. Benchmarking has shown that increased breadth in an equation's expression tree can slow down runtime. By "recursing left" here, we minimize breadth in the overall tree for an equation, as both <code><a class="el" href="structtenex_1_1AddSub.html" title="Defines the tensor expression representing the addition or subtraction of two tensor expressions.">AddSub</a></code> addition and <code><a class="el" href="structtenex_1_1OuterProduct.html" title="Defines the tensor expression representing the outer product of two tensor expressions.">OuterProduct</a></code> (other expressions with two children) make efforts to make their operands with larger subtrees be their left operand.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iteration</td><td>the nth term to sum, where n is between [0, num_terms_summed) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the expression contained within this contraction expression </td></tr>
    <tr><td class="paramname">current_multi_index</td><td>the multi-index of the uncontracted tensor component to retrieve </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the value of a component of the resulant contracted tensor </p>

</div>
</div>
<a id="a6fe96b9cb1c1327e727b6664182280df" name="a6fe96b9cb1c1327e727b6664182280df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe96b9cb1c1327e727b6664182280df">&#9670;&nbsp;</a></span>compute_contraction_leg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<div class="memtemplate">
template&lt;size_t Iteration&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static decltype(auto) <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::compute_contraction_leg </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#afe0e19a8be1a98e2c629e77c491a0802">num_uncontracted_tensor_indices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>current_multi_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#afe0e19a8be1a98e2c629e77c491a0802">num_uncontracted_tensor_indices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>next_leg_starting_multi_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the result of an internal leg of the contraction. </p>
<h3>Details</h3>
<p >This function differs from <code>compute_contraction</code> and <code>compute_contraction_primary</code> in that it only computes one leg of the whole contraction, as opposed to the whole contraction.</p>
<p >The leg being summed is defined by the <code>current_multi_index</code> and <code>Iteration</code> passed in from the inital external call: consecutive terms will be summed until the base case <code>Iteration == 0</code> is reached.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iteration</td><td>the nth term in the leg to sum, where n is between [0, leg_length) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the expression contained within this contraction expression </td></tr>
    <tr><td class="paramname">current_multi_index</td><td>the multi-index of the uncontracted tensor component to retrieve as part of this leg's summation </td></tr>
    <tr><td class="paramname">next_leg_starting_multi_index</td><td>in the final iteration, the multi-index to update to be the next leg's starting multi-index </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the result of summing up the terms in the given leg </p>

</div>
</div>
<a id="ae702153e6acdf215a6c63d2fa089c75a" name="ae702153e6acdf215a6c63d2fa089c75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae702153e6acdf215a6c63d2fa089c75a">&#9670;&nbsp;</a></span>compute_contraction_primary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<div class="memtemplate">
template&lt;size_t Iteration&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static decltype(auto) <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::compute_contraction_primary </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtenex_1_1TensorContract.html#ac287f5ce6e976e52c6e9b54b1815ae0b">type</a> &amp;&#160;</td>
          <td class="paramname"><em>result_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#afe0e19a8be1a98e2c629e77c491a0802">num_uncontracted_tensor_indices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>current_multi_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the value of a component in the resultant contracted tensor. </p>
<h3>Details</h3>
<p >First see <code>compute_contraction</code> for details on basic functionality.</p>
<p >This function differs from <code>compute_contraction</code> in that it takes into account whether we have already computed part of the result component at a lower subtree. In recursively computing this contraction, the current result component will be substituted in for the most recent (highest) subtree below it that has already been evaluated.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iteration</td><td>the nth term to sum, where n is between [0, num_terms_summed) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the expression contained within this contraction expression </td></tr>
    <tr><td class="paramname">result_component</td><td>the LHS tensor component to evaluate </td></tr>
    <tr><td class="paramname">current_multi_index</td><td>the multi-index of the uncontracted tensor component to retrieve </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the value of a component of the resulant contracted tensor </p>

</div>
</div>
<a id="abcfca0b93ea1cf89b9dd104714337916" name="abcfca0b93ea1cf89b9dd104714337916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcfca0b93ea1cf89b9dd104714337916">&#9670;&nbsp;</a></span>evaluate_primary_contraction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::evaluate_primary_contraction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtenex_1_1TensorContract.html#ac287f5ce6e976e52c6e9b54b1815ae0b">type</a> &amp;&#160;</td>
          <td class="paramname"><em>result_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#a299115d18ecdc589107bbdeb975b0094">num_tensor_indices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>contracted_multi_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#afe0e19a8be1a98e2c629e77c491a0802">num_uncontracted_tensor_indices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lowest_multi_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Successively evaluate the LHS Tensor's result component at each leg of summations within the contraction expression. </p>
<h3>Details</h3>
<p >This function takes into account whether we have already computed part of the result component at a lower subtree. In recursively computing this contraction, the current result component will be substituted in for the most recent (highest) subtree below it that has already been evaluated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result_component</td><td>the LHS tensor component to evaluate </td></tr>
    <tr><td class="paramname">contracted_multi_index</td><td>the multi-index of the component of the contracted result tensor to evaluate </td></tr>
    <tr><td class="paramname">lowest_multi_index</td><td>the lowest multi-index between the components being summed in the contraction (see <code>get_lowest_multi_index_to_sum</code>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fe14efcececb354346da54593d4e4fd" name="a2fe14efcececb354346da54593d4e4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe14efcececb354346da54593d4e4fd">&#9670;&nbsp;</a></span>evaluate_primary_subtree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<div class="memtemplate">
template&lt;typename ResultType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::evaluate_primary_subtree </td>
          <td>(</td>
          <td class="paramtype">ResultType &amp;&#160;</td>
          <td class="paramname"><em>result_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#a299115d18ecdc589107bbdeb975b0094">num_tensor_indices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>contracted_multi_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Successively evaluate the LHS Tensor's result component at each leg in this expression's subtree. </p>
<h3>Details</h3>
<p >This function takes into account whether we have already computed part of the result component at a lower subtree. In recursively computing this contraction, the current result component will be substituted in for the most recent (highest) subtree below it that has already been evaluated.</p>
<p >If this contraction expression is the beginning of a leg, <code>evaluate_primary_contraction</code> is called to evaluate each individual leg of summations within the contraction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result_component</td><td>the LHS tensor component to evaluate </td></tr>
    <tr><td class="paramname">contracted_multi_index</td><td>the multi-index of the component of the contracted result tensor to evaluate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aafc90cf79e41bec9e1e45268f5ca5408" name="aafc90cf79e41bec9e1e45268f5ca5408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc90cf79e41bec9e1e45268f5ca5408">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#a299115d18ecdc589107bbdeb975b0094">num_tensor_indices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>contracted_multi_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of the component of the resultant contracted tensor at a given multi-index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contracted_multi_index</td><td>the multi-index of the resultant contracted tensor component to retrieve </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the value of the component at <code>contracted_multi_index</code> in the resultant contracted tensor </p>

</div>
</div>
<a id="a60f97bc70614459da6a2cc6501cfaa01" name="a60f97bc70614459da6a2cc6501cfaa01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f97bc70614459da6a2cc6501cfaa01">&#9670;&nbsp;</a></span>get_highest_multi_index_to_sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#afe0e19a8be1a98e2c629e77c491a0802">num_uncontracted_tensor_indices</a> &gt; <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::get_highest_multi_index_to_sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#a299115d18ecdc589107bbdeb975b0094">num_tensor_indices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>contracted_multi_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the highest multi-index between the components being summed in the contraction. </p>
<h3>Details</h3>
<p >Example: We have expression <code>R(ti::A, ti::b, ti::a)</code> to represent the contraction \(L_b = R^{a}{}_{ba}\). If the <code>contracted_multi_index</code> is <code>{1}</code>, which represents \(L_1 = R^{a}{}_{1a}\), and the dimension of \(a\) is 3, then we will need to sum the following terms: \(R^{0}{}_{10}\), \(R^{1}{}_{11}\), and \(R^{2}{}_{12}\). Between the terms being summed, the multi-index whose values are the largest is \(R^{2}{}_{12}\), so this function would return <code>{2, 1, 2}</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contracted_multi_index</td><td>the multi-index of a component of the contracted expression </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the highest multi-index between the components being summed in the contraction </p>

</div>
</div>
<a id="a678cb923cf6b5ed240a6b36382da2a64" name="a678cb923cf6b5ed240a6b36382da2a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678cb923cf6b5ed240a6b36382da2a64">&#9670;&nbsp;</a></span>get_lowest_multi_index_to_sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#afe0e19a8be1a98e2c629e77c491a0802">num_uncontracted_tensor_indices</a> &gt; <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::get_lowest_multi_index_to_sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#a299115d18ecdc589107bbdeb975b0094">num_tensor_indices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>contracted_multi_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the lowest multi-index between the components being summed in the contraction. </p>
<h3>Details</h3>
<p >Example: We have expression <code>R(ti::A, ti::b, ti::a)</code> to represent the contraction \(L_b = R^{a}{}_{ba}\). If the <code>contracted_multi_index</code> is <code>{1}</code>, which represents \(L_1 = R^{a}{}_{1a}\), and the dimension of \(a\) is 3, then we will need to sum the following terms: \(R^{0}{}_{10}\), \(R^{1}{}_{11}\), and \(R^{2}{}_{12}\). Between the terms being summed, the multi-index whose values are the smallest is \(R^{0}{}_{10}\), so this function would return <code>{0, 1, 0}</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contracted_multi_index</td><td>the multi-index of a component of the contracted expression </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the lowest multi-index between the components being summed in the contraction </p>

</div>
</div>
<a id="a2197ff6df3cf7b23bc41c2d44b2e29ed" name="a2197ff6df3cf7b23bc41c2d44b2e29ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2197ff6df3cf7b23bc41c2d44b2e29ed">&#9670;&nbsp;</a></span>get_next_highest_multi_index_to_sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#afe0e19a8be1a98e2c629e77c491a0802">num_uncontracted_tensor_indices</a> &gt; <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::get_next_highest_multi_index_to_sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#afe0e19a8be1a98e2c629e77c491a0802">num_uncontracted_tensor_indices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>uncontracted_multi_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the multi-index of one term being summed in the contraction, return the next highest multi-index of a component being summed. </p>
<h3>Details</h3>
<p >What is meant by "next highest" is implementation defined, but generally means, of the components being summed, return the multi-index that results from lowering one of the contracted index pairs' values by one.</p>
<p >Example: We have expression <code>R(ti::A, ti::b, ti::a)</code> to represent the contraction \(L_b = R^{a}{}_{ba}\). If we are evaluating \(L_1 = R^{a}{}_{1a}\) and the dimension of \(a\) is 3, then we will need to sum the following terms: \(R^{0}{}_{10}\), \(R^{1}{}_{11}\), and \(R^{2}{}_{12}\). If <code>uncontracted_multi_index</code> is <code>{1, 1, 1}</code>, then the "next highest" multi-index is the result of lowering the values of the \(a\) indices by</p><ol type="1">
<li>The component with that resulting multi-index is \(R^{0}{}_{10}\), so this function would return <code>{0, 1, 0}</code>.</li>
</ol>
<p >Note: this function should perform the inverse functionality of <code>get_next_highest_multi_index_to_sum</code>. If the implementation of this function or the other changes what is meant by "next highest" or "next
lowest," the other function should be updated in accordance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uncontracted_multi_index</td><td>the multi-index of one of the components of the uncontracted operand expression to sum </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the next highest multi-index between the components being summed in the contraction </p>

</div>
</div>
<a id="a3de8e91823579b9646ea7f24616eef20" name="a3de8e91823579b9646ea7f24616eef20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de8e91823579b9646ea7f24616eef20">&#9670;&nbsp;</a></span>get_next_lowest_multi_index_to_sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#afe0e19a8be1a98e2c629e77c491a0802">num_uncontracted_tensor_indices</a> &gt; <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::get_next_lowest_multi_index_to_sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#afe0e19a8be1a98e2c629e77c491a0802">num_uncontracted_tensor_indices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>uncontracted_multi_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the multi-index of one term being summed in the contraction, return the next lowest multi-index of a component being summed. </p>
<h3>Details</h3>
<p >What is meant by "next lowest" is implementation defined, but generally means, of the components being summed, return the multi-index that results from raising one of the contracted index pairs' values by one.</p>
<p >Example: We have expression <code>R(ti::A, ti::b, ti::a)</code> to represent the contraction \(L_b = R^{a}{}_{ba}\). If we are evaluating \(L_1 = R^{a}{}_{1a}\) and the dimension of \(a\) is 3, then we will need to sum the following terms: \(R^{0}{}_{10}\), \(R^{1}{}_{11}\), and \(R^{2}{}_{12}\). If <code>uncontracted_multi_index</code> is <code>{1, 1, 1}</code>, then the "next lowest" multi-index is the result of raising the values of the \(a\) indices by</p><ol type="1">
<li>The component with that resulting multi-index is \(R^{2}{}_{12}\), so this function would return <code>{2, 1, 2}</code>.</li>
</ol>
<p >Note: this function should perform the inverse functionality of <code>get_next_lowest_multi_index_to_sum</code>. If the implementation of this function or the other changes what is meant by "next highest" or "next
lowest," the other function should be updated in accordance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uncontracted_multi_index</td><td>the multi-index of one of the components of the uncontracted operand expression to sum </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the next lowest multi-index between the components being summed in the contraction </p>

</div>
</div>
<a id="a40ea0072fd3ccdc59d26012559c37a7a" name="a40ea0072fd3ccdc59d26012559c37a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ea0072fd3ccdc59d26012559c37a7a">&#9670;&nbsp;</a></span>get_primary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<div class="memtemplate">
template&lt;typename ResultType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::get_primary </td>
          <td>(</td>
          <td class="paramtype">const ResultType &amp;&#160;</td>
          <td class="paramname"><em>result_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1TensorContract.html#a299115d18ecdc589107bbdeb975b0094">num_tensor_indices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>contracted_multi_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of the component of the resultant contracted tensor at a given multi-index. </p>
<h3>Details</h3>
<p >This function differs from <code>get</code> in that it takes into account whether we have already computed part of the result component at a lower subtree. In recursively computing this contraction, the current result component will be substituted in for the most recent (highest) subtree below it that has already been evaluated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result_component</td><td>the LHS tensor component to evaluate </td></tr>
    <tr><td class="paramname">contracted_multi_index</td><td>the multi-index of the resultant contracted tensor component to retrieve </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the value of the component at <code>contracted_multi_index</code> in the resultant contracted tensor </p>

</div>
</div>
<a id="ae836df8365793a2bba993919ed58e58a" name="ae836df8365793a2bba993919ed58e58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae836df8365793a2bba993919ed58e58a">&#9670;&nbsp;</a></span>get_rhs_tensor_component_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::get_rhs_tensor_component_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of a component from a <code>Tensor</code> in this expression's subtree of the RHS <code>TensorExpression</code> </p>
<p ><em>Returns:</em> the size of a component from a <code>Tensor</code> in this expression's subtree of the RHS <code>TensorExpression</code> </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a1a9b1b8096d7e917345dacc43706ee15" name="a1a9b1b8096d7e917345dacc43706ee15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a9b1b8096d7e917345dacc43706ee15">&#9670;&nbsp;</a></span>contracted_index_first_values</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt;size_t, size_t&gt;, <a class="el" href="structtenex_1_1TensorContract.html#a996a6c997204ab446e1135b9d4977a09">num_contracted_index_pairs</a>&gt; <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::contracted_index_first_values</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">          contracted_type::contracted_index_first_values</div>
</div><!-- fragment -->
<p>First concrete values of contracted indices to sum. This is to handle cases when we have generic spatial <code><a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a></code>s used for spacetime indices, as the first concrete index value to contract will be 1 (first spatial index) instead of 0 (the time index). Contracted index pairs will have different "starting" concrete indices when one index in the pair is a spatial spacetime index and the other is not. </p>

</div>
</div>
<a id="a8968e4870f4bd94bb7db361a1c02ef2b" name="a8968e4870f4bd94bb7db361a1c02ef2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8968e4870f4bd94bb7db361a1c02ef2b">&#9670;&nbsp;</a></span>contracted_index_pair_positions</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt;size_t, size_t&gt;, <a class="el" href="structtenex_1_1TensorContract.html#a996a6c997204ab446e1135b9d4977a09">num_contracted_index_pairs</a>&gt; <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::contracted_index_pair_positions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">          contracted_type::index_transformation_and_contracted_pair_positions</div>
<div class="line">              .second</div>
</div><!-- fragment -->
<p>Positions of the index pairs in the operand uncontracted tensor that we wish to contract. </p>

</div>
</div>
<a id="ac2a3a1256579136d50ff92849b430062" name="ac2a3a1256579136d50ff92849b430062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a3a1256579136d50ff92849b430062">&#9670;&nbsp;</a></span>height_relative_to_closest_tensor_leaf_in_subtree</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::height_relative_to_closest_tensor_leaf_in_subtree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      T::height_relative_to_closest_tensor_leaf_in_subtree !=</div>
<div class="line">              <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits/max.html">std::numeric_limits&lt;size_t&gt;::max</a>()</div>
<div class="line">          ? T::height_relative_to_closest_tensor_leaf_in_subtree + 1</div>
<div class="line">          : T::height_relative_to_closest_tensor_leaf_in_subtree</div>
<div class="ttc" id="amax_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/types/numeric_limits/max.html">std::numeric_limits::max</a></div><div class="ttdeci">T max(T... args)</div></div>
</div><!-- fragment -->
<p>The height of this expression's node in the expression tree relative to the closest <code><a class="el" href="structtenex_1_1TensorAsExpression.html" title="Defines an expression representing a Tensor.">TensorAsExpression</a></code> leaf in its subtree. </p>

</div>
</div>
<a id="ac946a1bf8541c32197dbc23b907ebab9" name="ac946a1bf8541c32197dbc23b907ebab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac946a1bf8541c32197dbc23b907ebab9">&#9670;&nbsp;</a></span>index_transformation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;size_t, NumContractedIndices&gt; <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::index_transformation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">          contracted_type::index_transformation_and_contracted_pair_positions</div>
<div class="line">              .first</div>
</div><!-- fragment -->
<p>Mapping from the positions of indices in the resultant contracted tensor to their positions in the operand uncontracted tensor. </p>

</div>
</div>
<a id="aabd8a9b2e8b1244fb5b49ac1d5e67821" name="aabd8a9b2e8b1244fb5b49ac1d5e67821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd8a9b2e8b1244fb5b49ac1d5e67821">&#9670;&nbsp;</a></span>is_primary_start</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::is_primary_start</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      <a class="code hl_variable" href="structtenex_1_1TensorContract.html#a1f2ef74a937690548f061089176815d6">num_ops_to_evaluate_primary_subtree</a> &gt;</div>
<div class="line">      </div>
<div class="line">      </div>
<div class="line">      2 * detail::max_num_ops_in_sub_expression&lt;type&gt;</div>
<div class="ttc" id="astructtenex_1_1TensorContract_html_a1f2ef74a937690548f061089176815d6"><div class="ttname"><a href="structtenex_1_1TensorContract.html#a1f2ef74a937690548f061089176815d6">tenex::TensorContract::num_ops_to_evaluate_primary_subtree</a></div><div class="ttdeci">static constexpr size_t num_ops_to_evaluate_primary_subtree</div><div class="ttdoc">If on the primary path, this is the remaining number of arithmetic tensor operations that need to be ...</div><div class="ttdef"><b>Definition:</b> Contract.hpp:500</div></div>
</div><!-- fragment -->
<p>If on the primary path, whether or not the expression is a starting point of a leg. </p>

</div>
</div>
<a id="a6a7b25f3f47a4c007d2bab59c1604b64" name="a6a7b25f3f47a4c007d2bab59c1604b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7b25f3f47a4c007d2bab59c1604b64">&#9670;&nbsp;</a></span>last_leg_length</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::last_leg_length</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      <a class="code hl_variable" href="structtenex_1_1TensorContract.html#abf4acd5225b70ae909891cae7da4819c">leg_length</a> == 0 ? 0 : <a class="code hl_variable" href="structtenex_1_1TensorContract.html#add6f95bd240ee1bbc862e561aa6f95f7">num_terms_summed</a> % <a class="code hl_variable" href="structtenex_1_1TensorContract.html#abf4acd5225b70ae909891cae7da4819c">leg_length</a></div>
<div class="ttc" id="astructtenex_1_1TensorContract_html_abf4acd5225b70ae909891cae7da4819c"><div class="ttname"><a href="structtenex_1_1TensorContract.html#abf4acd5225b70ae909891cae7da4819c">tenex::TensorContract::leg_length</a></div><div class="ttdeci">static constexpr size_t leg_length</div><div class="ttdoc">In the subtree for this contraction, how many terms we sum together for each leg of the contraction.</div><div class="ttdef"><b>Definition:</b> Contract.hpp:524</div></div>
<div class="ttc" id="astructtenex_1_1TensorContract_html_add6f95bd240ee1bbc862e561aa6f95f7"><div class="ttname"><a href="structtenex_1_1TensorContract.html#add6f95bd240ee1bbc862e561aa6f95f7">tenex::TensorContract::num_terms_summed</a></div><div class="ttdeci">static constexpr size_t num_terms_summed</div><div class="ttdoc">The number of terms to sum for this expression's contraction.</div><div class="ttdef"><b>Definition:</b> Contract.hpp:453</div></div>
</div><!-- fragment -->
<p>After dividing up the contraction subtree into legs of even length, the number of terms we still have left to sum. </p>

</div>
</div>
<a id="abf4acd5225b70ae909891cae7da4819c" name="abf4acd5225b70ae909891cae7da4819c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4acd5225b70ae909891cae7da4819c">&#9670;&nbsp;</a></span>leg_length</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::leg_length</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= []() {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (not <a class="code hl_variable" href="structtenex_1_1TensorContract.html#aabd8a9b2e8b1244fb5b49ac1d5e67821">is_primary_start</a>) {</div>
<div class="line">      </div>
<div class="line">      </div>
<div class="line">      </div>
<div class="line">      <span class="keywordflow">return</span> <a class="code hl_variable" href="structtenex_1_1TensorContract.html#add6f95bd240ee1bbc862e561aa6f95f7">num_terms_summed</a>;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (<a class="code hl_variable" href="structtenex_1_1TensorContract.html#a27a5c1a599590a45c620d70e846f3f10">num_ops_subexpression</a> &gt;=</div>
<div class="line">                         detail::max_num_ops_in_sub_expression&lt;type&gt;) {</div>
<div class="line">      </div>
<div class="line">      <span class="keywordflow">return</span> 0;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      </div>
<div class="line">      <span class="keywordtype">size_t</span> length = 1;</div>
<div class="line">      <span class="keywordflow">while</span> (2 * (length * (<a class="code hl_variable" href="structtenex_1_1TensorContract.html#a27a5c1a599590a45c620d70e846f3f10">num_ops_subexpression</a> + 1) - 1) &lt;=</div>
<div class="line">             detail::max_num_ops_in_sub_expression&lt;type&gt;) {</div>
<div class="line">        length *= 2;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> length;</div>
<div class="line">    }</div>
<div class="line">  }()</div>
<div class="ttc" id="astructtenex_1_1TensorContract_html_a27a5c1a599590a45c620d70e846f3f10"><div class="ttname"><a href="structtenex_1_1TensorContract.html#a27a5c1a599590a45c620d70e846f3f10">tenex::TensorContract::num_ops_subexpression</a></div><div class="ttdeci">static constexpr size_t num_ops_subexpression</div><div class="ttdoc">Number of arithmetic tensor operations done in the subtree of the operand expression being contracted...</div><div class="ttdef"><b>Definition:</b> Contract.hpp:521</div></div>
<div class="ttc" id="astructtenex_1_1TensorContract_html_aabd8a9b2e8b1244fb5b49ac1d5e67821"><div class="ttname"><a href="structtenex_1_1TensorContract.html#aabd8a9b2e8b1244fb5b49ac1d5e67821">tenex::TensorContract::is_primary_start</a></div><div class="ttdeci">static constexpr bool is_primary_start</div><div class="ttdoc">If on the primary path, whether or not the expression is a starting point of a leg.</div><div class="ttdef"><b>Definition:</b> Contract.hpp:505</div></div>
</div><!-- fragment -->
<p>In the subtree for this contraction, how many terms we sum together for each leg of the contraction. </p>

</div>
</div>
<a id="a996a6c997204ab446e1135b9d4977a09" name="a996a6c997204ab446e1135b9d4977a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996a6c997204ab446e1135b9d4977a09">&#9670;&nbsp;</a></span>num_contracted_index_pairs</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::num_contracted_index_pairs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      contracted_type::num_contracted_index_pairs</div>
</div><!-- fragment -->
<p>The number of tensor index pairs in the operand expression that will be contracted. </p>

</div>
</div>
<a id="ae34feacff1ecf39075edb8a62012aebc" name="ae34feacff1ecf39075edb8a62012aebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34feacff1ecf39075edb8a62012aebc">&#9670;&nbsp;</a></span>num_full_legs</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::num_full_legs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      <a class="code hl_variable" href="structtenex_1_1TensorContract.html#abf4acd5225b70ae909891cae7da4819c">leg_length</a> == 0 ? <a class="code hl_variable" href="structtenex_1_1TensorContract.html#add6f95bd240ee1bbc862e561aa6f95f7">num_terms_summed</a> : <a class="code hl_variable" href="structtenex_1_1TensorContract.html#add6f95bd240ee1bbc862e561aa6f95f7">num_terms_summed</a> / <a class="code hl_variable" href="structtenex_1_1TensorContract.html#abf4acd5225b70ae909891cae7da4819c">leg_length</a></div>
</div><!-- fragment -->
<p>After dividing up the contraction subtree into legs, the number of legs whose length is equal to <code>leg_length</code> </p>

</div>
</div>
<a id="a65af8321f8051a4bcc12727fb44470bd" name="a65af8321f8051a4bcc12727fb44470bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65af8321f8051a4bcc12727fb44470bd">&#9670;&nbsp;</a></span>num_indices_to_contract</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::num_indices_to_contract</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      contracted_type::num_indices_to_contract</div>
</div><!-- fragment -->
<p>The number of tensor indices in the operand expression that will be contracted. </p>

</div>
</div>
<a id="a9c5f59c27080e6914d32034c3823c0a1" name="a9c5f59c27080e6914d32034c3823c0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5f59c27080e6914d32034c3823c0a1">&#9670;&nbsp;</a></span>num_ops_left_child</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::num_ops_left_child</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      T::num_ops_subtree * <a class="code hl_variable" href="structtenex_1_1TensorContract.html#add6f95bd240ee1bbc862e561aa6f95f7">num_terms_summed</a> + <a class="code hl_variable" href="structtenex_1_1TensorContract.html#add6f95bd240ee1bbc862e561aa6f95f7">num_terms_summed</a> - 1</div>
</div><!-- fragment -->
<p>The number of arithmetic tensor operations done in the subtree for the left operand. </p>

</div>
</div>
<a id="ac46ab8c2ed4dd3cad2a1f48b44d96347" name="ac46ab8c2ed4dd3cad2a1f48b44d96347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac46ab8c2ed4dd3cad2a1f48b44d96347">&#9670;&nbsp;</a></span>num_ops_to_evaluate_primary_left_child</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::num_ops_to_evaluate_primary_left_child</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      <a class="code hl_variable" href="structtenex_1_1TensorContract.html#a1279515329d570be0940ac15e5535149">is_primary_end</a></div>
<div class="line">          ? <a class="code hl_variable" href="structtenex_1_1TensorContract.html#acc1015d0a46c130bb2fd6816c80af0ca">num_ops_subtree</a> - T::num_ops_subtree</div>
<div class="line">          : T::num_ops_subtree * (<a class="code hl_variable" href="structtenex_1_1TensorContract.html#add6f95bd240ee1bbc862e561aa6f95f7">num_terms_summed</a> - 1) +</div>
<div class="line">                T::num_ops_to_evaluate_primary_subtree + <a class="code hl_variable" href="structtenex_1_1TensorContract.html#add6f95bd240ee1bbc862e561aa6f95f7">num_terms_summed</a> - 1</div>
<div class="ttc" id="astructtenex_1_1TensorContract_html_a1279515329d570be0940ac15e5535149"><div class="ttname"><a href="structtenex_1_1TensorContract.html#a1279515329d570be0940ac15e5535149">tenex::TensorContract::is_primary_end</a></div><div class="ttdeci">static constexpr bool is_primary_end</div><div class="ttdoc">If on the primary path, whether or not the expression is an ending point of a leg.</div><div class="ttdef"><b>Definition:</b> Contract.hpp:481</div></div>
<div class="ttc" id="astructtenex_1_1TensorContract_html_acc1015d0a46c130bb2fd6816c80af0ca"><div class="ttname"><a href="structtenex_1_1TensorContract.html#acc1015d0a46c130bb2fd6816c80af0ca">tenex::TensorContract::num_ops_subtree</a></div><div class="ttdeci">static constexpr size_t num_ops_subtree</div><div class="ttdoc">The total number of arithmetic tensor operations done in this expression's whole subtree.</div><div class="ttdef"><b>Definition:</b> Contract.hpp:466</div></div>
</div><!-- fragment -->
<p>If on the primary path, this is the remaining number of arithmetic tensor operations that need to be done in the subtree of the child along the primary path, given that we will have already computed the whole subtree at the next lowest leg's starting point. </p>

</div>
</div>
<a id="a666d832ac274fdf924964ff222bb0299" name="a666d832ac274fdf924964ff222bb0299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666d832ac274fdf924964ff222bb0299">&#9670;&nbsp;</a></span>num_ops_to_evaluate_primary_right_child</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::num_ops_to_evaluate_primary_right_child</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      <a class="code hl_variable" href="structtenex_1_1TensorContract.html#a14adaff56facee149ef7d191eac5a147">num_ops_right_child</a></div>
<div class="ttc" id="astructtenex_1_1TensorContract_html_a14adaff56facee149ef7d191eac5a147"><div class="ttname"><a href="structtenex_1_1TensorContract.html#a14adaff56facee149ef7d191eac5a147">tenex::TensorContract::num_ops_right_child</a></div><div class="ttdeci">static constexpr size_t num_ops_right_child</div><div class="ttdoc">The number of arithmetic tensor operations done in the subtree for the right operand....</div><div class="ttdef"><b>Definition:</b> Contract.hpp:463</div></div>
</div><!-- fragment -->
<p>If on the primary path, this is the remaining number of arithmetic tensor operations that need to be done in the right operand's subtree. No splitting is currently done, so this is just <code>num_ops_right_child</code>. </p>

</div>
</div>
<a id="a1f2ef74a937690548f061089176815d6" name="a1f2ef74a937690548f061089176815d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2ef74a937690548f061089176815d6">&#9670;&nbsp;</a></span>num_ops_to_evaluate_primary_subtree</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::num_ops_to_evaluate_primary_subtree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      <a class="code hl_variable" href="structtenex_1_1TensorContract.html#ac46ab8c2ed4dd3cad2a1f48b44d96347">num_ops_to_evaluate_primary_left_child</a> +</div>
<div class="line">      <a class="code hl_variable" href="structtenex_1_1TensorContract.html#a666d832ac274fdf924964ff222bb0299">num_ops_to_evaluate_primary_right_child</a></div>
<div class="ttc" id="astructtenex_1_1TensorContract_html_a666d832ac274fdf924964ff222bb0299"><div class="ttname"><a href="structtenex_1_1TensorContract.html#a666d832ac274fdf924964ff222bb0299">tenex::TensorContract::num_ops_to_evaluate_primary_right_child</a></div><div class="ttdeci">static constexpr size_t num_ops_to_evaluate_primary_right_child</div><div class="ttdoc">If on the primary path, this is the remaining number of arithmetic tensor operations that need to be ...</div><div class="ttdef"><b>Definition:</b> Contract.hpp:494</div></div>
<div class="ttc" id="astructtenex_1_1TensorContract_html_ac46ab8c2ed4dd3cad2a1f48b44d96347"><div class="ttname"><a href="structtenex_1_1TensorContract.html#ac46ab8c2ed4dd3cad2a1f48b44d96347">tenex::TensorContract::num_ops_to_evaluate_primary_left_child</a></div><div class="ttdeci">static constexpr size_t num_ops_to_evaluate_primary_left_child</div><div class="ttdoc">If on the primary path, this is the remaining number of arithmetic tensor operations that need to be ...</div><div class="ttdef"><b>Definition:</b> Contract.hpp:486</div></div>
</div><!-- fragment -->
<p>If on the primary path, this is the remaining number of arithmetic tensor operations that need to be done for this expression's subtree, given that we will have already computed the subtree at the next lowest leg's starting point. </p>

</div>
</div>
<a id="afe0e19a8be1a98e2c629e77c491a0802" name="afe0e19a8be1a98e2c629e77c491a0802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe0e19a8be1a98e2c629e77c491a0802">&#9670;&nbsp;</a></span>num_uncontracted_tensor_indices</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::num_uncontracted_tensor_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      <a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">tmpl::size&lt;Symm&gt;::value</a></div>
<div class="ttc" id="agroup__UtilitiesGroup_html_ga4316f2ea7fb92cf4a3c5cf53bf36fb82"><div class="ttname"><a href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">value</a></div><div class="ttdeci">constexpr T &amp; value(T &amp;t)</div><div class="ttdoc">Returns t.value() if t is a std::optional otherwise returns t.</div><div class="ttdef"><b>Definition:</b> OptionalHelpers.hpp:32</div></div>
</div><!-- fragment -->
<p>The number of tensor indices in the operand expression being contracted. </p>

</div>
</div>
<a id="a21f31b481d0a87a693867af80de9f1d1" name="a21f31b481d0a87a693867af80de9f1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f31b481d0a87a693867af80de9f1d1">&#9670;&nbsp;</a></span>primary_child_subtree_contains_primary_start</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::primary_child_subtree_contains_primary_start</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      T::primary_subtree_contains_primary_start</div>
</div><!-- fragment -->
<p>If on the primary path, whether or not the expression's child along the primary path is a subtree that contains a starting point of a leg along the primary path. </p>

</div>
</div>
<a id="a3b3b49477f07bae3dd5401cac7c14e85" name="a3b3b49477f07bae3dd5401cac7c14e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b3b49477f07bae3dd5401cac7c14e85">&#9670;&nbsp;</a></span>primary_subtree_contains_primary_start</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename ArgsList , size_t NumContractedIndices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract</a>&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;::primary_subtree_contains_primary_start</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      <a class="code hl_variable" href="structtenex_1_1TensorContract.html#aabd8a9b2e8b1244fb5b49ac1d5e67821">is_primary_start</a> or <a class="code hl_variable" href="structtenex_1_1TensorContract.html#a21f31b481d0a87a693867af80de9f1d1">primary_child_subtree_contains_primary_start</a></div>
<div class="ttc" id="astructtenex_1_1TensorContract_html_a21f31b481d0a87a693867af80de9f1d1"><div class="ttname"><a href="structtenex_1_1TensorContract.html#a21f31b481d0a87a693867af80de9f1d1">tenex::TensorContract::primary_child_subtree_contains_primary_start</a></div><div class="ttdeci">static constexpr bool primary_child_subtree_contains_primary_start</div><div class="ttdoc">If on the primary path, whether or not the expression's child along the primary path is a subtree tha...</div><div class="ttdef"><b>Definition:</b> Contract.hpp:513</div></div>
</div><!-- fragment -->
<p>If on the primary path, whether or not this subtree contains a starting point of a leg along the primary path. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>src/DataStructures/Tensor/Expressions/Contract.hpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetenex.html">tenex</a></li><li class="navelem"><a class="el" href="structtenex_1_1TensorContract.html">TensorContract</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
