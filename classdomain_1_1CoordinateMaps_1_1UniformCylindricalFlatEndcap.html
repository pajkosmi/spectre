<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: domain::CoordinateMaps::UniformCylindricalFlatEndcap Class Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classdomain_1_1CoordinateMaps_1_1UniformCylindricalFlatEndcap.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalFlatEndcap-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">domain::CoordinateMaps::UniformCylindricalFlatEndcap Class Reference<div class="ingroups"><a class="el" href="group__CoordinateMapsGroup.html">Coordinate Maps</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Map from 3D unit right cylinder to a 3D volume that connects a portion of a spherical surface with a disk.  
 <a href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalFlatEndcap.html#details">More...</a></p>

<p><code>#include &lt;UniformCylindricalFlatEndcap.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a21bc8633ccfb11f8bd9e85e633e55fbf"><td class="memItemLeft" align="right" valign="top"><a id="a21bc8633ccfb11f8bd9e85e633e55fbf" name="a21bc8633ccfb11f8bd9e85e633e55fbf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UniformCylindricalFlatEndcap</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 3 &gt; &amp;center_one, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 3 &gt; &amp;center_two, double radius_one, double radius_two, double z_plane_one)</td></tr>
<tr class="separator:a21bc8633ccfb11f8bd9e85e633e55fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5170dee6ef190096c52d2be724da5552"><td class="memItemLeft" align="right" valign="top"><a id="a5170dee6ef190096c52d2be724da5552" name="a5170dee6ef190096c52d2be724da5552"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UniformCylindricalFlatEndcap</b> (<a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalFlatEndcap.html">UniformCylindricalFlatEndcap</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a5170dee6ef190096c52d2be724da5552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708be1e1614541367c7df2d50a60ef4a"><td class="memItemLeft" align="right" valign="top"><a id="a708be1e1614541367c7df2d50a60ef4a" name="a708be1e1614541367c7df2d50a60ef4a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UniformCylindricalFlatEndcap</b> (const <a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalFlatEndcap.html">UniformCylindricalFlatEndcap</a> &amp;)=default</td></tr>
<tr class="separator:a708be1e1614541367c7df2d50a60ef4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf15e5e5e55786b03a0b9609096e9145"><td class="memItemLeft" align="right" valign="top"><a id="acf15e5e5e55786b03a0b9609096e9145" name="acf15e5e5e55786b03a0b9609096e9145"></a>
<a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalFlatEndcap.html">UniformCylindricalFlatEndcap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalFlatEndcap.html">UniformCylindricalFlatEndcap</a> &amp;)=default</td></tr>
<tr class="separator:acf15e5e5e55786b03a0b9609096e9145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07cb19eb0a2c07ea61f7abea9f3795a"><td class="memItemLeft" align="right" valign="top"><a id="ae07cb19eb0a2c07ea61f7abea9f3795a" name="ae07cb19eb0a2c07ea61f7abea9f3795a"></a>
<a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalFlatEndcap.html">UniformCylindricalFlatEndcap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalFlatEndcap.html">UniformCylindricalFlatEndcap</a> &amp;&amp;)=default</td></tr>
<tr class="separator:ae07cb19eb0a2c07ea61f7abea9f3795a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61bbed67bd4bafc363e7dbd58e6fc83"><td class="memTemplParams" colspan="2"><a id="ac61bbed67bd4bafc363e7dbd58e6fc83" name="ac61bbed67bd4bafc363e7dbd58e6fc83"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac61bbed67bd4bafc363e7dbd58e6fc83"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; tt::remove_cvref_wrap_t&lt; T &gt;, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator()</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 3 &gt; &amp;source_coords) const</td></tr>
<tr class="separator:ac61bbed67bd4bafc363e7dbd58e6fc83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5065ba9d04a3980be84882edae226f9f"><td class="memItemLeft" align="right" valign="top"><a id="a5065ba9d04a3980be84882edae226f9f" name="a5065ba9d04a3980be84882edae226f9f"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>inverse</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 3 &gt; &amp;target_coords) const</td></tr>
<tr class="memdesc:a5065ba9d04a3980be84882edae226f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse function is only callable with doubles because the inverse might fail if called for a point out of range, and it is unclear what should happen if the inverse were to succeed for some points in a <a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a> but fail for other points. <br /></td></tr>
<tr class="separator:a5065ba9d04a3980be84882edae226f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912cfce6e2717be4533cde89d37e66f9"><td class="memTemplParams" colspan="2"><a id="a912cfce6e2717be4533cde89d37e66f9" name="a912cfce6e2717be4533cde89d37e66f9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a912cfce6e2717be4533cde89d37e66f9"><td class="memTemplItemLeft" align="right" valign="top">tnsr::Ij&lt; tt::remove_cvref_wrap_t&lt; T &gt;, 3, <a class="el" href="structFrame_1_1NoFrame.html">Frame::NoFrame</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>jacobian</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 3 &gt; &amp;source_coords) const</td></tr>
<tr class="separator:a912cfce6e2717be4533cde89d37e66f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a59505b5fd78b6abb5503c2777468c"><td class="memTemplParams" colspan="2"><a id="a88a59505b5fd78b6abb5503c2777468c" name="a88a59505b5fd78b6abb5503c2777468c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a88a59505b5fd78b6abb5503c2777468c"><td class="memTemplItemLeft" align="right" valign="top">tnsr::Ij&lt; tt::remove_cvref_wrap_t&lt; T &gt;, 3, <a class="el" href="structFrame_1_1NoFrame.html">Frame::NoFrame</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inv_jacobian</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 3 &gt; &amp;source_coords) const</td></tr>
<tr class="separator:a88a59505b5fd78b6abb5503c2777468c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784e2ab566e7365bcfb1c49bb9900482"><td class="memItemLeft" align="right" valign="top"><a id="a784e2ab566e7365bcfb1c49bb9900482" name="a784e2ab566e7365bcfb1c49bb9900482"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pup</b> (PUP::er &amp;p)</td></tr>
<tr class="separator:a784e2ab566e7365bcfb1c49bb9900482"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a856701fe725597a2ad606c5ba03e3dc2"><td class="memItemLeft" align="right" valign="top"><a id="a856701fe725597a2ad606c5ba03e3dc2" name="a856701fe725597a2ad606c5ba03e3dc2"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_identity</b> ()</td></tr>
<tr class="separator:a856701fe725597a2ad606c5ba03e3dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a13eb9aafbc59a8cbee206ea2e5073ef9"><td class="memItemLeft" align="right" valign="top"><a id="a13eb9aafbc59a8cbee206ea2e5073ef9" name="a13eb9aafbc59a8cbee206ea2e5073ef9"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>dim</b> = 3</td></tr>
<tr class="separator:a13eb9aafbc59a8cbee206ea2e5073ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0aba42cbe864fd9483e5f9a9ad7988c7"><td class="memItemLeft" align="right" valign="top"><a id="a0aba42cbe864fd9483e5f9a9ad7988c7" name="a0aba42cbe864fd9483e5f9a9ad7988c7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalFlatEndcap.html">UniformCylindricalFlatEndcap</a> &amp;lhs, const <a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalFlatEndcap.html">UniformCylindricalFlatEndcap</a> &amp;rhs)</td></tr>
<tr class="separator:a0aba42cbe864fd9483e5f9a9ad7988c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Map from 3D unit right cylinder to a 3D volume that connects a portion of a spherical surface with a disk. </p>
<div class="image">
<object type="image/svg+xml" data="UniCylFlatEndcap.svg" style="pointer-events: none;"></object>
<div class="caption">
A cylinder maps to the shaded region.</div></div>
<h3>Details</h3>
<p >Consider a sphere with center \(C_1\) and radius \(R_1\), and a disk in the \(xy\) plane with center \(C_2\) and radius \(R_2\). Let sphere 1 be intersected by a plane normal to the \(z\) axis and located at \(z = z_{\mathrm{P}1}\),</p>
<p ><a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalFlatEndcap.html" title="Map from 3D unit right cylinder to a 3D volume that connects a portion of a spherical surface with a ...">UniformCylindricalFlatEndcap</a> maps a 3D unit right cylinder (with coordinates \((\bar{x},\bar{y},\bar{z})\) such that \(-1\leq\bar{z}\leq 1\) and \(\bar{x}^2+\bar{y}^2 \leq 1\)) to the shaded area in the figure above (with coordinates \((x,y,z)\)). The "bottom" of the cylinder \(\bar{z}=-1\) is mapped to the portion of sphere 1 that has \(z \geq z_{\mathrm{P}1}\), and on this portion of the sphere the angular coordinate \(\theta_1 = \acos((z-C_1^z)/R_1)\) is uniform in \(\bar{\rho} = \sqrt{\bar{x}^2+\bar{y}^2}\) and the angular coordinate \(\phi_1 = \atan((y-C_1^y)/(x-C_1^x))\) is the same as \(\phi = \atan(\bar{y}/\bar{x})\). The "top" of the cylinder \(\bar{z}=+1\) is mapped to the disk, and the radial polar coordinate coordinate \(\sqrt{x^2+y^2}\) on this disk is equal to \(R_2\bar\rho\) and the angular coordinate \(\phi_2 = \atan((y-C_2^y)/(x-C_2^x))\) is the same as \(\phi\).</p>
<p ><a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalFlatEndcap.html" title="Map from 3D unit right cylinder to a 3D volume that connects a portion of a spherical surface with a ...">UniformCylindricalFlatEndcap</a> is intended to be composed with <code><a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html" title="Map from a square or cube to a wedge.">Wedge</a>&lt;2&gt;</code> maps to construct a portion of a cylindrical domain for a binary system.</p>
<p ><a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalFlatEndcap.html" title="Map from 3D unit right cylinder to a 3D volume that connects a portion of a spherical surface with a ...">UniformCylindricalFlatEndcap</a> can be used to construct a domain that is similar to, but not identical to, the one described briefly in the Appendix of <a class="el" href="citelist.html#CITEREF_Buchman:2012dw">[30]</a>. <a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalFlatEndcap.html" title="Map from 3D unit right cylinder to a 3D volume that connects a portion of a spherical surface with a ...">UniformCylindricalFlatEndcap</a> is used to construct the Blocks analogous to those labeled 'MA wedge' and 'MB wedge' in Figure 20 of that paper.</p>
<p ><a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalFlatEndcap.html" title="Map from 3D unit right cylinder to a 3D volume that connects a portion of a spherical surface with a ...">UniformCylindricalFlatEndcap</a> provides the following functions:</p>
<h3><a class="anchor" id="autotoc_md304"></a>
operator()</h3>
<p ><code>operator()</code> maps \((\bar{x},\bar{y},\bar{z})\) to \((x,y,z)\) according to</p>
<p class="formulaDsp">
\begin{align} x &amp;= C_1^x+\lambda(C_2^x-C_1^x) + \cos\phi\left(R_1\sin\theta_1 + \lambda(R_2\bar\rho-R_1\sin\theta_1)\right), \label{eq:x0} \\ y &amp;= C_1^y+\lambda(C_2^y-C_1^y) + \sin\phi\left(R_1\sin\theta_1 + \lambda(R_2\bar\rho-R_1\sin\theta_1)\right), \label{eq:x1} \\ z &amp;= C_1^z+\lambda(C_2^z-C_1^z) + (1-\lambda)R_1\cos\theta_1 \label{eq:x2}. \end{align}
</p>
<p >Here </p><p class="formulaDsp">
\begin{align} \lambda &amp;= \frac{\bar{z}+1}{2},\label{eq:lambdafromzbar}\\ \theta_1 &amp;= \bar{\rho} \theta_{1 \mathrm{max}},\label{eq:deftheta1}\\ \phi &amp;= \atan(\bar{y}/\bar{x})\label{eq:defphi}, \end{align}
</p>
<p> where \(\theta_{1 \mathrm{max}}\) is defined by </p><p class="formulaDsp">
\begin{align} \cos(\theta_{1\mathrm{max}}) &amp;= (z_{\mathrm{P}1}-C_1^z)/R_1,\\ \end{align}
</p>
<p> and </p><p class="formulaDsp">
\begin{align} \bar{\rho} &amp;= \sqrt{\bar{x}^2+\bar{y}^2}/\bar{R} \label{eq:defrhobar}, \end{align}
</p>
<p> where \(\bar{R}\) is the radius of the cylinder in barred coordinates, which is always unity.</p>
<h3><a class="anchor" id="autotoc_md305"></a>
inverse</h3>
<p >Given \((x,y,z)\) we want to find \((\bar{x},\bar{y},\bar{z})\). From Eq. ( \(\ref{eq:x2}\)) we can write \(\lambda\) as a function of \(\bar\rho\):</p>
<p class="formulaDsp">
\begin{align} \lambda &amp;= \frac{z - C_1^z - R_1\cos\theta_1} {C_2^z-C_1^z - R_1\cos\theta_1} \label{eq:lambda_from_rho}. \end{align}
</p>
<p >Then by eliminating \(\phi\) from Eqs. ( \(\ref{eq:x0}\)) and ( \(\ref{eq:x1}\)) we find that \(\bar{\rho}\) is the solution of \(Q(\bar{\rho})=0\), where</p>
<p class="formulaDsp">
\begin{align} Q(\bar{\rho}) &amp;= \left(x-C_1^x-\lambda(C_2^x-C_1^x)\right)^2+ \left(y-C_1^y-\lambda(C_2^y-C_1^y)\right)^2- \left((1-\lambda)R_1\sin\theta_1 + \lambda \bar\rho R_2\right)^2.\label{eq:defQ} \end{align}
</p>
<p> Here \(\lambda\) and \(\theta_1\), are functions of \(\bar{\rho}\) through Eqs. ( \(\ref{eq:lambda_from_rho}\)) and ( \(\ref{eq:deftheta1}\)).</p>
<p >We solve \(Q(\bar{\rho})=0\) numerically; it is a one-dimensional root-finding problem.</p>
<p >Once we have determined \(\bar{\rho}\), we then obtain \(\lambda\) from Eq. ( \(\ref{eq:lambda_from_rho}\)), and we obtain \(\phi\) from</p>
<p class="formulaDsp">
\begin{align} \tan\phi &amp;= \frac{y-C_1^y-\lambda(C_2^y-C_1^y)}{x-C_1^x-\lambda(C_2^x-C_1^x)}. \end{align}
</p>
<p >Then \(\bar{z}\) is obtained from Eq. ( \(\ref{eq:lambdafromzbar}\)) and \(\bar{x}\) and \(\bar{y}\) are obtained from</p>
<p class="formulaDsp">
\begin{align} \bar{x} &amp;= \bar{\rho}\bar{R}\cos\phi,\\ \bar{y} &amp;= \bar{\rho}\bar{R}\sin\phi. \end{align}
</p>
<h4><a class="anchor" id="autotoc_md306"></a>
Considerations when root-finding.</h4>
<p >We solve \(Q(\bar{\rho})=0\) numerically for \(\bar{\rho}\), where \(Q(\bar{\rho})\) is given by Eq. ( \(\ref{eq:defQ}\)).</p>
<p ><a class="anchor" id="autotoc_md307"></a> </p><h5>min/max values of \(\bar{\rho}\):</h5>
<p >Note that the root we care about must have \(0\leq\lambda\leq 1\); therefore from Eq. ( \(\ref{eq:lambda_from_rho}\)) we have</p>
<p class="formulaDsp">
\begin{align} \bar{\rho}_{\mathrm{min}} &amp;= \left\{\begin{array}{ll} 0 &amp; \text{for } z-C_1^z \geq R_1, \\ \displaystyle \frac{1}{\theta_{1 \mathrm{max}}} \cos^{-1}\left(\frac{z-C_1^z}{R_1}\right) &amp; \text{otherwise} \end{array}\right.\label{eq:rhobarmin}\\ \bar{\rho}_{\mathrm{max}} &amp;= 1. \label{eq:rhobarmax} \end{align}
</p>
<p >so we look for a root only between \(\bar{\rho}_{\mathrm{min}}\) and \(\bar{\rho}_{\mathrm{max}}\).</p>
<p ><a class="anchor" id="autotoc_md308"></a> </p><h5>Roots within roundoff of endpoints:</h5>
<p >Sometimes a root is within roundoff of \(\bar{\rho}_{\mathrm{min}}\) This tends to happen at points on the boundary of the mapped region. In this case, the root might not be bracketed by \([\bar{\rho}_{\mathrm{min}},\bar{\rho}_{\mathrm{max}}]\) if the root is slightly outside that interval. If we find that \(Q(\bar{\rho}_{\mathrm{min}})\) is near zero but has the wrong sign, then we slightly expand the interval as follows:</p>
<p class="formulaDsp">
\begin{align} \bar{\rho}_{\mathrm{min}} \to \bar{\rho}_{\mathrm{min}} - 2 \frac{Q(\bar{\rho}_{\mathrm{min}})}{Q&#39;(\bar{\rho}_{\mathrm{min}})}, \end{align}
</p>
<p >where \(Q&#39;(\bar{\rho}_{\mathrm{min}})\) is the derivative of the function in Eq. ( \(\ref{eq:defQ}\)). Note that without the factor of 2, this is a Newton-Raphson step; the factor of 2 is there to overcompensate so that the new \(\bar{\rho}_{\mathrm{min}}\) brackets the root. Sometimes, if the derivative is large enough so that the correction above amounts to a value less than roundoff; in that case, we increase the correction to a value larger than roundoff.</p>
<p >Note that by differentiating Eqs. ( \(\ref{eq:defQ}\)) and ( \(\ref{eq:lambda_from_rho}\)), one obtains</p>
<p class="formulaDsp">
\begin{align} Q&#39;(\bar{\rho}) =&amp; -2 \frac{d\lambda}{d\bar{\rho}}\left[ \left(x-C_1^x-\lambda(C_2^x-C_1^x)\right)(C_2^x-C_1^x)+ \left(y-C_1^y-\lambda(C_2^y-C_1^y)\right)(C_2^y-C_1^y) \right]\nonumber \\ &amp; -2 \left((1-\lambda)R_1\sin\theta_1 + \lambda \bar\rho R_2\right) \left[ \frac{d\lambda}{d\bar{\rho}} (R_2\bar\rho - R_1\sin\theta_1) +(1-\lambda)R_1\theta_{1 \mathrm{max}}\cos\theta_1 +\lambda R_2 \right], \label{eq:defQderiv} \end{align}
</p>
<p >where </p><p class="formulaDsp">
\begin{align} \frac{d\lambda}{d\bar{\rho}} &amp;= \frac{(1-\lambda)R_1\theta_{1 \mathrm{max}}\sin\theta_1} {C_2^z-C_1^z -R_1\cos\theta_1} \label{eq:dlambda_drhobar}. \end{align}
</p>
<p ><a class="anchor" id="autotoc_md309"></a> </p><h5>Roots within roundoff of \(\bar{\rho}=0\) or \(\bar{\rho}=1\):</h5>
<p >For some points on the boundary of the mapped domain, the root will be within roundoff of \(\bar{\rho}=0\) or \(\bar{\rho}=1\). Here it does not always make sense to expand the range of the map if the root fails (by roundoff) to be bracketed, as is done above. Furthermore, when \(\bar{\rho}=0\) is a root it turns out that both \(Q(\bar{\rho})=0\) and \(Q&#39;(\bar{\rho})=0\) for \(\bar{\rho}=0\), so some root-finders (e.g. Newton-Raphson) have difficulty converging. Therefore the cases where the root is within roundoff of \(\bar{\rho}=0\) or \(\bar{\rho}=1\) are treated separately.</p>
<p >These cases are detected by comparing terms in the first-order power series of \(Q(\bar{\rho})=0\) when expanded about \(\bar{\rho}=0\) or \(\bar{\rho}=1\). When one of these cases is recognized, the root is returned as either \(\bar{\rho}=0\) or \(\bar{\rho}=1\).</p>
<h4><a class="anchor" id="autotoc_md310"></a>
Quick rejection of points out of range of the map.</h4>
<p >It is expected that <code><a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalFlatEndcap.html#a5065ba9d04a3980be84882edae226f9f" title="The inverse function is only callable with doubles because the inverse might fail if called for a poi...">inverse()</a></code> will often be passed points \((x,y,z)\) that are out of the range of the map; in this case <code><a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalFlatEndcap.html#a5065ba9d04a3980be84882edae226f9f" title="The inverse function is only callable with doubles because the inverse might fail if called for a poi...">inverse()</a></code> returns a <code>std::nullopt</code>. To avoid the difficulty and expense of attempting to solve \(Q(\bar{\rho})=0\) numerically for such points (and then having this solution fail), it is useful to quickly reject points \((x,y,z)\) that are outside the range of the map.</p>
<p >Any point in the range of the map must be below the disk and it must be outside or on sphere 1, so the inverse map can immediately return a <code>std::nullopt</code> for a point that does not satisfy these conditions.</p>
<p >Likewise, the inverse map can immediately reject any point with \(z &lt; z_{\mathrm{P}1}\).</p>
<p >Finally, consider the circle \(S_1\) defining the intersection of sphere 1 and the plane \(z = z_{\mathrm{P}1}\); this circle has radius \(r_1 = R_1 \sin\theta_{1\mathrm{max}}\). Now consider the cone that passes through both \(S_1\) and the circle \(S_2\) bounding the upper disk. A point in the range of the map must be inside or on this cone. The cone can be defined parametrically as</p>
<p class="formulaDsp">
\begin{align} x_c &amp;= C_1^x + \tilde{\lambda}(C_2^x-C_1^x) + \cos\varphi (r_1 + \tilde{\lambda} (R_2 -r_1)),\\ y_c &amp;= C_1^y + \tilde{\lambda}(C_2^y-C_1^y),+ \sin\varphi (r_1 + \tilde{\lambda} (R_2 -r_1)),\\ z_c &amp;= C_1^z + R_1 \cos\theta_{1\mathrm{max}} + \tilde{\lambda}(C_2^z - C_1^z - R_1 \cos\theta_{1\mathrm{max}}), \end{align}
</p>
<p >where \((x_c,y_c,z_c)\) is a point on the cone, and the two parameters defining a point on the cone are the angle \(\varphi\) around the cone and the parameter \(\tilde{\lambda}\), which is defined to be zero on \(S_1\) and unity on \(S_2\).</p>
<p >Given an arbitrary point \((x, y, z)\), we can determine whether or not that point is inside the cone as follows. First determine</p>
<p class="formulaDsp">
\begin{align} \tilde{\lambda} &amp;= \frac{z - C_1^z - R_1 \cos\theta_{1\mathrm{max}}} {C_2^z - C_1^z- R_1 \cos\theta_{1\mathrm{max}}}, \\ \tilde{x} &amp;= x - C_1^x - \tilde{\lambda} (C_2^x-C_1^x),\\ \tilde{y} &amp;= y - C_1^y - \tilde{\lambda} (C_2^y-C_1^y).\\ \end{align}
</p>
<p >Then the condition for the point to be inside or on the cone is </p><p class="formulaDsp">
\begin{align} \sqrt{\tilde{x}^2+\tilde{y}^2} \le r_1 + (R_2-r_1)\tilde{\lambda}. \end{align}
</p>
<p >The inverse map can therefore reject any points that do not satisfy this criterion.</p>
<h3><a class="anchor" id="autotoc_md311"></a>
jacobian</h3>
<p >One can rewrite Eqs.( \(\ref{eq:x0}\)) through ( \(\ref{eq:x2}\)) as</p>
<p class="formulaDsp">
\begin{align} x &amp;= \frac{1}{2}\left((1-\bar{z})C_1^x+ (1+\bar{z})C_2^x\right) + \frac{\bar{x}}{2}\left( (1-\bar{z}) R_1 S(\bar{\rho},\theta_{1 \mathrm{max}}) + (1+\bar{z}) R_2 \right), \label{eq:x0alt} \\ y &amp;= \frac{1}{2}\left((1-\bar{z})C_1^y + (1+\bar{z})C_2^y\right) + \frac{\bar{y}}{2}\left( (1-\bar{z})R_1 S(\bar{\rho},\theta_{1 \mathrm{max}}) + (1+\bar{z})R_2 \right), \label{eq:x1alt} \\ z &amp;= \frac{1}{2}\left((1-\bar{z})C_1^z + (1+\bar{z})C_2^z\right) + \frac{1}{2} (1-\bar{z})R_1 \cos\theta_1, \label{eq:x2alt} \\ \end{align}
</p>
<p >where we have used Eq. ( \(\ref{eq:lambdafromzbar}\)) to eliminate \(\lambda\) in favor of \(\bar{z}\), and where we have defined the function</p>
<p class="formulaDsp">
\begin{align} S(\bar{\rho},a) = \frac{\sin(\bar{\rho} a)}{\bar{\rho}}. \label{eq:Sdef} \end{align}
</p>
<p >Note that \(S(\bar{\rho},a)\) is finite as \(\bar{\rho}\) approaches zero, and in the code we must take care that everything remains well-behaved in that limit.</p>
<p >Then differentiating Eqs. ( \(\ref{eq:x0alt}\)) and ( \(\ref{eq:x1alt}\)) with respect to \(\bar{x}\) and \(\bar{y}\), taking into account the dependence of \(\bar{\rho}\) on \(\bar{x}\) and \(\bar{y}\) from Eq. ( \(\ref{eq:defrhobar}\)), we find:</p>
<p class="formulaDsp">
\begin{align} \frac{\partial x^0}{\partial \bar{x}} &amp;= \frac{1}{2}\left( (1-\bar{z}) R_1 S(\bar{\rho},\theta_{1 \mathrm{max}}) + (1+\bar{z}) R_2 \right) + \frac{\bar{x}^2}{2\bar{\rho}} (1-\bar{z}) R_1 S&#39;(\bar{\rho},\theta_{1 \mathrm{max}}), \\ \frac{\partial x^1}{\partial \bar{y}} &amp;= \frac{1}{2}\left( (1-\bar{z}) R_1 S(\bar{\rho},\theta_{1 \mathrm{max}}) + (1+\bar{z}) R_2 \right) + \frac{\bar{y}^2}{2\bar{\rho}} (1-\bar{z}) R_1 S&#39;(\bar{\rho},\theta_{1 \mathrm{max}}), \\ \frac{\partial x^0}{\partial \bar{y}} &amp;= \frac{\bar{x}\bar{y}}{2\bar{\rho}} (1-\bar{z}) R_1 S&#39;(\bar{\rho},\theta_{1 \mathrm{max}}), \\ \frac{\partial x^1}{\partial \bar{x}} &amp;= \frac{\partial x^0}{\partial \bar{y}}, \end{align}
</p>
<p >where \(S&#39;(\bar{\rho},a)\) means the derivative of \(S(\bar{\rho},a)\) with respect to \(\bar\rho\). Note that \(S&#39;(\bar{\rho},a)/\bar{\rho}\) approaches a constant value as \(\bar{\rho}\) approaches zero.</p>
<p >Differentiating Eq. ( \(\ref{eq:x2alt}\)) with respect to \(\bar{x}\) and \(\bar{y}\) we find</p>
<p class="formulaDsp">
\begin{align} \frac{\partial z}{\partial \bar{x}} &amp;= - \frac{\bar{x}}{2} (1-\bar{z}) R_1 \theta_{1 \mathrm{max}} S(\bar{\rho},\theta_{1 \mathrm{max}}),\\ \frac{\partial z}{\partial \bar{y}} &amp;= - \frac{\bar{y}}{2} (1-\bar{z}) R_1 \theta_{1 \mathrm{max}} S(\bar{\rho},\theta_{1 \mathrm{max}}). \end{align}
</p>
<p >Differentiating Eqs. ( \(\ref{eq:x0alt}\)) through ( \(\ref{eq:x2alt}\)) with respect to \(\bar{z}\) yields</p>
<p class="formulaDsp">
\begin{align} \frac{\partial x}{\partial \bar{z}} &amp;= \frac{1}{2}\left[ C_2^x-C_1^x + \bar{x}\left(R_2 - R_1 S(\bar{\rho},\theta_{1 \mathrm{max}})\right) \right],\\ \frac{\partial y}{\partial \bar{z}} &amp;= \frac{1}{2}\left[ C_2^y-C_1^y + \bar{y}\left(R_2 - R_1 S(\bar{\rho},\theta_{1 \mathrm{max}})\right) \right],\\ \frac{\partial z}{\partial \bar{z}} &amp;= \frac{1}{2}\left( C_2^z-C_1^z - R_1\cos\theta_1 \right). \end{align}
</p>
<h3><a class="anchor" id="autotoc_md312"></a>
inv_jacobian</h3>
<p >The inverse Jacobian is computed by numerically inverting the Jacobian.</p>
<h3><a class="anchor" id="autotoc_md313"></a>
Restrictions on map parameters</h3>
<p >We demand that \(C^2_1 + 1.05 R_1 \leq C^2_2 \leq C^2_1 + 5 R_1\). It is possible to construct a valid map without this assumption, but the assumption simplifies the code, and the expected use cases obey this restriction.</p>
<p >We also demand that the z plane in the above figure lies above the center of the sphere and is not too close to the center or edge of the sphere; specifically, we demand that</p><ul>
<li>\( 0.075\pi &lt; \theta_{1 \mathrm{max}} &lt; 0.35\pi\)</li>
</ul>
<p >Here 0.075 and 0.35 are safety factors. These restrictions are not strictly necessary but are made for simplicity and to ensure the accuracy of the inverse map (the inverse map becomes less accurate if the map parameters are extreme).</p>
<p >Consider the line segment \(L\) that connects a point on the circle \(S_1\) (the circle formed by the intersection of sphere 1 and the plane \(z=z_{\mathrm{P}1}\)) with the center of the circle \(S_1\). Consider another line segment \(L&#39;\) that connects the same point on the circle \(S_1\) with the corresponding point on the circle \(S_2\) (the circle bounding the disk with center \(C_2\) and radius \(R_2\)). Now consider the angle between \(L\) and \(L&#39;\), as measured from the interior of sphere 1, and Let \(\alpha\) be the minimum value of this angle over the circle. \(\alpha\) is shown in the figure above. If \(\alpha &lt; \theta_{1 \mathrm{max}}\), then the line segment \(L&#39;\) intersects the mapped portion of sphere 1 twice, so the map is multi-valued. Therefore we demand that the map parameters are such that</p><ul>
<li>\(\alpha &gt; 1.1 \theta_{1 \mathrm{max}}\)</li>
</ul>
<p >where 1.1 is a safety factor.</p>
<p >The condition on \(\alpha\) is guaranteed to provide an invertible map if \(C_1^x=C_2^x\) and \(C_1^y=C_2^y\). However, for \(C_1^x \neq C_2^x\) or \(C_1^y\neq C_2^y\), even if the \(\alpha\) condition is satisfied, it is possible for two lines of constant \((\bar{x},\bar{y})\) (each line has different values of \((\bar{x},\bar{y})\)) to pass through the same point \((x,y,z)\) if those lines are not coplanar. This condition is difficult to check analytically, so we check it numerically. We have found empirically that if \(Q(\bar{\rho})\) from Eq. ( \(\ref{eq:defQ}\)) has only a single root between \(\bar{\rho}_{\mathrm{min}}\) and \(\bar{\rho}_{\mathrm{max}}\) for all points \((x,y,z)\) on the surface of sphere 1 with \(z\geq z_{\mathrm{P}1}\) and with \((x-C_1^x)/(y-C_1^y) = (C_1^x-C_2^x)/(C_1^y-C_2^y)\), then the map is single-valued everywhere. We cannot numerically check every point in this one-parameter family of points, but we demand that this condition is satisfied for a reasonably large number of points (currently 1000) in this family. This check is not very expensive since it is done only once, in the constructor. </p>
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li>src/Domain/CoordinateMaps/UniformCylindricalFlatEndcap.hpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedomain.html">domain</a></li><li class="navelem"><a class="el" href="namespacedomain_1_1CoordinateMaps.html">CoordinateMaps</a></li><li class="navelem"><a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalFlatEndcap.html">UniformCylindricalFlatEndcap</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
