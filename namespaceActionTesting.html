<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: ActionTesting Namespace Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceActionTesting.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ActionTesting Namespace Reference<div class="ingroups"><a class="el" href="group__TestingFrameworkGroup.html">Testing Framework</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Structures used for mocking the parallel components framework in order to test actions.  
<a href="namespaceActionTesting.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structActionTesting_1_1GlobalCoreId.html">GlobalCoreId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a size_t representing the global core number.  <a href="structActionTesting_1_1GlobalCoreId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structActionTesting_1_1InitializeDataBox_3_01tmpl_1_1list_3_01SimpleTags_8_8_8_01_4_00_01ComputeTagsList_01_4.html">InitializeDataBox&lt; tmpl::list&lt; SimpleTags... &gt;, ComputeTagsList &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structActionTesting_1_1LocalCoreId.html">LocalCoreId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a size_t representing the local core number. This is so the user can write things like <code>emplace_array_component(<a class="el" href="structActionTesting_1_1NodeId.html" title="Wraps a size_t representing the node number. This is so the user can write things like emplace_array_...">NodeId</a>{3},<a class="el" href="structActionTesting_1_1LocalCoreId.html" title="Wraps a size_t representing the local core number. This is so the user can write things like emplace_...">LocalCoreId</a>{2},...)</code> instead of <code>emplace_array_component(3,2,...)</code>.  <a href="structActionTesting_1_1LocalCoreId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structActionTesting_1_1MockArrayChare.html">MockArrayChare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mock class for the CMake-generated <code><a class="el" href="structParallel_1_1Algorithms_1_1Array.html" title="A struct that stores the charm++ types relevant for a particular array component.">Parallel::Algorithms::Array</a></code>  <a href="structActionTesting_1_1MockArrayChare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classActionTesting_1_1MockDistributedObject.html">MockDistributedObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classActionTesting_1_1MockDistributedObject.html" title="MockDistributedObject mocks the DistributedObject class. It should not be considered as part of the u...">MockDistributedObject</a> mocks the DistributedObject class. It should not be considered as part of the user interface.  <a href="classActionTesting_1_1MockDistributedObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structActionTesting_1_1MockGroupChare.html">MockGroupChare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mock class for the CMake-generated <code><a class="el" href="structParallel_1_1Algorithms_1_1Group.html" title="A struct that stores the charm++ types relevant for a particular group component.">Parallel::Algorithms::Group</a></code>  <a href="structActionTesting_1_1MockGroupChare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structActionTesting_1_1MockNodeGroupChare.html">MockNodeGroupChare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mock class for the CMake-generated <code>Parallel::Algorithms::NodeGroup</code>  <a href="structActionTesting_1_1MockNodeGroupChare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that mocks the infrastructure needed to run actions. It simulates message passing using the inbox infrastructure and handles most of the arguments to the apply method. This mocks the Charm++ runtime system as well as the layer built on top of it as part of SpECTRE.  <a href="classActionTesting_1_1MockRuntimeSystem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structActionTesting_1_1MockSingletonChare.html">MockSingletonChare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mock class for the CMake-generated <code><a class="el" href="structParallel_1_1Algorithms_1_1Singleton.html" title="A struct that stores the charm++ types relevant for a particular singleton component.">Parallel::Algorithms::Singleton</a></code>  <a href="structActionTesting_1_1MockSingletonChare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structActionTesting_1_1NodeId.html">NodeId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a size_t representing the node number. This is so the user can write things like <code>emplace_array_component(<a class="el" href="structActionTesting_1_1NodeId.html" title="Wraps a size_t representing the node number. This is so the user can write things like emplace_array_...">NodeId</a>{3},...)</code> instead of <code>emplace_array_component(3,...)</code>.  <a href="structActionTesting_1_1NodeId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8f719b86352a80e117516c07ce188fa8"><td class="memItemLeft" align="right" valign="top"><a id="a8f719b86352a80e117516c07ce188fa8" name="a8f719b86352a80e117516c07ce188fa8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structActionTesting_1_1NodeId.html">NodeId</a> &amp;lhs, const <a class="el" href="structActionTesting_1_1NodeId.html">NodeId</a> &amp;rhs)</td></tr>
<tr class="separator:a8f719b86352a80e117516c07ce188fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291c4a218da7897b34291b4369a10fb1"><td class="memItemLeft" align="right" valign="top"><a id="a291c4a218da7897b34291b4369a10fb1" name="a291c4a218da7897b34291b4369a10fb1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structActionTesting_1_1NodeId.html">NodeId</a> &amp;lhs, const <a class="el" href="structActionTesting_1_1NodeId.html">NodeId</a> &amp;rhs)</td></tr>
<tr class="separator:a291c4a218da7897b34291b4369a10fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c48a5a22a949af925ee3fc259fb9f42"><td class="memItemLeft" align="right" valign="top"><a id="a9c48a5a22a949af925ee3fc259fb9f42" name="a9c48a5a22a949af925ee3fc259fb9f42"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structActionTesting_1_1LocalCoreId.html">LocalCoreId</a> &amp;lhs, const <a class="el" href="structActionTesting_1_1LocalCoreId.html">LocalCoreId</a> &amp;rhs)</td></tr>
<tr class="separator:a9c48a5a22a949af925ee3fc259fb9f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8afd4c724ddf7be755bd7a61dd63702"><td class="memItemLeft" align="right" valign="top"><a id="ab8afd4c724ddf7be755bd7a61dd63702" name="ab8afd4c724ddf7be755bd7a61dd63702"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structActionTesting_1_1LocalCoreId.html">LocalCoreId</a> &amp;lhs, const <a class="el" href="structActionTesting_1_1LocalCoreId.html">LocalCoreId</a> &amp;rhs)</td></tr>
<tr class="separator:ab8afd4c724ddf7be755bd7a61dd63702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c9958dd61747cd52019dc28742c904"><td class="memItemLeft" align="right" valign="top"><a id="a95c9958dd61747cd52019dc28742c904" name="a95c9958dd61747cd52019dc28742c904"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structActionTesting_1_1GlobalCoreId.html">GlobalCoreId</a> &amp;lhs, const <a class="el" href="structActionTesting_1_1GlobalCoreId.html">GlobalCoreId</a> &amp;rhs)</td></tr>
<tr class="separator:a95c9958dd61747cd52019dc28742c904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d980e9e87d83231366d9d32490a9e3"><td class="memItemLeft" align="right" valign="top"><a id="a69d980e9e87d83231366d9d32490a9e3" name="a69d980e9e87d83231366d9d32490a9e3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structActionTesting_1_1GlobalCoreId.html">GlobalCoreId</a> &amp;lhs, const <a class="el" href="structActionTesting_1_1GlobalCoreId.html">GlobalCoreId</a> &amp;rhs)</td></tr>
<tr class="separator:a69d980e9e87d83231366d9d32490a9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24048740ba4b2070073d4f68667874b"><td class="memTemplParams" colspan="2"><a id="aa24048740ba4b2070073d4f68667874b" name="aa24048740ba4b2070073d4f68667874b"></a>
template&lt;typename Metavariables &gt; </td></tr>
<tr class="memitem:aa24048740ba4b2070073d4f68667874b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>set_phase</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; Metavariables &gt; * &gt; runner, const <a class="el" href="group__ParallelGroup.html#ga027a2e60b10898507f92ba7290f0ba61">Parallel::Phase</a> &amp;phase)</td></tr>
<tr class="memdesc:aa24048740ba4b2070073d4f68667874b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the phase of all parallel components to <code>phase</code> <br /></td></tr>
<tr class="separator:aa24048740ba4b2070073d4f68667874b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6abf05893d01ccff458fe23010b3f40"><td class="memTemplParams" colspan="2"><a id="ab6abf05893d01ccff458fe23010b3f40" name="ab6abf05893d01ccff458fe23010b3f40"></a>
template&lt;typename Component , typename... Options&gt; </td></tr>
<tr class="memitem:ab6abf05893d01ccff458fe23010b3f40"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_component</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; typename Component::metavariables &gt; * &gt; runner, const typename Component::array_index &amp;array_index, Options &amp;&amp;... opts)</td></tr>
<tr class="memdesc:ab6abf05893d01ccff458fe23010b3f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplaces a distributed object with index <code>array_index</code> into the parallel component <code>Component</code>. The options <code>opts</code> are forwarded to be used in a call to <code>detail::ForwardAllOptionsToDataBox::apply</code>. <br /></td></tr>
<tr class="separator:ab6abf05893d01ccff458fe23010b3f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6aa6848d4b0f2b5be7017a714b85191"><td class="memTemplParams" colspan="2"><a id="ab6aa6848d4b0f2b5be7017a714b85191" name="ab6aa6848d4b0f2b5be7017a714b85191"></a>
template&lt;typename Component , typename... Options&gt; </td></tr>
<tr class="memitem:ab6aa6848d4b0f2b5be7017a714b85191"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_array_component</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; typename Component::metavariables &gt; * &gt; runner, const <a class="el" href="structActionTesting_1_1NodeId.html">NodeId</a> node_id, const <a class="el" href="structActionTesting_1_1LocalCoreId.html">LocalCoreId</a> local_core_id, const typename Component::array_index &amp;array_index, Options &amp;&amp;... opts)</td></tr>
<tr class="memdesc:ab6aa6848d4b0f2b5be7017a714b85191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplaces a distributed array object with index <code>array_index</code> into the parallel component <code>Component</code>. The options <code>opts</code> are forwarded to be used in a call to <code>detail::ForwardAllOptionsToDataBox::apply</code>. <br /></td></tr>
<tr class="separator:ab6aa6848d4b0f2b5be7017a714b85191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4935a00768ec34601277de7e83f70665"><td class="memTemplParams" colspan="2"><a id="a4935a00768ec34601277de7e83f70665" name="a4935a00768ec34601277de7e83f70665"></a>
template&lt;typename Component , typename... Options&gt; </td></tr>
<tr class="memitem:a4935a00768ec34601277de7e83f70665"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_singleton_component</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; typename Component::metavariables &gt; * &gt; runner, const <a class="el" href="structActionTesting_1_1NodeId.html">NodeId</a> node_id, const <a class="el" href="structActionTesting_1_1LocalCoreId.html">LocalCoreId</a> local_core_id, Options &amp;&amp;... opts)</td></tr>
<tr class="memdesc:a4935a00768ec34601277de7e83f70665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplaces a distributed singleton object into the parallel component <code>Component</code>. The options <code>opts</code> are forwarded to be used in a call to <code>detail::ForwardAllOptionsToDataBox::apply</code>. <br /></td></tr>
<tr class="separator:a4935a00768ec34601277de7e83f70665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed38bffbd36476c3ae9486d5823a2e6f"><td class="memTemplParams" colspan="2"><a id="aed38bffbd36476c3ae9486d5823a2e6f" name="aed38bffbd36476c3ae9486d5823a2e6f"></a>
template&lt;typename Component , typename... Options&gt; </td></tr>
<tr class="memitem:aed38bffbd36476c3ae9486d5823a2e6f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_group_component</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; typename Component::metavariables &gt; * &gt; runner, Options &amp;&amp;... opts)</td></tr>
<tr class="memdesc:aed38bffbd36476c3ae9486d5823a2e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplaces a distributed group object into the parallel component <code>Component</code>. The options <code>opts</code> are forwarded to be used in a call to <code>detail::ForwardAllOptionsToDataBox::apply</code>. <br /></td></tr>
<tr class="separator:aed38bffbd36476c3ae9486d5823a2e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d50f691f4fbcda7f56d7aadee77903"><td class="memTemplParams" colspan="2"><a id="a14d50f691f4fbcda7f56d7aadee77903" name="a14d50f691f4fbcda7f56d7aadee77903"></a>
template&lt;typename Component , typename... Options&gt; </td></tr>
<tr class="memitem:a14d50f691f4fbcda7f56d7aadee77903"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_nodegroup_component</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; typename Component::metavariables &gt; * &gt; runner, Options &amp;&amp;... opts)</td></tr>
<tr class="memdesc:a14d50f691f4fbcda7f56d7aadee77903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplaces a distributed nodegroup object into the parallel component <code>Component</code>. The options <code>opts</code> are forwarded to be used in a call to <code>detail::ForwardAllOptionsToDataBox::apply</code>. <br /></td></tr>
<tr class="separator:a14d50f691f4fbcda7f56d7aadee77903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37cd694032cbb267f845a5485103af0"><td class="memTemplParams" colspan="2"><a id="ab37cd694032cbb267f845a5485103af0" name="ab37cd694032cbb267f845a5485103af0"></a>
template&lt;typename Component , typename... Options, typename Metavars  = typename Component::metavariables&gt; </td></tr>
<tr class="memitem:ab37cd694032cbb267f845a5485103af0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_component_and_initialize</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; typename Component::metavariables &gt; * &gt; runner, const typename Component::array_index &amp;array_index, const typename detail::get_initialization&lt; Component &gt;::InitialValues &amp;initial_values, Options &amp;&amp;... opts)</td></tr>
<tr class="memdesc:ab37cd694032cbb267f845a5485103af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplaces a distributed object with index <code>array_index</code> into the parallel component <code>Component</code>. The options <code>opts</code> are forwarded to be used in a call to <code>detail::ForwardAllOptionsToDataBox::apply</code> Additionally, the simple tags in the DataBox are initialized from the values set in <code>initial_values</code>. <br /></td></tr>
<tr class="separator:ab37cd694032cbb267f845a5485103af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aee6186b0ecbb9a9664d2817a8bd92e"><td class="memTemplParams" colspan="2"><a id="a7aee6186b0ecbb9a9664d2817a8bd92e" name="a7aee6186b0ecbb9a9664d2817a8bd92e"></a>
template&lt;typename Component , typename... Options, typename Metavars  = typename Component::metavariables&gt; </td></tr>
<tr class="memitem:a7aee6186b0ecbb9a9664d2817a8bd92e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_array_component_and_initialize</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; typename Component::metavariables &gt; * &gt; runner, const <a class="el" href="structActionTesting_1_1NodeId.html">NodeId</a> node_id, const <a class="el" href="structActionTesting_1_1LocalCoreId.html">LocalCoreId</a> local_core_id, const typename Component::array_index &amp;array_index, const typename detail::get_initialization&lt; Component &gt;::InitialValues &amp;initial_values, Options &amp;&amp;... opts)</td></tr>
<tr class="memdesc:a7aee6186b0ecbb9a9664d2817a8bd92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplaces a distributed array object with index <code>array_index</code> into the parallel component <code>Component</code>. The options <code>opts</code> are forwarded to be used in a call to <code>detail::ForwardAllOptionsToDataBox::apply</code> Additionally, the simple tags in the DataBox are initialized from the values set in <code>initial_values</code>. <br /></td></tr>
<tr class="separator:a7aee6186b0ecbb9a9664d2817a8bd92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d6e995ed34a45402c4b4e4cb39fbf8"><td class="memTemplParams" colspan="2"><a id="ad2d6e995ed34a45402c4b4e4cb39fbf8" name="ad2d6e995ed34a45402c4b4e4cb39fbf8"></a>
template&lt;typename Component , typename... Options, typename Metavars  = typename Component::metavariables&gt; </td></tr>
<tr class="memitem:ad2d6e995ed34a45402c4b4e4cb39fbf8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_singleton_component_and_initialize</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; typename Component::metavariables &gt; * &gt; runner, const <a class="el" href="structActionTesting_1_1NodeId.html">NodeId</a> node_id, const <a class="el" href="structActionTesting_1_1LocalCoreId.html">LocalCoreId</a> local_core_id, const typename detail::get_initialization&lt; Component &gt;::InitialValues &amp;initial_values, Options &amp;&amp;... opts)</td></tr>
<tr class="memdesc:ad2d6e995ed34a45402c4b4e4cb39fbf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplaces a distributed singleton object into the parallel component <code>Component</code>. The options <code>opts</code> are forwarded to be used in a call to <code>detail::ForwardAllOptionsToDataBox::apply</code> Additionally, the simple tags in the DataBox are initialized from the values set in <code>initial_values</code>. <br /></td></tr>
<tr class="separator:ad2d6e995ed34a45402c4b4e4cb39fbf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5c34ca84e211945b27c9715a7fbb75"><td class="memTemplParams" colspan="2"><a id="a6e5c34ca84e211945b27c9715a7fbb75" name="a6e5c34ca84e211945b27c9715a7fbb75"></a>
template&lt;typename Component , typename... Options, typename Metavars  = typename Component::metavariables&gt; </td></tr>
<tr class="memitem:a6e5c34ca84e211945b27c9715a7fbb75"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_group_component_and_initialize</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; typename Component::metavariables &gt; * &gt; runner, const typename detail::get_initialization&lt; Component &gt;::InitialValues &amp;initial_values, Options &amp;&amp;... opts)</td></tr>
<tr class="memdesc:a6e5c34ca84e211945b27c9715a7fbb75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplaces a distributed group object into the parallel component <code>Component</code>. The options <code>opts</code> are forwarded to be used in a call to <code>detail::ForwardAllOptionsToDataBox::apply</code> Additionally, the simple tags in the DataBox are initialized from the values set in <code>initial_values</code>. <br /></td></tr>
<tr class="separator:a6e5c34ca84e211945b27c9715a7fbb75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d639fcab55264384522c8a454c857b2"><td class="memTemplParams" colspan="2"><a id="a4d639fcab55264384522c8a454c857b2" name="a4d639fcab55264384522c8a454c857b2"></a>
template&lt;typename Component , typename... Options, typename Metavars  = typename Component::metavariables&gt; </td></tr>
<tr class="memitem:a4d639fcab55264384522c8a454c857b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_nodegroup_component_and_initialize</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; typename Component::metavariables &gt; * &gt; runner, const typename detail::get_initialization&lt; Component &gt;::InitialValues &amp;initial_values, Options &amp;&amp;... opts)</td></tr>
<tr class="memdesc:a4d639fcab55264384522c8a454c857b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplaces a distributed nodegroup object into the parallel component <code>Component</code>. The options <code>opts</code> are forwarded to be used in a call to <code>detail::ForwardAllOptionsToDataBox::apply</code> Additionally, the simple tags in the DataBox are initialized from the values set in <code>initial_values</code>. <br /></td></tr>
<tr class="separator:a4d639fcab55264384522c8a454c857b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41b4d131662bea7e63e882cb510c977"><td class="memTemplParams" colspan="2"><a id="ac41b4d131662bea7e63e882cb510c977" name="ac41b4d131662bea7e63e882cb510c977"></a>
template&lt;typename Component , typename Metavariables &gt; </td></tr>
<tr class="memitem:ac41b4d131662bea7e63e882cb510c977"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_next_action_index</b> (const <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; Metavariables &gt; &amp;runner, const typename Component::array_index &amp;array_index)</td></tr>
<tr class="memdesc:ac41b4d131662bea7e63e882cb510c977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index in the action list of the next action. <br /></td></tr>
<tr class="separator:ac41b4d131662bea7e63e882cb510c977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f3a72f48625f5063db1619aef76cb4"><td class="memTemplParams" colspan="2"><a id="ae8f3a72f48625f5063db1619aef76cb4" name="ae8f3a72f48625f5063db1619aef76cb4"></a>
template&lt;typename Component , typename Tag , typename Metavariables &gt; </td></tr>
<tr class="memitem:ae8f3a72f48625f5063db1619aef76cb4"><td class="memTemplItemLeft" align="right" valign="top">const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_databox_tag</b> (const <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; Metavariables &gt; &amp;runner, const typename Component::array_index &amp;array_index)</td></tr>
<tr class="memdesc:ae8f3a72f48625f5063db1619aef76cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>Tag</code> from the <code>DataBox</code> of the parallel component <code>Component</code> with array index <code>array_index</code>. If the component's current <code>DataBox</code> type does not contain <code>Tag</code> then an error is emitted. <br /></td></tr>
<tr class="separator:ae8f3a72f48625f5063db1619aef76cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94ed84934cd02f1a3d3b098e71ab1a9"><td class="memTemplParams" colspan="2"><a id="ad94ed84934cd02f1a3d3b098e71ab1a9" name="ad94ed84934cd02f1a3d3b098e71ab1a9"></a>
template&lt;typename Component , typename Tag , typename Metavariables &gt; </td></tr>
<tr class="memitem:ad94ed84934cd02f1a3d3b098e71ab1a9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>box_contains</b> (const <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; Metavariables &gt; &amp;runner, const typename Component::array_index &amp;array_index)</td></tr>
<tr class="memdesc:ad94ed84934cd02f1a3d3b098e71ab1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the current DataBox of <code>Component</code> with index <code>array_index</code> contains the tag <code>Tag</code>. If the tag is not contained, returns <code>false</code>. <br /></td></tr>
<tr class="separator:ad94ed84934cd02f1a3d3b098e71ab1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e69b6d47fc253371b6ffa38d8afd196"><td class="memTemplParams" colspan="2"><a id="a4e69b6d47fc253371b6ffa38d8afd196" name="a4e69b6d47fc253371b6ffa38d8afd196"></a>
template&lt;typename Component , typename Tag , typename Metavariables &gt; </td></tr>
<tr class="memitem:a4e69b6d47fc253371b6ffa38d8afd196"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tag_is_retrievable</b> (const <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; Metavariables &gt; &amp;runner, const typename Component::array_index &amp;array_index)</td></tr>
<tr class="memdesc:a4e69b6d47fc253371b6ffa38d8afd196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the tag <code>Tag</code> can be retrieved from the current DataBox of <code>Component</code> with index <code>array_index</code>. <br /></td></tr>
<tr class="separator:a4e69b6d47fc253371b6ffa38d8afd196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef024479609d45a26cbcf396ea7f0ac"><td class="memTemplParams" colspan="2"><a id="a4ef024479609d45a26cbcf396ea7f0ac" name="a4ef024479609d45a26cbcf396ea7f0ac"></a>
template&lt;typename Component , typename Metavariables &gt; </td></tr>
<tr class="memitem:a4ef024479609d45a26cbcf396ea7f0ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>next_action</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; Metavariables &gt; * &gt; runner, const typename Component::array_index &amp;array_index)</td></tr>
<tr class="memdesc:a4ef024479609d45a26cbcf396ea7f0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the next action in the ActionList on the parallel component <code>Component</code> on the component labeled by <code>array_index</code>, failing if it was not ready. <br /></td></tr>
<tr class="separator:a4ef024479609d45a26cbcf396ea7f0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27cfefd9a069a27ca7a71479dd0b9a84"><td class="memTemplParams" colspan="2"><a id="a27cfefd9a069a27ca7a71479dd0b9a84" name="a27cfefd9a069a27ca7a71479dd0b9a84"></a>
template&lt;typename Component , typename Metavariables &gt; </td></tr>
<tr class="memitem:a27cfefd9a069a27ca7a71479dd0b9a84"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>next_action_if_ready</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; Metavariables &gt; * &gt; runner, const typename Component::array_index &amp;array_index)</td></tr>
<tr class="memdesc:a27cfefd9a069a27ca7a71479dd0b9a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the next action in the ActionList on the parallel component <code>Component</code> on the component labeled by <code>array_index</code>, returning whether it was ready. <br /></td></tr>
<tr class="separator:a27cfefd9a069a27ca7a71479dd0b9a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf394fb04aab18d6c78c99b17b44bd4"><td class="memTemplParams" colspan="2"><a id="a7cf394fb04aab18d6c78c99b17b44bd4" name="a7cf394fb04aab18d6c78c99b17b44bd4"></a>
template&lt;typename Component , typename Action , typename Metavariables , typename... Args&gt; </td></tr>
<tr class="memitem:a7cf394fb04aab18d6c78c99b17b44bd4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>simple_action</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; Metavariables &gt; * &gt; runner, const typename Component::array_index &amp;array_index, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a7cf394fb04aab18d6c78c99b17b44bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the simple action <code>Action</code> on the <code>array_index</code>th element of the parallel component <code>Component</code>. <br /></td></tr>
<tr class="separator:a7cf394fb04aab18d6c78c99b17b44bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef02793550d65afb3a8ac47a26fd2d33"><td class="memTemplParams" colspan="2"><a id="aef02793550d65afb3a8ac47a26fd2d33" name="aef02793550d65afb3a8ac47a26fd2d33"></a>
template&lt;typename Component , typename Action , typename Metavariables , typename... Args&gt; </td></tr>
<tr class="memitem:aef02793550d65afb3a8ac47a26fd2d33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>queue_simple_action</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; Metavariables &gt; * &gt; runner, const typename Component::array_index &amp;array_index, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aef02793550d65afb3a8ac47a26fd2d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues the simple action <code>Action</code> on the <code>array_index</code>th element of the parallel component <code>Component</code>. <br /></td></tr>
<tr class="separator:aef02793550d65afb3a8ac47a26fd2d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f6ed06e278f0c2a3cf6e281d6c038a"><td class="memTemplParams" colspan="2"><a id="a30f6ed06e278f0c2a3cf6e281d6c038a" name="a30f6ed06e278f0c2a3cf6e281d6c038a"></a>
template&lt;typename Component , typename Action , typename Metavariables , typename... Args&gt; </td></tr>
<tr class="memitem:a30f6ed06e278f0c2a3cf6e281d6c038a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>threaded_action</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; Metavariables &gt; * &gt; runner, const typename Component::array_index &amp;array_index, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a30f6ed06e278f0c2a3cf6e281d6c038a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the simple action <code>Action</code> on the <code>array_index</code>th element of the parallel component <code>Component</code>. <br /></td></tr>
<tr class="separator:a30f6ed06e278f0c2a3cf6e281d6c038a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ffde8a7c81b2df86552e98493b6810"><td class="memTemplParams" colspan="2"><a id="ac5ffde8a7c81b2df86552e98493b6810" name="ac5ffde8a7c81b2df86552e98493b6810"></a>
template&lt;typename Component , typename Metavariables &gt; </td></tr>
<tr class="memitem:ac5ffde8a7c81b2df86552e98493b6810"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invoke_queued_simple_action</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; Metavariables &gt; * &gt; runner, const typename Component::array_index &amp;array_index)</td></tr>
<tr class="memdesc:ac5ffde8a7c81b2df86552e98493b6810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the next queued simple action on the <code>array_index</code>th element of the parallel component <code>Component</code>. <br /></td></tr>
<tr class="separator:ac5ffde8a7c81b2df86552e98493b6810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea823a90bb8bc00324b7c7c98d86b563"><td class="memTemplParams" colspan="2"><a id="aea823a90bb8bc00324b7c7c98d86b563" name="aea823a90bb8bc00324b7c7c98d86b563"></a>
template&lt;typename Component , typename Metavariables &gt; </td></tr>
<tr class="memitem:aea823a90bb8bc00324b7c7c98d86b563"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_simple_action_queue_empty</b> (const <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; Metavariables &gt; &amp;runner, const typename Component::array_index &amp;array_index)</td></tr>
<tr class="memdesc:aea823a90bb8bc00324b7c7c98d86b563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if there are no simple actions in the queue. <br /></td></tr>
<tr class="separator:aea823a90bb8bc00324b7c7c98d86b563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf76e26e744581e74ef5173a54686d04"><td class="memTemplParams" colspan="2"><a id="abf76e26e744581e74ef5173a54686d04" name="abf76e26e744581e74ef5173a54686d04"></a>
template&lt;typename Component , typename Metavariables &gt; </td></tr>
<tr class="memitem:abf76e26e744581e74ef5173a54686d04"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>number_of_queued_simple_actions</b> (const <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; Metavariables &gt; &amp;runner, const typename Component::array_index &amp;array_index)</td></tr>
<tr class="memdesc:abf76e26e744581e74ef5173a54686d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of simple actions in the queue. <br /></td></tr>
<tr class="separator:abf76e26e744581e74ef5173a54686d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc84a4afb502c6fabc7fb228298e1b84"><td class="memTemplParams" colspan="2"><a id="adc84a4afb502c6fabc7fb228298e1b84" name="adc84a4afb502c6fabc7fb228298e1b84"></a>
template&lt;typename Component , typename Metavariables &gt; </td></tr>
<tr class="memitem:adc84a4afb502c6fabc7fb228298e1b84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invoke_queued_threaded_action</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; Metavariables &gt; * &gt; runner, const typename Component::array_index &amp;array_index)</td></tr>
<tr class="memdesc:adc84a4afb502c6fabc7fb228298e1b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the next queued threaded action on the <code>array_index</code>th element of the parallel component <code>Component</code>. <br /></td></tr>
<tr class="separator:adc84a4afb502c6fabc7fb228298e1b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36d6dd4063001dcb0036e13bc6d560c"><td class="memTemplParams" colspan="2"><a id="ae36d6dd4063001dcb0036e13bc6d560c" name="ae36d6dd4063001dcb0036e13bc6d560c"></a>
template&lt;typename Component , typename Metavariables &gt; </td></tr>
<tr class="memitem:ae36d6dd4063001dcb0036e13bc6d560c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_threaded_action_queue_empty</b> (const <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; Metavariables &gt; &amp;runner, const typename Component::array_index &amp;array_index)</td></tr>
<tr class="memdesc:ae36d6dd4063001dcb0036e13bc6d560c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if there are no threaded actions in the queue. <br /></td></tr>
<tr class="separator:ae36d6dd4063001dcb0036e13bc6d560c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231706f20a8aa8c6b7740037efc6f457"><td class="memTemplParams" colspan="2"><a id="a231706f20a8aa8c6b7740037efc6f457" name="a231706f20a8aa8c6b7740037efc6f457"></a>
template&lt;typename Component , typename Metavariables &gt; </td></tr>
<tr class="memitem:a231706f20a8aa8c6b7740037efc6f457"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>number_of_queued_threaded_actions</b> (const <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; Metavariables &gt; &amp;runner, const typename Component::array_index &amp;array_index)</td></tr>
<tr class="memdesc:a231706f20a8aa8c6b7740037efc6f457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of threaded actions in the queue. <br /></td></tr>
<tr class="separator:a231706f20a8aa8c6b7740037efc6f457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851bcc00d480a8205544e1fa8fe2dfc1"><td class="memTemplParams" colspan="2"><a id="a851bcc00d480a8205544e1fa8fe2dfc1" name="a851bcc00d480a8205544e1fa8fe2dfc1"></a>
template&lt;typename Component , typename Metavariables &gt; </td></tr>
<tr class="memitem:a851bcc00d480a8205544e1fa8fe2dfc1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_terminate</b> (const <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; Metavariables &gt; &amp;runner, const typename Component::array_index &amp;array_index)</td></tr>
<tr class="memdesc:a851bcc00d480a8205544e1fa8fe2dfc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the <code>Component</code> with index <code>array_index</code> has been terminated. <br /></td></tr>
<tr class="separator:a851bcc00d480a8205544e1fa8fe2dfc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645bd6af028059c31bced3807764827e"><td class="memTemplParams" colspan="2"><a id="a645bd6af028059c31bced3807764827e" name="a645bd6af028059c31bced3807764827e"></a>
template&lt;typename Component , typename Metavariables , typename ArrayIndex &gt; </td></tr>
<tr class="memitem:a645bd6af028059c31bced3807764827e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache</a>&lt; Metavariables &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cache</b> (<a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; Metavariables &gt; &amp;runner, const ArrayIndex &amp;array_index)</td></tr>
<tr class="memdesc:a645bd6af028059c31bced3807764827e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the GlobalCache of <code>Component</code> with index <code>array_index</code>. <br /></td></tr>
<tr class="separator:a645bd6af028059c31bced3807764827e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ff2412d7aae9b87c7ce036073534d4"><td class="memTemplParams" colspan="2"><a id="a40ff2412d7aae9b87c7ce036073534d4" name="a40ff2412d7aae9b87c7ce036073534d4"></a>
template&lt;typename ComponentList , typename <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a> , typename ArrayIndex &gt; </td></tr>
<tr class="memitem:a40ff2412d7aae9b87c7ce036073534d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>indices_of_components_with_queued_simple_actions</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a> * &gt; runner, const ArrayIndex &amp;array_index)</td></tr>
<tr class="memdesc:a40ff2412d7aae9b87c7ce036073534d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of all the indices of the Components in the ComponentList that have queued simple actions, for a particular array_index. <br /></td></tr>
<tr class="separator:a40ff2412d7aae9b87c7ce036073534d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d2bdc340acc86035587ac6ffba291b"><td class="memTemplParams" colspan="2"><a id="a02d2bdc340acc86035587ac6ffba291b" name="a02d2bdc340acc86035587ac6ffba291b"></a>
template&lt;typename ComponentList , typename <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a> &gt; </td></tr>
<tr class="memitem:a02d2bdc340acc86035587ac6ffba291b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>array_indices_with_queued_simple_actions</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a> * &gt; runner) -&gt; detail::array_indices_for_each_component&lt; ComponentList &gt;</td></tr>
<tr class="memdesc:a02d2bdc340acc86035587ac6ffba291b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of array_indices for each Component. The vector is filled with only those array_indices for which there are queued simple actions. <br /></td></tr>
<tr class="separator:a02d2bdc340acc86035587ac6ffba291b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da961a707dc63dddbc96a3af366cadb"><td class="memTemplParams" colspan="2"><a id="a3da961a707dc63dddbc96a3af366cadb" name="a3da961a707dc63dddbc96a3af366cadb"></a>
template&lt;typename ComponentList &gt; </td></tr>
<tr class="memitem:a3da961a707dc63dddbc96a3af366cadb"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>number_of_elements_with_queued_simple_actions</b> (const detail::array_indices_for_each_component&lt; ComponentList &gt; &amp;array_indices)</td></tr>
<tr class="memdesc:a3da961a707dc63dddbc96a3af366cadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the output of <code>array_indices_with_queued_simple_actions</code>, returns the total number of array indices that have queued simple actions. <br /></td></tr>
<tr class="separator:a3da961a707dc63dddbc96a3af366cadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fcd88b67a7daf06530a4aa28a7a282"><td class="memTemplParams" colspan="2"><a id="a69fcd88b67a7daf06530a4aa28a7a282" name="a69fcd88b67a7daf06530a4aa28a7a282"></a>
template&lt;typename ComponentList , typename <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a> , typename Generator &gt; </td></tr>
<tr class="memitem:a69fcd88b67a7daf06530a4aa28a7a282"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invoke_random_queued_simple_action</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a> * &gt; runner, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Generator * &gt; generator, const detail::array_indices_for_each_component&lt; ComponentList &gt; &amp;array_indices)</td></tr>
<tr class="memdesc:a69fcd88b67a7daf06530a4aa28a7a282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the next queued action on a random Component on a random array_index of that component. <code>array_indices</code> is the thing returned by <code>array_indices_with_queued_simple_actions</code> <br /></td></tr>
<tr class="separator:a69fcd88b67a7daf06530a4aa28a7a282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a452573aac469e8e37cdd9abb959c1b1c"><td class="memTemplParams" colspan="2"><a id="a452573aac469e8e37cdd9abb959c1b1c" name="a452573aac469e8e37cdd9abb959c1b1c"></a>
template&lt;typename Component , typename Metavariables &gt; </td></tr>
<tr class="memitem:a452573aac469e8e37cdd9abb959c1b1c"><td class="memTemplItemLeft" align="right" valign="top">const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_databox</b> (const <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; Metavariables &gt; &amp;runner, const typename Component::array_index &amp;array_index)</td></tr>
<tr class="memdesc:a452573aac469e8e37cdd9abb959c1b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the DataBox from the parallel component <code>Component</code> with index <code>array_index</code>. <br /></td></tr>
<tr class="separator:a452573aac469e8e37cdd9abb959c1b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7746a73e8e4e9bed7fa0440573f5e1aa"><td class="memTemplParams" colspan="2"><a id="a7746a73e8e4e9bed7fa0440573f5e1aa" name="a7746a73e8e4e9bed7fa0440573f5e1aa"></a>
template&lt;typename Component , typename Metavariables &gt; </td></tr>
<tr class="memitem:a7746a73e8e4e9bed7fa0440573f5e1aa"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_databox</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; Metavariables &gt; * &gt; runner, const typename Component::array_index &amp;array_index)</td></tr>
<tr class="memdesc:a7746a73e8e4e9bed7fa0440573f5e1aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the DataBox from the parallel component <code>Component</code> with index <code>array_index</code>. <br /></td></tr>
<tr class="separator:a7746a73e8e4e9bed7fa0440573f5e1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:addd24681d1564521bdce51f7d1769e2e"><td class="memTemplParams" colspan="2"><a id="addd24681d1564521bdce51f7d1769e2e" name="addd24681d1564521bdce51f7d1769e2e"></a>
template&lt;typename Component , typename InboxTag , typename Metavariables &gt; </td></tr>
<tr class="memitem:addd24681d1564521bdce51f7d1769e2e"><td class="memTemplItemLeft" align="right" valign="top">const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_inbox_tag</b> (const <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; Metavariables &gt; &amp;runner, const typename Component::array_index &amp;array_index)</td></tr>
<tr class="memdesc:addd24681d1564521bdce51f7d1769e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>InboxTag</code> from the parallel component <code>Component</code> with array index <code>array_index</code>. <br /></td></tr>
<tr class="separator:addd24681d1564521bdce51f7d1769e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd82d9e4382a3c66c6d943b8e5cf2b5e"><td class="memTemplParams" colspan="2"><a id="afd82d9e4382a3c66c6d943b8e5cf2b5e" name="afd82d9e4382a3c66c6d943b8e5cf2b5e"></a>
template&lt;typename Component , typename InboxTag , typename Metavariables &gt; </td></tr>
<tr class="memitem:afd82d9e4382a3c66c6d943b8e5cf2b5e"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_inbox_tag</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a>&lt; Metavariables &gt; * &gt; runner, const typename Component::array_index &amp;array_index)</td></tr>
<tr class="memdesc:afd82d9e4382a3c66c6d943b8e5cf2b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>InboxTag</code> from the parallel component <code>Component</code> with array index <code>array_index</code>. <br /></td></tr>
<tr class="separator:afd82d9e4382a3c66c6d943b8e5cf2b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Structures used for mocking the parallel components framework in order to test actions. </p>
<p >The <a class="el" href="namespaceActionTesting.html" title="Structures used for mocking the parallel components framework in order to test actions.">ActionTesting</a> framework is designed to mock the parallel components so that actions and sequences of actions can be tested in a controlled environment that behaves effectively identical to the actual parallel environment.</p>
<h3><a class="anchor" id="autotoc_md392"></a>
The basics</h3>
<p >The action testing framework (ATF) works essentially identically to the parallel infrastructure. A metavariables must be supplied which must at least list the components used (<code>using component_list = tmpl::list&lt;&gt;</code>). As a simple example, let's look at the test for the <code><a class="el" href="structParallel_1_1Actions_1_1TerminatePhase.html" title="Terminate the algorithm to proceed to the next phase.">Parallel::Actions::TerminatePhase</a></code> action.</p>
<p >The <code>Metavariables</code> is given by:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Metavariables {</div>
<div class="line">  <span class="keyword">using</span> component_list = tmpl::list&lt;Component&lt;Metavariables&gt;&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p >The component list in this case just contains a single component that is described below.</p>
<p >The component is templated on the metavariables, which, while not always necessary, eliminates some compilation issues that may arise otherwise. The component for the <code>TerminatePhase</code> test is given by:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Metavariables&gt;</div>
<div class="line"><span class="keyword">struct </span>Component {</div>
<div class="line">  <span class="keyword">using</span> metavariables = Metavariables;</div>
<div class="line">  <span class="keyword">using</span> chare_type = <a class="code hl_struct" href="structActionTesting_1_1MockArrayChare.html">ActionTesting::MockArrayChare</a>;</div>
<div class="line">  <span class="keyword">using</span> array_index = int;</div>
<div class="line">  <span class="keyword">using</span> phase_dependent_action_list = tmpl::list&lt;<a class="code hl_struct" href="structParallel_1_1PhaseActions.html">Parallel::PhaseActions</a>&lt;</div>
<div class="line">      <a class="code hl_enumvalue" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61afa6a5a3224d7da66d9e0bdec25f62cf0">Parallel::Phase::Testing</a>, tmpl::list&lt;Parallel::Actions::TerminatePhase&gt;&gt;&gt;;</div>
<div class="line">};</div>
<div class="ttc" id="agroup__ParallelGroup_html_gga027a2e60b10898507f92ba7290f0ba61afa6a5a3224d7da66d9e0bdec25f62cf0"><div class="ttname"><a href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61afa6a5a3224d7da66d9e0bdec25f62cf0">Parallel::Phase::Testing</a></div><div class="ttdeci">@ Testing</div><div class="ttdoc">phase in which something is tested</div></div>
<div class="ttc" id="astructActionTesting_1_1MockArrayChare_html"><div class="ttname"><a href="structActionTesting_1_1MockArrayChare.html">ActionTesting::MockArrayChare</a></div><div class="ttdoc">A mock class for the CMake-generated Parallel::Algorithms::Array</div><div class="ttdef"><b>Definition:</b> ActionTesting.hpp:732</div></div>
<div class="ttc" id="astructParallel_1_1PhaseActions_html"><div class="ttname"><a href="structParallel_1_1PhaseActions.html">Parallel::PhaseActions</a></div><div class="ttdoc">List of all the actions to be executed in the specified phase.</div><div class="ttdef"><b>Definition:</b> PhaseDependentActionList.hpp:17</div></div>
</div><!-- fragment --><p >Just like with the standard parallel code, a <code>metavariables</code> type alias must be present. The chare type should be <code><a class="el" href="structActionTesting_1_1MockArrayChare.html" title="A mock class for the CMake-generated Parallel::Algorithms::Array">ActionTesting::MockArrayChare</a></code>, <code><a class="el" href="structActionTesting_1_1MockGroupChare.html" title="A mock class for the CMake-generated Parallel::Algorithms::Group">ActionTesting::MockGroupChare</a></code>, <code><a class="el" href="structActionTesting_1_1MockNodeGroupChare.html" title="A mock class for the CMake-generated Parallel::Algorithms::NodeGroup">ActionTesting::MockNodeGroupChare</a></code>, or <code><a class="el" href="structActionTesting_1_1MockSingletonChare.html" title="A mock class for the CMake-generated Parallel::Algorithms::Singleton">ActionTesting::MockSingletonChare</a></code>. Currently many groups, nodegroups, and singletons are treated during action testing as a one-element array component, but that usage is deprecated and will eventually be removed. The <code>index_type</code> must be whatever the actions will use to index the array. In the case of a singleton <code>int</code> is recommended. Finally, the <code>phase_dependent_action_list</code> must be specified just as in the cases for parallel executables. In this case only the <code>Testing</code> phase is used and only has the <code>TerminatePhase</code> action listed.</p>
<p >The <code>SPECTRE_TEST_CASE</code> is</p>
<div class="fragment"><div class="line">SPECTRE_TEST_CASE(<span class="stringliteral">&quot;Unit.Parallel.Actions.TerminatePhase&quot;</span>,</div>
<div class="line">                  <span class="stringliteral">&quot;[Unit][Parallel][Actions]&quot;</span>) {</div>
<div class="line">  <span class="keyword">using</span> component = Component&lt;Metavariables&gt;;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classActionTesting_1_1MockRuntimeSystem.html">ActionTesting::MockRuntimeSystem&lt;Metavariables&gt;</a> runner{{}};</div>
<div class="line">  ActionTesting::emplace_component&lt;component&gt;(&amp;runner, 0);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="namespaceActionTesting.html#aa24048740ba4b2070073d4f68667874b">ActionTesting::set_phase</a>(make_not_null(&amp;runner), <a class="code hl_enumvalue" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61afa6a5a3224d7da66d9e0bdec25f62cf0">Parallel::Phase::Testing</a>);</div>
<div class="line"> </div>
<div class="line">  CHECK_FALSE(ActionTesting::get_terminate&lt;component&gt;(runner, 0));</div>
<div class="line">  ActionTesting::next_action&lt;component&gt;(make_not_null(&amp;runner), 0);</div>
<div class="line">  CHECK(ActionTesting::get_terminate&lt;component&gt;(runner, 0));</div>
<div class="line">}</div>
<div class="ttc" id="aclassActionTesting_1_1MockRuntimeSystem_html"><div class="ttname"><a href="classActionTesting_1_1MockRuntimeSystem.html">ActionTesting::MockRuntimeSystem</a></div><div class="ttdoc">A class that mocks the infrastructure needed to run actions. It simulates message passing using the i...</div><div class="ttdef"><b>Definition:</b> MockRuntimeSystem.hpp:83</div></div>
<div class="ttc" id="anamespaceActionTesting_html_aa24048740ba4b2070073d4f68667874b"><div class="ttname"><a href="namespaceActionTesting.html#aa24048740ba4b2070073d4f68667874b">ActionTesting::set_phase</a></div><div class="ttdeci">void set_phase(const gsl::not_null&lt; MockRuntimeSystem&lt; Metavariables &gt; * &gt; runner, const Parallel::Phase &amp;phase)</div><div class="ttdoc">Set the phase of all parallel components to phase</div><div class="ttdef"><b>Definition:</b> MockRuntimeSystemFreeFunctions.hpp:24</div></div>
</div><!-- fragment --><p >The type alias <code>component = Component&lt;Metavariables&gt;</code> is just used to reduce the amount of typing needed. The ATF provides a <code><a class="el" href="classActionTesting_1_1MockRuntimeSystem.html" title="A class that mocks the infrastructure needed to run actions. It simulates message passing using the i...">ActionTesting::MockRuntimeSystem</a></code> class, which is the code that takes the place of the parallel runtime system (RTS) (e.g. Charm++) that manages the actions and components. The constructor of <code><a class="el" href="classActionTesting_1_1MockRuntimeSystem.html" title="A class that mocks the infrastructure needed to run actions. It simulates message passing using the i...">ActionTesting::MockRuntimeSystem</a></code> takes a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;size_t&gt;</code> whose length is the number of (mocked) nodes and whose values are the number of (mocked) cores on each node; the RTS runs only on a single core, but it keeps track of which components are on which (mocked) nodes and cores so that one can test some of the functionality of multiple cores/nodes. Components are added to the RTS using the functions <code><a class="el" href="namespaceActionTesting.html#ab6aa6848d4b0f2b5be7017a714b85191" title="Emplaces a distributed array object with index array_index into the parallel component Component....">ActionTesting::emplace_array_component()</a></code>, <code><a class="el" href="namespaceActionTesting.html#a4935a00768ec34601277de7e83f70665" title="Emplaces a distributed singleton object into the parallel component Component. The options opts are f...">ActionTesting::emplace_singleton_component()</a></code>, <code><a class="el" href="namespaceActionTesting.html#aed38bffbd36476c3ae9486d5823a2e6f" title="Emplaces a distributed group object into the parallel component Component. The options opts are forwa...">ActionTesting::emplace_group_component()</a></code>, and <code><a class="el" href="namespaceActionTesting.html#a14d50f691f4fbcda7f56d7aadee77903" title="Emplaces a distributed nodegroup object into the parallel component Component. The options opts are f...">ActionTesting::emplace_nodegroup_component()</a></code>. Currently there is a deprecated <code><a class="el" href="namespaceActionTesting.html#ab6abf05893d01ccff458fe23010b3f40" title="Emplaces a distributed object with index array_index into the parallel component Component....">ActionTesting::emplace_component()</a></code> function that is the same as <code><a class="el" href="namespaceActionTesting.html#ab6aa6848d4b0f2b5be7017a714b85191" title="Emplaces a distributed array object with index array_index into the parallel component Component....">ActionTesting::emplace_array_component()</a></code> and can be used for the deprecated usage of treating singletons, groups, and nodegroups as single-element arrays. The emplace functions take the runner by <code>not_null</code>. The array emplace function take the array index of the component being inserted (<code>0</code> in the above example, but this is arbitrary), and the array and singleton emplace functions take the (mocked) node and core on which the component lives. The emplace function for groups places its object on all (mocked) cores and the array index is the same as the global core index; the emplace function for nodegroups places its object on a single (mocked) core on each (mocked) node, and the array index is the same as the node index. All emplace functions optionally take a parameter pack of additional arguments that are forwarded to the constructor of the component. These additional arguments are how input options (set in the <code>simple_tags_from_options</code> type alias of the parallel component) get passed to parallel components.</p>
<p >With the ATF, everything is controlled explicitly, providing the ability to perform full introspection into the state of the RTS at virtually any point during the execution. This means that the phase is not automatically advanced like it is in a parallel executable, but instead must be advanced by calling the <code><a class="el" href="namespaceActionTesting.html#aa24048740ba4b2070073d4f68667874b" title="Set the phase of all parallel components to phase">ActionTesting::set_phase</a></code> function. While testing the <code>TerminatePhase</code> action we are only interesting in checking whether the algorithm has set the <code>terminate</code> flag. This is done using the <code><a class="el" href="namespaceActionTesting.html#a851bcc00d480a8205544e1fa8fe2dfc1" title="Returns whether or not the Component with index array_index has been terminated.">ActionTesting::get_terminate()</a></code> function and is done for each distributed object (i.e. per component). The next action in the action list for the current phase is invoked by using the <code><a class="el" href="namespaceActionTesting.html#a4ef024479609d45a26cbcf396ea7f0ac" title="Invoke the next action in the ActionList on the parallel component Component on the component labeled...">ActionTesting::next_action()</a></code> function, which takes as arguments the runner by <code>not_null</code> and the array index of the distributed object to invoke the next action on.</p>
<h3><a class="anchor" id="autotoc_md393"></a>
InitializeDataBox and action introspection</h3>
<p >Having covered the very basics of ATF let us look at the test for the <code><a class="el" href="structActions_1_1Goto.html" title="Jumps to a Label.">Actions::Goto</a></code> action. We will introduce the functionality <code>InitializeDataBox</code>,<code>force_next_action_to_be</code>, <code>get_next_action_index</code>, and <code>get_databox_tag</code>. The <code>Goto&lt;the_label_class&gt;</code> action changes the next action in the algorithm to be the <code><a class="el" href="structActions_1_1Label.html" title="Labels a location in the action list that can be jumped to using Goto.">Actions::Label</a>&lt;the_label_class&gt;</code>. For this test the Metavariables is:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Metavariables {</div>
<div class="line">  <span class="keyword">using</span> component_list = tmpl::list&lt;Component&lt;Metavariables&gt;&gt;;</div>
<div class="line"> </div>
<div class="line">};</div>
</div><!-- fragment --><p >You can see that this time there are two test phases, <code>Testing</code> and <code>Execute</code>.</p>
<p >The component for this case is quite a bit more complicated so we will go through it in detail. It is given by</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Metavariables&gt;</div>
<div class="line"><span class="keyword">struct </span>Component {</div>
<div class="line">  <span class="keyword">using</span> metavariables = Metavariables;</div>
<div class="line">  <span class="keyword">using</span> chare_type = <a class="code hl_struct" href="structActionTesting_1_1MockArrayChare.html">ActionTesting::MockArrayChare</a>;</div>
<div class="line">  <span class="keyword">using</span> array_index = int;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">using</span> repeat_until_phase_action_list = tmpl::flatten&lt;</div>
<div class="line">      tmpl::list&lt;Actions::RepeatUntil&lt;HasConverged, tmpl::list&lt;Increment&gt;&gt;,</div>
<div class="line">                 <a class="code hl_struct" href="structParallel_1_1Actions_1_1TerminatePhase.html">Parallel::Actions::TerminatePhase</a>&gt;&gt;;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">using</span> phase_dependent_action_list = tmpl::list&lt;</div>
<div class="line">      <a class="code hl_struct" href="structParallel_1_1PhaseActions.html">Parallel::PhaseActions</a>&lt;<a class="code hl_enumvalue" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a61bcd96a2c1f8026527cbf2019d6e9a4">Parallel::Phase::Initialization</a>,</div>
<div class="line">                             tmpl::list&lt;ActionTesting::InitializeDataBox&lt;</div>
<div class="line">                                 <a class="code hl_typedef" href="group__DataBoxGroup.html#ga3dc674ba575ece4a8be1c23fa6c2cdcb">db::AddSimpleTags&lt;Counter&gt;</a>,</div>
<div class="line">                                 <a class="code hl_typedef" href="group__DataBoxGroup.html#ga64597eb7f5df0dc4d99698289265b1a7">db::AddComputeTags&lt;HasConvergedCompute&gt;</a>&gt;&gt;&gt;,</div>
<div class="line">      <a class="code hl_struct" href="structParallel_1_1PhaseActions.html">Parallel::PhaseActions</a>&lt;</div>
<div class="line">          <a class="code hl_enumvalue" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61afa6a5a3224d7da66d9e0bdec25f62cf0">Parallel::Phase::Testing</a>,</div>
<div class="line">          tmpl::list&lt;Actions::Goto&lt;Label1&gt;, <a class="code hl_struct" href="structActions_1_1Label.html">Actions::Label&lt;Label2&gt;</a>,</div>
<div class="line">                     <a class="code hl_struct" href="structActions_1_1Label.html">Actions::Label&lt;Label1&gt;</a>, <a class="code hl_struct" href="structActions_1_1Goto.html">Actions::Goto&lt;Label2&gt;</a>&gt;&gt;,</div>
<div class="line">      <a class="code hl_struct" href="structParallel_1_1PhaseActions.html">Parallel::PhaseActions</a>&lt;<a class="code hl_enumvalue" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a40cd014b7b6251e3a22e6a45a73a64e1">Parallel::Phase::Execute</a>,</div>
<div class="line">                             repeat_until_phase_action_list&gt;&gt;;</div>
<div class="line">};</div>
<div class="ttc" id="agroup__DataBoxGroup_html_ga3dc674ba575ece4a8be1c23fa6c2cdcb"><div class="ttname"><a href="group__DataBoxGroup.html#ga3dc674ba575ece4a8be1c23fa6c2cdcb">db::AddSimpleTags</a></div><div class="ttdeci">tmpl::flatten&lt; tmpl::list&lt; Tags... &gt; &gt; AddSimpleTags</div><div class="ttdoc">List of Tags to add to the DataBox.</div><div class="ttdef"><b>Definition:</b> DataBox.hpp:1018</div></div>
<div class="ttc" id="agroup__DataBoxGroup_html_ga64597eb7f5df0dc4d99698289265b1a7"><div class="ttname"><a href="group__DataBoxGroup.html#ga64597eb7f5df0dc4d99698289265b1a7">db::AddComputeTags</a></div><div class="ttdeci">tmpl::flatten&lt; tmpl::list&lt; Tags... &gt; &gt; AddComputeTags</div><div class="ttdoc">List of Compute Item Tags to add to the DataBox.</div><div class="ttdef"><b>Definition:</b> DataBox.hpp:1025</div></div>
<div class="ttc" id="agroup__ParallelGroup_html_gga027a2e60b10898507f92ba7290f0ba61a40cd014b7b6251e3a22e6a45a73a64e1"><div class="ttname"><a href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a40cd014b7b6251e3a22e6a45a73a64e1">Parallel::Phase::Execute</a></div><div class="ttdeci">@ Execute</div><div class="ttdoc">generic execution phase of an executable</div></div>
<div class="ttc" id="agroup__ParallelGroup_html_gga027a2e60b10898507f92ba7290f0ba61a61bcd96a2c1f8026527cbf2019d6e9a4"><div class="ttname"><a href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a61bcd96a2c1f8026527cbf2019d6e9a4">Parallel::Phase::Initialization</a></div><div class="ttdeci">@ Initialization</div><div class="ttdoc">initial phase of an executable</div></div>
<div class="ttc" id="astructActions_1_1Goto_html"><div class="ttname"><a href="structActions_1_1Goto.html">Actions::Goto</a></div><div class="ttdoc">Jumps to a Label.</div><div class="ttdef"><b>Definition:</b> Goto.hpp:71</div></div>
<div class="ttc" id="astructActions_1_1Label_html"><div class="ttname"><a href="structActions_1_1Label.html">Actions::Label</a></div><div class="ttdoc">Labels a location in the action list that can be jumped to using Goto.</div><div class="ttdef"><b>Definition:</b> Goto.hpp:40</div></div>
<div class="ttc" id="astructParallel_1_1Actions_1_1TerminatePhase_html"><div class="ttname"><a href="structParallel_1_1Actions_1_1TerminatePhase.html">Parallel::Actions::TerminatePhase</a></div><div class="ttdoc">Terminate the algorithm to proceed to the next phase.</div><div class="ttdef"><b>Definition:</b> TerminatePhase.hpp:28</div></div>
</div><!-- fragment --><p >In addition to the <code>Initialization</code> and <code>Exit</code> phases, there are two additional phases, <code>Testing</code> and <code>Execute</code>. Just as before there are <code>metavariables</code>, <code>chare_type</code>, and <code>array_index</code> type aliases. The <code>repeat_until_phase_action_list</code> is the list of iterable actions that are called during the <code>Execute</code> phase. The <code>Initialization</code> phase action list now has the action <code>ActionTesting::InitializeDataBox</code>, which takes simple tags and compute tags that will be added to the DataBox in the Initialization phase. How the values for the simple tags are set will be made clear below when we discuss the <code><a class="el" href="namespaceActionTesting.html#ab37cd694032cbb267f845a5485103af0" title="Emplaces a distributed object with index array_index into the parallel component Component....">ActionTesting::emplace_component_and_initialize()</a></code> functions. The action lists for the <code>Testing</code> and <code>Execute</code> phases are fairly simple and not the focus of this discussion.</p>
<p >Having discussed the metavariables and component, let us now look at the test case.</p>
<div class="fragment"><div class="line">SPECTRE_TEST_CASE(<span class="stringliteral">&quot;Unit.Parallel.GotoAction&quot;</span>, <span class="stringliteral">&quot;[Unit][Parallel][Actions]&quot;</span>) {</div>
<div class="line">  <span class="keyword">using</span> component = Component&lt;Metavariables&gt;;</div>
<div class="line">  <span class="keyword">using</span> <a class="code hl_class" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a> = <a class="code hl_class" href="classActionTesting_1_1MockRuntimeSystem.html">ActionTesting::MockRuntimeSystem&lt;Metavariables&gt;</a>;</div>
<div class="line">  <a class="code hl_class" href="classActionTesting_1_1MockRuntimeSystem.html">MockRuntimeSystem</a> runner{{}};</div>
<div class="line">  ActionTesting::emplace_component_and_initialize&lt;component&gt;(&amp;runner, 0,</div>
<div class="line">                                                             {<span class="keywordtype">size_t</span>{0}});</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="namespaceActionTesting.html#aa24048740ba4b2070073d4f68667874b">ActionTesting::set_phase</a>(make_not_null(&amp;runner), <a class="code hl_enumvalue" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61afa6a5a3224d7da66d9e0bdec25f62cf0">Parallel::Phase::Testing</a>);</div>
<div class="line">  runner.force_next_action_to_be&lt;component, <a class="code hl_struct" href="structActions_1_1Label.html">Actions::Label&lt;Label1&gt;</a>&gt;(0);</div>
<div class="line">  runner.next_action&lt;component&gt;(0);</div>
<div class="line">  CHECK(runner.get_next_action_index&lt;component&gt;(0) == 3);</div>
<div class="line"> </div>
<div class="line">  runner.force_next_action_to_be&lt;component, <a class="code hl_struct" href="structActions_1_1Goto.html">Actions::Goto&lt;Label1&gt;</a>&gt;(0);</div>
<div class="line">  runner.next_action&lt;component&gt;(0);</div>
<div class="line">  CHECK(runner.get_next_action_index&lt;component&gt;(0) == 2);</div>
<div class="line"> </div>
<div class="line">  runner.force_next_action_to_be&lt;component, <a class="code hl_struct" href="structActions_1_1Goto.html">Actions::Goto&lt;Label2&gt;</a>&gt;(0);</div>
<div class="line">  runner.next_action&lt;component&gt;(0);</div>
<div class="line">  CHECK(runner.get_next_action_index&lt;component&gt;(0) == 1);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="namespaceActionTesting.html#aa24048740ba4b2070073d4f68667874b">ActionTesting::set_phase</a>(make_not_null(&amp;runner), <a class="code hl_enumvalue" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a40cd014b7b6251e3a22e6a45a73a64e1">Parallel::Phase::Execute</a>);</div>
<div class="line">  <span class="keywordflow">while</span> (not ActionTesting::get_terminate&lt;component&gt;(runner, 0)) {</div>
<div class="line">    runner.next_action&lt;component&gt;(0);</div>
<div class="line">  }</div>
<div class="line">  CHECK(ActionTesting::get_databox_tag&lt;component, HasConverged&gt;(runner, 0));</div>
<div class="line">  CHECK(ActionTesting::get_databox_tag&lt;component, Counter&gt;(runner, 0) == 2);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Test zero iterations of the `RepeatUntil` loop</span></div>
<div class="line">  <a class="code hl_function" href="namespaceActionTesting.html#aa24048740ba4b2070073d4f68667874b">ActionTesting::set_phase</a>(make_not_null(&amp;runner), <a class="code hl_enumvalue" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a40cd014b7b6251e3a22e6a45a73a64e1">Parallel::Phase::Execute</a>);</div>
<div class="line">  runner.next_action&lt;component&gt;(0);</div>
<div class="line">  CHECK(runner.get_next_action_index&lt;component&gt;(0) ==</div>
<div class="line">        tmpl::index_of&lt;<span class="keyword">typename</span> component::repeat_until_phase_action_list,</div>
<div class="line">                       <a class="code hl_struct" href="structParallel_1_1Actions_1_1TerminatePhase.html">Parallel::Actions::TerminatePhase</a>&gt;<a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">::value</a>);</div>
<div class="line">  <span class="comment">// Make sure `Increment` was not called for this situation where the</span></div>
<div class="line">  <span class="comment">// condition is already fulfilled at the start.</span></div>
<div class="line">  CHECK(ActionTesting::get_databox_tag&lt;component, Counter&gt;(runner, 0) == 2);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__UtilitiesGroup_html_ga4316f2ea7fb92cf4a3c5cf53bf36fb82"><div class="ttname"><a href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">value</a></div><div class="ttdeci">constexpr T &amp; value(T &amp;t)</div><div class="ttdoc">Returns t.value() if t is a std::optional otherwise returns t.</div><div class="ttdef"><b>Definition:</b> OptionalHelpers.hpp:32</div></div>
</div><!-- fragment --><p >Just as for the <code>TerminatePhase</code> test we have some type aliases to reduce the amount of typing needed and to make the test easier to read. The runner is again created with the default constructor. However, the component is now inserted using the functions <code><a class="el" href="namespaceActionTesting.html#a7aee6186b0ecbb9a9664d2817a8bd92e" title="Emplaces a distributed array object with index array_index into the parallel component Component....">ActionTesting::emplace_array_component_and_initialize()</a></code>, <code><a class="el" href="namespaceActionTesting.html#ad2d6e995ed34a45402c4b4e4cb39fbf8" title="Emplaces a distributed singleton object into the parallel component Component. The options opts are f...">ActionTesting::emplace_singleton_component_and_initialize()</a></code>, <code><a class="el" href="namespaceActionTesting.html#a6e5c34ca84e211945b27c9715a7fbb75" title="Emplaces a distributed group object into the parallel component Component. The options opts are forwa...">ActionTesting::emplace_group_component_and_initialize()</a></code>, and <code><a class="el" href="namespaceActionTesting.html#a4d639fcab55264384522c8a454c857b2" title="Emplaces a distributed nodegroup object into the parallel component Component. The options opts are f...">ActionTesting::emplace_nodegroup_component_and_initialize()</a></code>. There is a deprecated function <code><a class="el" href="namespaceActionTesting.html#ab37cd694032cbb267f845a5485103af0" title="Emplaces a distributed object with index array_index into the parallel component Component....">ActionTesting::emplace_component_and_initialize()</a></code> that is used when one treats groups, nodegroups, and singletons as arrays. The third argument to the <code><a class="el" href="namespaceActionTesting.html#ab37cd694032cbb267f845a5485103af0" title="Emplaces a distributed object with index array_index into the parallel component Component....">ActionTesting::emplace_component_and_initialize()</a></code> functions is a <code><a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs.">tuples::TaggedTuple</a></code> of the simple tags, which is to be populated with the initial values for the component. Note that there is no call to <code><a class="el" href="namespaceActionTesting.html#aa24048740ba4b2070073d4f68667874b" title="Set the phase of all parallel components to phase">ActionTesting::set_phase</a> (&amp;runner, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a61bcd96a2c1f8026527cbf2019d6e9a4" title="initial phase of an executable">Parallel::Phase::Initialization</a>)</code>: this and the required action invocation is handled internally by the <code><a class="el" href="namespaceActionTesting.html#ab37cd694032cbb267f845a5485103af0" title="Emplaces a distributed object with index array_index into the parallel component Component....">ActionTesting::emplace_component_and_initialize()</a></code> functions.</p>
<p >Once the phase is set the next action to be executed is set to be <code><a class="el" href="structActions_1_1Label.html" title="Labels a location in the action list that can be jumped to using Goto.">Actions::Label</a>&lt;Label1&gt;</code> by calling the <code><a class="el" href="classActionTesting_1_1MockRuntimeSystem.html#ab61616325698db68693f6cf62476350d" title="Instead of the next call to next_action applying the next action in the action list,...">MockRuntimeSystem::force_next_action_to_be()</a></code> member function of the runner. The argument to the function is the array index of the component for which to set the next action. After the <code>Label&lt;Label1&gt;</code> action is invoked we check that the next action is the fourth (index <code>3</code> because we use zero-based indexing) by calling the <code><a class="el" href="classActionTesting_1_1MockRuntimeSystem.html#ac71f177fd6e752fc100286514d53cf3e" title="Obtain the index into the action list of the next action.">MockRuntimeSystem::get_next_action_index()</a></code> member function. For clarity, the indices of the actions in the <code>Phase::Testing</code> phase are:</p><ul>
<li>0: <code><a class="el" href="structActions_1_1Goto.html" title="Jumps to a Label.">Actions::Goto</a>&lt;Label1&gt;</code></li>
<li>1: <code><a class="el" href="structActions_1_1Label.html" title="Labels a location in the action list that can be jumped to using Goto.">Actions::Label</a>&lt;Label2&gt;</code></li>
<li>2: <code><a class="el" href="structActions_1_1Label.html" title="Labels a location in the action list that can be jumped to using Goto.">Actions::Label</a>&lt;Label1&gt;</code></li>
<li>3: <code><a class="el" href="structActions_1_1Goto.html" title="Jumps to a Label.">Actions::Goto</a>&lt;Label2&gt;</code></li>
</ul>
<h3><a class="anchor" id="autotoc_md394"></a>
DataBox introspection</h3>
<p >Since the exact DataBox type of any component at some point in the action list may not be known, the <code><a class="el" href="namespaceActionTesting.html#ae8f3a72f48625f5063db1619aef76cb4" title="Returns the Tag from the DataBox of the parallel component Component with array index array_index....">ActionTesting::get_databox_tag()</a></code> function is provided. An example usage of this function can be seen in the last line of the test snippet above. The component and tag are passed as template parameters while the runner and array index are passed as arguments. It is also possible to retrieve DataBox directly using the <code><a class="el" href="namespaceActionTesting.html#a452573aac469e8e37cdd9abb959c1b1c" title="Retrieves the DataBox from the parallel component Component with index array_index.">ActionTesting::get_databox()</a></code> function if the DataBox type is known:</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; box =</div>
<div class="line">      ActionTesting::get_databox&lt;component_for_simple_action_mock&lt;metavars&gt;&gt;(</div>
<div class="line">          runner, 0);</div>
</div><!-- fragment --><p >There is also a <code><a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a></code> overload of <code><a class="el" href="namespaceActionTesting.html#a452573aac469e8e37cdd9abb959c1b1c" title="Retrieves the DataBox from the parallel component Component with index array_index.">ActionTesting::get_databox()</a></code> that can be used to mutate tags in the DataBox. It is also possible to check if an item can be retrieved from the DataBox using the <code><a class="el" href="namespaceActionTesting.html#a4e69b6d47fc253371b6ffa38d8afd196" title="Returns true if the tag Tag can be retrieved from the current DataBox of Component with index array_i...">ActionTesting::tag_is_retrievable()</a></code> function as follows:</p>
<div class="fragment"><div class="line">      ActionTesting::tag_is_retrievable&lt;component, DummyTimeTag&gt;(runner, 0)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md395"></a>
Stub actions and invoking simple and threaded actions</h3>
<p >A simple action can be invoked on a distributed object or component using the <code><a class="el" href="namespaceActionTesting.html#a7cf394fb04aab18d6c78c99b17b44bd4" title="Runs the simple action Action on the array_indexth element of the parallel component Component.">ActionTesting::simple_action()</a></code> function:</p>
<div class="fragment"><div class="line">  ActionTesting::simple_action&lt;component_for_simple_action_mock&lt;metavars&gt;,</div>
<div class="line">                               simple_action_b&gt;(make_not_null(&amp;runner), 0, 2);</div>
</div><!-- fragment --><p >A threaded action can be invoked on a distributed object or component using the <code><a class="el" href="namespaceActionTesting.html#a30f6ed06e278f0c2a3cf6e281d6c038a" title="Runs the simple action Action on the array_indexth element of the parallel component Component.">ActionTesting::threaded_action()</a></code> function:</p>
<div class="fragment"><div class="line">  ActionTesting::threaded_action&lt;component_for_simple_action_mock&lt;metavars&gt;,</div>
<div class="line">                                 threaded_action_a&gt;(make_not_null(&amp;runner), 0);</div>
</div><!-- fragment --><p >Sometimes an individual action calls other actions but we still want to be able to test the action and its effects in isolation. To this end the ATF supports replacing calls to actions with calls to other actions. For example, instead of calling <code>simple_action_a</code> we want to call <code>simple_action_a_mock</code> which just verifies the data received is correct and sets a flag in the DataBox that it was invoked. This can be done by setting the type aliases <code>replace_these_simple_actions</code> and <code>with_these_simple_actions</code> in the parallel component definition as follows:</p>
<div class="fragment"><div class="line">  <span class="keyword">using</span> replace_these_simple_actions =</div>
<div class="line">      tmpl::list&lt;simple_action_a, simple_action_c, threaded_action_b&gt;;</div>
<div class="line">  <span class="keyword">using</span> with_these_simple_actions =</div>
<div class="line">      tmpl::list&lt;simple_action_a_mock, simple_action_c_mock,</div>
<div class="line">                 threaded_action_b_mock&gt;;</div>
</div><!-- fragment --><p >The length of the two type lists must be the same and the Nth action in <code>replace_these_simple_actions</code> gets replaced by the Nth action in <code>with_these_simple_actions</code>. Note that <code>simple_action_a_mock</code> will get invoked in any context that <code>simple_action_a</code> is called to be invoked. The same feature also exists for threaded actions:</p>
<div class="fragment"><div class="line">  <span class="keyword">using</span> replace_these_threaded_actions = tmpl::list&lt;threaded_action_b&gt;;</div>
<div class="line">  <span class="keyword">using</span> with_these_threaded_actions = tmpl::list&lt;threaded_action_b_mock&gt;;</div>
</div><!-- fragment --><p >Furthermore, simple actions invoked from an action are not run immediately. Instead, they are queued so that order randomization and introspection may occur. The simplest form of introspection is checking whether the simple action queue is empty:</p>
<div class="fragment"><div class="line">          <a class="code hl_function" href="namespaceActionTesting.html#aea823a90bb8bc00324b7c7c98d86b563">ActionTesting::is_simple_action_queue_empty</a>&lt;</div>
<div class="line">              component_for_simple_action_mock&lt;metavars&gt;&gt;(runner, 0)</div>
<div class="ttc" id="anamespaceActionTesting_html_aea823a90bb8bc00324b7c7c98d86b563"><div class="ttname"><a href="namespaceActionTesting.html#aea823a90bb8bc00324b7c7c98d86b563">ActionTesting::is_simple_action_queue_empty</a></div><div class="ttdeci">bool is_simple_action_queue_empty(const MockRuntimeSystem&lt; Metavariables &gt; &amp;runner, const typename Component::array_index &amp;array_index)</div><div class="ttdoc">Returns true if there are no simple actions in the queue.</div><div class="ttdef"><b>Definition:</b> MockRuntimeSystemFreeFunctions.hpp:326</div></div>
</div><!-- fragment --><p >The <code><a class="el" href="namespaceActionTesting.html#ac5ffde8a7c81b2df86552e98493b6810" title="Runs the next queued simple action on the array_indexth element of the parallel component Component.">ActionTesting::invoke_queued_simple_action()</a></code> invokes the next queued simple action:</p>
<div class="fragment"><div class="line">  <a class="code hl_function" href="namespaceActionTesting.html#ac5ffde8a7c81b2df86552e98493b6810">ActionTesting::invoke_queued_simple_action</a>&lt;</div>
<div class="line">      component_for_simple_action_mock&lt;metavars&gt;&gt;(make_not_null(&amp;runner), 0);</div>
<div class="ttc" id="anamespaceActionTesting_html_ac5ffde8a7c81b2df86552e98493b6810"><div class="ttname"><a href="namespaceActionTesting.html#ac5ffde8a7c81b2df86552e98493b6810">ActionTesting::invoke_queued_simple_action</a></div><div class="ttdeci">void invoke_queued_simple_action(const gsl::not_null&lt; MockRuntimeSystem&lt; Metavariables &gt; * &gt; runner, const typename Component::array_index &amp;array_index)</div><div class="ttdoc">Runs the next queued simple action on the array_indexth element of the parallel component Component.</div><div class="ttdef"><b>Definition:</b> MockRuntimeSystemFreeFunctions.hpp:318</div></div>
</div><!-- fragment --><p >Note that the same functionality exists for threaded actions. The functions are <code><a class="el" href="namespaceActionTesting.html#ae36d6dd4063001dcb0036e13bc6d560c" title="Returns true if there are no threaded actions in the queue.">ActionTesting::is_threaded_action_queue_empty()</a></code>, and <code><a class="el" href="namespaceActionTesting.html#adc84a4afb502c6fabc7fb228298e1b84" title="Runs the next queued threaded action on the array_indexth element of the parallel component Component...">ActionTesting::invoke_queued_threaded_action()</a></code>.</p>
<h3><a class="anchor" id="autotoc_md396"></a>
Reduction Actions</h3>
<p >The ATF, in general, does not support reduction actions at the moment. Meaning that calls to <code><a class="el" href="group__ParallelGroup.html#ga893fa42fabb3cb7273cfdd7348e9a75d" title="Perform a reduction from the sender_component (typically your own parallel component) to the target_c...">Parallel::contribute_to_reduction</a></code> and <code><a class="el" href="group__ParallelGroup.html#ga49eb59320a0258c95d58b1447ff8702b" title="Invoke a threaded action on proxy, where the proxy must be a nodegroup.">Parallel::threaded_action</a>&lt;<a class="el" href="structobservers_1_1ThreadedActions_1_1WriteReductionData.html" title="Write reduction data to disk from node 0.">observers::ThreadedActions::WriteReductionData</a>&gt;</code> are not supported. However, the ATF does support calls using <code>WriteReductionDataRow</code> without having to actually write any data to disk (this avoids unnecessary IO when all we really care about is if the values are correct).</p>
<p >If you want to test code that has a call to <code><a class="el" href="group__ParallelGroup.html#ga49eb59320a0258c95d58b1447ff8702b" title="Invoke a threaded action on proxy, where the proxy must be a nodegroup.">Parallel::threaded_action</a>&lt; <a class="el" href="structobservers_1_1ThreadedActions_1_1WriteReductionDataRow.html" title="Write a single row of data to the reductions file without the need to register or reduce anything,...">observers::ThreadedActions::WriteReductionDataRow</a>&gt;</code>, you'll need to add the <code><a class="el" href="structTestHelpers_1_1observers_1_1MockObserverWriter.html" title="Component that mocks the ObserverWriter.">TestHelpers::observers::MockObserverWriter</a></code> component, found in Helpers/IO/Observers/MockWriteReductionDataRow.hpp, to your test metavars (see next section for what mocking a component means). Initialize the component as follows:</p>
<div class="fragment"><div class="line">  <a class="code hl_function" href="namespaceActionTesting.html#a4d639fcab55264384522c8a454c857b2">ActionTesting::emplace_nodegroup_component_and_initialize</a>&lt;</div>
<div class="line">      mock_observer_writer&gt;(make_not_null(&amp;runner), {});</div>
<div class="ttc" id="anamespaceActionTesting_html_a4d639fcab55264384522c8a454c857b2"><div class="ttname"><a href="namespaceActionTesting.html#a4d639fcab55264384522c8a454c857b2">ActionTesting::emplace_nodegroup_component_and_initialize</a></div><div class="ttdeci">void emplace_nodegroup_component_and_initialize(const gsl::not_null&lt; MockRuntimeSystem&lt; typename Component::metavariables &gt; * &gt; runner, const typename detail::get_initialization&lt; Component &gt;::InitialValues &amp;initial_values, Options &amp;&amp;... opts)</div><div class="ttdoc">Emplaces a distributed nodegroup object into the parallel component Component. The options opts are f...</div><div class="ttdef"><b>Definition:</b> MockRuntimeSystemFreeFunctions.hpp:173</div></div>
</div><!-- fragment --><p >Then, when you want to check the data that was "written", you can do something along the lines of</p>
<div class="fragment"><div class="line">  <span class="keyword">auto</span>&amp; mock_h5_file =</div>
<div class="line">      <a class="code hl_function" href="namespaceActionTesting.html#ae8f3a72f48625f5063db1619aef76cb4">ActionTesting::get_databox_tag</a>&lt;mock_observer_writer,</div>
<div class="line">                                     MockReductionFileTag&gt;(runner, 0);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; mock_dat_file = mock_h5_file.get_dat(subfile_path);</div>
<div class="line">  CHECK(mock_dat_file.get_legend() == legend);</div>
<div class="line">  CHECK(mock_dat_file.get_data() == <a class="code hl_class" href="classMatrix.html">Matrix</a>{{1.0, 9.3}});</div>
<div class="ttc" id="aclassMatrix_html"><div class="ttname"><a href="classMatrix.html">Matrix</a></div><div class="ttdoc">A dynamically sized matrix of doubles with column-major storage.</div><div class="ttdef"><b>Definition:</b> Matrix.hpp:19</div></div>
<div class="ttc" id="anamespaceActionTesting_html_ae8f3a72f48625f5063db1619aef76cb4"><div class="ttname"><a href="namespaceActionTesting.html#ae8f3a72f48625f5063db1619aef76cb4">ActionTesting::get_databox_tag</a></div><div class="ttdeci">const auto &amp; get_databox_tag(const MockRuntimeSystem&lt; Metavariables &gt; &amp;runner, const typename Component::array_index &amp;array_index)</div><div class="ttdoc">Returns the Tag from the DataBox of the parallel component Component with array index array_index....</div><div class="ttdef"><b>Definition:</b> MockRuntimeSystemFreeFunctions.hpp:215</div></div>
</div><!-- fragment --><p >The data is stored in <code>MockH5File</code> and <code>MockDat</code> objects, which have similar interfaces to <code><a class="el" href="classh5_1_1H5File.html" title="Opens an HDF5 file for access and allows manipulation of data.">h5::H5File</a></code> and <code><a class="el" href="classh5_1_1Dat.html" title="Represents a multicolumn dat file inside an HDF5 file.">h5::Dat</a></code>, respectively.</p>
<h3><a class="anchor" id="autotoc_md397"></a>
Mocking or replacing components with stubs</h3>
<p >An action can invoke an action on another parallel component. In this case we need to be able to tell the mocking framework to replace the component the action is trying to invoke the other action on and instead use a different component that we have set up to mock the original component. For example, the action below invokes an action on <code>ComponentB</code></p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>CallActionOnComponentB {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ParallelComponent, <span class="keyword">typename</span> DbTagsList,</div>
<div class="line">            <span class="keyword">typename</span> Metavariables, <span class="keyword">typename</span> ArrayIndex&gt;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code hl_function" href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">apply</a>(db::DataBox&lt;DbTagsList&gt;&amp; <span class="comment">/*box*/</span>,             <span class="comment">// NOLINT</span></div>
<div class="line">                    <a class="code hl_class" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache&lt;Metavariables&gt;</a>&amp; <a class="code hl_function" href="namespaceActionTesting.html#a645bd6af028059c31bced3807764827e">cache</a>,  <span class="comment">// NOLINT</span></div>
<div class="line">                    <span class="keyword">const</span> ArrayIndex&amp; <span class="comment">/*array_index*/</span>) {</div>
<div class="line">    Parallel::simple_action&lt;ActionCalledOnComponentB&gt;(</div>
<div class="line">        <a class="code hl_function" href="group__ParallelGroup.html#gaeee02b1e4faf8051fe703e6b9adada0f">Parallel::get_parallel_component</a>&lt;ComponentB&lt;Metavariables&gt;&gt;(<a class="code hl_function" href="namespaceActionTesting.html#a645bd6af028059c31bced3807764827e">cache</a>));</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="ttc" id="aclassParallel_1_1GlobalCache_html"><div class="ttname"><a href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache</a></div><div class="ttdoc">A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++...</div><div class="ttdef"><b>Definition:</b> GlobalCache.hpp:374</div></div>
<div class="ttc" id="agroup__DataStructuresGroup_html_ga058ade0497757606713948256728c6db"><div class="ttname"><a href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">apply</a></div><div class="ttdeci">auto apply(F &amp;&amp;f, const ObservationBox&lt; ComputeTagsList, DataBoxType &gt; &amp;observation_box, Args &amp;&amp;... args)</div><div class="ttdoc">Apply the function object f using its nested argument_tags list of tags.</div><div class="ttdef"><b>Definition:</b> ObservationBox.hpp:182</div></div>
<div class="ttc" id="agroup__ParallelGroup_html_gaeee02b1e4faf8051fe703e6b9adada0f"><div class="ttname"><a href="group__ParallelGroup.html#gaeee02b1e4faf8051fe703e6b9adada0f">Parallel::get_parallel_component</a></div><div class="ttdeci">auto get_parallel_component(GlobalCache&lt; Metavariables &gt; &amp;cache) -&gt; Parallel::proxy_from_parallel_component&lt; GlobalCache_detail::get_component_if_mocked&lt; typename Metavariables::component_list, ParallelComponentTag &gt; &gt; &amp;</div><div class="ttdoc">Access the Charm++ proxy associated with a ParallelComponent.</div><div class="ttdef"><b>Definition:</b> GlobalCache.hpp:835</div></div>
<div class="ttc" id="anamespaceActionTesting_html_a645bd6af028059c31bced3807764827e"><div class="ttname"><a href="namespaceActionTesting.html#a645bd6af028059c31bced3807764827e">ActionTesting::cache</a></div><div class="ttdeci">Parallel::GlobalCache&lt; Metavariables &gt; &amp; cache(MockRuntimeSystem&lt; Metavariables &gt; &amp;runner, const ArrayIndex &amp;array_index)</div><div class="ttdoc">Returns the GlobalCache of Component with index array_index.</div><div class="ttdef"><b>Definition:</b> MockRuntimeSystemFreeFunctions.hpp:379</div></div>
</div><!-- fragment --><p >Let us assume we cannot use the component <code>ComponentB</code> in our test and that we need to mock it. We do so using the type alias <code>component_being_mocked</code> in the mock component:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Metavariables&gt;</div>
<div class="line"><span class="keyword">struct </span>ComponentBMock {</div>
<div class="line">  <span class="keyword">using</span> metavariables = Metavariables;</div>
<div class="line">  <span class="keyword">using</span> chare_type = <a class="code hl_struct" href="structActionTesting_1_1MockArrayChare.html">ActionTesting::MockArrayChare</a>;</div>
<div class="line">  <span class="keyword">using</span> array_index = size_t;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">using</span> component_being_mocked = ComponentB&lt;Metavariables&gt;;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">using</span> phase_dependent_action_list = tmpl::list&lt;</div>
<div class="line">      <a class="code hl_struct" href="structParallel_1_1PhaseActions.html">Parallel::PhaseActions</a>&lt;<a class="code hl_enumvalue" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a61bcd96a2c1f8026527cbf2019d6e9a4">Parallel::Phase::Initialization</a>,</div>
<div class="line">                             tmpl::list&lt;ActionTesting::InitializeDataBox&lt;</div>
<div class="line">                                 <a class="code hl_typedef" href="group__DataBoxGroup.html#ga3dc674ba575ece4a8be1c23fa6c2cdcb">db::AddSimpleTags&lt;ValueTag&gt;</a>&gt;&gt;&gt;,</div>
<div class="line">      <a class="code hl_struct" href="structParallel_1_1PhaseActions.html">Parallel::PhaseActions&lt;Parallel::Phase::Testing, tmpl::list&lt;&gt;</a>&gt;&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p >When creating the runner <code>ComponentBMock</code> is emplaced:</p>
<div class="fragment"><div class="line">  <a class="code hl_function" href="namespaceActionTesting.html#ab37cd694032cbb267f845a5485103af0">ActionTesting::emplace_component_and_initialize</a>&lt;</div>
<div class="line">      ComponentBMock&lt;Metavariables&gt;&gt;(&amp;runner, 0, {0});</div>
<div class="ttc" id="anamespaceActionTesting_html_ab37cd694032cbb267f845a5485103af0"><div class="ttname"><a href="namespaceActionTesting.html#ab37cd694032cbb267f845a5485103af0">ActionTesting::emplace_component_and_initialize</a></div><div class="ttdeci">void emplace_component_and_initialize(const gsl::not_null&lt; MockRuntimeSystem&lt; typename Component::metavariables &gt; * &gt; runner, const typename Component::array_index &amp;array_index, const typename detail::get_initialization&lt; Component &gt;::InitialValues &amp;initial_values, Options &amp;&amp;... opts)</div><div class="ttdoc">Emplaces a distributed object with index array_index into the parallel component Component....</div><div class="ttdef"><b>Definition:</b> MockRuntimeSystemFreeFunctions.hpp:100</div></div>
</div><!-- fragment --><p >Any checks and function calls into the ATF also use <code>ComponentBMock</code>. For example:</p>
<div class="fragment"><div class="line">  CHECK(not ActionTesting::is_simple_action_queue_empty&lt;component_b_mock&gt;(</div>
<div class="line">      runner, 0));</div>
<div class="line">  ActionTesting::invoke_queued_simple_action&lt;component_b_mock&gt;(</div>
<div class="line">      make_not_null(&amp;runner), 0);</div>
<div class="line">  CHECK(ActionTesting::get_databox_tag&lt;component_b_mock, ValueTag&gt;(runner, 0) ==</div>
<div class="line">        5);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md398"></a>
Const global cache tags</h3>
<p >Actions sometimes need tags/items to be placed into the <code><a class="el" href="classParallel_1_1GlobalCache.html" title="A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++...">Parallel::GlobalCache</a></code>. Once the list of tags for the global cache has been assembled, the associated objects need to be inserted. This is done using the constructor of the <code><a class="el" href="classActionTesting_1_1MockRuntimeSystem.html" title="A class that mocks the infrastructure needed to run actions. It simulates message passing using the i...">ActionTesting::MockRuntimeSystem</a></code>. For example, consider the tags:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ValueTag : <a class="code hl_struct" href="structdb_1_1SimpleTag.html">db::SimpleTag</a> {</div>
<div class="line">  <span class="keyword">using</span> type = int;</div>
<div class="line">  <span class="keyword">static</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> <a class="code hl_function" href="group__PrettyTypeGroup.html#gac698d0d763b59b714fca6ed84376eb92">name</a>() { <span class="keywordflow">return</span> <span class="stringliteral">&quot;ValueTag&quot;</span>; }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>PassedToB : <a class="code hl_struct" href="structdb_1_1SimpleTag.html">db::SimpleTag</a> {</div>
<div class="line">  <span class="keyword">using</span> type = double;</div>
<div class="line">  <span class="keyword">static</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> <a class="code hl_function" href="group__PrettyTypeGroup.html#gac698d0d763b59b714fca6ed84376eb92">name</a>() { <span class="keywordflow">return</span> <span class="stringliteral">&quot;PassedToB&quot;</span>; }</div>
<div class="line">};</div>
<div class="ttc" id="abasic_string_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a></div></div>
<div class="ttc" id="agroup__PrettyTypeGroup_html_gac698d0d763b59b714fca6ed84376eb92"><div class="ttname"><a href="group__PrettyTypeGroup.html#gac698d0d763b59b714fca6ed84376eb92">pretty_type::name</a></div><div class="ttdeci">std::string name()</div><div class="ttdoc">Return the result of the name() member of a class. If a class doesn't have a name() member,...</div><div class="ttdef"><b>Definition:</b> PrettyType.hpp:733</div></div>
<div class="ttc" id="astructdb_1_1SimpleTag_html"><div class="ttname"><a href="structdb_1_1SimpleTag.html">db::SimpleTag</a></div><div class="ttdoc">Mark a struct as a simple tag by inheriting from this.</div><div class="ttdef"><b>Definition:</b> Tag.hpp:36</div></div>
</div><!-- fragment --><p >These are added into the global cache by, for example, the metavariables:</p>
<div class="fragment"><div class="line">  <span class="keyword">using</span> const_global_cache_tags = tmpl::list&lt;ValueTag, PassedToB&gt;;</div>
</div><!-- fragment --><p >A constructor of <code><a class="el" href="classActionTesting_1_1MockRuntimeSystem.html" title="A class that mocks the infrastructure needed to run actions. It simulates message passing using the i...">ActionTesting::MockRuntimeSystem</a></code> takes a <code><a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs.">tuples::TaggedTuple</a></code> of the const global cache tags. If you know the order of the tags in the <code><a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs.">tuples::TaggedTuple</a></code> you can use the constructor without explicitly specifying the type of the <code><a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs.">tuples::TaggedTuple</a></code> as follows:</p>
<div class="fragment"><div class="line">  <a class="code hl_class" href="classActionTesting_1_1MockRuntimeSystem.html">ActionTesting::MockRuntimeSystem&lt;metavars&gt;</a> runner1{{3, 7.0}};</div>
</div><!-- fragment --><p >If you do not know the order of the tags but know all the tags that are present you can use another constructor where you explicitly specify the <code><a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs.">tuples::TaggedTuple</a></code> type:</p>
<div class="fragment"><div class="line">  <a class="code hl_class" href="classActionTesting_1_1MockRuntimeSystem.html">ActionTesting::MockRuntimeSystem&lt;metavars&gt;</a> runner2{</div>
<div class="line">      <a class="code hl_class" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple&lt;PassedToB, ValueTag&gt;</a>{7.0, 3}};</div>
<div class="ttc" id="aclasstuples_1_1TaggedTuple_html"><div class="ttname"><a href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a></div><div class="ttdoc">An associative container that is indexed by structs.</div><div class="ttdef"><b>Definition:</b> TaggedTuple.hpp:261</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md399"></a>
Mutable global cache tags</h3>
<p >Similarly to const global cache tags, sometimes Actions will want to change the data of a tag in the <code><a class="el" href="classParallel_1_1GlobalCache.html" title="A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++...">Parallel::GlobalCache</a></code>. Consider this tag:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>CacheTag : <a class="code hl_struct" href="structdb_1_1SimpleTag.html">db::SimpleTag</a> {</div>
<div class="line">  <span class="keyword">using</span> type = int;</div>
<div class="line">};</div>
</div><!-- fragment --><p >To indicate that this tag in the global cache may be changed, it is added by, for example, the metavariables:</p>
<div class="fragment"><div class="line">  <span class="keyword">using</span> mutable_global_cache_tags = tmpl::list&lt;CacheTag&gt;;</div>
</div><!-- fragment --><p >Then, exactly like the const global cache tags, the constructor of <code><a class="el" href="classActionTesting_1_1MockRuntimeSystem.html" title="A class that mocks the infrastructure needed to run actions. It simulates message passing using the i...">ActionTesting::MockRuntimeSystem</a></code> takes a <code><a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs.">tuples::TaggedTuple</a></code> of the mutable global cache tags as its <em>second</em> argument. The mutable global cache tags are empty by default so you need not specify a <code><a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs.">tuples::TaggedTuple</a></code> if you don't have any mutable global cache tags. Here is how you would specify zero const global cache tags and one mutable global cache tag:</p>
<div class="fragment"><div class="line">  <a class="code hl_class" href="classActionTesting_1_1MockRuntimeSystem.html">ActionTesting::MockRuntimeSystem&lt;metavars&gt;</a> runner{{}, {0}};</div>
</div><!-- fragment --><p >To mutate a tag in the mutable global cache, use the <code><a class="el" href="group__ParallelGroup.html#ga8fb8fc6f30581c450abecc8258dead3c" title="Mutates non-const data in the cache, by calling Function::apply()">Parallel::mutate</a></code> function just like you would in a charm-aware situation.</p>
<h3><a class="anchor" id="autotoc_md400"></a>
Inbox tags introspection</h3>
<p >The inbox tags can also be retrieved from a component by using the <code><a class="el" href="namespaceActionTesting.html#addd24681d1564521bdce51f7d1769e2e" title="Returns the InboxTag from the parallel component Component with array index array_index.">ActionTesting::get_inbox_tag</a></code> function. Both a const version:</p>
<div class="fragment"><div class="line">      ActionTesting::get_inbox_tag&lt;component, Tags::ValueTag&gt;(runner, 0).at(1)</div>
</div><!-- fragment --><p >and a non-const version exist:</p>
<div class="fragment"><div class="line">  ActionTesting::get_inbox_tag&lt;component, Tags::ValueTag&gt;(</div>
<div class="line">      make_not_null(&amp;runner), 0)</div>
<div class="line">      .clear();</div>
</div><!-- fragment --><p >The non-const version can be used like in the above example to clear or otherwise manipulate the inbox tags. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceActionTesting.html">ActionTesting</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
