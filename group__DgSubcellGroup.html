<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: DG-Subcell</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__DgSubcellGroup.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">DG-Subcell</div></div>
</div><!--header-->
<div class="contents">

<p>Functions and classes specific to the discontinuous Galerkin method supplemented with a finite volume or finite difference subcell limiter. Can also be thought of as a DG-FD hybrid method.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceevolution_1_1dg_1_1subcell"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html">evolution::dg::subcell</a></td></tr>
<tr class="memdesc:namespaceevolution_1_1dg_1_1subcell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a generic finite volume/conservative finite difference subcell limiter. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceevolution_1_1dg_1_1subcell_1_1fv"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell_1_1fv.html">evolution::dg::subcell::fv</a></td></tr>
<tr class="memdesc:namespaceevolution_1_1dg_1_1subcell_1_1fv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code specific to a finite volume subcell limiter. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceevolution_1_1dg_1_1subcell_1_1fd"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell_1_1fd.html">evolution::dg::subcell::fd</a></td></tr>
<tr class="memdesc:namespaceevolution_1_1dg_1_1subcell_1_1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code specific to a conservative finite difference subcell limiter. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceevolution_1_1dg_1_1subcell_1_1fd_1_1Actions"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell_1_1fd_1_1Actions.html">evolution::dg::subcell::fd::Actions</a></td></tr>
<tr class="memdesc:namespaceevolution_1_1dg_1_1subcell_1_1fd_1_1Actions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actions specific to using a finite-difference subcell method. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceevolution_1_1dg_1_1subcell_1_1fd_1_1Tags"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell_1_1fd_1_1Tags.html">evolution::dg::subcell::fd::Tags</a></td></tr>
<tr class="memdesc:namespaceevolution_1_1dg_1_1subcell_1_1fd_1_1Tags"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tags for the DG-subcell finite difference solver <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceevolution_1_1dg_1_1subcell_1_1Tags"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell_1_1Tags.html">evolution::dg::subcell::Tags</a></td></tr>
<tr class="memdesc:namespaceevolution_1_1dg_1_1subcell_1_1Tags"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tags for the DG-subcell solver <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceevolution_1_1dg_1_1subcell_1_1OptionTags"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell_1_1OptionTags.html">evolution::dg::subcell::OptionTags</a></td></tr>
<tr class="memdesc:namespaceevolution_1_1dg_1_1subcell_1_1OptionTags"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option tags for the DG-subcell solver. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceevolution_1_1dg_1_1subcell_1_1Actions"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell_1_1Actions.html">evolution::dg::subcell::Actions</a></td></tr>
<tr class="memdesc:namespaceevolution_1_1dg_1_1subcell_1_1Actions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actions for the DG-subcell hybrid solver. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga97fbd926840d2508e331694db731e18a"><td class="memItemLeft" align="right" valign="top"><a id="ga97fbd926840d2508e331694db731e18a" name="ga97fbd926840d2508e331694db731e18a"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DgSubcellGroup.html#ga97fbd926840d2508e331694db731e18a">evolution::dg::subcell::ActiveGrid</a> { <b>Dg</b>
, <b>Subcell</b>
 }</td></tr>
<tr class="memdesc:ga97fbd926840d2508e331694db731e18a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The grid that is currently being used for the DG-subcell evolution. <br /></td></tr>
<tr class="separator:ga97fbd926840d2508e331694db731e18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga767924c20812627135346a81d8afe292"><td class="memItemLeft" align="right" valign="top"><a id="ga767924c20812627135346a81d8afe292" name="ga767924c20812627135346a81d8afe292"></a>
const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>evolution::dg::subcell::fd::projection_matrix</b> (const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;dg_mesh, size_t subcell_extents, const <a class="el" href="group__SpectralGroup.html#ga7744e520f6d553caf358a6f09f5978c1">Spectral::Quadrature</a> &amp;subcell_quadrature)</td></tr>
<tr class="memdesc:ga767924c20812627135346a81d8afe292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the projection matrix in 1 dimension going from a DG mesh to a conservative finite difference subcell mesh. <br /></td></tr>
<tr class="separator:ga767924c20812627135346a81d8afe292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaf77a36e3a6cec18b40d21285d4f58a"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:gafaf77a36e3a6cec18b40d21285d4f58a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DgSubcellGroup.html#gafaf77a36e3a6cec18b40d21285d4f58a">evolution::dg::subcell::fd::reconstruction_matrix</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;dg_mesh, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;subcell_extents)</td></tr>
<tr class="memdesc:gafaf77a36e3a6cec18b40d21285d4f58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the matrix needed for reconstructing the DG solution from the subcell solution.  <a href="group__DgSubcellGroup.html#gafaf77a36e3a6cec18b40d21285d4f58a">More...</a><br /></td></tr>
<tr class="separator:gafaf77a36e3a6cec18b40d21285d4f58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1d5d396a77a9ae2b20bb092ba3a9cab"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DgSubcellGroup.html#gac1d5d396a77a9ae2b20bb092ba3a9cab">evolution::dg::subcell::fd::projection_matrix</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;dg_mesh, size_t subcell_extents, size_t ghost_zone_size, <a class="el" href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">Side</a> side)</td></tr>
<tr class="memdesc:gac1d5d396a77a9ae2b20bb092ba3a9cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the projection matrix in 1 dimension going from a DG mesh to a conservative finite difference subcell mesh for only the ghost zones.  <a href="group__DgSubcellGroup.html#gac1d5d396a77a9ae2b20bb092ba3a9cab">More...</a><br /></td></tr>
<tr class="separator:gac1d5d396a77a9ae2b20bb092ba3a9cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab892479fc0a3a3c953e6c90ab40fea67"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:gab892479fc0a3a3c953e6c90ab40fea67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDataVector.html">DataVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DgSubcellGroup.html#gab892479fc0a3a3c953e6c90ab40fea67">evolution::dg::subcell::fd::project</a> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;dg_u, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;dg_mesh, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;subcell_extents)</td></tr>
<tr class="memdesc:gab892479fc0a3a3c953e6c90ab40fea67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project the variable <code>dg_u</code> onto the subcell grid with extents <code>subcell_extents</code>.  <a href="group__DgSubcellGroup.html#gab892479fc0a3a3c953e6c90ab40fea67">More...</a><br /></td></tr>
<tr class="separator:gab892479fc0a3a3c953e6c90ab40fea67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ba01d87278470b834d0db77edccbb44"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ga4ba01d87278470b834d0db77edccbb44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DgSubcellGroup.html#ga4ba01d87278470b834d0db77edccbb44">evolution::dg::subcell::fd::project</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt; subcell_u, const <a class="el" href="classDataVector.html">DataVector</a> &amp;dg_u, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;dg_mesh, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;subcell_extents)</td></tr>
<tr class="memdesc:ga4ba01d87278470b834d0db77edccbb44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project the variable <code>dg_u</code> onto the subcell grid with extents <code>subcell_extents</code>.  <a href="group__DgSubcellGroup.html#ga4ba01d87278470b834d0db77edccbb44">More...</a><br /></td></tr>
<tr class="separator:ga4ba01d87278470b834d0db77edccbb44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef83eccd6987782965349afcccceae66"><td class="memTemplParams" colspan="2">template&lt;typename SubcellTagList , typename DgTagList , size_t Dim&gt; </td></tr>
<tr class="memitem:gaef83eccd6987782965349afcccceae66"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DgSubcellGroup.html#gaef83eccd6987782965349afcccceae66">evolution::dg::subcell::fd::project</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; SubcellTagList &gt; * &gt; subcell_u, const Variables&lt; DgTagList &gt; &amp;dg_u, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;dg_mesh, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;subcell_extents)</td></tr>
<tr class="memdesc:gaef83eccd6987782965349afcccceae66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project the variable <code>dg_u</code> onto the subcell grid with extents <code>subcell_extents</code>.  <a href="group__DgSubcellGroup.html#gaef83eccd6987782965349afcccceae66">More...</a><br /></td></tr>
<tr class="separator:gaef83eccd6987782965349afcccceae66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcbcd879f0fb98eb8751bb0d06efd623"><td class="memTemplParams" colspan="2">template&lt;typename TagList , size_t Dim&gt; </td></tr>
<tr class="memitem:gadcbcd879f0fb98eb8751bb0d06efd623"><td class="memTemplItemLeft" align="right" valign="top">Variables&lt; TagList &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DgSubcellGroup.html#gadcbcd879f0fb98eb8751bb0d06efd623">evolution::dg::subcell::fd::project</a> (const Variables&lt; TagList &gt; &amp;dg_u, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;dg_mesh, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;subcell_extents)</td></tr>
<tr class="memdesc:gadcbcd879f0fb98eb8751bb0d06efd623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project the variable <code>dg_u</code> onto the subcell grid with extents <code>subcell_extents</code>.  <a href="group__DgSubcellGroup.html#gadcbcd879f0fb98eb8751bb0d06efd623">More...</a><br /></td></tr>
<tr class="separator:gadcbcd879f0fb98eb8751bb0d06efd623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf3c14616111b495e7227c45d940d96c"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:gacf3c14616111b495e7227c45d940d96c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDataVector.html">DataVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DgSubcellGroup.html#gacf3c14616111b495e7227c45d940d96c">evolution::dg::subcell::fd::project_to_face</a> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;dg_u, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;dg_mesh, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;subcell_extents, const size_t &amp;face_direction)</td></tr>
<tr class="memdesc:gacf3c14616111b495e7227c45d940d96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project the variable <code>dg_u</code> onto the subcell grid with extents <code>subcell_extents</code>.  <a href="group__DgSubcellGroup.html#gacf3c14616111b495e7227c45d940d96c">More...</a><br /></td></tr>
<tr class="separator:gacf3c14616111b495e7227c45d940d96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafac1388c53bba9804b237ffc8dbc89d1"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:gafac1388c53bba9804b237ffc8dbc89d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DgSubcellGroup.html#gafac1388c53bba9804b237ffc8dbc89d1">evolution::dg::subcell::fd::project_to_face</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt; subcell_u, const <a class="el" href="classDataVector.html">DataVector</a> &amp;dg_u, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;dg_mesh, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;subcell_extents, const size_t &amp;face_direction)</td></tr>
<tr class="memdesc:gafac1388c53bba9804b237ffc8dbc89d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project the variable <code>dg_u</code> onto the subcell grid with extents <code>subcell_extents</code>.  <a href="group__DgSubcellGroup.html#gafac1388c53bba9804b237ffc8dbc89d1">More...</a><br /></td></tr>
<tr class="separator:gafac1388c53bba9804b237ffc8dbc89d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22f095e502e2a290b4722d3ec3d3ddbc"><td class="memTemplParams" colspan="2">template&lt;typename SubcellTagList , typename DgTagList , size_t Dim&gt; </td></tr>
<tr class="memitem:ga22f095e502e2a290b4722d3ec3d3ddbc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DgSubcellGroup.html#ga22f095e502e2a290b4722d3ec3d3ddbc">evolution::dg::subcell::fd::project_to_face</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; SubcellTagList &gt; * &gt; subcell_u, const Variables&lt; DgTagList &gt; &amp;dg_u, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;dg_mesh, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;subcell_extents, const size_t &amp;face_direction)</td></tr>
<tr class="memdesc:ga22f095e502e2a290b4722d3ec3d3ddbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project the variable <code>dg_u</code> onto the subcell grid with extents <code>subcell_extents</code>.  <a href="group__DgSubcellGroup.html#ga22f095e502e2a290b4722d3ec3d3ddbc">More...</a><br /></td></tr>
<tr class="separator:ga22f095e502e2a290b4722d3ec3d3ddbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83b7065c40b099a7d8a1d29d1da24892"><td class="memTemplParams" colspan="2">template&lt;typename TagList , size_t Dim&gt; </td></tr>
<tr class="memitem:ga83b7065c40b099a7d8a1d29d1da24892"><td class="memTemplItemLeft" align="right" valign="top">Variables&lt; TagList &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DgSubcellGroup.html#ga83b7065c40b099a7d8a1d29d1da24892">evolution::dg::subcell::fd::project_to_face</a> (const Variables&lt; TagList &gt; &amp;dg_u, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;dg_mesh, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;subcell_extents, const size_t &amp;face_direction)</td></tr>
<tr class="memdesc:ga83b7065c40b099a7d8a1d29d1da24892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project the variable <code>dg_u</code> onto the subcell grid with extents <code>subcell_extents</code>.  <a href="group__DgSubcellGroup.html#ga83b7065c40b099a7d8a1d29d1da24892">More...</a><br /></td></tr>
<tr class="separator:ga83b7065c40b099a7d8a1d29d1da24892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b33efc5ccf1316e849aeea781aa914c"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ga6b33efc5ccf1316e849aeea781aa914c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDataVector.html">DataVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DgSubcellGroup.html#ga6b33efc5ccf1316e849aeea781aa914c">evolution::dg::subcell::fd::reconstruct</a> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;subcell_u_times_projected_det_jac, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;dg_mesh, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;subcell_extents, <a class="el" href="namespaceevolution_1_1dg_1_1subcell_1_1fd.html#a4797048a3224325369715aa4977f6d5d">ReconstructionMethod</a> reconstruction_method)</td></tr>
<tr class="memdesc:ga6b33efc5ccf1316e849aeea781aa914c"><td class="mdescLeft">&#160;</td><td class="mdescRight">reconstruct the variable <code>subcell_u_times_projected_det_jac</code> onto the DG grid <code>dg_mesh</code>.  <a href="group__DgSubcellGroup.html#ga6b33efc5ccf1316e849aeea781aa914c">More...</a><br /></td></tr>
<tr class="separator:ga6b33efc5ccf1316e849aeea781aa914c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54fc65d00c26154fbb82531fe7e678f8"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ga54fc65d00c26154fbb82531fe7e678f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DgSubcellGroup.html#ga54fc65d00c26154fbb82531fe7e678f8">evolution::dg::subcell::fd::reconstruct</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt; dg_u, const <a class="el" href="classDataVector.html">DataVector</a> &amp;subcell_u_times_projected_det_jac, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;dg_mesh, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;subcell_extents, <a class="el" href="namespaceevolution_1_1dg_1_1subcell_1_1fd.html#a4797048a3224325369715aa4977f6d5d">ReconstructionMethod</a> reconstruction_method)</td></tr>
<tr class="memdesc:ga54fc65d00c26154fbb82531fe7e678f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">reconstruct the variable <code>subcell_u_times_projected_det_jac</code> onto the DG grid <code>dg_mesh</code>.  <a href="group__DgSubcellGroup.html#ga54fc65d00c26154fbb82531fe7e678f8">More...</a><br /></td></tr>
<tr class="separator:ga54fc65d00c26154fbb82531fe7e678f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga587959da4e6c1ce40ff80318f4c8b2e4"><td class="memTemplParams" colspan="2">template&lt;typename SubcellTagList , typename DgTagList , size_t Dim&gt; </td></tr>
<tr class="memitem:ga587959da4e6c1ce40ff80318f4c8b2e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DgSubcellGroup.html#ga587959da4e6c1ce40ff80318f4c8b2e4">evolution::dg::subcell::fd::reconstruct</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; DgTagList &gt; * &gt; dg_u, const Variables&lt; SubcellTagList &gt; &amp;subcell_u, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;dg_mesh, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;subcell_extents, const <a class="el" href="namespaceevolution_1_1dg_1_1subcell_1_1fd.html#a4797048a3224325369715aa4977f6d5d">ReconstructionMethod</a> reconstruction_method)</td></tr>
<tr class="memdesc:ga587959da4e6c1ce40ff80318f4c8b2e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">reconstruct the variable <code>subcell_u_times_projected_det_jac</code> onto the DG grid <code>dg_mesh</code>.  <a href="group__DgSubcellGroup.html#ga587959da4e6c1ce40ff80318f4c8b2e4">More...</a><br /></td></tr>
<tr class="separator:ga587959da4e6c1ce40ff80318f4c8b2e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ab01c9d966d6e9956200efb0ae58f67"><td class="memTemplParams" colspan="2">template&lt;typename TagList , size_t Dim&gt; </td></tr>
<tr class="memitem:ga3ab01c9d966d6e9956200efb0ae58f67"><td class="memTemplItemLeft" align="right" valign="top">Variables&lt; TagList &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DgSubcellGroup.html#ga3ab01c9d966d6e9956200efb0ae58f67">evolution::dg::subcell::fd::reconstruct</a> (const Variables&lt; TagList &gt; &amp;subcell_u, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;dg_mesh, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;subcell_extents, const <a class="el" href="namespaceevolution_1_1dg_1_1subcell_1_1fd.html#a4797048a3224325369715aa4977f6d5d">ReconstructionMethod</a> reconstruction_method)</td></tr>
<tr class="memdesc:ga3ab01c9d966d6e9956200efb0ae58f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">reconstruct the variable <code>subcell_u_times_projected_det_jac</code> onto the DG grid <code>dg_mesh</code>.  <a href="group__DgSubcellGroup.html#ga3ab01c9d966d6e9956200efb0ae58f67">More...</a><br /></td></tr>
<tr class="separator:ga3ab01c9d966d6e9956200efb0ae58f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Functions and classes specific to the discontinuous Galerkin method supplemented with a finite volume or finite difference subcell limiter. Can also be thought of as a DG-FD hybrid method. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab892479fc0a3a3c953e6c90ab40fea67" name="gab892479fc0a3a3c953e6c90ab40fea67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab892479fc0a3a3c953e6c90ab40fea67">&#9670;&nbsp;</a></span>project() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataVector.html">DataVector</a> evolution::dg::subcell::fd::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dg_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dg_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_extents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project the variable <code>dg_u</code> onto the subcell grid with extents <code>subcell_extents</code>. </p>
<dl class="section note"><dt>Note</dt><dd>In the return-by-<code><a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a></code> with <code>Variables</code> interface, the <code>SubcellTagList</code> and the <code>DgtagList</code> must be the same when all tag prefixes are removed. </dd></dl>

</div>
</div>
<a id="gaef83eccd6987782965349afcccceae66" name="gaef83eccd6987782965349afcccceae66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef83eccd6987782965349afcccceae66">&#9670;&nbsp;</a></span>project() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SubcellTagList , typename DgTagList , size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void evolution::dg::subcell::fd::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; SubcellTagList &gt; * &gt;&#160;</td>
          <td class="paramname"><em>subcell_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Variables&lt; DgTagList &gt; &amp;&#160;</td>
          <td class="paramname"><em>dg_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dg_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_extents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project the variable <code>dg_u</code> onto the subcell grid with extents <code>subcell_extents</code>. </p>
<dl class="section note"><dt>Note</dt><dd>In the return-by-<code><a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a></code> with <code>Variables</code> interface, the <code>SubcellTagList</code> and the <code>DgtagList</code> must be the same when all tag prefixes are removed. </dd></dl>

</div>
</div>
<a id="gadcbcd879f0fb98eb8751bb0d06efd623" name="gadcbcd879f0fb98eb8751bb0d06efd623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcbcd879f0fb98eb8751bb0d06efd623">&#9670;&nbsp;</a></span>project() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TagList , size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Variables&lt; TagList &gt; evolution::dg::subcell::fd::project </td>
          <td>(</td>
          <td class="paramtype">const Variables&lt; TagList &gt; &amp;&#160;</td>
          <td class="paramname"><em>dg_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dg_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_extents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project the variable <code>dg_u</code> onto the subcell grid with extents <code>subcell_extents</code>. </p>
<dl class="section note"><dt>Note</dt><dd>In the return-by-<code><a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a></code> with <code>Variables</code> interface, the <code>SubcellTagList</code> and the <code>DgtagList</code> must be the same when all tag prefixes are removed. </dd></dl>

</div>
</div>
<a id="ga4ba01d87278470b834d0db77edccbb44" name="ga4ba01d87278470b834d0db77edccbb44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ba01d87278470b834d0db77edccbb44">&#9670;&nbsp;</a></span>project() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void evolution::dg::subcell::fd::project </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt;&#160;</td>
          <td class="paramname"><em>subcell_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dg_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dg_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_extents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project the variable <code>dg_u</code> onto the subcell grid with extents <code>subcell_extents</code>. </p>
<dl class="section note"><dt>Note</dt><dd>In the return-by-<code><a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a></code> with <code>Variables</code> interface, the <code>SubcellTagList</code> and the <code>DgtagList</code> must be the same when all tag prefixes are removed. </dd></dl>

</div>
</div>
<a id="gacf3c14616111b495e7227c45d940d96c" name="gacf3c14616111b495e7227c45d940d96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf3c14616111b495e7227c45d940d96c">&#9670;&nbsp;</a></span>project_to_face() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataVector.html">DataVector</a> evolution::dg::subcell::fd::project_to_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dg_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dg_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>face_direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project the variable <code>dg_u</code> onto the subcell grid with extents <code>subcell_extents</code>. </p>
<dl class="section note"><dt>Note</dt><dd>In the return-by-<code><a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a></code> with <code>Variables</code> interface, the <code>SubcellTagList</code> and the <code>DgtagList</code> must be the same when all tag prefixes are removed. </dd></dl>

</div>
</div>
<a id="ga22f095e502e2a290b4722d3ec3d3ddbc" name="ga22f095e502e2a290b4722d3ec3d3ddbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22f095e502e2a290b4722d3ec3d3ddbc">&#9670;&nbsp;</a></span>project_to_face() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SubcellTagList , typename DgTagList , size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void evolution::dg::subcell::fd::project_to_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; SubcellTagList &gt; * &gt;&#160;</td>
          <td class="paramname"><em>subcell_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Variables&lt; DgTagList &gt; &amp;&#160;</td>
          <td class="paramname"><em>dg_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dg_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>face_direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project the variable <code>dg_u</code> onto the subcell grid with extents <code>subcell_extents</code>. </p>
<dl class="section note"><dt>Note</dt><dd>In the return-by-<code><a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a></code> with <code>Variables</code> interface, the <code>SubcellTagList</code> and the <code>DgtagList</code> must be the same when all tag prefixes are removed. </dd></dl>

</div>
</div>
<a id="ga83b7065c40b099a7d8a1d29d1da24892" name="ga83b7065c40b099a7d8a1d29d1da24892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83b7065c40b099a7d8a1d29d1da24892">&#9670;&nbsp;</a></span>project_to_face() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TagList , size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Variables&lt; TagList &gt; evolution::dg::subcell::fd::project_to_face </td>
          <td>(</td>
          <td class="paramtype">const Variables&lt; TagList &gt; &amp;&#160;</td>
          <td class="paramname"><em>dg_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dg_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>face_direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project the variable <code>dg_u</code> onto the subcell grid with extents <code>subcell_extents</code>. </p>
<dl class="section note"><dt>Note</dt><dd>In the return-by-<code><a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a></code> with <code>Variables</code> interface, the <code>SubcellTagList</code> and the <code>DgtagList</code> must be the same when all tag prefixes are removed. </dd></dl>

</div>
</div>
<a id="gafac1388c53bba9804b237ffc8dbc89d1" name="gafac1388c53bba9804b237ffc8dbc89d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafac1388c53bba9804b237ffc8dbc89d1">&#9670;&nbsp;</a></span>project_to_face() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void evolution::dg::subcell::fd::project_to_face </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt;&#160;</td>
          <td class="paramname"><em>subcell_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dg_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dg_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>face_direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project the variable <code>dg_u</code> onto the subcell grid with extents <code>subcell_extents</code>. </p>
<dl class="section note"><dt>Note</dt><dd>In the return-by-<code><a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a></code> with <code>Variables</code> interface, the <code>SubcellTagList</code> and the <code>DgtagList</code> must be the same when all tag prefixes are removed. </dd></dl>

</div>
</div>
<a id="gac1d5d396a77a9ae2b20bb092ba3a9cab" name="gac1d5d396a77a9ae2b20bb092ba3a9cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1d5d396a77a9ae2b20bb092ba3a9cab">&#9670;&nbsp;</a></span>projection_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a> &amp; evolution::dg::subcell::fd::projection_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dg_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>subcell_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ghost_zone_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">Side</a>&#160;</td>
          <td class="paramname"><em>side</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the projection matrix in 1 dimension going from a DG mesh to a conservative finite difference subcell mesh for only the ghost zones. </p>
<p >This is used when a neighbor sends DG volume data and we need to switch to FD. In this case we need to project the DG volume data onto the ghost zone cells.</p>
<dl class="section note"><dt>Note</dt><dd>Currently assumes a max ghost zone size of <code>5</code> and a minimum ghost zone size of 2. </dd></dl>

</div>
</div>
<a id="ga6b33efc5ccf1316e849aeea781aa914c" name="ga6b33efc5ccf1316e849aeea781aa914c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b33efc5ccf1316e849aeea781aa914c">&#9670;&nbsp;</a></span>reconstruct() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataVector.html">DataVector</a> evolution::dg::subcell::fd::reconstruct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>subcell_u_times_projected_det_jac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dg_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceevolution_1_1dg_1_1subcell_1_1fd.html#a4797048a3224325369715aa4977f6d5d">ReconstructionMethod</a>&#160;</td>
          <td class="paramname"><em>reconstruction_method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reconstruct the variable <code>subcell_u_times_projected_det_jac</code> onto the DG grid <code>dg_mesh</code>. </p>
<p >In general we wish that the reconstruction operator is the pseudo-inverse of the projection operator. On curved meshes this means we either need to compute a (time-dependent) reconstruction and projection matrix on each DG element, or we expand the determinant of the Jacobian on the basis, accepting the aliasing errors from that. We accept the aliasing errors in favor of the significantly reduced computational overhead. This means that the projection and reconstruction operators are only inverses of each other if both operate on \(u J\) where \(u\) is the variable being projected and \(J\) is the determinant of the Jacobian. That is, the matrices are guaranteed to satisfy \(\mathcal{R}(\mathcal{P}(u J))=u J\). If the mesh is regular Cartesian, then this isn't an issue. Furthermore, if we reconstruct \(uJ/\mathcal{P}(J)\) we again recover the exact DG solution. Doing the latter has the advantage that, in general, we are ideally projecting to the subcells much more often than reconstructing from them (a statement that we would rather use DG more than the subcells). </p>

</div>
</div>
<a id="ga587959da4e6c1ce40ff80318f4c8b2e4" name="ga587959da4e6c1ce40ff80318f4c8b2e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga587959da4e6c1ce40ff80318f4c8b2e4">&#9670;&nbsp;</a></span>reconstruct() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SubcellTagList , typename DgTagList , size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void evolution::dg::subcell::fd::reconstruct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; DgTagList &gt; * &gt;&#160;</td>
          <td class="paramname"><em>dg_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Variables&lt; SubcellTagList &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dg_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceevolution_1_1dg_1_1subcell_1_1fd.html#a4797048a3224325369715aa4977f6d5d">ReconstructionMethod</a>&#160;</td>
          <td class="paramname"><em>reconstruction_method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reconstruct the variable <code>subcell_u_times_projected_det_jac</code> onto the DG grid <code>dg_mesh</code>. </p>
<p >In general we wish that the reconstruction operator is the pseudo-inverse of the projection operator. On curved meshes this means we either need to compute a (time-dependent) reconstruction and projection matrix on each DG element, or we expand the determinant of the Jacobian on the basis, accepting the aliasing errors from that. We accept the aliasing errors in favor of the significantly reduced computational overhead. This means that the projection and reconstruction operators are only inverses of each other if both operate on \(u J\) where \(u\) is the variable being projected and \(J\) is the determinant of the Jacobian. That is, the matrices are guaranteed to satisfy \(\mathcal{R}(\mathcal{P}(u J))=u J\). If the mesh is regular Cartesian, then this isn't an issue. Furthermore, if we reconstruct \(uJ/\mathcal{P}(J)\) we again recover the exact DG solution. Doing the latter has the advantage that, in general, we are ideally projecting to the subcells much more often than reconstructing from them (a statement that we would rather use DG more than the subcells). </p>

</div>
</div>
<a id="ga3ab01c9d966d6e9956200efb0ae58f67" name="ga3ab01c9d966d6e9956200efb0ae58f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ab01c9d966d6e9956200efb0ae58f67">&#9670;&nbsp;</a></span>reconstruct() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TagList , size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Variables&lt; TagList &gt; evolution::dg::subcell::fd::reconstruct </td>
          <td>(</td>
          <td class="paramtype">const Variables&lt; TagList &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dg_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceevolution_1_1dg_1_1subcell_1_1fd.html#a4797048a3224325369715aa4977f6d5d">ReconstructionMethod</a>&#160;</td>
          <td class="paramname"><em>reconstruction_method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reconstruct the variable <code>subcell_u_times_projected_det_jac</code> onto the DG grid <code>dg_mesh</code>. </p>
<p >In general we wish that the reconstruction operator is the pseudo-inverse of the projection operator. On curved meshes this means we either need to compute a (time-dependent) reconstruction and projection matrix on each DG element, or we expand the determinant of the Jacobian on the basis, accepting the aliasing errors from that. We accept the aliasing errors in favor of the significantly reduced computational overhead. This means that the projection and reconstruction operators are only inverses of each other if both operate on \(u J\) where \(u\) is the variable being projected and \(J\) is the determinant of the Jacobian. That is, the matrices are guaranteed to satisfy \(\mathcal{R}(\mathcal{P}(u J))=u J\). If the mesh is regular Cartesian, then this isn't an issue. Furthermore, if we reconstruct \(uJ/\mathcal{P}(J)\) we again recover the exact DG solution. Doing the latter has the advantage that, in general, we are ideally projecting to the subcells much more often than reconstructing from them (a statement that we would rather use DG more than the subcells). </p>

</div>
</div>
<a id="ga54fc65d00c26154fbb82531fe7e678f8" name="ga54fc65d00c26154fbb82531fe7e678f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54fc65d00c26154fbb82531fe7e678f8">&#9670;&nbsp;</a></span>reconstruct() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void evolution::dg::subcell::fd::reconstruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt;&#160;</td>
          <td class="paramname"><em>dg_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>subcell_u_times_projected_det_jac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dg_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceevolution_1_1dg_1_1subcell_1_1fd.html#a4797048a3224325369715aa4977f6d5d">ReconstructionMethod</a>&#160;</td>
          <td class="paramname"><em>reconstruction_method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reconstruct the variable <code>subcell_u_times_projected_det_jac</code> onto the DG grid <code>dg_mesh</code>. </p>
<p >In general we wish that the reconstruction operator is the pseudo-inverse of the projection operator. On curved meshes this means we either need to compute a (time-dependent) reconstruction and projection matrix on each DG element, or we expand the determinant of the Jacobian on the basis, accepting the aliasing errors from that. We accept the aliasing errors in favor of the significantly reduced computational overhead. This means that the projection and reconstruction operators are only inverses of each other if both operate on \(u J\) where \(u\) is the variable being projected and \(J\) is the determinant of the Jacobian. That is, the matrices are guaranteed to satisfy \(\mathcal{R}(\mathcal{P}(u J))=u J\). If the mesh is regular Cartesian, then this isn't an issue. Furthermore, if we reconstruct \(uJ/\mathcal{P}(J)\) we again recover the exact DG solution. Doing the latter has the advantage that, in general, we are ideally projecting to the subcells much more often than reconstructing from them (a statement that we would rather use DG more than the subcells). </p>

</div>
</div>
<a id="gafaf77a36e3a6cec18b40d21285d4f58a" name="gafaf77a36e3a6cec18b40d21285d4f58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafaf77a36e3a6cec18b40d21285d4f58a">&#9670;&nbsp;</a></span>reconstruction_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a> &amp; evolution::dg::subcell::fd::reconstruction_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dg_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_extents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the matrix needed for reconstructing the DG solution from the subcell solution. </p>
<p >Reconstructing the DG solution from the FD solution is a bit more involved than projecting the DG solution to the FD subcells. Denoting the projection operator by \(\mathcal{P}\) and the reconstruction operator by \(\mathcal{R}\), we desire the property</p>
<p class="formulaDsp">
\begin{align*} \mathcal{R}(\mathcal{P}(u_{\breve{\imath}} J_{\breve{\imath}}))=u_{\breve{\imath}} J_{\breve{\imath}}, \end{align*}
</p>
<p >where \(\breve{\imath}\) denotes a grid point on the DG grid, \(u\) is the solution on the DG grid, and \(J\) is the determinant of the Jacobian on the DG grid. We also require that the integral of the conserved variables over the subcells is equal to the integral over the DG element. That is,</p>
<p class="formulaDsp">
\begin{align*} \int_{\Omega}u \,d^3x =\int_{\Omega} \underline{u} \,d^3x \Longrightarrow \int_{\Omega}u J \,d^3\xi=\int_{\Omega} \underline{u} J \,d^3\xi, \end{align*}
</p>
<p >where \(\underline{u}\) is the solution on the subcells. Because the number of subcell points is larger than the number of DG points, we need to solve a constrained linear least squares problem to reconstruct the DG solution from the subcells.</p>
<p >The final reconstruction matrix is given by</p>
<p class="formulaDsp">
\begin{align*} R_{\breve{\jmath}\underline{i}} &amp;=\left\{(2 \mathcal{P}\otimes\mathcal{P})^{-1}2\mathcal{P} - (2 \mathcal{P}\otimes\mathcal{P})^{-1}\vec{w}\left[\mathbf{w}(2 \mathcal{P}\otimes\mathcal{P})^{-1}\vec{w}\right]^{-1}\mathbf{w}(2 \mathcal{P}\otimes\mathcal{P})^{-1}2\mathcal{P} + (2 \mathcal{P}\otimes\mathcal{P})^{-1}\vec{w}\left[\mathbf{w}(2 \mathcal{P}\otimes\mathcal{P})^{-1}\vec{w}\right]^{-1}\vec{\underline{w}} \right\}_{\breve{\jmath}\underline{i}}, \end{align*}
</p>
<p >where \(\vec{w}\) is the vector of integration weights on the DG element, \(\mathbf{w}=w_{\breve{l}}\delta_{\breve{l}\breve{\jmath}}\), and \(\vec{\underline{w}}\) is the vector of integration weights over the subcells. The integration weights \(\vec{\underline{w}}\) on the subcells are those for 6th-order integration on a uniform mesh. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
