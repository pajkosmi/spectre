<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: Parallel Namespace Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceParallel.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Parallel Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Functionality for parallelization.  
<a href="namespaceParallel.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceParallel_1_1InboxInserters"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParallel_1_1InboxInserters.html">InboxInserters</a></td></tr>
<tr class="memdesc:namespaceParallel_1_1InboxInserters"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structs that have <code>insert_into_inbox</code> methods for commonly used cases. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1ArrayIndex.html">ArrayIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array index used for indexing Chare Arrays, mostly an implementation detail.  <a href="structParallel_1_1ArrayIndex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1Callback.html">Callback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract base class, whose derived class holds a function that can be invoked at a later time. The function is intended to be invoked only once.  <a href="classParallel_1_1Callback.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1get__action__list__from__phase__dep__action__list.html">get_action_list_from_phase_dep_action_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Lazy) metafunction to get the action list from a <code><a class="el" href="structParallel_1_1PhaseActions.html" title="List of all the actions to be executed in the specified phase.">PhaseActions</a></code>  <a href="structParallel_1_1get__action__list__from__phase__dep__action__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1get__mutable__cache__tag.html">get_mutable_cache_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1get__parallel__component__from__proxy.html">get_parallel_component_from_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a parallel component from its proxy.  <a href="structParallel_1_1get__parallel__component__from__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1get__parallel__component__from__proxy_3_01Proxy_3_01ParallelComponent_00_01Ts_8_8_8_01_4_01_4.html">get_parallel_component_from_proxy&lt; Proxy&lt; ParallelComponent, Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++ core.  <a href="classParallel_1_1GlobalCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1has__pup__member.html">has_pup_member</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> has a <code>pup</code> member function.  <a href="structParallel_1_1has__pup__member.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__array.html">is_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a SpECTRE Array.  <a href="structParallel_1_1is__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__array__element__proxy.html">is_array_element_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a Charm++ proxy for an array chare element (from indexing into the array chare)  <a href="structParallel_1_1is__array__element__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__array__proxy.html">is_array_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a Charm++ proxy for an array chare (the entire array)  <a href="structParallel_1_1is__array__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__bound__array.html">is_bound_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a ParallelComponent for a Charm++ bound array.  <a href="structParallel_1_1is__bound__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_bound_array&lt; T, std::void_t&lt; typename T::bind_to &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__group.html">is_group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a SpECTRE Group.  <a href="structParallel_1_1is__group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__group__proxy.html">is_group_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a Charm++ proxy for a group chare.  <a href="structParallel_1_1is__group__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__node__group__proxy.html">is_node_group_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a Charm++ proxy for a node group chare.  <a href="structParallel_1_1is__node__group__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__nodegroup.html">is_nodegroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a SpECTRE Nodegroup.  <a href="structParallel_1_1is__nodegroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__pupable.html">is_pupable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if type <code>T</code> has operator| defined for Charm++ serialization.  <a href="structParallel_1_1is__pupable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__singleton.html">is_singleton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a SpECTRE Singleton.  <a href="structParallel_1_1is__singleton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1Main.html">Main</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main function of a Charm++ executable. See <a href="group__ParallelGroup.html#details">the Parallelization documentation</a> for an overview of Metavariables, Phases, and parallel components.  <a href="classParallel_1_1Main.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1MutableCacheTag.html">MutableCacheTag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1MutableGlobalCache.html">MutableGlobalCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Charm++ chare that caches mutable data once per Charm++ core.  <a href="classParallel_1_1MutableGlobalCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1NodeLock.html">NodeLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typesafe wrapper for a lock for synchronization of shared resources on a given node, with safe creation, destruction, and serialization.  <a href="classParallel_1_1NodeLock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1NoSection.html">NoSection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be used instead of a <code><a class="el" href="structParallel_1_1Section.html" title="A subset of chares in a parallel component.">Parallel::Section</a></code> when no section is desired.  <a href="structParallel_1_1NoSection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1PerformAlgorithmCallback.html">PerformAlgorithmCallback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a call to perform_algorithm.  <a href="classParallel_1_1PerformAlgorithmCallback.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1PhaseActions.html">PhaseActions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all the actions to be executed in the specified phase.  <a href="structParallel_1_1PhaseActions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1ReductionData_3_01ReductionDatum_3_01Ts_00_01InvokeCombines_00_01InvokeFinals_92b572618a1ebe21ccf137654ec822ac.html">ReductionData&lt; ReductionDatum&lt; Ts, InvokeCombines, InvokeFinals, InvokeFinalExtraArgsIndices &gt;... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for reducing a possibly heterogeneous collection of types in a single reduction call.  <a href="structParallel_1_1ReductionData_3_01ReductionDatum_3_01Ts_00_01InvokeCombines_00_01InvokeFinals_92b572618a1ebe21ccf137654ec822ac.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1ReductionDatum.html">ReductionDatum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data to be reduced, and invokables to be called whenever two reduction messages are combined and after the reduction has been completed.  <a href="structParallel_1_1ReductionDatum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1ResourceInfo.html">ResourceInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds resource info for all singletons and for avoiding placing array elements/singletons on the global proc 0.  <a href="structParallel_1_1ResourceInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1Section.html">Section</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A subset of chares in a parallel component.  <a href="structParallel_1_1Section.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1SimpleActionCallback.html">SimpleActionCallback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a call to a simple action and its arguments. Can be invoked only once.  <a href="classParallel_1_1SimpleActionCallback.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1SimpleActionCallback_3_01SimpleAction_00_01Proxy_01_4.html">SimpleActionCallback&lt; SimpleAction, Proxy &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a call to a simple action without arguments.  <a href="classParallel_1_1SimpleActionCallback_3_01SimpleAction_00_01Proxy_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1SingletonInfoHolder.html">SingletonInfoHolder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds resource info for a single singleton component.  <a href="structParallel_1_1SingletonInfoHolder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1SingletonPack.html">SingletonPack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1SingletonPack_3_01tmpl_1_1list_3_01ParallelComponents_8_8_8_01_4_01_4.html">SingletonPack&lt; tmpl::list&lt; ParallelComponents... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds options for a group of singleton components.  <a href="structParallel_1_1SingletonPack_3_01tmpl_1_1list_3_01ParallelComponents_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af78863455c4051f7335d78eaa9c5c4e8"><td class="memItemLeft" align="right" valign="top"><a id="af78863455c4051f7335d78eaa9c5c4e8" name="af78863455c4051f7335d78eaa9c5c4e8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterable_action_return_t</b> = <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; <a class="el" href="namespaceParallel.html#af31fff079d116e958890e079a35955cf">AlgorithmExecution</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; size_t &gt; &gt;</td></tr>
<tr class="memdesc:af78863455c4051f7335d78eaa9c5c4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for iterable actions. The <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a> can be used to specify the index of the action to be called next in the phase dependent action list. Passing std::nullopt will execute the next action in the list. <br /></td></tr>
<tr class="separator:af78863455c4051f7335d78eaa9c5c4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af00caa6f5b7401a8e0235898224263"><td class="memItemLeft" align="right" valign="top"><a id="a5af00caa6f5b7401a8e0235898224263" name="a5af00caa6f5b7401a8e0235898224263"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ArrayIndex1D</b> = <a class="el" href="structParallel_1_1ArrayIndex.html">ArrayIndex</a>&lt; CkIndex1D &gt;</td></tr>
<tr class="separator:a5af00caa6f5b7401a8e0235898224263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708856568c7f6b3cf04998b8d3b313b5"><td class="memItemLeft" align="right" valign="top"><a id="a708856568c7f6b3cf04998b8d3b313b5" name="a708856568c7f6b3cf04998b8d3b313b5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ArrayIndex2D</b> = <a class="el" href="structParallel_1_1ArrayIndex.html">ArrayIndex</a>&lt; CkIndex2D &gt;</td></tr>
<tr class="separator:a708856568c7f6b3cf04998b8d3b313b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e74268e437cfcbd24c65c9f483bd7b"><td class="memItemLeft" align="right" valign="top"><a id="a51e74268e437cfcbd24c65c9f483bd7b" name="a51e74268e437cfcbd24c65c9f483bd7b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ArrayIndex3D</b> = <a class="el" href="structParallel_1_1ArrayIndex.html">ArrayIndex</a>&lt; CkIndex3D &gt;</td></tr>
<tr class="separator:a51e74268e437cfcbd24c65c9f483bd7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2716038682076ad43ca77c3e516db722"><td class="memItemLeft" align="right" valign="top"><a id="a2716038682076ad43ca77c3e516db722" name="a2716038682076ad43ca77c3e516db722"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ArrayIndex4D</b> = <a class="el" href="structParallel_1_1ArrayIndex.html">ArrayIndex</a>&lt; CkIndex4D &gt;</td></tr>
<tr class="separator:a2716038682076ad43ca77c3e516db722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec254431cf1a28459a5baea688877fc"><td class="memItemLeft" align="right" valign="top"><a id="a5ec254431cf1a28459a5baea688877fc" name="a5ec254431cf1a28459a5baea688877fc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ArrayIndex5D</b> = <a class="el" href="structParallel_1_1ArrayIndex.html">ArrayIndex</a>&lt; CkIndex5D &gt;</td></tr>
<tr class="separator:a5ec254431cf1a28459a5baea688877fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2d628261f946a0f57d2e9cb90efe3d"><td class="memItemLeft" align="right" valign="top"><a id="a0b2d628261f946a0f57d2e9cb90efe3d" name="a0b2d628261f946a0f57d2e9cb90efe3d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ArrayIndex6D</b> = <a class="el" href="structParallel_1_1ArrayIndex.html">ArrayIndex</a>&lt; CkIndex6D &gt;</td></tr>
<tr class="separator:a0b2d628261f946a0f57d2e9cb90efe3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae918917e798cb6dd36a6cca9ede77616"><td class="memTemplParams" colspan="2">
template&lt;class ActionsList &gt; </td></tr>
<tr class="memitem:gae918917e798cb6dd36a6cca9ede77616"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_inbox_tags</b> = tmpl::remove_duplicates&lt; tmpl::join&lt; tmpl::transform&lt; ActionsList, detail::get_inbox_tags_from_action&lt; tmpl::_1 &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gae918917e798cb6dd36a6cca9ede77616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of Actions, get a list of the unique inbox tags. <br /></td></tr>
<tr class="separator:gae918917e798cb6dd36a6cca9ede77616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2c3e5b7084f5cb31c8c5cc7595349a6"><td class="memTemplParams" colspan="2">
template&lt;class ActionsList &gt; </td></tr>
<tr class="memitem:gab2c3e5b7084f5cb31c8c5cc7595349a6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_const_global_cache_tags_from_actions</b> = tmpl::remove_duplicates&lt; tmpl::join&lt; tmpl::transform&lt; ActionsList, detail::get_const_global_cache_tags_from_parallel_struct&lt; tmpl::_1 &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gab2c3e5b7084f5cb31c8c5cc7595349a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of Actions, get a list of the unique tags specified in the actions' <code>const_global_cache_tags</code> aliases. <br /></td></tr>
<tr class="separator:gab2c3e5b7084f5cb31c8c5cc7595349a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54c47960b4397660c8ece4b63da46558"><td class="memTemplParams" colspan="2">
template&lt;class ActionsList &gt; </td></tr>
<tr class="memitem:ga54c47960b4397660c8ece4b63da46558"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_mutable_global_cache_tags_from_actions</b> = tmpl::remove_duplicates&lt; tmpl::join&lt; tmpl::transform&lt; ActionsList, detail::get_mutable_global_cache_tags_from_parallel_struct&lt; tmpl::_1 &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga54c47960b4397660c8ece4b63da46558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of Actions, get a list of the unique tags specified in the actions' <code>mutable_global_cache_tags</code> aliases. <br /></td></tr>
<tr class="separator:ga54c47960b4397660c8ece4b63da46558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03e3053314568ebf144ba895c04ead0e"><td class="memTemplParams" colspan="2">
template&lt;typename Metavariables &gt; </td></tr>
<tr class="memitem:ga03e3053314568ebf144ba895c04ead0e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_const_global_cache_tags</b> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::list&lt; typename detail::get_const_global_cache_tags_from_parallel_struct&lt; Metavariables &gt;::type, tmpl::transform&lt; typename Metavariables::component_list, detail::get_const_global_cache_tags_from_parallel_struct&lt; tmpl::_1 &gt; &gt;, tmpl::transform&lt; typename Metavariables::component_list, detail::get_const_global_cache_tags_from_pdal&lt; tmpl::_1 &gt; &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga03e3053314568ebf144ba895c04ead0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the metavariables, get a list of the unique tags that will specify the items in the <a class="el" href="classParallel_1_1GlobalCache.html" title="A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++...">GlobalCache</a>. <br /></td></tr>
<tr class="separator:ga03e3053314568ebf144ba895c04ead0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab10d351ad8ecf07b1ec23dbad2e70a3d"><td class="memTemplParams" colspan="2">
template&lt;typename Metavariables &gt; </td></tr>
<tr class="memitem:gab10d351ad8ecf07b1ec23dbad2e70a3d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_mutable_global_cache_tags</b> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::list&lt; typename detail::get_mutable_global_cache_tags_from_parallel_struct&lt; Metavariables &gt;::type, tmpl::transform&lt; typename Metavariables::component_list, detail::get_mutable_global_cache_tags_from_parallel_struct&lt; tmpl::_1 &gt; &gt;, tmpl::transform&lt; typename Metavariables::component_list, detail::get_mutable_global_cache_tags_from_pdal&lt; tmpl::_1 &gt; &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gab10d351ad8ecf07b1ec23dbad2e70a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the metavariables, get a list of the unique tags that will specify the mutable items in the <a class="el" href="classParallel_1_1GlobalCache.html" title="A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++...">GlobalCache</a>. <br /></td></tr>
<tr class="separator:gab10d351ad8ecf07b1ec23dbad2e70a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38dc75a2988c215c842aa1192219b192"><td class="memTemplParams" colspan="2"><a id="a38dc75a2988c215c842aa1192219b192" name="a38dc75a2988c215c842aa1192219b192"></a>
template&lt;typename Metavariables &gt; </td></tr>
<tr class="memitem:a38dc75a2988c215c842aa1192219b192"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_mutable_global_cache_tag_storage</b> = tmpl::transform&lt; <a class="el" href="group__ParallelGroup.html#gab10d351ad8ecf07b1ec23dbad2e70a3d">get_mutable_global_cache_tags</a>&lt; Metavariables &gt;, <a class="el" href="structParallel_1_1get__mutable__cache__tag.html">get_mutable_cache_tag</a>&lt; tmpl::_1 &gt; &gt;</td></tr>
<tr class="separator:a38dc75a2988c215c842aa1192219b192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5fb42f8eaf4da2707e32ed37ecf4e66"><td class="memTemplParams" colspan="2">
template&lt;typename PhaseDepActionList &gt; </td></tr>
<tr class="memitem:gac5fb42f8eaf4da2707e32ed37ecf4e66"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_initialization_actions_list</b> = tmpl::flatten&lt; tmpl::transform&lt; PhaseDepActionList, detail::get_initialization_actions_list&lt; tmpl::_1 &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gac5fb42f8eaf4da2707e32ed37ecf4e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the phase dependent action list, return the list of actions in the Initialization phase (or an empty list if the Initialization phase is absent from the phase dependent action list) <br /></td></tr>
<tr class="separator:gac5fb42f8eaf4da2707e32ed37ecf4e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c2c630360df51b5cc4cf0f7fda6e87d"><td class="memTemplParams" colspan="2">
template&lt;typename InitializationActionsList &gt; </td></tr>
<tr class="memitem:ga7c2c630360df51b5cc4cf0f7fda6e87d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_simple_tags_from_options</b> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::transform&lt; InitializationActionsList, detail::get_simple_tags_from_options_from_action&lt; tmpl::_1 &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga7c2c630360df51b5cc4cf0f7fda6e87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of initialization actions, returns a list of the unique simple_tags_from_options for all the actions. <br /></td></tr>
<tr class="separator:ga7c2c630360df51b5cc4cf0f7fda6e87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a9af2d9b7484c86ea4e9594fd7c8a2f"><td class="memTemplParams" colspan="2">
template&lt;typename SimpleTagsList , typename Metavariables &gt; </td></tr>
<tr class="memitem:ga3a9af2d9b7484c86ea4e9594fd7c8a2f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_option_tags</b> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::transform&lt; SimpleTagsList, tmpl::bind&lt; detail::get_option_tags_from_simple_tag&lt; Metavariables &gt;::template f, tmpl::_1 &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga3a9af2d9b7484c86ea4e9594fd7c8a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of simple tags, returns a list of the unique option tags required to construct them. <br /></td></tr>
<tr class="separator:ga3a9af2d9b7484c86ea4e9594fd7c8a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:af31fff079d116e958890e079a35955cf"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParallel.html#af31fff079d116e958890e079a35955cf">AlgorithmExecution</a> { <a class="el" href="namespaceParallel.html#af31fff079d116e958890e079a35955cfaa0bfb8e59e6c13fc8d990781f77694fe">Continue</a>
, <a class="el" href="namespaceParallel.html#af31fff079d116e958890e079a35955cfa6327b4e59f58137083214a1fec358855">Retry</a>
, <a class="el" href="namespaceParallel.html#af31fff079d116e958890e079a35955cfa105b296a83f9c105355403f3332af50f">Pause</a>
, <a class="el" href="namespaceParallel.html#af31fff079d116e958890e079a35955cfa4558f7fa8f5356a88a53347ad89babde">Halt</a>
 }</td></tr>
<tr class="memdesc:af31fff079d116e958890e079a35955cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible options for altering the current execution of the algorithm, used in the return type of iterable actions.  <a href="namespaceParallel.html#af31fff079d116e958890e079a35955cf">More...</a><br /></td></tr>
<tr class="separator:af31fff079d116e958890e079a35955cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8eb212d6b33aaf0d4eab15314afb50"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParallel.html#abb8eb212d6b33aaf0d4eab15314afb50">ExitCode</a> : int { <a class="el" href="namespaceParallel.html#abb8eb212d6b33aaf0d4eab15314afb50aae94f80b3ce82062a5dd7815daa04f9d">Complete</a> = 0
, <a class="el" href="namespaceParallel.html#abb8eb212d6b33aaf0d4eab15314afb50a727b63583e01fa2b3952dab580c84dc2">Abort</a> = 1
, <a class="el" href="namespaceParallel.html#abb8eb212d6b33aaf0d4eab15314afb50a007e935f6c83835821e4c804dbd81f2a">ContinueFromCheckpoint</a> = 2
 }</td></tr>
<tr class="memdesc:abb8eb212d6b33aaf0d4eab15314afb50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit code of an executable.  <a href="namespaceParallel.html#abb8eb212d6b33aaf0d4eab15314afb50">More...</a><br /></td></tr>
<tr class="separator:abb8eb212d6b33aaf0d4eab15314afb50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga027a2e60b10898507f92ba7290f0ba61"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga027a2e60b10898507f92ba7290f0ba61">Phase</a> { <br />
&#160;&#160;<a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a87d39a9f8e226843f84e237b180ae012">Phase::AdjustDomain</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a5b047d61130e0b2918cd1e9952abac77">Phase::CheckDomain</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a8c6384dda98d8864d00e29dc96179970">Phase::Cleanup</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61ad1365ec133a9a3d4195808473ef742d4">Phase::EvaluateAmrCriteria</a>
, <br />
&#160;&#160;<a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a022b83d0b2bb2af3709c384b36e7ce2b">Phase::Evolve</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a40cd014b7b6251e3a22e6a45a73a64e1">Phase::Execute</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61afef46e5063ce3dc78b8ae64fa474241d">Phase::Exit</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a0fff9cc14992a69d78edc10a85206c01">Phase::ImportInitialData</a>
, <br />
&#160;&#160;<a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a61bcd96a2c1f8026527cbf2019d6e9a4">Phase::Initialization</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61ab0fc63355327fdd0b60d600564afcc63">Phase::InitializeInitialDataDependentQuantities</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a8c04c19a8219116bb54698ec3a8544c2">Phase::InitializeTimeStepperHistory</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a5fb96ac8b4e030b4e88bd71b95460d02">Phase::LoadBalancing</a>
, <br />
&#160;&#160;<a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a03777d3c99bd348b67be0944927faeee">Phase::PostFailureCleanup</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a0ba7583639a274c434bbe6ef797115a4">Phase::Register</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a303602e6afb9f2d4b528497410bdec47">Phase::RegisterWithElementDataReader</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a97817e0979af8f0291365165b76a45b5">Phase::Solve</a>
, <br />
&#160;&#160;<a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61afa6a5a3224d7da66d9e0bdec25f62cf0">Phase::Testing</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a667488c55c3abca96b02755bfe193681">Phase::WriteCheckpoint</a>
<br />
 }</td></tr>
<tr class="memdesc:ga027a2e60b10898507f92ba7290f0ba61"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible phases of an executable.  <a href="group__ParallelGroup.html#ga027a2e60b10898507f92ba7290f0ba61">More...</a><br /></td></tr>
<tr class="separator:ga027a2e60b10898507f92ba7290f0ba61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaed29f7ca4a887fbbea9e55d94f7674cd"><td class="memTemplParams" colspan="2">
template&lt;typename Metavariables , typename... Tags, typename... OptionTags&gt; </td></tr>
<tr class="memitem:gaed29f7ca4a887fbbea9e55d94f7674cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; Tags... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_from_options</b> (const <a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; OptionTags... &gt; &amp;options, tmpl::list&lt; Tags... &gt;)</td></tr>
<tr class="memdesc:gaed29f7ca4a887fbbea9e55d94f7674cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of tags and a tagged tuple containing items created from input options, return a tagged tuple of items constructed by calls to create_from_options for each tag in the list. <br /></td></tr>
<tr class="separator:gaed29f7ca4a887fbbea9e55d94f7674cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f4c71471966c113f4c5e87830cda5c"><td class="memTemplParams" colspan="2">template&lt;typename ParallelComponent , typename SectionIdTag , typename DbTagsList &gt; </td></tr>
<tr class="memitem:ab3f4c71471966c113f4c5e87830cda5c"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParallel.html#ab3f4c71471966c113f4c5e87830cda5c">get_section</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; db::DataBox&lt; DbTagsList &gt; * &gt; box)</td></tr>
<tr class="memdesc:ab3f4c71471966c113f4c5e87830cda5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the section that the element belongs to, or <code>Parallel::no_section()</code> if <code>SectionIdTag</code> is <code>void</code>.  <a href="namespaceParallel.html#ab3f4c71471966c113f4c5e87830cda5c">More...</a><br /></td></tr>
<tr class="separator:ab3f4c71471966c113f4c5e87830cda5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga602c224997d604c7741c21dd4138e29d"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename DistribObject &gt; </td></tr>
<tr class="memitem:ga602c224997d604c7741c21dd4138e29d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>number_of_procs</b> (const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:ga602c224997d604c7741c21dd4138e29d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of processing elements. <br /></td></tr>
<tr class="separator:ga602c224997d604c7741c21dd4138e29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf89c583112f5be12c618a0ec2fc0cfb"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename DistribObject &gt; </td></tr>
<tr class="memitem:gadf89c583112f5be12c618a0ec2fc0cfb"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>my_proc</b> (const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:gadf89c583112f5be12c618a0ec2fc0cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of my processing element. <br /></td></tr>
<tr class="separator:gadf89c583112f5be12c618a0ec2fc0cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf79215bb2d12770fdbd2ad6c3cec91a8"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename DistribObject &gt; </td></tr>
<tr class="memitem:gaf79215bb2d12770fdbd2ad6c3cec91a8"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>number_of_nodes</b> (const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:gaf79215bb2d12770fdbd2ad6c3cec91a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes. <br /></td></tr>
<tr class="separator:gaf79215bb2d12770fdbd2ad6c3cec91a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad03ed6d71aee72251a19eb2c7d25b621"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename DistribObject &gt; </td></tr>
<tr class="memitem:gad03ed6d71aee72251a19eb2c7d25b621"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>my_node</b> (const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:gad03ed6d71aee72251a19eb2c7d25b621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of my node. <br /></td></tr>
<tr class="separator:gad03ed6d71aee72251a19eb2c7d25b621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga360db89dbc73353e6bf4c484db619403"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename R , typename DistribObject &gt; </td></tr>
<tr class="memitem:ga360db89dbc73353e6bf4c484db619403"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>procs_on_node</b> (const R node_index, const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:ga360db89dbc73353e6bf4c484db619403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of processing elements on the given node. <br /></td></tr>
<tr class="separator:ga360db89dbc73353e6bf4c484db619403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76a1e2bd8f33a1eb980b4eae811c0575"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename DistribObject &gt; </td></tr>
<tr class="memitem:ga76a1e2bd8f33a1eb980b4eae811c0575"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>my_local_rank</b> (const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:ga76a1e2bd8f33a1eb980b4eae811c0575"><td class="mdescLeft">&#160;</td><td class="mdescRight">The local index of my processing element on my node. This is in the interval 0, ..., procs_on_node(my_node()) - 1. <br /></td></tr>
<tr class="separator:ga76a1e2bd8f33a1eb980b4eae811c0575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga004b55d123b4f2541b38c16c195c07d1"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename R , typename DistribObject &gt; </td></tr>
<tr class="memitem:ga004b55d123b4f2541b38c16c195c07d1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>first_proc_on_node</b> (const R node_index, const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:ga004b55d123b4f2541b38c16c195c07d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of first processing element on the given node. <br /></td></tr>
<tr class="separator:ga004b55d123b4f2541b38c16c195c07d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga224caf730591903abf339e9f551adddc"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename R , typename DistribObject &gt; </td></tr>
<tr class="memitem:ga224caf730591903abf339e9f551adddc"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>node_of</b> (const R proc_index, const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:ga224caf730591903abf339e9f551adddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the node for the given processing element. <br /></td></tr>
<tr class="separator:ga224caf730591903abf339e9f551adddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbdc7feb7a9dfc90022976465b747d8c"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename R , typename DistribObject &gt; </td></tr>
<tr class="memitem:gafbdc7feb7a9dfc90022976465b747d8c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>local_rank_of</b> (const R proc_index, const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:gafbdc7feb7a9dfc90022976465b747d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The local index for the given processing element on its node. <br /></td></tr>
<tr class="separator:gafbdc7feb7a9dfc90022976465b747d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1078fa99233851c6475fbfa99a2f51d"><td class="memTemplParams" colspan="2">template&lt;typename ReceiveTag , typename Proxy , typename ReceiveDataType &gt; </td></tr>
<tr class="memitem:gad1078fa99233851c6475fbfa99a2f51d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gad1078fa99233851c6475fbfa99a2f51d">receive_data</a> (Proxy &amp;&amp;proxy, typename ReceiveTag::temporal_id temporal_id, ReceiveDataType &amp;&amp;receive_data, const bool enable_if_disabled=false)</td></tr>
<tr class="memdesc:gad1078fa99233851c6475fbfa99a2f51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the data <code>args...</code> to the algorithm running on <code>proxy</code>, and tag the message with the identifier <code>temporal_id</code>.  <a href="group__ParallelGroup.html#gad1078fa99233851c6475fbfa99a2f51d">More...</a><br /></td></tr>
<tr class="separator:gad1078fa99233851c6475fbfa99a2f51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49aa2598782609c76503c8523e0f20f1"><td class="memTemplParams" colspan="2">template&lt;typename ReceiveTag , typename Proxy , typename MessageType &gt; </td></tr>
<tr class="memitem:ga49aa2598782609c76503c8523e0f20f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga49aa2598782609c76503c8523e0f20f1">receive_data</a> (Proxy &amp;&amp;proxy, MessageType *message)</td></tr>
<tr class="memdesc:ga49aa2598782609c76503c8523e0f20f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a pointer <code>message</code> to the algorithm running on <code>proxy</code>.  <a href="group__ParallelGroup.html#ga49aa2598782609c76503c8523e0f20f1">More...</a><br /></td></tr>
<tr class="separator:ga49aa2598782609c76503c8523e0f20f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabed954105c6dfd7cc13d07dbcb0504b1"><td class="memTemplParams" colspan="2">
template&lt;typename Action , typename Proxy , typename... Args&gt; </td></tr>
<tr class="memitem:gabed954105c6dfd7cc13d07dbcb0504b1"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>local_synchronous_action</b> (Proxy &amp;&amp;proxy, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gabed954105c6dfd7cc13d07dbcb0504b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a local synchronous action on <code>proxy</code> <br /></td></tr>
<tr class="separator:gabed954105c6dfd7cc13d07dbcb0504b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3299e04cea9f206f194e7b118c7b44"><td class="memTemplParams" colspan="2">template&lt;typename Proxy &gt; </td></tr>
<tr class="memitem:a7c3299e04cea9f206f194e7b118c7b44"><td class="memTemplItemLeft" align="right" valign="top">auto *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParallel.html#a7c3299e04cea9f206f194e7b118c7b44">local</a> (Proxy &amp;&amp;proxy)</td></tr>
<tr class="memdesc:a7c3299e04cea9f206f194e7b118c7b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for calling Charm++'s <code>.ckLocal()</code> on a proxy.  <a href="namespaceParallel.html#a7c3299e04cea9f206f194e7b118c7b44">More...</a><br /></td></tr>
<tr class="separator:a7c3299e04cea9f206f194e7b118c7b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4ca5b6143a3b8a8c5c1dd9dacf3d08"><td class="memTemplParams" colspan="2">template&lt;typename Proxy &gt; </td></tr>
<tr class="memitem:a3e4ca5b6143a3b8a8c5c1dd9dacf3d08"><td class="memTemplItemLeft" align="right" valign="top">auto *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParallel.html#a3e4ca5b6143a3b8a8c5c1dd9dacf3d08">local_branch</a> (Proxy &amp;&amp;proxy)</td></tr>
<tr class="memdesc:a3e4ca5b6143a3b8a8c5c1dd9dacf3d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for calling Charm++'s <code>.ckLocalBranch()</code> on a proxy.  <a href="namespaceParallel.html#a3e4ca5b6143a3b8a8c5c1dd9dacf3d08">More...</a><br /></td></tr>
<tr class="separator:a3e4ca5b6143a3b8a8c5c1dd9dacf3d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac126cca66653c3f3d5c403107d9e4318"><td class="memItemLeft" align="right" valign="top"><a id="ac126cca66653c3f3d5c403107d9e4318" name="ac126cca66653c3f3d5c403107d9e4318"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="group__ParallelGroup.html#ga027a2e60b10898507f92ba7290f0ba61">Phase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>known_phases</b> ()</td></tr>
<tr class="separator:ac126cca66653c3f3d5c403107d9e4318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc561fe8ad0420179e2803eacd4f3cc"><td class="memItemLeft" align="right" valign="top"><a id="a1bc561fe8ad0420179e2803eacd4f3cc" name="a1bc561fe8ad0420179e2803eacd4f3cc"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="el" href="group__ParallelGroup.html#ga027a2e60b10898507f92ba7290f0ba61">Phase</a> &amp;phase)</td></tr>
<tr class="memdesc:a1bc561fe8ad0420179e2803eacd4f3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output operator for a Phase. <br /></td></tr>
<tr class="separator:a1bc561fe8ad0420179e2803eacd4f3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae21964b5d28608afd21ae090c1c4c073"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:gae21964b5d28608afd21ae090c1c4c073"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gae21964b5d28608afd21ae090c1c4c073">printf</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;format, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gae21964b5d28608afd21ae090c1c4c073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an atomic message to stdout with C printf usage.  <a href="group__ParallelGroup.html#gae21964b5d28608afd21ae090c1c4c073">More...</a><br /></td></tr>
<tr class="separator:gae21964b5d28608afd21ae090c1c4c073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8448205dbaf9741505bd30dfad2cadc"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:gaa8448205dbaf9741505bd30dfad2cadc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gaa8448205dbaf9741505bd30dfad2cadc">printf_error</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;format, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gaa8448205dbaf9741505bd30dfad2cadc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an atomic message to stderr with C printf usage.  <a href="group__ParallelGroup.html#gaa8448205dbaf9741505bd30dfad2cadc">More...</a><br /></td></tr>
<tr class="separator:gaa8448205dbaf9741505bd30dfad2cadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga893fa42fabb3cb7273cfdd7348e9a75d"><td class="memTemplParams" colspan="2">template&lt;class Action , class SenderProxy , class TargetProxy , class... Ts, class SectionType  = NoSection&gt; </td></tr>
<tr class="memitem:ga893fa42fabb3cb7273cfdd7348e9a75d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga893fa42fabb3cb7273cfdd7348e9a75d">contribute_to_reduction</a> (ReductionData&lt; Ts... &gt; reduction_data, const SenderProxy &amp;sender_component, const TargetProxy &amp;target_component, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; SectionType * &gt; section=&amp;no_section())</td></tr>
<tr class="memdesc:ga893fa42fabb3cb7273cfdd7348e9a75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a reduction from the <code>sender_component</code> (typically your own parallel component) to the <code>target_component</code>, performing the <code>Action</code> upon receiving the reduction.  <a href="group__ParallelGroup.html#ga893fa42fabb3cb7273cfdd7348e9a75d">More...</a><br /></td></tr>
<tr class="separator:ga893fa42fabb3cb7273cfdd7348e9a75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317309e266a868a61036c46e08a5fa0c"><td class="memTemplParams" colspan="2"><a id="a317309e266a868a61036c46e08a5fa0c" name="a317309e266a868a61036c46e08a5fa0c"></a>
template&lt;typename ParallelComponent &gt; </td></tr>
<tr class="memitem:a317309e266a868a61036c46e08a5fa0c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structParallel_1_1SingletonInfoHolder.html">SingletonInfoHolder</a>&lt; ParallelComponent &gt; &amp;lhs, const <a class="el" href="structParallel_1_1SingletonInfoHolder.html">SingletonInfoHolder</a>&lt; ParallelComponent &gt; &amp;rhs)</td></tr>
<tr class="separator:a317309e266a868a61036c46e08a5fa0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0f1a8c72c24fbff1c2dfa1c0c038bd"><td class="memTemplParams" colspan="2"><a id="a1e0f1a8c72c24fbff1c2dfa1c0c038bd" name="a1e0f1a8c72c24fbff1c2dfa1c0c038bd"></a>
template&lt;typename ParallelComponent &gt; </td></tr>
<tr class="memitem:a1e0f1a8c72c24fbff1c2dfa1c0c038bd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structParallel_1_1SingletonInfoHolder.html">SingletonInfoHolder</a>&lt; ParallelComponent &gt; &amp;lhs, const <a class="el" href="structParallel_1_1SingletonInfoHolder.html">SingletonInfoHolder</a>&lt; ParallelComponent &gt; &amp;rhs)</td></tr>
<tr class="separator:a1e0f1a8c72c24fbff1c2dfa1c0c038bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425bbd0a80624bca42138578f56c0e53"><td class="memTemplParams" colspan="2"><a id="a425bbd0a80624bca42138578f56c0e53" name="a425bbd0a80624bca42138578f56c0e53"></a>
template&lt;typename... Components&gt; </td></tr>
<tr class="memitem:a425bbd0a80624bca42138578f56c0e53"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structParallel_1_1SingletonPack.html">SingletonPack</a>&lt; tmpl::list&lt; Components... &gt; &gt; &amp;lhs, const <a class="el" href="structParallel_1_1SingletonPack.html">SingletonPack</a>&lt; tmpl::list&lt; Components... &gt; &gt; &amp;rhs)</td></tr>
<tr class="separator:a425bbd0a80624bca42138578f56c0e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63dbd7d45e1487fa0bb9dedd11f68bc"><td class="memTemplParams" colspan="2"><a id="af63dbd7d45e1487fa0bb9dedd11f68bc" name="af63dbd7d45e1487fa0bb9dedd11f68bc"></a>
template&lt;typename... Components&gt; </td></tr>
<tr class="memitem:af63dbd7d45e1487fa0bb9dedd11f68bc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structParallel_1_1SingletonPack.html">SingletonPack</a>&lt; tmpl::list&lt; Components... &gt; &gt; &amp;lhs, const <a class="el" href="structParallel_1_1SingletonPack.html">SingletonPack</a>&lt; tmpl::list&lt; Components... &gt; &gt; &amp;rhs)</td></tr>
<tr class="separator:af63dbd7d45e1487fa0bb9dedd11f68bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456a163f00b6ab7861d5163f9f537519"><td class="memTemplParams" colspan="2"><a id="a456a163f00b6ab7861d5163f9f537519" name="a456a163f00b6ab7861d5163f9f537519"></a>
template&lt;typename Metavars &gt; </td></tr>
<tr class="memitem:a456a163f00b6ab7861d5163f9f537519"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structParallel_1_1ResourceInfo.html">ResourceInfo</a>&lt; Metavars &gt; &amp;lhs, const <a class="el" href="structParallel_1_1ResourceInfo.html">ResourceInfo</a>&lt; Metavars &gt; &amp;rhs)</td></tr>
<tr class="separator:a456a163f00b6ab7861d5163f9f537519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1860b4c49a578b861e0c7d12d5779288"><td class="memTemplParams" colspan="2"><a id="a1860b4c49a578b861e0c7d12d5779288" name="a1860b4c49a578b861e0c7d12d5779288"></a>
template&lt;typename Metavars &gt; </td></tr>
<tr class="memitem:a1860b4c49a578b861e0c7d12d5779288"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structParallel_1_1ResourceInfo.html">ResourceInfo</a>&lt; Metavars &gt; &amp;lhs, const <a class="el" href="structParallel_1_1ResourceInfo.html">ResourceInfo</a>&lt; Metavars &gt; &amp;rhs)</td></tr>
<tr class="separator:a1860b4c49a578b861e0c7d12d5779288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gaeee02b1e4faf8051fe703e6b9adada0f"><td class="memTemplParams" colspan="2">template&lt;typename ParallelComponentTag , typename Metavariables &gt; </td></tr>
<tr class="memitem:gaeee02b1e4faf8051fe703e6b9adada0f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gaeee02b1e4faf8051fe703e6b9adada0f">get_parallel_component</a> (<a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;cache) -&gt; Parallel::proxy_from_parallel_component&lt; GlobalCache_detail::get_component_if_mocked&lt; typename Metavariables::component_list, ParallelComponentTag &gt; &gt; &amp;</td></tr>
<tr class="memdesc:gaeee02b1e4faf8051fe703e6b9adada0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the Charm++ proxy associated with a ParallelComponent.  <a href="group__ParallelGroup.html#gaeee02b1e4faf8051fe703e6b9adada0f">More...</a><br /></td></tr>
<tr class="separator:gaeee02b1e4faf8051fe703e6b9adada0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c24e9812c22ee923354a3906e50f296"><td class="memTemplParams" colspan="2">template&lt;typename ParallelComponentTag , typename Metavariables &gt; </td></tr>
<tr class="memitem:ga8c24e9812c22ee923354a3906e50f296"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga8c24e9812c22ee923354a3906e50f296">get_parallel_component</a> (const <a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;cache) -&gt; const Parallel::proxy_from_parallel_component&lt; GlobalCache_detail::get_component_if_mocked&lt; typename Metavariables::component_list, ParallelComponentTag &gt; &gt; &amp;</td></tr>
<tr class="memdesc:ga8c24e9812c22ee923354a3906e50f296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the Charm++ proxy associated with a ParallelComponent.  <a href="group__ParallelGroup.html#ga8c24e9812c22ee923354a3906e50f296">More...</a><br /></td></tr>
<tr class="separator:ga8c24e9812c22ee923354a3906e50f296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga43c98b994ca4a6ef61235109c5b94e14"><td class="memTemplParams" colspan="2">template&lt;typename GlobalCacheTag , typename Metavariables &gt; </td></tr>
<tr class="memitem:ga43c98b994ca4a6ef61235109c5b94e14"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga43c98b994ca4a6ef61235109c5b94e14">get</a> (const <a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;cache) -&gt; const GlobalCache_detail::type_for_get&lt; GlobalCacheTag, Metavariables &gt; &amp;</td></tr>
<tr class="memdesc:ga43c98b994ca4a6ef61235109c5b94e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access data in the cache.  <a href="group__ParallelGroup.html#ga43c98b994ca4a6ef61235109c5b94e14">More...</a><br /></td></tr>
<tr class="separator:ga43c98b994ca4a6ef61235109c5b94e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee973d82ab6a1dbac2b504e86d8de2e5"><td class="memTemplParams" colspan="2">template&lt;typename GlobalCacheTag , typename Function , typename Metavariables &gt; </td></tr>
<tr class="memitem:gaee973d82ab6a1dbac2b504e86d8de2e5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gaee973d82ab6a1dbac2b504e86d8de2e5">mutable_cache_item_is_ready</a> (<a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;cache, const Function &amp;function)</td></tr>
<tr class="memdesc:gaee973d82ab6a1dbac2b504e86d8de2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the object identified by <code>GlobalCacheTag</code> is ready to be accessed by <code>get</code>.  <a href="group__ParallelGroup.html#gaee973d82ab6a1dbac2b504e86d8de2e5">More...</a><br /></td></tr>
<tr class="separator:gaee973d82ab6a1dbac2b504e86d8de2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fb8fc6f30581c450abecc8258dead3c"><td class="memTemplParams" colspan="2">template&lt;typename GlobalCacheTag , typename Function , typename Metavariables , typename... Args&gt; </td></tr>
<tr class="memitem:ga8fb8fc6f30581c450abecc8258dead3c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga8fb8fc6f30581c450abecc8258dead3c">mutate</a> (<a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;cache, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga8fb8fc6f30581c450abecc8258dead3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutates non-const data in the cache, by calling <code>Function::apply()</code>  <a href="group__ParallelGroup.html#ga8fb8fc6f30581c450abecc8258dead3c">More...</a><br /></td></tr>
<tr class="separator:ga8fb8fc6f30581c450abecc8258dead3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga1902e18e22b3092208b8dd9f0e5f11c0"><td class="memTemplParams" colspan="2">
template&lt;typename Action , typename Proxy &gt; </td></tr>
<tr class="memitem:ga1902e18e22b3092208b8dd9f0e5f11c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>simple_action</b> (Proxy &amp;&amp;proxy)</td></tr>
<tr class="memdesc:ga1902e18e22b3092208b8dd9f0e5f11c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a simple action on <code>proxy</code> <br /></td></tr>
<tr class="separator:ga1902e18e22b3092208b8dd9f0e5f11c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e9708c581cfd958746b601be4a03eb5"><td class="memTemplParams" colspan="2">
template&lt;typename Action , typename Proxy , typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:ga8e9708c581cfd958746b601be4a03eb5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>simple_action</b> (Proxy &amp;&amp;proxy, Arg0 &amp;&amp;arg0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga8e9708c581cfd958746b601be4a03eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a simple action on <code>proxy</code> <br /></td></tr>
<tr class="separator:ga8e9708c581cfd958746b601be4a03eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga49eb59320a0258c95d58b1447ff8702b"><td class="memTemplParams" colspan="2">
template&lt;typename Action , typename Proxy &gt; </td></tr>
<tr class="memitem:ga49eb59320a0258c95d58b1447ff8702b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>threaded_action</b> (Proxy &amp;&amp;proxy)</td></tr>
<tr class="memdesc:ga49eb59320a0258c95d58b1447ff8702b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a threaded action on <code>proxy</code>, where the proxy must be a nodegroup. <br /></td></tr>
<tr class="separator:ga49eb59320a0258c95d58b1447ff8702b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga942169b97926623cb569158e724e62e0"><td class="memTemplParams" colspan="2">
template&lt;typename Action , typename Proxy , typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:ga942169b97926623cb569158e724e62e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>threaded_action</b> (Proxy &amp;&amp;proxy, Arg0 &amp;&amp;arg0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga942169b97926623cb569158e724e62e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a threaded action on <code>proxy</code>, where the proxy must be a nodegroup. <br /></td></tr>
<tr class="separator:ga942169b97926623cb569158e724e62e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab3efd47ce7ceacc271fd4f6809230deb"><td class="memTemplParams" colspan="2">template&lt;typename SenderComponent , typename <a class="el" href="structParallel_1_1ArrayIndex.html">ArrayIndex</a> , typename Metavariables , class... Ts&gt; </td></tr>
<tr class="memitem:ab3efd47ce7ceacc271fd4f6809230deb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParallel.html#ab3efd47ce7ceacc271fd4f6809230deb">contribute_to_phase_change_reduction</a> (<a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; Ts... &gt; data_for_reduction, <a class="el" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache</a>&lt; Metavariables &gt; &amp;cache, const <a class="el" href="structParallel_1_1ArrayIndex.html">ArrayIndex</a> &amp;array_index)</td></tr>
<tr class="memdesc:ab3efd47ce7ceacc271fd4f6809230deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data from a parallel component to the <a class="el" href="classParallel_1_1Main.html" title="The main function of a Charm++ executable. See the Parallelization documentation for an overview of M...">Main</a> chare for making phase-change decisions.  <a href="namespaceParallel.html#ab3efd47ce7ceacc271fd4f6809230deb">More...</a><br /></td></tr>
<tr class="separator:ab3efd47ce7ceacc271fd4f6809230deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4026b678032c7c72edca27c1675f9da"><td class="memTemplParams" colspan="2">template&lt;typename SenderComponent , typename Metavariables , class... Ts&gt; </td></tr>
<tr class="memitem:ae4026b678032c7c72edca27c1675f9da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParallel.html#ae4026b678032c7c72edca27c1675f9da">contribute_to_phase_change_reduction</a> (<a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; Ts... &gt; data_for_reduction, <a class="el" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache</a>&lt; Metavariables &gt; &amp;cache)</td></tr>
<tr class="memdesc:ae4026b678032c7c72edca27c1675f9da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data from a parallel component to the <a class="el" href="classParallel_1_1Main.html" title="The main function of a Charm++ executable. See the Parallelization documentation for an overview of M...">Main</a> chare for making phase-change decisions.  <a href="namespaceParallel.html#ae4026b678032c7c72edca27c1675f9da">More...</a><br /></td></tr>
<tr class="separator:ae4026b678032c7c72edca27c1675f9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae7e1d4d655d030689e964d81625b7fcf"><td class="memItemLeft" align="right" valign="top"><a id="ae7e1d4d655d030689e964d81625b7fcf" name="ae7e1d4d655d030689e964d81625b7fcf"></a>
<a class="el" href="structParallel_1_1NoSection.html">NoSection</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>no_section</b> ()</td></tr>
<tr class="separator:ae7e1d4d655d030689e964d81625b7fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga6794d6d662e9f601ebdbd8528536ead1"><td class="memTemplParams" colspan="2">template&lt;typename Metavariables , typename Tag &gt; </td></tr>
<tr class="memitem:ga6794d6d662e9f601ebdbd8528536ead1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga6794d6d662e9f601ebdbd8528536ead1">is_in_const_global_cache</a></td></tr>
<tr class="memdesc:ga6794d6d662e9f601ebdbd8528536ead1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a tag is retrievable from the const portion of the global cache.  <a href="group__ParallelGroup.html#ga6794d6d662e9f601ebdbd8528536ead1">More...</a><br /></td></tr>
<tr class="separator:ga6794d6d662e9f601ebdbd8528536ead1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f79ab2930d68c2050849ff60f80f162"><td class="memTemplParams" colspan="2">template&lt;typename Metavariables , typename Tag &gt; </td></tr>
<tr class="memitem:ga6f79ab2930d68c2050849ff60f80f162"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga6f79ab2930d68c2050849ff60f80f162">is_in_mutable_global_cache</a></td></tr>
<tr class="memdesc:ga6f79ab2930d68c2050849ff60f80f162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a tag is retrievable from the mutable portion of the global cache.  <a href="group__ParallelGroup.html#ga6f79ab2930d68c2050849ff60f80f162">More...</a><br /></td></tr>
<tr class="separator:ga6f79ab2930d68c2050849ff60f80f162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga118c900b55b0e55a8d11cef00c77bd2d"><td class="memTemplParams" colspan="2">template&lt;typename Metavariables , typename Tag &gt; </td></tr>
<tr class="memitem:ga118c900b55b0e55a8d11cef00c77bd2d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga118c900b55b0e55a8d11cef00c77bd2d">is_in_global_cache</a></td></tr>
<tr class="memdesc:ga118c900b55b0e55a8d11cef00c77bd2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a tag is retrievable from the global cache.  <a href="group__ParallelGroup.html#ga118c900b55b0e55a8d11cef00c77bd2d">More...</a><br /></td></tr>
<tr class="separator:ga118c900b55b0e55a8d11cef00c77bd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7f44f7252bb541984b8010ed8e40728e"><td class="memTemplParams" colspan="2"><a id="a7f44f7252bb541984b8010ed8e40728e" name="a7f44f7252bb541984b8010ed8e40728e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7f44f7252bb541984b8010ed8e40728e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_array_v</b> = <a class="el" href="structParallel_1_1is__array.html">is_array</a>&lt;T&gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a></td></tr>
<tr class="separator:a7f44f7252bb541984b8010ed8e40728e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a39e2a2af240311b7eefd6ae99f7e2a94"><td class="memTemplParams" colspan="2"><a id="a39e2a2af240311b7eefd6ae99f7e2a94" name="a39e2a2af240311b7eefd6ae99f7e2a94"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a39e2a2af240311b7eefd6ae99f7e2a94"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_singleton_v</b> = <a class="el" href="structParallel_1_1is__singleton.html">is_singleton</a>&lt;T&gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a></td></tr>
<tr class="separator:a39e2a2af240311b7eefd6ae99f7e2a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab52c36a18b398dd30610e5ec1924fbdf"><td class="memTemplParams" colspan="2"><a id="ab52c36a18b398dd30610e5ec1924fbdf" name="ab52c36a18b398dd30610e5ec1924fbdf"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab52c36a18b398dd30610e5ec1924fbdf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_group_v</b> = <a class="el" href="structParallel_1_1is__group.html">is_group</a>&lt;T&gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a></td></tr>
<tr class="separator:ab52c36a18b398dd30610e5ec1924fbdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac9745c720ae59a68cbd2c5a837db00ec"><td class="memTemplParams" colspan="2"><a id="ac9745c720ae59a68cbd2c5a837db00ec" name="ac9745c720ae59a68cbd2c5a837db00ec"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac9745c720ae59a68cbd2c5a837db00ec"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_nodegroup_v</b> = <a class="el" href="structParallel_1_1is__nodegroup.html">is_nodegroup</a>&lt;T&gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a></td></tr>
<tr class="separator:ac9745c720ae59a68cbd2c5a837db00ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27907852d1e51848fc42c073f824554c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a27907852d1e51848fc42c073f824554c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParallel.html#a27907852d1e51848fc42c073f824554c">has_pup_member_t</a> = typename <a class="el" href="structParallel_1_1has__pup__member.html">has_pup_member</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a27907852d1e51848fc42c073f824554c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9bb92f00c4aa3fb15b1888332bc5462"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae9bb92f00c4aa3fb15b1888332bc5462"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParallel.html#ae9bb92f00c4aa3fb15b1888332bc5462">has_pup_member_v</a> = <a class="el" href="structParallel_1_1has__pup__member.html">has_pup_member</a>&lt;T&gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a></td></tr>
<tr class="separator:ae9bb92f00c4aa3fb15b1888332bc5462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f8a5f10d370ff570bb623bf858b6ed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af9f8a5f10d370ff570bb623bf858b6ed"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParallel.html#af9f8a5f10d370ff570bb623bf858b6ed">is_pupable_t</a> = typename <a class="el" href="structParallel_1_1is__pupable.html">is_pupable</a>&lt; T &gt;::type</td></tr>
<tr class="separator:af9f8a5f10d370ff570bb623bf858b6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e5e039d67f87cc794544f3eb871029"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a99e5e039d67f87cc794544f3eb871029"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParallel.html#a99e5e039d67f87cc794544f3eb871029">is_pupable_v</a> = <a class="el" href="structParallel_1_1is__pupable.html">is_pupable</a>&lt;T&gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a></td></tr>
<tr class="separator:a99e5e039d67f87cc794544f3eb871029"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Functionality for parallelization. </p>
<p >The functions in namespace <code><a class="el" href="namespaceParallel.html" title="Functionality for parallelization.">Parallel</a></code> that return information on nodes and cores are templated on DistribObject. Actions should use these functions rather than the raw charm++ versions (in the sys namespace in Utilities/System/ParallelInfo.hpp) so that the mocking framework will see the mocked cores and nodes. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a27907852d1e51848fc42c073f824554c" name="a27907852d1e51848fc42c073f824554c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27907852d1e51848fc42c073f824554c">&#9670;&nbsp;</a></span>has_pup_member_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceParallel.html#a27907852d1e51848fc42c073f824554c">Parallel::has_pup_member_t</a> = typedef typename <a class="el" href="structParallel_1_1has__pup__member.html">has_pup_member</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structParallel_1_1has__pup__member.html" title="Check if T has a pup member function.">has_pup_member</a> </dd></dl>

</div>
</div>
<a id="af9f8a5f10d370ff570bb623bf858b6ed" name="af9f8a5f10d370ff570bb623bf858b6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9f8a5f10d370ff570bb623bf858b6ed">&#9670;&nbsp;</a></span>is_pupable_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceParallel.html#af9f8a5f10d370ff570bb623bf858b6ed">Parallel::is_pupable_t</a> = typedef typename <a class="el" href="structParallel_1_1is__pupable.html">is_pupable</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structParallel_1_1is__pupable.html" title="Check if type T has operator| defined for Charm++ serialization.">is_pupable</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="af31fff079d116e958890e079a35955cf" name="af31fff079d116e958890e079a35955cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31fff079d116e958890e079a35955cf">&#9670;&nbsp;</a></span>AlgorithmExecution</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceParallel.html#af31fff079d116e958890e079a35955cf">Parallel::AlgorithmExecution</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The possible options for altering the current execution of the algorithm, used in the return type of iterable actions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af31fff079d116e958890e079a35955cfaa0bfb8e59e6c13fc8d990781f77694fe" name="af31fff079d116e958890e079a35955cfaa0bfb8e59e6c13fc8d990781f77694fe"></a>Continue&#160;</td><td class="fielddoc"><p >Continue executing iterable actions. </p>
</td></tr>
<tr><td class="fieldname"><a id="af31fff079d116e958890e079a35955cfa6327b4e59f58137083214a1fec358855" name="af31fff079d116e958890e079a35955cfa6327b4e59f58137083214a1fec358855"></a>Retry&#160;</td><td class="fielddoc"><p >Temporarily stop executing iterable actions, but try the same action again after receiving data from other distributed objects. </p>
</td></tr>
<tr><td class="fieldname"><a id="af31fff079d116e958890e079a35955cfa105b296a83f9c105355403f3332af50f" name="af31fff079d116e958890e079a35955cfa105b296a83f9c105355403f3332af50f"></a>Pause&#160;</td><td class="fielddoc"><p >Stop the execution of iterable actions, but allow entry methods (communication) to explicitly request restarting the execution. </p>
</td></tr>
<tr><td class="fieldname"><a id="af31fff079d116e958890e079a35955cfa4558f7fa8f5356a88a53347ad89babde" name="af31fff079d116e958890e079a35955cfa4558f7fa8f5356a88a53347ad89babde"></a>Halt&#160;</td><td class="fielddoc"><p >Stop the execution of iterable actions and do not allow their execution until after a phase change. Simple actions will still execute. </p>
</td></tr>
</table>

</div>
</div>
<a id="abb8eb212d6b33aaf0d4eab15314afb50" name="abb8eb212d6b33aaf0d4eab15314afb50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8eb212d6b33aaf0d4eab15314afb50">&#9670;&nbsp;</a></span>ExitCode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceParallel.html#abb8eb212d6b33aaf0d4eab15314afb50">Parallel::ExitCode</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exit code of an executable. </p>
<dl class="section warning"><dt>Warning</dt><dd>Don't change the integer values of the enum cases unless you have a very good reason to do so. The integer values are used by external code, so this is a public interface that should remain stable. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abb8eb212d6b33aaf0d4eab15314afb50aae94f80b3ce82062a5dd7815daa04f9d" name="abb8eb212d6b33aaf0d4eab15314afb50aae94f80b3ce82062a5dd7815daa04f9d"></a>Complete&#160;</td><td class="fielddoc"><p >Program is complete. </p>
</td></tr>
<tr><td class="fieldname"><a id="abb8eb212d6b33aaf0d4eab15314afb50a727b63583e01fa2b3952dab580c84dc2" name="abb8eb212d6b33aaf0d4eab15314afb50a727b63583e01fa2b3952dab580c84dc2"></a>Abort&#160;</td><td class="fielddoc"><p >Program aborted because of an error. </p>
</td></tr>
<tr><td class="fieldname"><a id="abb8eb212d6b33aaf0d4eab15314afb50a007e935f6c83835821e4c804dbd81f2a" name="abb8eb212d6b33aaf0d4eab15314afb50a007e935f6c83835821e4c804dbd81f2a"></a>ContinueFromCheckpoint&#160;</td><td class="fielddoc"><p >Program is incomplete and should be continued from the last checkpoint. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae4026b678032c7c72edca27c1675f9da" name="ae4026b678032c7c72edca27c1675f9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4026b678032c7c72edca27c1675f9da">&#9670;&nbsp;</a></span>contribute_to_phase_change_reduction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SenderComponent , typename Metavariables , class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::contribute_to_phase_change_reduction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; Ts... &gt;&#160;</td>
          <td class="paramname"><em>data_for_reduction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache</a>&lt; Metavariables &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data from a parallel component to the <a class="el" href="classParallel_1_1Main.html" title="The main function of a Charm++ executable. See the Parallelization documentation for an overview of M...">Main</a> chare for making phase-change decisions. </p>
<p >This function is distinct from <code><a class="el" href="group__ParallelGroup.html#ga893fa42fabb3cb7273cfdd7348e9a75d" title="Perform a reduction from the sender_component (typically your own parallel component) to the target_c...">Parallel::contribute_to_reduction</a></code> because this function contributes reduction data to the <a class="el" href="classParallel_1_1Main.html" title="The main function of a Charm++ executable. See the Parallelization documentation for an overview of M...">Main</a> chare via the entry method <code>phase_change_reduction</code>. This must be done because the entry method must alter member data specific to the <a class="el" href="classParallel_1_1Main.html" title="The main function of a Charm++ executable. See the Parallelization documentation for an overview of M...">Main</a> chare, and the <a class="el" href="classParallel_1_1Main.html" title="The main function of a Charm++ executable. See the Parallelization documentation for an overview of M...">Main</a> chare cannot execute actions like most SpECTRE parallel components. For all cases other than sending phase-change decision data to the <a class="el" href="classParallel_1_1Main.html" title="The main function of a Charm++ executable. See the Parallelization documentation for an overview of M...">Main</a> chare, you should use <code><a class="el" href="group__ParallelGroup.html#ga893fa42fabb3cb7273cfdd7348e9a75d" title="Perform a reduction from the sender_component (typically your own parallel component) to the target_c...">Parallel::contribute_to_reduction</a></code>. </p>

</div>
</div>
<a id="ab3efd47ce7ceacc271fd4f6809230deb" name="ab3efd47ce7ceacc271fd4f6809230deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3efd47ce7ceacc271fd4f6809230deb">&#9670;&nbsp;</a></span>contribute_to_phase_change_reduction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SenderComponent , typename <a class="el" href="structParallel_1_1ArrayIndex.html">ArrayIndex</a> , typename Metavariables , class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::contribute_to_phase_change_reduction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; Ts... &gt;&#160;</td>
          <td class="paramname"><em>data_for_reduction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache</a>&lt; Metavariables &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structParallel_1_1ArrayIndex.html">ArrayIndex</a> &amp;&#160;</td>
          <td class="paramname"><em>array_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data from a parallel component to the <a class="el" href="classParallel_1_1Main.html" title="The main function of a Charm++ executable. See the Parallelization documentation for an overview of M...">Main</a> chare for making phase-change decisions. </p>
<p >This function is distinct from <code><a class="el" href="group__ParallelGroup.html#ga893fa42fabb3cb7273cfdd7348e9a75d" title="Perform a reduction from the sender_component (typically your own parallel component) to the target_c...">Parallel::contribute_to_reduction</a></code> because this function contributes reduction data to the <a class="el" href="classParallel_1_1Main.html" title="The main function of a Charm++ executable. See the Parallelization documentation for an overview of M...">Main</a> chare via the entry method <code>phase_change_reduction</code>. This must be done because the entry method must alter member data specific to the <a class="el" href="classParallel_1_1Main.html" title="The main function of a Charm++ executable. See the Parallelization documentation for an overview of M...">Main</a> chare, and the <a class="el" href="classParallel_1_1Main.html" title="The main function of a Charm++ executable. See the Parallelization documentation for an overview of M...">Main</a> chare cannot execute actions like most SpECTRE parallel components. For all cases other than sending phase-change decision data to the <a class="el" href="classParallel_1_1Main.html" title="The main function of a Charm++ executable. See the Parallelization documentation for an overview of M...">Main</a> chare, you should use <code><a class="el" href="group__ParallelGroup.html#ga893fa42fabb3cb7273cfdd7348e9a75d" title="Perform a reduction from the sender_component (typically your own parallel component) to the target_c...">Parallel::contribute_to_reduction</a></code>. </p>

</div>
</div>
<a id="ab3f4c71471966c113f4c5e87830cda5c" name="ab3f4c71471966c113f4c5e87830cda5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f4c71471966c113f4c5e87830cda5c">&#9670;&nbsp;</a></span>get_section()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParallelComponent , typename SectionIdTag , typename DbTagsList &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; Parallel::get_section </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; db::DataBox&lt; DbTagsList &gt; * &gt;&#160;</td>
          <td class="paramname"><em>box</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the section that the element belongs to, or <code>Parallel::no_section()</code> if <code>SectionIdTag</code> is <code>void</code>. </p>
<p >This function is useful to support sections in parallel algorithms. Specify the <code>SectionIdTag</code> template parameter to retrieve the associated section, or set it to <code>void</code> when the parallel algorithm runs over all elements of the parallel component. See <code><a class="el" href="structParallel_1_1Section.html" title="A subset of chares in a parallel component.">Parallel::Section</a></code> for details on sections.</p>
<p >Only call this function on elements that are part of a section. In case not all elements are part of a section with the <code>SectionIdTag</code>, make sure to skip those elements before calling this function. </p>

</div>
</div>
<a id="a7c3299e04cea9f206f194e7b118c7b44" name="a7c3299e04cea9f206f194e7b118c7b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3299e04cea9f206f194e7b118c7b44">&#9670;&nbsp;</a></span>local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Proxy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto * Parallel::local </td>
          <td>(</td>
          <td class="paramtype">Proxy &amp;&amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for calling Charm++'s <code>.ckLocal()</code> on a proxy. </p>
<p >The Proxy must be to a Charm++ array chare (implementing a singleton design pattern using a single-element array) or to a Charm++ array element chare (i.e., the proxy obtained by indexing into a Charm++ array chare).</p>
<p >The function returns a pointer to the chare if it exists on the local processor, and NULL if it does not. See the Charm++ documentation. It is the responsibility of the user to check the result pointer is valid. </p>

</div>
</div>
<a id="a3e4ca5b6143a3b8a8c5c1dd9dacf3d08" name="a3e4ca5b6143a3b8a8c5c1dd9dacf3d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e4ca5b6143a3b8a8c5c1dd9dacf3d08">&#9670;&nbsp;</a></span>local_branch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Proxy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto * Parallel::local_branch </td>
          <td>(</td>
          <td class="paramtype">Proxy &amp;&amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for calling Charm++'s <code>.ckLocalBranch()</code> on a proxy. </p>
<p >The Proxy must be to a Charm++ group chare or nodegroup chare.</p>
<p >The function returns a pointer to the local group/nodegroup chare. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae9bb92f00c4aa3fb15b1888332bc5462" name="ae9bb92f00c4aa3fb15b1888332bc5462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9bb92f00c4aa3fb15b1888332bc5462">&#9670;&nbsp;</a></span>has_pup_member_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Parallel::has_pup_member_v = <a class="el" href="structParallel_1_1has__pup__member.html">has_pup_member</a>&lt;T&gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structParallel_1_1has__pup__member.html" title="Check if T has a pup member function.">has_pup_member</a> </dd></dl>

</div>
</div>
<a id="a99e5e039d67f87cc794544f3eb871029" name="a99e5e039d67f87cc794544f3eb871029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e5e039d67f87cc794544f3eb871029">&#9670;&nbsp;</a></span>is_pupable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Parallel::is_pupable_v = <a class="el" href="structParallel_1_1is__pupable.html">is_pupable</a>&lt;T&gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structParallel_1_1is__pupable.html" title="Check if type T has operator| defined for Charm++ serialization.">is_pupable</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceParallel.html">Parallel</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
