<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: Computational Domain</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__ComputationalDomainGroup.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Computational Domain</div></div>
</div><!--header-->
<div class="contents">

<p>The building blocks used to describe the computational domain.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedomain"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedomain.html">domain</a></td></tr>
<tr class="memdesc:namespacedomain"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds entities related to the computational domain. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedomain_1_1BoundaryConditions"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedomain_1_1BoundaryConditions.html">domain::BoundaryConditions</a></td></tr>
<tr class="memdesc:namespacedomain_1_1BoundaryConditions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Domain support for applying boundary conditions <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedomain_1_1CoordinateMaps_1_1Tags"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedomain_1_1CoordinateMaps_1_1Tags.html">domain::CoordinateMaps::Tags</a></td></tr>
<tr class="memdesc:namespacedomain_1_1CoordinateMaps_1_1Tags"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tags for the coordinate maps. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedomain_1_1creators"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedomain_1_1creators.html">domain::creators</a></td></tr>
<tr class="memdesc:namespacedomain_1_1creators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines classes that create Domains. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedomain_1_1creators_1_1time__dependence"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedomain_1_1creators_1_1time__dependence.html">domain::creators::time_dependence</a></td></tr>
<tr class="memdesc:namespacedomain_1_1creators_1_1time__dependence"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classes and functions for adding time dependence to a domain. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedomain_1_1FunctionsOfTime"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedomain_1_1FunctionsOfTime.html">domain::FunctionsOfTime</a></td></tr>
<tr class="memdesc:namespacedomain_1_1FunctionsOfTime"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains functions of time to support the dual frame system. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedomain_1_1Tags"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedomain_1_1Tags.html">domain::Tags</a></td></tr>
<tr class="memdesc:namespacedomain_1_1Tags"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tags for the domain. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlock.html">Block&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root node of a tree which is used to construct the Elements that cover a region of the computational domain.  <a href="classBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1CoordinateMaps_1_1Tags_1_1CoordinateMap.html">domain::CoordinateMaps::Tags::CoordinateMap&lt; VolumeDim, SourceFrame, TargetFrame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coordinate map from source to target coordinates.  <a href="structdomain_1_1CoordinateMaps_1_1Tags_1_1CoordinateMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdomain_1_1creators_1_1BinaryCompactObject.html">domain::creators::BinaryCompactObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A general domain for two compact objects.  <a href="classdomain_1_1creators_1_1BinaryCompactObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdomain_1_1creators_1_1CylindricalBinaryCompactObject.html">domain::creators::CylindricalBinaryCompactObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A general domain for two compact objects based on cylinders.  <a href="classdomain_1_1creators_1_1CylindricalBinaryCompactObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomainCreator.html">DomainCreator&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for creating Domains from an option string.  <a href="classDomainCreator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1OptionTags_1_1DomainCreator.html">domain::OptionTags::DomainCreator&lt; Dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The input file tag for the <a class="el" href="structdomain_1_1OptionTags_1_1DomainCreator.html" title="The input file tag for the DomainCreator to use.">DomainCreator</a> to use.  <a href="structdomain_1_1OptionTags_1_1DomainCreator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1Domain.html">domain::Tags::Domain&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain.">Domain</a>.  <a href="structdomain_1_1Tags_1_1Domain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1InitialExtents.html">domain::Tags::InitialExtents&lt; Dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of grid points per dimension for all elements in each block of the initial computational domain.  <a href="structdomain_1_1Tags_1_1InitialExtents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1InitialRefinementLevels.html">domain::Tags::InitialRefinementLevels&lt; Dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial refinement level per dimension for all elements in each block of the initial computational domain.  <a href="structdomain_1_1Tags_1_1InitialRefinementLevels.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1ObjectCenter.html">domain::Tags::ObjectCenter&lt; Label &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base tag to retrieve the grid frame centers of objects in the domain corresponding to the <code>ObjectLabel</code>.  <a href="structdomain_1_1Tags_1_1ObjectCenter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1ExcisionCenter.html">domain::Tags::ExcisionCenter&lt; Label &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The grid frame center of the excision sphere for the given object.  <a href="structdomain_1_1Tags_1_1ExcisionCenter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html">Domain&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around a vector of Blocks that represent the computational domain.  <a href="classDomain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPairOfFaces.html">PairOfFaces</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each member in <code><a class="el" href="structPairOfFaces.html" title="Each member in PairOfFaces holds the global corner ids of a block face. PairOfFaces is used in settin...">PairOfFaces</a></code> holds the global corner ids of a block face. <code><a class="el" href="structPairOfFaces.html" title="Each member in PairOfFaces holds the global corner ids of a block face. PairOfFaces is used in settin...">PairOfFaces</a></code> is used in setting up periodic boundary conditions by identifying the two faces with each other.  <a href="structPairOfFaces.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVolumeCornerIterator.html">VolumeCornerIterator&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over the corners of a VolumeDim-dimensional cube.  <a href="classVolumeCornerIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFaceCornerIterator.html">FaceCornerIterator&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over the 2^(VolumeDim-1) logical corners of the face of a VolumeDim-dimensional cube in the given direction.  <a href="classFaceCornerIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structElementLogicalCoordHolder.html">ElementLogicalCoordHolder&lt; Dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds element logical coordinates of an arbitrary set of points on a single <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code>. The arbitrary set of points is assumed to be a subset of a larger set of points spanning multiple <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code>s, and this class holds <code>offsets</code> that index into that larger set of points.  <a href="structElementLogicalCoordHolder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElementMap.html">ElementMap&lt; Dim, TargetFrame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CoordinateMap for the <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> from the Logical frame to the <code>TargetFrame</code>  <a href="classElementMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1UnnormalizedFaceNormal.html">domain::Tags::UnnormalizedFaceNormal&lt; VolumeDim, Frame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unnormalized face normal one form.  <a href="structdomain_1_1Tags_1_1UnnormalizedFaceNormal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1InterfaceCompute_3_01Tags_1_1BoundaryDirectionsExterior_3_01VolumeDim_0184ce0938d30efe351cc7c3751f2e8f00.html">domain::Tags::InterfaceCompute&lt; Tags::BoundaryDirectionsExterior&lt; VolumeDim &gt;, UnnormalizedFaceNormalCompute&lt; VolumeDim, Frame &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of <a class="el" href="structdomain_1_1Tags_1_1UnnormalizedFaceNormal.html" title="The unnormalized face normal one form.">UnnormalizedFaceNormal</a> for the external boundaries which inverts the normals. Since ExternalBoundariesDirections are meant to represent ghost elements, the normals should correspond to the normals in said element, which are inverted with respect to the current element.  <a href="structdomain_1_1Tags_1_1InterfaceCompute_3_01Tags_1_1BoundaryDirectionsExterior_3_01VolumeDim_0184ce0938d30efe351cc7c3751f2e8f00.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for <a class="el" href="namespacedomain_1_1FunctionsOfTime.html" title="Contains functions of time to support the dual frame system.">FunctionsOfTime</a>.  <a href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Actions_1_1CheckFunctionsOfTimeAreReady.html">domain::Actions::CheckFunctionsOfTimeAreReady</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that functions of time are up-to-date.  <a href="structdomain_1_1Actions_1_1CheckFunctionsOfTimeAreReady.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1CheckFunctionsOfTimeAreReadyPostprocessor.html">domain::CheckFunctionsOfTimeAreReadyPostprocessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">check that functions of time are up-to-date.  <a href="structdomain_1_1CheckFunctionsOfTimeAreReadyPostprocessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdomain_1_1FunctionsOfTime_1_1PiecewisePolynomial.html">domain::FunctionsOfTime::PiecewisePolynomial&lt; MaxDeriv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that has a piecewise-constant <code>MaxDeriv</code>th derivative.  <a href="classdomain_1_1FunctionsOfTime_1_1PiecewisePolynomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdomain_1_1FunctionsOfTime_1_1QuaternionFunctionOfTime.html">domain::FunctionsOfTime::QuaternionFunctionOfTime&lt; MaxDeriv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html" title="Base class for FunctionsOfTime.">FunctionOfTime</a> that stores quaternions for the rotation map.  <a href="classdomain_1_1FunctionsOfTime_1_1QuaternionFunctionOfTime.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1InterfaceCompute.html">domain::Tags::InterfaceCompute&lt; DirectionsTag, Tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute tag for representing items computed on a set of interfaces. Can be retrieved using <code><a class="el" href="structdomain_1_1Tags_1_1Interface.html" title="Tag which is either a SimpleTag for quantities on an interface, base tag to a compute item which acts...">Tags::Interface</a>&lt;DirectionsTag, Tag&gt;</code>  <a href="structdomain_1_1Tags_1_1InterfaceCompute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1Slice.html">domain::Tags::Slice&lt; DirectionsTag, Tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute tag for representing a compute item that slices data from the volume to a set of interfaces.  <a href="structdomain_1_1Tags_1_1Slice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1InterfaceMesh.html">domain::Tags::InterfaceMesh&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <code>VolumeDim-1</code> dimensional mesh on an interface from the volume mesh. <code><a class="el" href="structdomain_1_1Tags_1_1InterfaceCompute.html" title="Compute tag for representing items computed on a set of interfaces. Can be retrieved using Tags::Inte...">Tags::InterfaceCompute</a>&lt;Dirs, <a class="el" href="structdomain_1_1Tags_1_1InterfaceMesh.html" title="Computes the VolumeDim-1 dimensional mesh on an interface from the volume mesh. Tags::InterfaceComput...">InterfaceMesh</a>&lt;VolumeDim&gt;&gt;</code> is retrievable as <code><a class="el" href="structdomain_1_1Tags_1_1Interface.html" title="Tag which is either a SimpleTag for quantities on an interface, base tag to a compute item which acts...">Tags::Interface</a>&lt;Dirs, <a class="el" href="structdomain_1_1Tags_1_1Mesh.html" title="The computational grid of the Element in the DataBox.">Mesh</a>&lt;VolumeDim&gt;&gt;</code> from the DataBox.  <a href="structdomain_1_1Tags_1_1InterfaceMesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1BoundaryCoordinates.html">domain::Tags::BoundaryCoordinates&lt; VolumeDim, MovingMesh &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the coordinates in the frame <code><a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a></code> on the faces defined by <code><a class="el" href="structdomain_1_1Tags_1_1Direction.html" title="Direction to an interface">Direction</a></code>. Intended to be prefixed by a <code><a class="el" href="structdomain_1_1Tags_1_1InterfaceCompute.html" title="Compute tag for representing items computed on a set of interfaces. Can be retrieved using Tags::Inte...">Tags::InterfaceCompute</a></code> to define the directions on which to compute the coordinates.  <a href="structdomain_1_1Tags_1_1BoundaryCoordinates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1JacobianDiagnostic.html">domain::Tags::JacobianDiagnostic&lt; Dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A diagnostic comparing the analytic and numerical Jacobians for a map. See <code><a class="el" href="group__ComputationalDomainGroup.html#ga45b5650adddebf194bd3d70113a73eb6" title="A diagnostic comparing the analytic and numerical Jacobians for a map.">domain::jacobian_diagnostic</a></code> for details.  <a href="structdomain_1_1Tags_1_1JacobianDiagnostic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1JacobianDiagnosticCompute.html">domain::Tags::JacobianDiagnosticCompute&lt; Dim, TargetFrame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <a class="el" href="structdomain_1_1Tags_1_1Jacobian.html" title="The Jacobian from the source frame to the target frame.">Jacobian</a> diagnostic, which compares the analytic <a class="el" href="structdomain_1_1Tags_1_1Jacobian.html" title="The Jacobian from the source frame to the target frame.">Jacobian</a> (provided by some coordinate map) to a numerical <a class="el" href="structdomain_1_1Tags_1_1Jacobian.html" title="The Jacobian from the source frame to the target frame.">Jacobian</a> computed using numerical partial derivatives. The coordinates must be in the target frame of the map. See <code><a class="el" href="group__ComputationalDomainGroup.html#ga45b5650adddebf194bd3d70113a73eb6" title="A diagnostic comparing the analytic and numerical Jacobians for a map.">domain::jacobian_diagnostic</a></code> for details of the calculation.  <a href="structdomain_1_1Tags_1_1JacobianDiagnosticCompute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1MinimumGridSpacing.html">domain::Tags::MinimumGridSpacing&lt; Dim, Frame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum coordinate distance between grid points.  <a href="structdomain_1_1Tags_1_1MinimumGridSpacing.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1SizeOfElement.html">domain::Tags::SizeOfElement&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inertial-coordinate size of an element along each of its logical directions.  <a href="structdomain_1_1Tags_1_1SizeOfElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdomain_1_1BlockId.html">domain::BlockId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classIndex.html" title="An integer multi-index.">Index</a> a block of the computational domain.  <a href="classdomain_1_1BlockId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockNeighbor.html">BlockNeighbor&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the neighbor of a host <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> in a particular direction.  <a href="classBlockNeighbor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDirection.html">Direction&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A particular Side along a particular coordinate Axis.  <a href="classDirection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDirectionHash.html">DirectionHash&lt; Dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a perfect hash if the size of the hash table is <code>2 * Dim</code>. To take advantage of this, use the <code><a class="el" href="classFixedHashMap.html" title="A hash table with a compile-time specified maximum size and ability to efficiently handle perfect has...">FixedHashMap</a></code> class.  <a href="structDirectionHash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDirectionMap.html">DirectionMap&lt; Dim, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optimized map with <a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis.">Direction</a> keys.  <a href="classDirectionMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html">Element&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A spectral element with knowledge of its neighbors.  <a href="classElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElementId.html">ElementId&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a> uniquely labels an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>.  <a href="classElementId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExcisionSphere.html">ExcisionSphere&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The excision sphere information of a computational domain. The excision sphere is assumed to be a coordinate sphere in the grid frame.  <a href="classExcisionSphere.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeighbors.html">Neighbors&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the neighbors of a host <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> in a particular direction.  <a href="classNeighbors.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrientationMap.html">OrientationMap&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mapping of the logical coordinate axes of a host to the logical coordinate axes of a neighbor of the host.  <a href="classOrientationMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSegmentId.html">SegmentId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classSegmentId.html" title="A SegmentId labels a segment of the interval  and is used to identify the bounds of an Element in a B...">SegmentId</a> labels a segment of the interval \([-1,1]\) and is used to identify the bounds of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> in a <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> in each dimension.  <a href="classSegmentId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1Element.html">domain::Tags::Element&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> associated with the DataBox.  <a href="structdomain_1_1Tags_1_1Element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1Mesh.html">domain::Tags::Mesh&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The computational grid of the <a class="el" href="structdomain_1_1Tags_1_1Element.html" title="The Element associated with the DataBox.">Element</a> in the DataBox.  <a href="structdomain_1_1Tags_1_1Mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1ElementMap.html">domain::Tags::ElementMap&lt; VolumeDim, TargetFrame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coordinate map from the ElementLogical frame to the TargetFrame.  <a href="structdomain_1_1Tags_1_1ElementMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1Coordinates.html">domain::Tags::Coordinates&lt; Dim, Frame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coordinates in a given frame.  <a href="structdomain_1_1Tags_1_1Coordinates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1MappedCoordinates.html">domain::Tags::MappedCoordinates&lt; MapTag, SourceCoordsTag, CoordinatesTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coordinates in the target frame of <code>MapTag</code>. The <code>SourceCoordsTag</code>'s frame must be the source frame of <code>MapTag</code>  <a href="structdomain_1_1Tags_1_1MappedCoordinates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1InverseJacobian.html">domain::Tags::InverseJacobian&lt; Dim, SourceFrame, TargetFrame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse <a class="el" href="structdomain_1_1Tags_1_1Jacobian.html" title="The Jacobian from the source frame to the target frame.">Jacobian</a> from the source frame to the target frame.  <a href="structdomain_1_1Tags_1_1InverseJacobian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1InverseJacobianCompute.html">domain::Tags::InverseJacobianCompute&lt; MapTag, SourceCoordsTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse <a class="el" href="structdomain_1_1Tags_1_1Jacobian.html" title="The Jacobian from the source frame to the target frame.">Jacobian</a> of the map held by <code>MapTag</code> at the coordinates held by <code>SourceCoordsTag</code>. The coordinates must be in the source frame of the map.  <a href="structdomain_1_1Tags_1_1InverseJacobianCompute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1Jacobian.html">domain::Tags::Jacobian&lt; Dim, SourceFrame, TargetFrame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structdomain_1_1Tags_1_1Jacobian.html" title="The Jacobian from the source frame to the target frame.">Jacobian</a> from the source frame to the target frame.  <a href="structdomain_1_1Tags_1_1Jacobian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1JacobianCompute.html">domain::Tags::JacobianCompute&lt; Dim, SourceFrame, TargetFrame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <a class="el" href="structdomain_1_1Tags_1_1Jacobian.html" title="The Jacobian from the source frame to the target frame.">Jacobian</a> of the map from the <code><a class="el" href="structdomain_1_1Tags_1_1InverseJacobian.html" title="The inverse Jacobian from the source frame to the target frame.">InverseJacobian</a>&lt;Dim, SourceFrame, TargetFrame&gt;</code> tag.  <a href="structdomain_1_1Tags_1_1JacobianCompute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1DetInvJacobian.html">domain::Tags::DetInvJacobian&lt; SourceFrame, TargetFrame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The determinant of the inverse <a class="el" href="structdomain_1_1Tags_1_1Jacobian.html" title="The Jacobian from the source frame to the target frame.">Jacobian</a> from the source frame to the target frame.  <a href="structdomain_1_1Tags_1_1DetInvJacobian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1DetInvJacobianCompute.html">domain::Tags::DetInvJacobianCompute&lt; Dim, SourceFrame, TargetFrame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the determinant of the inverse <a class="el" href="structdomain_1_1Tags_1_1Jacobian.html" title="The Jacobian from the source frame to the target frame.">Jacobian</a>.  <a href="structdomain_1_1Tags_1_1DetInvJacobianCompute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1VariablesBoundaryData.html">domain::Tags::VariablesBoundaryData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base tag for boundary data needed for updating the variables.  <a href="structdomain_1_1Tags_1_1VariablesBoundaryData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1InternalDirections.html">domain::Tags::InternalDirections&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of directions to neighboring Elements.  <a href="structdomain_1_1Tags_1_1InternalDirections.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1BoundaryDirectionsInterior.html">domain::Tags::BoundaryDirectionsInterior&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of directions which correspond to external boundaries. Used for representing data on the interior side of the external boundary faces.  <a href="structdomain_1_1Tags_1_1BoundaryDirectionsInterior.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1BoundaryDirectionsExterior.html">domain::Tags::BoundaryDirectionsExterior&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of directions which correspond to external boundaries. To be used to represent data which exists on the exterior side of the external boundary faces.  <a href="structdomain_1_1Tags_1_1BoundaryDirectionsExterior.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1Interface.html">domain::Tags::Interface&lt; DirectionsTag, Tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag which is either a SimpleTag for quantities on an interface, base tag to a compute item which acts on tags on an interface, or base tag to a compute item which slices a tag from the volume to an interface.  <a href="structdomain_1_1Tags_1_1Interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1Direction.html">domain::Tags::Direction&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis.">Direction</a> to an interface  <a href="structdomain_1_1Tags_1_1Direction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1LogicalCoordinates.html">domain::Tags::LogicalCoordinates&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The logical coordinates in the <a class="el" href="structdomain_1_1Tags_1_1Element.html" title="The Element associated with the DataBox.">Element</a>.  <a href="structdomain_1_1Tags_1_1LogicalCoordinates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga39eb7361b3bcfe317a1576be5141b10f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga39eb7361b3bcfe317a1576be5141b10f">INSTANTIATE_MAPS_SIMPLE_FUNCTIONS</a>(_,  data)</td></tr>
<tr class="memdesc:ga39eb7361b3bcfe317a1576be5141b10f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate instantiations of member functions of the <code>CoordinateMap</code> class template.  <a href="group__ComputationalDomainGroup.html#ga39eb7361b3bcfe317a1576be5141b10f">More...</a><br /></td></tr>
<tr class="separator:ga39eb7361b3bcfe317a1576be5141b10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45607952ebcf523987906a5c27ccef59"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga45607952ebcf523987906a5c27ccef59">INSTANTIATE_MAPS_DATA_TYPE_FUNCTIONS</a>(_,  data)</td></tr>
<tr class="memdesc:ga45607952ebcf523987906a5c27ccef59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate instantiations of member functions of the <code>CoordinateMap</code> class template.  <a href="group__ComputationalDomainGroup.html#ga45607952ebcf523987906a5c27ccef59">More...</a><br /></td></tr>
<tr class="separator:ga45607952ebcf523987906a5c27ccef59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8773fe02f44b68af479cb53dd4383978"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga8773fe02f44b68af479cb53dd4383978">INSTANTIATE_MAPS_FUNCTIONS</a>(MAPS_TUPLE,  SOURCE_FRAME,  TARGET_FRAMES_TUPLE,  TYPES_TUPLE)</td></tr>
<tr class="memdesc:ga8773fe02f44b68af479cb53dd4383978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate instantiations of member functions of the <code>CoordinateMap</code> class template.  <a href="group__ComputationalDomainGroup.html#ga8773fe02f44b68af479cb53dd4383978">More...</a><br /></td></tr>
<tr class="separator:ga8773fe02f44b68af479cb53dd4383978"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gac672a529d9aaa6a948b8b7eb6ec9b528"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gac672a529d9aaa6a948b8b7eb6ec9b528">ShellWedges</a> { <a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ab1c94ca2fbc3e78fc30069c8d0f01680">ShellWedges::All</a>
, <a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ace553534ea34f25db4b4a8b5bd29cf45">ShellWedges::FourOnEquator</a>
, <a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ae9d8dbfbf81de7cf729066f677661edb">ShellWedges::OneAlongMinusX</a>
 }</td></tr>
<tr class="memdesc:gac672a529d9aaa6a948b8b7eb6ec9b528"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of wedges to include in the Sphere domain.  <a href="group__ComputationalDomainGroup.html#gac672a529d9aaa6a948b8b7eb6ec9b528">More...</a><br /></td></tr>
<tr class="separator:gac672a529d9aaa6a948b8b7eb6ec9b528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c0137d7160ad71b6ed265c53c99ed00"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">Side</a> { <b>Lower</b>
, <b>Upper</b>
 }</td></tr>
<tr class="memdesc:ga8c0137d7160ad71b6ed265c53c99ed00"><td class="mdescLeft">&#160;</td><td class="mdescRight">A label for the side of a manifold.  <a href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">More...</a><br /></td></tr>
<tr class="separator:ga8c0137d7160ad71b6ed265c53c99ed00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad820f28f973850990200bcb2d858fe1d"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename Frame &gt; </td></tr>
<tr class="memitem:gad820f28f973850990200bcb2d858fe1d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gad820f28f973850990200bcb2d858fe1d">block_logical_coordinates</a> (const <a class="el" href="classDomain.html">Domain</a>&lt; Dim &gt; &amp;domain, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, Frame &gt; &amp;x, double time=<a class="elRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits</a>&lt; double &gt;::signaling_NaN(), const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt; &gt; &amp;functions_of_time=<a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt; &gt;{}) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="el" href="structIdPair.html">IdPair</a>&lt; <a class="el" href="classdomain_1_1BlockId.html">domain::BlockId</a>, tnsr::I&lt; double, Dim, <a class="el" href="structFrame_1_1BlockLogical.html">::Frame::BlockLogical</a> &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gad820f28f973850990200bcb2d858fe1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the block logical coordinates and the containing <code>BlockId</code> of a set of points, given coordinates in a particular frame.  <a href="group__ComputationalDomainGroup.html#gad820f28f973850990200bcb2d858fe1d">More...</a><br /></td></tr>
<tr class="separator:gad820f28f973850990200bcb2d858fe1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96dc1aa7d7d767871d0eecf941f9b5a8"><td class="memTemplParams" colspan="2"><a id="ga96dc1aa7d7d767871d0eecf941f9b5a8" name="ga96dc1aa7d7d767871d0eecf941f9b5a8"></a>
template&lt;typename SourceFrame , typename TargetFrame , typename... Maps&gt; </td></tr>
<tr class="memitem:ga96dc1aa7d7d767871d0eecf941f9b5a8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>domain::make_coordinate_map</b> (Maps &amp;&amp;... maps) -&gt; <a class="el" href="classdomain_1_1CoordinateMap.html">CoordinateMap</a>&lt; SourceFrame, TargetFrame, <a class="elRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt; Maps &gt;... &gt;</td></tr>
<tr class="memdesc:ga96dc1aa7d7d767871d0eecf941f9b5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="classdomain_1_1CoordinateMap.html" title="A coordinate map or composition of coordinate maps.">CoordinateMap</a></code> of <code>maps...</code> <br /></td></tr>
<tr class="separator:ga96dc1aa7d7d767871d0eecf941f9b5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1668b4acdae04db8e32fe562f68abccb"><td class="memTemplParams" colspan="2"><a id="ga1668b4acdae04db8e32fe562f68abccb" name="ga1668b4acdae04db8e32fe562f68abccb"></a>
template&lt;typename SourceFrame , typename TargetFrame , typename... Maps&gt; </td></tr>
<tr class="memitem:ga1668b4acdae04db8e32fe562f68abccb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>domain::make_coordinate_map_base</b> (Maps &amp;&amp;... maps) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">CoordinateMapBase</a>&lt; SourceFrame, TargetFrame, <a class="el" href="classdomain_1_1CoordinateMap.html">CoordinateMap</a>&lt; SourceFrame, TargetFrame, <a class="elRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt; Maps &gt;... &gt;::dim &gt; &gt;</td></tr>
<tr class="memdesc:ga1668b4acdae04db8e32fe562f68abccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;<a class="el" href="classdomain_1_1CoordinateMapBase.html" title="Abstract base class for CoordinateMap.">CoordinateMapBase</a>&gt;</code> of <code>maps...</code> <br /></td></tr>
<tr class="separator:ga1668b4acdae04db8e32fe562f68abccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0ab51e0621530cf6697181900c0f289"><td class="memTemplParams" colspan="2"><a id="gaa0ab51e0621530cf6697181900c0f289" name="gaa0ab51e0621530cf6697181900c0f289"></a>
template&lt;typename SourceFrame , typename TargetFrame , typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:gaa0ab51e0621530cf6697181900c0f289"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>domain::make_vector_coordinate_map_base</b> (Arg0 &amp;&amp;arg_0, Args &amp;&amp;... remaining_args) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">CoordinateMapBase</a>&lt; SourceFrame, TargetFrame, <a class="elRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt; Arg0 &gt;::dim &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gaa0ab51e0621530cf6697181900c0f289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;<a class="el" href="classdomain_1_1CoordinateMapBase.html" title="Abstract base class for CoordinateMap.">CoordinateMapBase</a>&gt;&gt;</code> containing the result of <code>make_coordinate_map_base</code> applied to each argument passed in. <br /></td></tr>
<tr class="separator:gaa0ab51e0621530cf6697181900c0f289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga274e0101fff8b99a67419c3f496c9be3"><td class="memTemplParams" colspan="2"><a id="ga274e0101fff8b99a67419c3f496c9be3" name="ga274e0101fff8b99a67419c3f496c9be3"></a>
template&lt;typename SourceFrame , typename TargetFrame , size_t Dim, typename Map , typename... Maps&gt; </td></tr>
<tr class="memitem:ga274e0101fff8b99a67419c3f496c9be3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>domain::make_vector_coordinate_map_base</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; Map &gt; maps, const Maps &amp;... remaining_maps) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">CoordinateMapBase</a>&lt; SourceFrame, TargetFrame, Dim &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga274e0101fff8b99a67419c3f496c9be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;<a class="el" href="classdomain_1_1CoordinateMapBase.html" title="Abstract base class for CoordinateMap.">CoordinateMapBase</a>&gt;&gt;</code> containing the result of <code>make_coordinate_map_base</code> applied to each element of the vector of maps composed with the rest of the arguments passed in. <br /></td></tr>
<tr class="separator:ga274e0101fff8b99a67419c3f496c9be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8cd3961d1743137316f45a21e44e633"><td class="memTemplParams" colspan="2"><a id="gaa8cd3961d1743137316f45a21e44e633" name="gaa8cd3961d1743137316f45a21e44e633"></a>
template&lt;typename SourceFrame , typename TargetFrame , typename... Maps, typename NewMap &gt; </td></tr>
<tr class="memitem:gaa8cd3961d1743137316f45a21e44e633"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdomain_1_1CoordinateMap.html">CoordinateMap</a>&lt; SourceFrame, TargetFrame, Maps..., NewMap &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>domain::push_back</b> (<a class="el" href="classdomain_1_1CoordinateMap.html">CoordinateMap</a>&lt; SourceFrame, TargetFrame, Maps... &gt; old_map, NewMap new_map)</td></tr>
<tr class="memdesc:gaa8cd3961d1743137316f45a21e44e633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="classdomain_1_1CoordinateMap.html" title="A coordinate map or composition of coordinate maps.">CoordinateMap</a></code> by appending the new map to the end of the old maps. <br /></td></tr>
<tr class="separator:gaa8cd3961d1743137316f45a21e44e633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac81519ee0b09d6e2080198045a195794"><td class="memTemplParams" colspan="2"><a id="gac81519ee0b09d6e2080198045a195794" name="gac81519ee0b09d6e2080198045a195794"></a>
template&lt;typename SourceFrame , typename TargetFrame , typename... Maps, typename NewMap &gt; </td></tr>
<tr class="memitem:gac81519ee0b09d6e2080198045a195794"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdomain_1_1CoordinateMap.html">CoordinateMap</a>&lt; SourceFrame, TargetFrame, NewMap, Maps... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>domain::push_front</b> (<a class="el" href="classdomain_1_1CoordinateMap.html">CoordinateMap</a>&lt; SourceFrame, TargetFrame, Maps... &gt; old_map, NewMap new_map)</td></tr>
<tr class="memdesc:gac81519ee0b09d6e2080198045a195794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="classdomain_1_1CoordinateMap.html" title="A coordinate map or composition of coordinate maps.">CoordinateMap</a></code> by prepending the new map to the beginning of the old maps. <br /></td></tr>
<tr class="separator:gac81519ee0b09d6e2080198045a195794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga027b0f10547532972db32bb8429a6373"><td class="memTemplParams" colspan="2"><a id="ga027b0f10547532972db32bb8429a6373" name="ga027b0f10547532972db32bb8429a6373"></a>
template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga027b0f10547532972db32bb8429a6373"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>set_internal_boundaries</b> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; VolumeDim, <a class="el" href="classBlockNeighbor.html">BlockNeighbor</a>&lt; VolumeDim &gt; &gt; &gt; * &gt; neighbors_of_all_blocks, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt; &gt; &amp;corners_of_all_blocks)</td></tr>
<tr class="memdesc:ga027b0f10547532972db32bb8429a6373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the BlockNeighbors using the corner numbering scheme provided by the user to deduce the correct neighbors and orientations. Does not set up periodic boundary conditions. <br /></td></tr>
<tr class="separator:ga027b0f10547532972db32bb8429a6373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab99ad646c285e1457d42733ff283fba1"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:gab99ad646c285e1457d42733ff283fba1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gab99ad646c285e1457d42733ff283fba1">set_internal_boundaries</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; VolumeDim, <a class="el" href="classBlockNeighbor.html">BlockNeighbor</a>&lt; VolumeDim &gt; &gt; &gt; * &gt; neighbors_of_all_blocks, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1BlockLogical.html">Frame::BlockLogical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, VolumeDim &gt; &gt; &gt; &amp;maps)</td></tr>
<tr class="memdesc:gab99ad646c285e1457d42733ff283fba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the BlockNeighbors using the corner numbering scheme implied by the maps provided by the user to deduce the correct neighbors and orientations.  <a href="group__ComputationalDomainGroup.html#gab99ad646c285e1457d42733ff283fba1">More...</a><br /></td></tr>
<tr class="separator:gab99ad646c285e1457d42733ff283fba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fd9512dd6916bf553bb13978951e44d"><td class="memTemplParams" colspan="2"><a id="ga3fd9512dd6916bf553bb13978951e44d" name="ga3fd9512dd6916bf553bb13978951e44d"></a>
template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga3fd9512dd6916bf553bb13978951e44d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>set_identified_boundaries</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="structPairOfFaces.html">PairOfFaces</a> &gt; &amp;identifications, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt; &gt; &amp;corners_of_all_blocks, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; VolumeDim, <a class="el" href="classBlockNeighbor.html">BlockNeighbor</a>&lt; VolumeDim &gt; &gt; &gt; * &gt; neighbors_of_all_blocks)</td></tr>
<tr class="memdesc:ga3fd9512dd6916bf553bb13978951e44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up additional BlockNeighbors corresponding to any identifications of faces provided by the user. Can be used for manually setting up periodic boundary conditions. <br /></td></tr>
<tr class="separator:ga3fd9512dd6916bf553bb13978951e44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92c8b5d0f433d2aba92efd0747a20110"><td class="memTemplParams" colspan="2"><a id="ga92c8b5d0f433d2aba92efd0747a20110" name="ga92c8b5d0f433d2aba92efd0747a20110"></a>
template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga92c8b5d0f433d2aba92efd0747a20110"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>indices_for_rectilinear_domains</b> (const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;domain_extents, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &gt; &amp;block_indices_to_exclude={}) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &gt;</td></tr>
<tr class="memdesc:ga92c8b5d0f433d2aba92efd0747a20110"><td class="mdescLeft">&#160;</td><td class="mdescRight">The multi-indices that identify the individual Blocks in the lattice. <br /></td></tr>
<tr class="separator:ga92c8b5d0f433d2aba92efd0747a20110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ae13666f13523f52e00e508129999c1"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga0ae13666f13523f52e00e508129999c1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga0ae13666f13523f52e00e508129999c1">corners_for_rectilinear_domains</a> (const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;domain_extents, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &gt; &amp;block_indices_to_exclude={}) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt; &gt;</td></tr>
<tr class="memdesc:ga0ae13666f13523f52e00e508129999c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The corners for a rectilinear domain made of n-cubes.  <a href="group__ComputationalDomainGroup.html#ga0ae13666f13523f52e00e508129999c1">More...</a><br /></td></tr>
<tr class="separator:ga0ae13666f13523f52e00e508129999c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41d1330e86ab890c0a17b81f09e07503"><td class="memItemLeft" align="right" valign="top"><a id="ga41d1330e86ab890c0a17b81f09e07503" name="ga41d1330e86ab890c0a17b81f09e07503"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>which_wedge_index</b> (const <a class="el" href="group__ComputationalDomainGroup.html#gac672a529d9aaa6a948b8b7eb6ec9b528">ShellWedges</a> &amp;which_wedges)</td></tr>
<tr class="memdesc:ga41d1330e86ab890c0a17b81f09e07503"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first index in the list "UpperZ", "LowerZ", "UpperY", "LowerY", "UpperX" "LowerX" that is included in <code>which_wedges</code>. It is 0 for <code><a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ab1c94ca2fbc3e78fc30069c8d0f01680" title="Use the entire shell.">ShellWedges::All</a></code>, 2 for <code><a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ace553534ea34f25db4b4a8b5bd29cf45" title="Use only the four equatorial wedges.">ShellWedges::FourOnEquator</a></code>, and 5 for <code><a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ae9d8dbfbf81de7cf729066f677661edb" title="Use only the single wedge along -x.">ShellWedges::OneAlongMinusX</a></code>. <br /></td></tr>
<tr class="separator:ga41d1330e86ab890c0a17b81f09e07503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6c9a4469ceecf0541c580bd0a4abb73"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html">domain::CoordinateMaps::Wedge</a>&lt; 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gac6c9a4469ceecf0541c580bd0a4abb73">sph_wedge_coordinate_maps</a> (double inner_radius, double outer_radius, double inner_sphericity, double outer_sphericity, bool use_equiangular_map, bool use_half_wedges=false, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;radial_partitioning={}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">domain::CoordinateMaps::Distribution</a> &gt; &amp;radial_distribution={domain::CoordinateMaps::Distribution::Linear}, <a class="el" href="group__ComputationalDomainGroup.html#gac672a529d9aaa6a948b8b7eb6ec9b528">ShellWedges</a> which_wedges=<a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ab1c94ca2fbc3e78fc30069c8d0f01680">ShellWedges::All</a>, double opening_angle=M_PI_2)</td></tr>
<tr class="separator:gac6c9a4469ceecf0541c580bd0a4abb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5a26a3f95902480b4892f296996900e"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classdomain_1_1CoordinateMaps_1_1Frustum.html">domain::CoordinateMaps::Frustum</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gab5a26a3f95902480b4892f296996900e">frustum_coordinate_maps</a> (double length_inner_cube, double length_outer_cube, bool use_equiangular_map, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 3 &gt; &amp;origin_preimage={{0.0, 0.0, 0.0}}, double projective_scale_factor=1.0, double sphericity=0.0, double opening_angle=M_PI_2)</td></tr>
<tr class="memdesc:gab5a26a3f95902480b4892f296996900e"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are the ten Frustums used in the DomainCreators for binary compact objects. The Frustums partition the volume defined by two bounding surfaces: The inner surface is the surface of the two joined inner cubes enveloping the two compact objects, while the outer is the surface of the outer cube. The cubes enveloping the two Shells each have a side length of <code>length_inner_cube</code>. The outer cube has a side length of <code>length_outer_cube</code>. <code>origin_preimage</code> is a parameter that moves the center of the two joined inner cubes away from the origin and to <code>-origin_preimage</code>. <code>projective_scale_factor</code> acts to change the gridpoint distribution in the radial direction.  <a href="group__ComputationalDomainGroup.html#gab5a26a3f95902480b4892f296996900e">More...</a><br /></td></tr>
<tr class="separator:gab5a26a3f95902480b4892f296996900e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00df68c8b8f3362d716905aaae483088"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga00df68c8b8f3362d716905aaae483088">corners_for_radially_layered_domains</a> (size_t number_of_layers, bool include_central_block, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &amp;central_block_corners={{1, 2, 3, 4, 5, 6, 7, 8}}, <a class="el" href="group__ComputationalDomainGroup.html#gac672a529d9aaa6a948b8b7eb6ec9b528">ShellWedges</a> which_wedges=<a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ab1c94ca2fbc3e78fc30069c8d0f01680">ShellWedges::All</a>)</td></tr>
<tr class="memdesc:ga00df68c8b8f3362d716905aaae483088"><td class="mdescLeft">&#160;</td><td class="mdescRight">The corners for a domain with radial layers.  <a href="group__ComputationalDomainGroup.html#ga00df68c8b8f3362d716905aaae483088">More...</a><br /></td></tr>
<tr class="separator:ga00df68c8b8f3362d716905aaae483088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdc7ac14ee646a462ce8fc921ab40f92"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gabdc7ac14ee646a462ce8fc921ab40f92">corners_for_biradially_layered_domains</a> (size_t number_of_radial_layers, size_t number_of_biradial_layers, bool include_central_block_lhs, bool include_central_block_rhs, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &amp;central_block_corners_lhs={ {1, 2, 3, 4, 5, 6, 7, 8}})</td></tr>
<tr class="memdesc:gabdc7ac14ee646a462ce8fc921ab40f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">The corners for a domain with biradial layers.  <a href="group__ComputationalDomainGroup.html#gabdc7ac14ee646a462ce8fc921ab40f92">More...</a><br /></td></tr>
<tr class="separator:gabdc7ac14ee646a462ce8fc921ab40f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f9cd607fe3deeb525b1dc14d0b876c6"><td class="memTemplParams" colspan="2">template&lt;typename TargetFrame &gt; </td></tr>
<tr class="memitem:ga6f9cd607fe3deeb525b1dc14d0b876c6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga6f9cd607fe3deeb525b1dc14d0b876c6">cyl_wedge_coordinate_maps</a> (double inner_radius, double outer_radius, double lower_z_bound, double upper_z_bound, bool use_equiangular_map, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;radial_partitioning={}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;partitioning_in_z={}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">domain::CoordinateMaps::Distribution</a> &gt; &amp;radial_distribution={domain::CoordinateMaps::Distribution::Linear}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">domain::CoordinateMaps::Distribution</a> &gt; &amp;distribution_in_z={domain::CoordinateMaps::Distribution::Linear}) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1BlockLogical.html">Frame::BlockLogical</a>, TargetFrame, 3 &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga6f9cd607fe3deeb525b1dc14d0b876c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are the CoordinateMaps used in the Cylinder <a class="el" href="classDomainCreator.html" title="Base class for creating Domains from an option string.">DomainCreator</a>.  <a href="group__ComputationalDomainGroup.html#ga6f9cd607fe3deeb525b1dc14d0b876c6">More...</a><br /></td></tr>
<tr class="separator:ga6f9cd607fe3deeb525b1dc14d0b876c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2104aed15616a0d35eb5224366b60853"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga2104aed15616a0d35eb5224366b60853">cyl_wedge_coord_map_center_blocks</a> (double inner_radius, double lower_z_bound, double upper_z_bound, bool use_equiangular_map, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;partitioning_in_z={}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">domain::CoordinateMaps::Distribution</a> &gt; &amp;distribution_in_z={domain::CoordinateMaps::Distribution::Linear}, CylindricalDomainParityFlip parity_flip=CylindricalDomainParityFlip::none) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classdomain_1_1CoordinateMaps_1_1ProductOf3Maps.html">domain::CoordinateMaps::ProductOf3Maps</a>&lt; <a class="el" href="classdomain_1_1CoordinateMaps_1_1Interval.html">domain::CoordinateMaps::Interval</a>, <a class="el" href="classdomain_1_1CoordinateMaps_1_1Interval.html">domain::CoordinateMaps::Interval</a>, <a class="el" href="classdomain_1_1CoordinateMaps_1_1Interval.html">domain::CoordinateMaps::Interval</a> &gt; &gt;</td></tr>
<tr class="memdesc:ga2104aed15616a0d35eb5224366b60853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>cyl_wedge_coordinate_maps</code>, but only the center square blocks,.  <a href="group__ComputationalDomainGroup.html#ga2104aed15616a0d35eb5224366b60853">More...</a><br /></td></tr>
<tr class="separator:ga2104aed15616a0d35eb5224366b60853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b7f632f810cd61504431c933f9470fd"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga1b7f632f810cd61504431c933f9470fd">cyl_wedge_coord_map_surrounding_blocks</a> (double inner_radius, double outer_radius, double lower_z_bound, double upper_z_bound, bool use_equiangular_map, double inner_circularity, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;radial_partitioning={}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;partitioning_in_z={}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">domain::CoordinateMaps::Distribution</a> &gt; &amp;radial_distribution={domain::CoordinateMaps::Distribution::Linear}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">domain::CoordinateMaps::Distribution</a> &gt; &amp;distribution_in_z={domain::CoordinateMaps::Distribution::Linear}, CylindricalDomainParityFlip parity_flip=CylindricalDomainParityFlip::none) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classdomain_1_1CoordinateMaps_1_1ProductOf2Maps.html">domain::CoordinateMaps::ProductOf2Maps</a>&lt; <a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html">domain::CoordinateMaps::Wedge</a>&lt; 2 &gt;, <a class="el" href="classdomain_1_1CoordinateMaps_1_1Interval.html">domain::CoordinateMaps::Interval</a> &gt; &gt;</td></tr>
<tr class="memdesc:ga1b7f632f810cd61504431c933f9470fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as cyl_wedge_coordinate_maps, but only the surrounding wedge blocks.  <a href="group__ComputationalDomainGroup.html#ga1b7f632f810cd61504431c933f9470fd">More...</a><br /></td></tr>
<tr class="separator:ga1b7f632f810cd61504431c933f9470fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b0d40a514ae8440623b32a4420f9452"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga7b0d40a514ae8440623b32a4420f9452">corners_for_cylindrical_layered_domains</a> (size_t number_of_shells, size_t number_of_discs)</td></tr>
<tr class="memdesc:ga7b0d40a514ae8440623b32a4420f9452"><td class="mdescLeft">&#160;</td><td class="mdescRight">The corners for a cylindrical domain split into discs with radial shells.  <a href="group__ComputationalDomainGroup.html#ga7b0d40a514ae8440623b32a4420f9452">More...</a><br /></td></tr>
<tr class="separator:ga7b0d40a514ae8440623b32a4420f9452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24a1fcea4aafb78195851e7bd25394f5"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga24a1fcea4aafb78195851e7bd25394f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga24a1fcea4aafb78195851e7bd25394f5">discrete_rotation</a> (const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;orientation, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt; &amp;corners_of_aligned)</td></tr>
<tr class="memdesc:ga24a1fcea4aafb78195851e7bd25394f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutes the corner numbers of an n-cube.  <a href="group__ComputationalDomainGroup.html#ga24a1fcea4aafb78195851e7bd25394f5">More...</a><br /></td></tr>
<tr class="separator:ga24a1fcea4aafb78195851e7bd25394f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga772eeed19a2f610810889ac961d06e67"><td class="memTemplParams" colspan="2">template&lt;typename TargetFrame , size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga772eeed19a2f610810889ac961d06e67"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga772eeed19a2f610810889ac961d06e67">maps_for_rectilinear_domains</a> (const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;domain_extents, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt;, VolumeDim &gt; &amp;block_demarcations, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &gt; &amp;block_indices_to_exclude={}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &gt; &amp;orientations_of_all_blocks={}, bool use_equiangular_map=false) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1BlockLogical.html">Frame::BlockLogical</a>, TargetFrame, VolumeDim &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga772eeed19a2f610810889ac961d06e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CoordinateMaps for a rectilinear domain of n-cubes.  <a href="group__ComputationalDomainGroup.html#ga772eeed19a2f610810889ac961d06e67">More...</a><br /></td></tr>
<tr class="separator:ga772eeed19a2f610810889ac961d06e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d5a73eaa01c10f7d3b456318e0880a9"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga0d5a73eaa01c10f7d3b456318e0880a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDomain.html">Domain</a>&lt; VolumeDim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga0d5a73eaa01c10f7d3b456318e0880a9">rectilinear_domain</a> (const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;domain_extents, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt;, VolumeDim &gt; &amp;block_demarcations, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &gt; &amp;block_indices_to_exclude={}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &gt; &amp;orientations_of_all_blocks={}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; bool, VolumeDim &gt; &amp;dimension_is_periodic=<a class="el" href="group__UtilitiesGroup.html#gaef51773ec780d16fddcda8e5094f2a21">make_array</a>&lt; VolumeDim &gt;(false), const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="structPairOfFaces.html">PairOfFaces</a> &gt; &amp;identifications={}, bool use_equiangular_map=false)</td></tr>
<tr class="memdesc:ga0d5a73eaa01c10f7d3b456318e0880a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rectilinear <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain.">Domain</a> of multicubes.  <a href="group__ComputationalDomainGroup.html#ga0d5a73eaa01c10f7d3b456318e0880a9">More...</a><br /></td></tr>
<tr class="separator:ga0d5a73eaa01c10f7d3b456318e0880a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8679bb8131f836ff5e2d4deb1f4eff07"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ga8679bb8131f836ff5e2d4deb1f4eff07"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga8679bb8131f836ff5e2d4deb1f4eff07">element_logical_coordinates</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt; &amp;element_ids, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="el" href="structIdPair.html">IdPair</a>&lt; <a class="el" href="classdomain_1_1BlockId.html">domain::BlockId</a>, tnsr::I&lt; double, Dim, typename <a class="el" href="structFrame_1_1BlockLogical.html">Frame::BlockLogical</a> &gt; &gt; &gt; &gt; &amp;block_coord_holders) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt;, <a class="el" href="structElementLogicalCoordHolder.html">ElementLogicalCoordHolder</a>&lt; Dim &gt; &gt;</td></tr>
<tr class="memdesc:ga8679bb8131f836ff5e2d4deb1f4eff07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of points in block logical coordinates and their <code>BlockIds</code>, as returned from the function <code>block_logical_coordinates</code>, determines which <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code>s in a list of <code><a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a></code>s contains each point, and determines the element logical coordinates of each point.  <a href="group__ComputationalDomainGroup.html#ga8679bb8131f836ff5e2d4deb1f4eff07">More...</a><br /></td></tr>
<tr class="separator:ga8679bb8131f836ff5e2d4deb1f4eff07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7de6fa2c6d431c00ca9fe7d309c10cd2"><td class="memTemplParams" colspan="2">template&lt;typename CacheTag , typename Metavariables , typename ArrayIndex , typename Component , size_t N = 0&gt; </td></tr>
<tr class="memitem:ga7de6fa2c6d431c00ca9fe7d309c10cd2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga7de6fa2c6d431c00ca9fe7d309c10cd2">domain::functions_of_time_are_ready</a> (<a class="el" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache</a>&lt; Metavariables &gt; &amp;cache, const ArrayIndex &amp;array_index, const Component *, const double time, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, N &gt; &amp;functions_to_check=<a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, 0 &gt;{})</td></tr>
<tr class="memdesc:ga7de6fa2c6d431c00ca9fe7d309c10cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that functions of time are up-to-date.  <a href="group__ComputationalDomainGroup.html#ga7de6fa2c6d431c00ca9fe7d309c10cd2">More...</a><br /></td></tr>
<tr class="separator:ga7de6fa2c6d431c00ca9fe7d309c10cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3255acdd06d1f41f624e4519a9006082"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga3255acdd06d1f41f624e4519a9006082"><td class="memTemplItemLeft" align="right" valign="top">tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga3255acdd06d1f41f624e4519a9006082">interface_logical_coordinates</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;mesh, const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;direction)</td></tr>
<tr class="memdesc:ga3255acdd06d1f41f624e4519a9006082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines functions interface_logical_coordinates.  <a href="group__ComputationalDomainGroup.html#ga3255acdd06d1f41f624e4519a9006082">More...</a><br /></td></tr>
<tr class="separator:ga3255acdd06d1f41f624e4519a9006082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45b5650adddebf194bd3d70113a73eb6"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename Fr &gt; </td></tr>
<tr class="memitem:ga45b5650adddebf194bd3d70113a73eb6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga45b5650adddebf194bd3d70113a73eb6">domain::jacobian_diagnostic</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, typename <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; * &gt; jacobian_diag, const Jacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, typename <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, Fr &gt; &amp;analytic_jacobian, const <a class="el" href="group__TensorGroup.html#ga5e4aece332518b3a95c2a73557aaa596">TensorMetafunctions::prepend_spatial_index</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, Fr &gt;, Dim, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, typename <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; &amp;numeric_jacobian_transpose)</td></tr>
<tr class="memdesc:ga45b5650adddebf194bd3d70113a73eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A diagnostic comparing the analytic and numerical Jacobians for a map.  <a href="group__ComputationalDomainGroup.html#ga45b5650adddebf194bd3d70113a73eb6">More...</a><br /></td></tr>
<tr class="separator:ga45b5650adddebf194bd3d70113a73eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd0f4524b115d136aeafefab90cab6ad"><td class="memTemplParams" colspan="2"><a id="gabd0f4524b115d136aeafefab90cab6ad" name="gabd0f4524b115d136aeafefab90cab6ad"></a>
template&lt;size_t Dim, typename Frame &gt; </td></tr>
<tr class="memitem:gabd0f4524b115d136aeafefab90cab6ad"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>minimum_grid_spacing</b> (const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;extents, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, Frame &gt; &amp;coords)</td></tr>
<tr class="memdesc:gabd0f4524b115d136aeafefab90cab6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the minimum coordinate distance between grid points. <br /></td></tr>
<tr class="separator:gabd0f4524b115d136aeafefab90cab6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7277b2f5c68fd943f3e10da1b93485d8"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ga7277b2f5c68fd943f3e10da1b93485d8"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga7277b2f5c68fd943f3e10da1b93485d8">index_to_slice_at</a> (const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;extents, const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;direction, const size_t offset=0)</td></tr>
<tr class="memdesc:ga7277b2f5c68fd943f3e10da1b93485d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index in the perpendicular dimension of an element boundary.  <a href="group__ComputationalDomainGroup.html#ga7277b2f5c68fd943f3e10da1b93485d8">More...</a><br /></td></tr>
<tr class="separator:ga7277b2f5c68fd943f3e10da1b93485d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e375c0d81527dd6007a8dc0810d44b2"><td class="memTemplParams" colspan="2"><a id="ga0e375c0d81527dd6007a8dc0810d44b2" name="ga0e375c0d81527dd6007a8dc0810d44b2"></a>
template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga0e375c0d81527dd6007a8dc0810d44b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classElementId.html">ElementId</a>&lt; VolumeDim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>initial_element_ids</b> (size_t block_id, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, VolumeDim &gt; initial_ref_levs, size_t grid_index=0)</td></tr>
<tr class="memdesc:ga0e375c0d81527dd6007a8dc0810d44b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the <code><a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a></code>s of the a single <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a>. <br /></td></tr>
<tr class="separator:ga0e375c0d81527dd6007a8dc0810d44b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga797af5d3cab1d052a16c14d3faac8161"><td class="memTemplParams" colspan="2"><a id="ga797af5d3cab1d052a16c14d3faac8161" name="ga797af5d3cab1d052a16c14d3faac8161"></a>
template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga797af5d3cab1d052a16c14d3faac8161"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classElementId.html">ElementId</a>&lt; VolumeDim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>initial_element_ids</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, VolumeDim &gt; &gt; &amp;initial_refinement_levels, size_t grid_index=0)</td></tr>
<tr class="memdesc:ga797af5d3cab1d052a16c14d3faac8161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the <code><a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a></code>s of the initial computational domain. <br /></td></tr>
<tr class="separator:ga797af5d3cab1d052a16c14d3faac8161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa8cb44daebc8f9e080718961530be89"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gafa8cb44daebc8f9e080718961530be89">maximum_number_of_neighbors</a> (const size_t dim)</td></tr>
<tr class="memdesc:gafa8cb44daebc8f9e080718961530be89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of neighbors an element can have in <code>dim</code> dimensions.  <a href="group__ComputationalDomainGroup.html#gafa8cb44daebc8f9e080718961530be89">More...</a><br /></td></tr>
<tr class="separator:gafa8cb44daebc8f9e080718961530be89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45ff23a83bb3bab32bd30a13bc9a41a0"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga45ff23a83bb3bab32bd30a13bc9a41a0">maximum_number_of_neighbors_per_direction</a> (const size_t dim)</td></tr>
<tr class="memdesc:ga45ff23a83bb3bab32bd30a13bc9a41a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of neighbors in each direction an element can have in <code>dim</code> dimensions.  <a href="group__ComputationalDomainGroup.html#ga45ff23a83bb3bab32bd30a13bc9a41a0">More...</a><br /></td></tr>
<tr class="separator:ga45ff23a83bb3bab32bd30a13bc9a41a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83a74526fa2d2d6d6b9d4081a76db3c1"><td class="memTemplParams" colspan="2"><a id="ga83a74526fa2d2d6d6b9d4081a76db3c1" name="ga83a74526fa2d2d6d6b9d4081a76db3c1"></a>
template&lt;size_t VolumeDim, typename T &gt; </td></tr>
<tr class="memitem:ga83a74526fa2d2d6d6b9d4081a76db3c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; tt::remove_cvref_wrap_t&lt; T &gt;, VolumeDim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>discrete_rotation</b> (const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;rotation, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, VolumeDim &gt; source_coords)</td></tr>
<tr class="memdesc:ga83a74526fa2d2d6d6b9d4081a76db3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classOrientationMap.html" title="A mapping of the logical coordinate axes of a host to the logical coordinate axes of a neighbor of th...">OrientationMap</a></code>s define an active rotation of the logical axes that bring the axes of a host block into alignment with the logical axes of the neighbor block. <code>discrete_rotation</code> applies this active rotation on the coordinates as opposed to the axes. For a two-dimensional example, consider a host block and a neighbor block, where the <a class="el" href="classOrientationMap.html" title="A mapping of the logical coordinate axes of a host to the logical coordinate axes of a neighbor of th...">OrientationMap</a> between them is \(\{-\eta,+\xi\}\). A quarter- turn counterclockwise of the host block's logical axes would bring them into alignment with those of the neighbor. That is, after this active rotation, the blocks would be Aligned. Now consider a point A with coordinates (+1.0,-0.5). An active quarter-turn rotation counter-clockwise about the origin, keeping the axes fixed, brings point A into the coordinates (+0.5,+1.0). This is how <code>discrete_rotation</code> interprets the <code><a class="el" href="classOrientationMap.html" title="A mapping of the logical coordinate axes of a host to the logical coordinate axes of a neighbor of th...">OrientationMap</a></code> passed to it. <br /></td></tr>
<tr class="separator:ga83a74526fa2d2d6d6b9d4081a76db3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc2f76a2d422ac605ac2c22de56a2bd3"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:gafc2f76a2d422ac605ac2c22de56a2bd3"><td class="memTemplItemLeft" align="right" valign="top">tnsr::Ij&lt; double, VolumeDim, <a class="el" href="structFrame_1_1NoFrame.html">Frame::NoFrame</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gafc2f76a2d422ac605ac2c22de56a2bd3">discrete_rotation_jacobian</a> (const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;orientation)</td></tr>
<tr class="memdesc:gafc2f76a2d422ac605ac2c22de56a2bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Jacobian of the transformation that is computed by <code><a class="el" href="group__ComputationalDomainGroup.html#ga83a74526fa2d2d6d6b9d4081a76db3c1" title="OrientationMaps define an active rotation of the logical axes that bring the axes of a host block int...">discrete_rotation()</a></code>  <a href="group__ComputationalDomainGroup.html#gafc2f76a2d422ac605ac2c22de56a2bd3">More...</a><br /></td></tr>
<tr class="separator:gafc2f76a2d422ac605ac2c22de56a2bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49106ff288c9b60897a13b72946ef347"><td class="memTemplParams" colspan="2"><a id="ga49106ff288c9b60897a13b72946ef347" name="ga49106ff288c9b60897a13b72946ef347"></a>
template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga49106ff288c9b60897a13b72946ef347"><td class="memTemplItemLeft" align="right" valign="top">tnsr::Ij&lt; double, VolumeDim, <a class="el" href="structFrame_1_1NoFrame.html">Frame::NoFrame</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>discrete_rotation_inverse_jacobian</b> (const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;orientation)</td></tr>
<tr class="memdesc:ga49106ff288c9b60897a13b72946ef347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse Jacobian of the transformation that is computed by <code><a class="el" href="group__ComputationalDomainGroup.html#ga83a74526fa2d2d6d6b9d4081a76db3c1" title="OrientationMaps define an active rotation of the logical axes that bring the axes of a host block int...">discrete_rotation()</a></code> <br /></td></tr>
<tr class="separator:ga49106ff288c9b60897a13b72946ef347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga649a7da35c207e46d234256976b33103"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename TargetFrame &gt; </td></tr>
<tr class="memitem:ga649a7da35c207e46d234256976b33103"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga649a7da35c207e46d234256976b33103">unnormalized_face_normal</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame &gt; * &gt; result, const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;interface_mesh, const InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, TargetFrame &gt; &amp;inv_jacobian_on_interface, const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;direction)</td></tr>
<tr class="memdesc:ga649a7da35c207e46d234256976b33103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>.  <a href="group__ComputationalDomainGroup.html#ga649a7da35c207e46d234256976b33103">More...</a><br /></td></tr>
<tr class="separator:ga649a7da35c207e46d234256976b33103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9feb4e7cd655d238161671644c3cda1"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename TargetFrame &gt; </td></tr>
<tr class="memitem:gae9feb4e7cd655d238161671644c3cda1"><td class="memTemplItemLeft" align="right" valign="top">tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gae9feb4e7cd655d238161671644c3cda1">unnormalized_face_normal</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;interface_mesh, const InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, TargetFrame &gt; &amp;inv_jacobian_on_interface, const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;direction)</td></tr>
<tr class="memdesc:gae9feb4e7cd655d238161671644c3cda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>.  <a href="group__ComputationalDomainGroup.html#gae9feb4e7cd655d238161671644c3cda1">More...</a><br /></td></tr>
<tr class="separator:gae9feb4e7cd655d238161671644c3cda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad35fc33b7c504dd9af13636624d56378"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename TargetFrame &gt; </td></tr>
<tr class="memitem:gad35fc33b7c504dd9af13636624d56378"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gad35fc33b7c504dd9af13636624d56378">unnormalized_face_normal</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame &gt; * &gt; result, const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;interface_mesh, const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, TargetFrame &gt; &amp;map, const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;direction)</td></tr>
<tr class="memdesc:gad35fc33b7c504dd9af13636624d56378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>.  <a href="group__ComputationalDomainGroup.html#gad35fc33b7c504dd9af13636624d56378">More...</a><br /></td></tr>
<tr class="separator:gad35fc33b7c504dd9af13636624d56378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96dfe0dd3fbf25876726e544c1443993"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename TargetFrame &gt; </td></tr>
<tr class="memitem:ga96dfe0dd3fbf25876726e544c1443993"><td class="memTemplItemLeft" align="right" valign="top">tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga96dfe0dd3fbf25876726e544c1443993">unnormalized_face_normal</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;interface_mesh, const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, TargetFrame &gt; &amp;map, const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;direction)</td></tr>
<tr class="memdesc:ga96dfe0dd3fbf25876726e544c1443993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>.  <a href="group__ComputationalDomainGroup.html#ga96dfe0dd3fbf25876726e544c1443993">More...</a><br /></td></tr>
<tr class="separator:ga96dfe0dd3fbf25876726e544c1443993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga146ed5451c212031cd1824d032e0c9fd"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename TargetFrame &gt; </td></tr>
<tr class="memitem:ga146ed5451c212031cd1824d032e0c9fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga146ed5451c212031cd1824d032e0c9fd">unnormalized_face_normal</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame &gt; * &gt; result, const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;interface_mesh, const <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, TargetFrame, VolumeDim &gt; &amp;map, const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;direction)</td></tr>
<tr class="memdesc:ga146ed5451c212031cd1824d032e0c9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>.  <a href="group__ComputationalDomainGroup.html#ga146ed5451c212031cd1824d032e0c9fd">More...</a><br /></td></tr>
<tr class="separator:ga146ed5451c212031cd1824d032e0c9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa27bf2e1f6c4c39085dc8d91d9969931"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename TargetFrame &gt; </td></tr>
<tr class="memitem:gaa27bf2e1f6c4c39085dc8d91d9969931"><td class="memTemplItemLeft" align="right" valign="top">tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gaa27bf2e1f6c4c39085dc8d91d9969931">unnormalized_face_normal</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;interface_mesh, const <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, TargetFrame, VolumeDim &gt; &amp;map, const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;direction)</td></tr>
<tr class="memdesc:gaa27bf2e1f6c4c39085dc8d91d9969931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>.  <a href="group__ComputationalDomainGroup.html#gaa27bf2e1f6c4c39085dc8d91d9969931">More...</a><br /></td></tr>
<tr class="separator:gaa27bf2e1f6c4c39085dc8d91d9969931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43b8d40f75ed4eb339bc14c73038e697"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga43b8d40f75ed4eb339bc14c73038e697"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga43b8d40f75ed4eb339bc14c73038e697">unnormalized_face_normal</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; * &gt; result, const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;interface_mesh, const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, <a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a> &gt; &amp;logical_to_grid_map, const <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, VolumeDim &gt; &amp;grid_to_inertial_map, double time, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt; &gt; &amp;functions_of_time, const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;direction)</td></tr>
<tr class="memdesc:ga43b8d40f75ed4eb339bc14c73038e697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>.  <a href="group__ComputationalDomainGroup.html#ga43b8d40f75ed4eb339bc14c73038e697">More...</a><br /></td></tr>
<tr class="separator:ga43b8d40f75ed4eb339bc14c73038e697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12b573aba8992f8a67126994057a6ebc"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga12b573aba8992f8a67126994057a6ebc"><td class="memTemplItemLeft" align="right" valign="top">tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga12b573aba8992f8a67126994057a6ebc">unnormalized_face_normal</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;interface_mesh, const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, <a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a> &gt; &amp;logical_to_grid_map, const <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, VolumeDim &gt; &amp;grid_to_inertial_map, double time, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt; &gt; &amp;functions_of_time, const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;direction)</td></tr>
<tr class="memdesc:ga12b573aba8992f8a67126994057a6ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>.  <a href="group__ComputationalDomainGroup.html#ga12b573aba8992f8a67126994057a6ebc">More...</a><br /></td></tr>
<tr class="separator:ga12b573aba8992f8a67126994057a6ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab579049797d1e22b31d7e21288c53370"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename Fr &gt; </td></tr>
<tr class="memitem:gab579049797d1e22b31d7e21288c53370"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gab579049797d1e22b31d7e21288c53370">domain::jacobian_diagnostic</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; * &gt; jacobian_diag, const ::Jacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, Fr &gt; &amp;analytic_jacobian, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, Fr &gt; &amp;mapped_coords, const <a class="el" href="classMesh.html">::Mesh</a>&lt; Dim &gt; &amp;mesh)</td></tr>
<tr class="memdesc:gab579049797d1e22b31d7e21288c53370"><td class="mdescLeft">&#160;</td><td class="mdescRight">A diagnostic comparing the analytic and numerical Jacobians for a map.  <a href="group__ComputationalDomainGroup.html#gab579049797d1e22b31d7e21288c53370">More...</a><br /></td></tr>
<tr class="separator:gab579049797d1e22b31d7e21288c53370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22ab91fc5d9d14fca8a1034e69832bf6"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename Fr &gt; </td></tr>
<tr class="memitem:ga22ab91fc5d9d14fca8a1034e69832bf6"><td class="memTemplItemLeft" align="right" valign="top">tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga22ab91fc5d9d14fca8a1034e69832bf6">domain::jacobian_diagnostic</a> (const ::Jacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, Fr &gt; &amp;analytic_jacobian, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, Fr &gt; &amp;mapped_coords, const <a class="el" href="classMesh.html">::Mesh</a>&lt; Dim &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga22ab91fc5d9d14fca8a1034e69832bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A diagnostic comparing the analytic and numerical Jacobians for a map.  <a href="group__ComputationalDomainGroup.html#ga22ab91fc5d9d14fca8a1034e69832bf6">More...</a><br /></td></tr>
<tr class="separator:ga22ab91fc5d9d14fca8a1034e69832bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe0f1e9e5bdbcfd1aa2a7228e894ac52"><td class="memTemplParams" colspan="2">template&lt;typename DataType , size_t Dim, typename CoordsFrame &gt; </td></tr>
<tr class="memitem:gafe0f1e9e5bdbcfd1aa2a7228e894ac52"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gafe0f1e9e5bdbcfd1aa2a7228e894ac52">domain::radially_compressed_coordinates</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; DataType, Dim, CoordsFrame &gt; * &gt; result, const tnsr::I&lt; DataType, Dim, CoordsFrame &gt; &amp;coordinates, double inner_radius, double outer_radius, <a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">CoordinateMaps::Distribution</a> compression)</td></tr>
<tr class="memdesc:gafe0f1e9e5bdbcfd1aa2a7228e894ac52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coordinates suitable for visualizing large radii by compressing them logarithmically or inversely.  <a href="group__ComputationalDomainGroup.html#gafe0f1e9e5bdbcfd1aa2a7228e894ac52">More...</a><br /></td></tr>
<tr class="separator:gafe0f1e9e5bdbcfd1aa2a7228e894ac52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55562b21706cdbb5ec553d6122b86eda"><td class="memTemplParams" colspan="2">template&lt;typename DataType , size_t Dim, typename CoordsFrame &gt; </td></tr>
<tr class="memitem:ga55562b21706cdbb5ec553d6122b86eda"><td class="memTemplItemLeft" align="right" valign="top">tnsr::I&lt; DataType, Dim, CoordsFrame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga55562b21706cdbb5ec553d6122b86eda">domain::radially_compressed_coordinates</a> (const tnsr::I&lt; DataType, Dim, CoordsFrame &gt; &amp;coordinates, double inner_radius, double outer_radius, <a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">CoordinateMaps::Distribution</a> compression)</td></tr>
<tr class="memdesc:ga55562b21706cdbb5ec553d6122b86eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coordinates suitable for visualizing large radii by compressing them logarithmically or inversely.  <a href="group__ComputationalDomainGroup.html#ga55562b21706cdbb5ec553d6122b86eda">More...</a><br /></td></tr>
<tr class="separator:ga55562b21706cdbb5ec553d6122b86eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b4c280017c392c47a68ce156010b271"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga6b4c280017c392c47a68ce156010b271"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, VolumeDim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga6b4c280017c392c47a68ce156010b271">size_of_element</a> (const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &amp;logical_to_inertial_map)</td></tr>
<tr class="memdesc:ga6b4c280017c392c47a68ce156010b271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inertial-coordinate size of an element along each of its logical directions.  <a href="group__ComputationalDomainGroup.html#ga6b4c280017c392c47a68ce156010b271">More...</a><br /></td></tr>
<tr class="separator:ga6b4c280017c392c47a68ce156010b271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a4bc0136871c65fe8a305576ea2b171"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga3a4bc0136871c65fe8a305576ea2b171"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, VolumeDim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga3a4bc0136871c65fe8a305576ea2b171">size_of_element</a> (const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, <a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a> &gt; &amp;logical_to_grid_map, const <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, VolumeDim &gt; &amp;grid_to_inertial_map, double time, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt; &gt; &amp;functions_of_time)</td></tr>
<tr class="memdesc:ga3a4bc0136871c65fe8a305576ea2b171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inertial-coordinate size of an element along each of its logical directions.  <a href="group__ComputationalDomainGroup.html#ga3a4bc0136871c65fe8a305576ea2b171">More...</a><br /></td></tr>
<tr class="separator:ga3a4bc0136871c65fe8a305576ea2b171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3619aae9c08e6fe73183d872b2c8c925"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga3619aae9c08e6fe73183d872b2c8c925"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga3619aae9c08e6fe73183d872b2c8c925">orient_variables</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt; result, const <a class="el" href="classDataVector.html">DataVector</a> &amp;variables, const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;extents, const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;orientation_of_neighbor)</td></tr>
<tr class="memdesc:ga3619aae9c08e6fe73183d872b2c8c925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orient variables to the data-storage order of a neighbor element with the given orientation.  <a href="group__ComputationalDomainGroup.html#ga3619aae9c08e6fe73183d872b2c8c925">More...</a><br /></td></tr>
<tr class="separator:ga3619aae9c08e6fe73183d872b2c8c925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae19eebf840f202d53fdb423820236486"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:gae19eebf840f202d53fdb423820236486"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gae19eebf840f202d53fdb423820236486">orient_variables_on_slice</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt; result, const <a class="el" href="classDataVector.html">DataVector</a> &amp;variables_on_slice, const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim - 1 &gt; &amp;slice_extents, size_t sliced_dim, const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;orientation_of_neighbor)</td></tr>
<tr class="memdesc:gae19eebf840f202d53fdb423820236486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orient variables to the data-storage order of a neighbor element with the given orientation.  <a href="group__ComputationalDomainGroup.html#gae19eebf840f202d53fdb423820236486">More...</a><br /></td></tr>
<tr class="separator:gae19eebf840f202d53fdb423820236486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad98ba46f9ff56f10f53f950f6fa0401d"><td class="memTemplParams" colspan="2"><a id="gad98ba46f9ff56f10f53f950f6fa0401d" name="gad98ba46f9ff56f10f53f950f6fa0401d"></a>
template&lt;size_t VolumeDim, typename TagsList &gt; </td></tr>
<tr class="memitem:gad98ba46f9ff56f10f53f950f6fa0401d"><td class="memTemplItemLeft" align="right" valign="top">Variables&lt; TagsList &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>orient_variables</b> (const Variables&lt; TagsList &gt; &amp;variables, const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;extents, const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;orientation_of_neighbor)</td></tr>
<tr class="memdesc:gad98ba46f9ff56f10f53f950f6fa0401d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orient variables to the data-storage order of a neighbor element with the given orientation. <br /></td></tr>
<tr class="separator:gad98ba46f9ff56f10f53f950f6fa0401d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca3eaabeb785ff54a70ccf02a44b931f"><td class="memTemplParams" colspan="2"><a id="gaca3eaabeb785ff54a70ccf02a44b931f" name="gaca3eaabeb785ff54a70ccf02a44b931f"></a>
template&lt;size_t VolumeDim, typename TagsList &gt; </td></tr>
<tr class="memitem:gaca3eaabeb785ff54a70ccf02a44b931f"><td class="memTemplItemLeft" align="right" valign="top">Variables&lt; TagsList &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>orient_variables_on_slice</b> (const Variables&lt; TagsList &gt; &amp;variables_on_slice, const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim - 1 &gt; &amp;slice_extents, const size_t sliced_dim, const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;orientation_of_neighbor)</td></tr>
<tr class="memdesc:gaca3eaabeb785ff54a70ccf02a44b931f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orient variables to the data-storage order of a neighbor element with the given orientation. <br /></td></tr>
<tr class="separator:gaca3eaabeb785ff54a70ccf02a44b931f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7bda3cdc5430928c0ad8b1f2d6909d9"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:gaa7bda3cdc5430928c0ad8b1f2d6909d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gaa7bda3cdc5430928c0ad8b1f2d6909d9">orient_variables</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;variables, const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;extents, const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;orientation_of_neighbor)</td></tr>
<tr class="memdesc:gaa7bda3cdc5430928c0ad8b1f2d6909d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orient data in a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;double&gt;</code> or <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code> representing one or more tensor components.  <a href="group__ComputationalDomainGroup.html#gaa7bda3cdc5430928c0ad8b1f2d6909d9">More...</a><br /></td></tr>
<tr class="separator:gaa7bda3cdc5430928c0ad8b1f2d6909d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c1177a899891bf32b1ce4e1100c0ab5"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga7c1177a899891bf32b1ce4e1100c0ab5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDataVector.html">DataVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga7c1177a899891bf32b1ce4e1100c0ab5">orient_variables</a> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;variables, const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;extents, const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;orientation_of_neighbor)</td></tr>
<tr class="memdesc:ga7c1177a899891bf32b1ce4e1100c0ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orient data in a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;double&gt;</code> or <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code> representing one or more tensor components.  <a href="group__ComputationalDomainGroup.html#ga7c1177a899891bf32b1ce4e1100c0ab5">More...</a><br /></td></tr>
<tr class="separator:ga7c1177a899891bf32b1ce4e1100c0ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ea39f708807d4a31ea2429b4357f38b"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga1ea39f708807d4a31ea2429b4357f38b"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga1ea39f708807d4a31ea2429b4357f38b">orient_variables_on_slice</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;variables_on_slice, const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim - 1 &gt; &amp;slice_extents, size_t sliced_dim, const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;orientation_of_neighbor)</td></tr>
<tr class="memdesc:ga1ea39f708807d4a31ea2429b4357f38b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orient data in a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;double&gt;</code> or <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code> representing one or more tensor components.  <a href="group__ComputationalDomainGroup.html#ga1ea39f708807d4a31ea2429b4357f38b">More...</a><br /></td></tr>
<tr class="separator:ga1ea39f708807d4a31ea2429b4357f38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49edd246d872be455c3a499ed63e73b6"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga49edd246d872be455c3a499ed63e73b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDataVector.html">DataVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga49edd246d872be455c3a499ed63e73b6">orient_variables_on_slice</a> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;variables_on_slice, const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim - 1 &gt; &amp;slice_extents, size_t sliced_dim, const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;orientation_of_neighbor)</td></tr>
<tr class="memdesc:ga49edd246d872be455c3a499ed63e73b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orient data in a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;double&gt;</code> or <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code> representing one or more tensor components.  <a href="group__ComputationalDomainGroup.html#ga49edd246d872be455c3a499ed63e73b6">More...</a><br /></td></tr>
<tr class="separator:ga49edd246d872be455c3a499ed63e73b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b413be413e7562d25ad9c3c9c3cc7f0"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga1b413be413e7562d25ad9c3c9c3cc7f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga1b413be413e7562d25ad9c3c9c3cc7f0">logical_coordinates</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; * &gt; logical_coords, const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga1b413be413e7562d25ad9c3c9c3cc7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the logical coordinates in an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>.  <a href="group__ComputationalDomainGroup.html#ga1b413be413e7562d25ad9c3c9c3cc7f0">More...</a><br /></td></tr>
<tr class="separator:ga1b413be413e7562d25ad9c3c9c3cc7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga244443757eca7cce2a735011474c7c20"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga244443757eca7cce2a735011474c7c20"><td class="memTemplItemLeft" align="right" valign="top">tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga244443757eca7cce2a735011474c7c20">logical_coordinates</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga244443757eca7cce2a735011474c7c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the logical coordinates in an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>.  <a href="group__ComputationalDomainGroup.html#ga244443757eca7cce2a735011474c7c20">More...</a><br /></td></tr>
<tr class="separator:ga244443757eca7cce2a735011474c7c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >The building blocks used to describe the computational domain. </p>
<h3><a class="anchor" id="autotoc_md180"></a>
Description</h3>
<p >The VolumeDim-dimensional computational <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain.">Domain</a> is constructed from a set of non-overlapping <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a>s. Each <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> is a distorted VolumeDim-dimensional hypercube. Each codimension-1 boundary of a <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> is either part of the external boundary of the computational domain, or is identical to a boundary of one other <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a>. Each <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> is subdivided into one or more <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>s that may be changed dynamically if AMR is enabled.</p>
<h3><a class="anchor" id="autotoc_md199"></a>
Description</h3>
<p >The VolumeDim-dimensional computational <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain.">Domain</a> is constructed from a set of non-overlapping <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a>s. Each <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> is a distorted VolumeDim-dimensional hypercube. Each codimension-1 boundary of a <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> is either part of the external boundary of the computational domain, or is identical to a boundary of one other <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a>. Each <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> is subdivided into one or more <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>s that may be changed dynamically if AMR is enabled. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga45607952ebcf523987906a5c27ccef59" name="ga45607952ebcf523987906a5c27ccef59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45607952ebcf523987906a5c27ccef59">&#9670;&nbsp;</a></span>INSTANTIATE_MAPS_DATA_TYPE_FUNCTIONS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INSTANTIATE_MAPS_DATA_TYPE_FUNCTIONS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate instantiations of member functions of the <code>CoordinateMap</code> class template. </p>
<p >Called as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Affine2d =</div>
<div class="line">    <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1ProductOf2Maps.html">domain::CoordinateMaps::ProductOf2Maps</a>&lt;<a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>,</div>
<div class="line">                                           <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>&gt;;</div>
<div class="line"><span class="keyword">using</span> Affine3d =</div>
<div class="line">    <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1ProductOf3Maps.html">domain::CoordinateMaps::ProductOf3Maps</a>&lt;<a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>,</div>
<div class="line">                                           <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>,</div>
<div class="line">                                           <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>&gt;;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__UtilitiesGroup.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a>(<a class="code hl_define" href="group__ComputationalDomainGroup.html#ga45607952ebcf523987906a5c27ccef59">INSTANTIATE_MAPS_DATA_TYPE_FUNCTIONS</a>,</div>
<div class="line">                        ((Affine2d), (Affine3d)), (<a class="code hl_struct" href="structFrame_1_1BlockLogical.html">Frame::BlockLogical</a>),</div>
<div class="line">                        (<a class="code hl_struct" href="structFrame_1_1Grid.html">Frame::Grid</a>, <a class="code hl_struct" href="structFrame_1_1Inertial.html">Frame::Inertial</a>),</div>
<div class="line">                        (<span class="keywordtype">double</span>, <a class="code hl_class" href="classDataVector.html">DataVector</a>))</div>
<div class="ttc" id="aclassDataVector_html"><div class="ttname"><a href="classDataVector.html">DataVector</a></div><div class="ttdoc">Stores a collection of function values.</div><div class="ttdef"><b>Definition:</b> DataVector.hpp:48</div></div>
<div class="ttc" id="aclassdomain_1_1CoordinateMaps_1_1Affine_html"><div class="ttname"><a href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a></div><div class="ttdoc">Affine map from .</div><div class="ttdef"><b>Definition:</b> Affine.hpp:37</div></div>
<div class="ttc" id="aclassdomain_1_1CoordinateMaps_1_1ProductOf2Maps_html"><div class="ttname"><a href="classdomain_1_1CoordinateMaps_1_1ProductOf2Maps.html">domain::CoordinateMaps::ProductOf2Maps</a></div><div class="ttdoc">Product of two codimension=0 CoordinateMaps.</div><div class="ttdef"><b>Definition:</b> ProductMaps.hpp:35</div></div>
<div class="ttc" id="aclassdomain_1_1CoordinateMaps_1_1ProductOf3Maps_html"><div class="ttname"><a href="classdomain_1_1CoordinateMaps_1_1ProductOf3Maps.html">domain::CoordinateMaps::ProductOf3Maps</a></div><div class="ttdoc">Product of three one-dimensional CoordinateMaps.</div><div class="ttdef"><b>Definition:</b> ProductMaps.hpp:89</div></div>
<div class="ttc" id="agroup__ComputationalDomainGroup_html_ga45607952ebcf523987906a5c27ccef59"><div class="ttname"><a href="group__ComputationalDomainGroup.html#ga45607952ebcf523987906a5c27ccef59">INSTANTIATE_MAPS_DATA_TYPE_FUNCTIONS</a></div><div class="ttdeci">#define INSTANTIATE_MAPS_DATA_TYPE_FUNCTIONS(_, data)</div><div class="ttdoc">Generate instantiations of member functions of the CoordinateMap class template.</div><div class="ttdef"><b>Definition:</b> MapInstantiationMacros.hpp:149</div></div>
<div class="ttc" id="agroup__UtilitiesGroup_html_gad7b776398a66e9a6bd561c8decf08b47"><div class="ttname"><a href="group__UtilitiesGroup.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a></div><div class="ttdeci">#define GENERATE_INSTANTIATIONS(INSTANTIATION_MACRO,...)</div><div class="ttdoc">Macro useful for generating many explicit instantiations of function or class templates.</div><div class="ttdef"><b>Definition:</b> GenerateInstantiations.hpp:160</div></div>
<div class="ttc" id="astructFrame_1_1BlockLogical_html"><div class="ttname"><a href="structFrame_1_1BlockLogical.html">Frame::BlockLogical</a></div><div class="ttdef"><b>Definition:</b> IndexType.hpp:42</div></div>
<div class="ttc" id="astructFrame_1_1Grid_html"><div class="ttname"><a href="structFrame_1_1Grid.html">Frame::Grid</a></div><div class="ttdef"><b>Definition:</b> IndexType.hpp:44</div></div>
<div class="ttc" id="astructFrame_1_1Inertial_html"><div class="ttname"><a href="structFrame_1_1Inertial.html">Frame::Inertial</a></div><div class="ttdef"><b>Definition:</b> IndexType.hpp:45</div></div>
</div><!-- fragment --><p >The first tuple passed to <code>GENERATE_INSTANTIATIONS</code> has a bunch of tuples in it that is the list of maps being composed. The reason for defining the type aliases <code>Affine2d</code> and <code>Affine3d</code> is that otherwise the number of maps being composed is calculated incorrectly. The second tuple contains the source frames for the map. The third tuple passed to <code>GENERATE_INSTANTIATIONS</code> contains the target frames to instantiate for, typically <code><a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a></code> and <code><a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a></code>. The last tuple is the data types for which to instantiate the functions, usually <code>double</code> and <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code>.</p>
<p >Instantiates:</p><ul>
<li><code>call_impl</code></li>
<li><code>inv_jacobian_impl</code></li>
<li><code>jacobian_impl</code></li>
<li><code>coords_frame_velocity_jacobians_impl</code> </li>
</ul>

</div>
</div>
<a id="ga8773fe02f44b68af479cb53dd4383978" name="ga8773fe02f44b68af479cb53dd4383978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8773fe02f44b68af479cb53dd4383978">&#9670;&nbsp;</a></span>INSTANTIATE_MAPS_FUNCTIONS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INSTANTIATE_MAPS_FUNCTIONS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">MAPS_TUPLE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">SOURCE_FRAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TARGET_FRAMES_TUPLE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TYPES_TUPLE&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <a class="code hl_define" href="group__UtilitiesGroup.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a>(<a class="code hl_define" href="group__ComputationalDomainGroup.html#ga39eb7361b3bcfe317a1576be5141b10f">INSTANTIATE_MAPS_SIMPLE_FUNCTIONS</a>, MAPS_TUPLE,    \</div>
<div class="line">                          SOURCE_FRAME, TARGET_FRAMES_TUPLE)                \</div>
<div class="line">  GENERATE_INSTANTIATIONS(<a class="code hl_define" href="group__ComputationalDomainGroup.html#ga45607952ebcf523987906a5c27ccef59">INSTANTIATE_MAPS_DATA_TYPE_FUNCTIONS</a>, MAPS_TUPLE, \</div>
<div class="line">                          SOURCE_FRAME, TARGET_FRAMES_TUPLE, TYPES_TUPLE)</div>
<div class="ttc" id="agroup__ComputationalDomainGroup_html_ga39eb7361b3bcfe317a1576be5141b10f"><div class="ttname"><a href="group__ComputationalDomainGroup.html#ga39eb7361b3bcfe317a1576be5141b10f">INSTANTIATE_MAPS_SIMPLE_FUNCTIONS</a></div><div class="ttdeci">#define INSTANTIATE_MAPS_SIMPLE_FUNCTIONS(_, data)</div><div class="ttdoc">Generate instantiations of member functions of the CoordinateMap class template.</div><div class="ttdef"><b>Definition:</b> MapInstantiationMacros.hpp:78</div></div>
</div><!-- fragment -->
<p>Generate instantiations of member functions of the <code>CoordinateMap</code> class template. </p>
<p >Called as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Affine2d =</div>
<div class="line">    <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1ProductOf2Maps.html">domain::CoordinateMaps::ProductOf2Maps</a>&lt;<a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>,</div>
<div class="line">                                           <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>&gt;;</div>
<div class="line"><span class="keyword">using</span> Affine3d =</div>
<div class="line">    <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1ProductOf3Maps.html">domain::CoordinateMaps::ProductOf3Maps</a>&lt;<a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>,</div>
<div class="line">                                           <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>,</div>
<div class="line">                                           <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>&gt;;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__ComputationalDomainGroup.html#ga8773fe02f44b68af479cb53dd4383978">INSTANTIATE_MAPS_FUNCTIONS</a>(((Affine2d), (Affine3d)), (<a class="code hl_struct" href="structFrame_1_1BlockLogical.html">Frame::BlockLogical</a>),</div>
<div class="line">                           (<a class="code hl_struct" href="structFrame_1_1Grid.html">Frame::Grid</a>, <a class="code hl_struct" href="structFrame_1_1Inertial.html">Frame::Inertial</a>),</div>
<div class="line">                           (<span class="keywordtype">double</span>, <a class="code hl_class" href="classDataVector.html">DataVector</a>))</div>
<div class="ttc" id="agroup__ComputationalDomainGroup_html_ga8773fe02f44b68af479cb53dd4383978"><div class="ttname"><a href="group__ComputationalDomainGroup.html#ga8773fe02f44b68af479cb53dd4383978">INSTANTIATE_MAPS_FUNCTIONS</a></div><div class="ttdeci">#define INSTANTIATE_MAPS_FUNCTIONS(MAPS_TUPLE, SOURCE_FRAME, TARGET_FRAMES_TUPLE, TYPES_TUPLE)</div><div class="ttdoc">Generate instantiations of member functions of the CoordinateMap class template.</div><div class="ttdef"><b>Definition:</b> MapInstantiationMacros.hpp:267</div></div>
</div><!-- fragment --><p >The first tuple passed to <code>GENERATE_INSTANTIATIONS</code> has a bunch of tuples in it that is the list of maps being composed. The reason for defining the type aliases <code>Affine2d</code> and <code>Affine3d</code> is that otherwise the number of maps being composed is calculated incorrectly. The second tuple contains the source frames for the map. The third tuple passed to <code>GENERATE_INSTANTIATIONS</code> contains the frames to instantiate for, typically <code><a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a></code> and <code><a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a></code>.</p>
<p >Instantiates:</p><ul>
<li><code>get_to_grid_frame_impl</code></li>
<li><code>inverse_impl</code></li>
<li><code>class CoordinateMap</code></li>
<li><code>call_impl</code></li>
<li><code>inv_jacobian_impl</code></li>
<li><code>jacobian_impl</code></li>
<li><code>coords_frame_velocity_jacobians_impl</code> </li>
</ul>

</div>
</div>
<a id="ga39eb7361b3bcfe317a1576be5141b10f" name="ga39eb7361b3bcfe317a1576be5141b10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39eb7361b3bcfe317a1576be5141b10f">&#9670;&nbsp;</a></span>INSTANTIATE_MAPS_SIMPLE_FUNCTIONS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INSTANTIATE_MAPS_SIMPLE_FUNCTIONS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate instantiations of member functions of the <code>CoordinateMap</code> class template. </p>
<p >Called as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Affine2d =</div>
<div class="line">    <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1ProductOf2Maps.html">domain::CoordinateMaps::ProductOf2Maps</a>&lt;<a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>,</div>
<div class="line">                                           <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>&gt;;</div>
<div class="line"><span class="keyword">using</span> Affine3d =</div>
<div class="line">    <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1ProductOf3Maps.html">domain::CoordinateMaps::ProductOf3Maps</a>&lt;<a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>,</div>
<div class="line">                                           <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>,</div>
<div class="line">                                           <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>&gt;;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__UtilitiesGroup.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a>(<a class="code hl_define" href="group__ComputationalDomainGroup.html#ga39eb7361b3bcfe317a1576be5141b10f">INSTANTIATE_MAPS_SIMPLE_FUNCTIONS</a>,</div>
<div class="line">                        ((Affine2d), (Affine3d)), (<a class="code hl_struct" href="structFrame_1_1BlockLogical.html">Frame::BlockLogical</a>),</div>
<div class="line">                        (<a class="code hl_struct" href="structFrame_1_1Grid.html">Frame::Grid</a>, <a class="code hl_struct" href="structFrame_1_1Inertial.html">Frame::Inertial</a>))</div>
</div><!-- fragment --><p >The first tuple passed to <code>GENERATE_INSTANTIATIONS</code> has a bunch of tuples in it that is the list of maps being composed. The reason for defining the type aliases <code>Affine2d</code> and <code>Affine3d</code> is that otherwise the number of maps being composed is calculated incorrectly. The second tuple contains the source frames for the map. The third tuple passed to <code>GENERATE_INSTANTIATIONS</code> contains the target frames to instantiate for, typically <code><a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a></code> and <code><a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a></code>.</p>
<p >Instantiates:</p><ul>
<li><code>get_to_grid_frame_impl</code></li>
<li><code>inverse_impl</code></li>
<li><code>class CoordinateMap</code> </li>
</ul>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gac672a529d9aaa6a948b8b7eb6ec9b528" name="gac672a529d9aaa6a948b8b7eb6ec9b528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac672a529d9aaa6a948b8b7eb6ec9b528">&#9670;&nbsp;</a></span>ShellWedges</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="group__ComputationalDomainGroup.html#gac672a529d9aaa6a948b8b7eb6ec9b528">ShellWedges</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of wedges to include in the Sphere domain. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac672a529d9aaa6a948b8b7eb6ec9b528ab1c94ca2fbc3e78fc30069c8d0f01680" name="ggac672a529d9aaa6a948b8b7eb6ec9b528ab1c94ca2fbc3e78fc30069c8d0f01680"></a>All&#160;</td><td class="fielddoc"><p >Use the entire shell. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac672a529d9aaa6a948b8b7eb6ec9b528ace553534ea34f25db4b4a8b5bd29cf45" name="ggac672a529d9aaa6a948b8b7eb6ec9b528ace553534ea34f25db4b4a8b5bd29cf45"></a>FourOnEquator&#160;</td><td class="fielddoc"><p >Use only the four equatorial wedges. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac672a529d9aaa6a948b8b7eb6ec9b528ae9d8dbfbf81de7cf729066f677661edb" name="ggac672a529d9aaa6a948b8b7eb6ec9b528ae9d8dbfbf81de7cf729066f677661edb"></a>OneAlongMinusX&#160;</td><td class="fielddoc"><p >Use only the single wedge along -x. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga8c0137d7160ad71b6ed265c53c99ed00" name="ga8c0137d7160ad71b6ed265c53c99ed00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c0137d7160ad71b6ed265c53c99ed00">&#9670;&nbsp;</a></span>Side</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">Side</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A label for the side of a manifold. </p>
<p >Lower and Upper are with respect to the logical coordinate whose axis is normal to the side, i.e. beyond the Upper (Lower) side, the logical coordinate is increasing (decreasing). </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad820f28f973850990200bcb2d858fe1d" name="gad820f28f973850990200bcb2d858fe1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad820f28f973850990200bcb2d858fe1d">&#9670;&nbsp;</a></span>block_logical_coordinates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename Frame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto block_logical_coordinates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDomain.html">Domain</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em> = <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits</a>&lt;&#160;double&#160;&gt;::signaling_NaN()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>functions_of_time</em> = <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt;&#160;<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>,&#160;<a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;&#160;<a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a>&#160;&gt;&#160;&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="el" href="structIdPair.html">IdPair</a>&lt; <a class="el" href="classdomain_1_1BlockId.html">domain::BlockId</a>, tnsr::I&lt; double, Dim, <a class="el" href="structFrame_1_1BlockLogical.html">::Frame::BlockLogical</a> &gt; &gt; &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the block logical coordinates and the containing <code>BlockId</code> of a set of points, given coordinates in a particular frame. </p>
<h3>Details</h3>
<p >Returns a std::vector&lt;std::optional&lt;IdPair&lt;BlockId,coords&gt;&gt;&gt;, where the vector runs over the points and is indexed in the same order as the input coordinates <code>x</code>. For each point, the <code><a class="el" href="structIdPair.html" title="A data structure that contains an ID and data associated with that ID.">IdPair</a></code> holds the block logical coords of that point and the <code>BlockId</code> of the <code><a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a></code> that contains that point. The <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a> is invalid if the point is not in any <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a>. If a point is on a shared boundary of two or more <code><a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a></code>s, it is returned only once, and is considered to belong to the <code><a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a></code> with the smaller <code>BlockId</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Since map inverses can involve numerical roundoff error, care must be taken with points on shared block boundaries. They will be assigned to the first block (by block ID) that contains the point <em>within roundoff error</em>. Therefore, be advised to use the logical coordinates returned by this function, which are guaranteed to be in [-1, 1] and can be safely passed along to <code>element_logical_coordinates</code>.</dd>
<dd>
<code>block_logical_coordinates</code> with x in <code><a class="el" href="structFrame_1_1Distorted.html">Frame::Distorted</a></code> ignores all <code><a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a></code>s that lack a distorted frame, and it will return std::nullopt for points that lie outside all distorted-frame-endowed <code><a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a></code>s. This is what is expected for typical use cases. This means that <code>block_logical_coordinates</code> does not assume that grid and distorted frames are equal in <code><a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a></code>s that lack a distorted frame. </dd></dl>

</div>
</div>
<a id="gabdc7ac14ee646a462ce8fc921ab40f92" name="gabdc7ac14ee646a462ce8fc921ab40f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdc7ac14ee646a462ce8fc921ab40f92">&#9670;&nbsp;</a></span>corners_for_biradially_layered_domains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &gt; corners_for_biradially_layered_domains </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_radial_layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_biradial_layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_central_block_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_central_block_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>central_block_corners_lhs</em> = <code>{&#160;{1,&#160;2,&#160;3,&#160;4,&#160;5,&#160;6,&#160;7,&#160;8}}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The corners for a domain with biradial layers. </p>
<p >Generates the corners for a BBH-like <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain.">Domain</a> which is made of one or more layers of Blocks fully enveloping two interior volumes. The <code>number_of_radial_layers</code> gives the number of layers that fully envelop each interior volume with six Blocks each. The <code>number_of_biradial_layers</code> gives the number of layers that fully envelop both volumes at once, using ten Blocks per layer as opposed to six. The <code>central_block_corners_lhs</code> are used as seed values to generate the corners for the surrounding Blocks. </p>

</div>
</div>
<a id="ga7b0d40a514ae8440623b32a4420f9452" name="ga7b0d40a514ae8440623b32a4420f9452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b0d40a514ae8440623b32a4420f9452">&#9670;&nbsp;</a></span>corners_for_cylindrical_layered_domains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &gt; corners_for_cylindrical_layered_domains </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_shells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_discs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The corners for a cylindrical domain split into discs with radial shells. </p>
<p >Generates the corners for a <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain.">Domain</a> which is made of one or more stacked discs consisting of layers of Blocks enveloping an interior square prism. The <code>number_of_shells</code> specifies how many of these layers of Blocks to have in each disc.</p>
<p >The <code>number_of_discs</code> specifies how many discs make up the domain. The very basic cylinder with one shell and one layer serves as a base to generate the corners for subsequent shells first and discs second. </p>

</div>
</div>
<a id="ga00df68c8b8f3362d716905aaae483088" name="ga00df68c8b8f3362d716905aaae483088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00df68c8b8f3362d716905aaae483088">&#9670;&nbsp;</a></span>corners_for_radially_layered_domains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &gt; corners_for_radially_layered_domains </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_central_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>central_block_corners</em> = <code>{{1,&#160;2,&#160;3,&#160;4,&#160;5,&#160;6,&#160;7,&#160;8}}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ComputationalDomainGroup.html#gac672a529d9aaa6a948b8b7eb6ec9b528">ShellWedges</a>&#160;</td>
          <td class="paramname"><em>which_wedges</em> = <code><a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ab1c94ca2fbc3e78fc30069c8d0f01680">ShellWedges::All</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The corners for a domain with radial layers. </p>
<p >Generates the corners for a <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain.">Domain</a> which is made of one or more layers of Blocks fully enveloping an interior volume, e.g. Sphere.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number_of_layers</td><td>specifies how many layers of Blocks to have in the final domain. </td></tr>
    <tr><td class="paramname">include_central_block</td><td>set to <code>true</code> where the interior volume is filled with a central <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a>, and <code>false</code> where the interior volume is left empty. </td></tr>
    <tr><td class="paramname">central_block_corners</td><td>are used as seed values to generate the corners for the surrounding Blocks. </td></tr>
    <tr><td class="paramname">which_wedges</td><td>can be used to exclude a subset of the wedges. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0ae13666f13523f52e00e508129999c1" name="ga0ae13666f13523f52e00e508129999c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ae13666f13523f52e00e508129999c1">&#9670;&nbsp;</a></span>corners_for_rectilinear_domains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto corners_for_rectilinear_domains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>domain_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_indices_to_exclude</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The corners for a rectilinear domain made of n-cubes. </p>
<p >The <code>domain_extents</code> argument holds the number of blocks to have in each dimension. The blocks all have aligned orientations by construction. The <code>block_indices_to_exclude</code> argument allows the user to selectively exclude blocks from the resulting domain. This allows for the creation of non-trivial shapes such as the net for a tesseract. </p>

</div>
</div>
<a id="ga2104aed15616a0d35eb5224366b60853" name="ga2104aed15616a0d35eb5224366b60853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2104aed15616a0d35eb5224366b60853">&#9670;&nbsp;</a></span>cyl_wedge_coord_map_center_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto cyl_wedge_coord_map_center_blocks </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lower_z_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>upper_z_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_equiangular_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>partitioning_in_z</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">domain::CoordinateMaps::Distribution</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>distribution_in_z</em> = <code>{domain::CoordinateMaps::Distribution::Linear}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CylindricalDomainParityFlip&#160;</td>
          <td class="paramname"><em>parity_flip</em> = <code>CylindricalDomainParityFlip::none</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classdomain_1_1CoordinateMaps_1_1ProductOf3Maps.html">domain::CoordinateMaps::ProductOf3Maps</a>&lt; <a class="el" href="classdomain_1_1CoordinateMaps_1_1Interval.html">domain::CoordinateMaps::Interval</a>, <a class="el" href="classdomain_1_1CoordinateMaps_1_1Interval.html">domain::CoordinateMaps::Interval</a>, <a class="el" href="classdomain_1_1CoordinateMaps_1_1Interval.html">domain::CoordinateMaps::Interval</a> &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <code>cyl_wedge_coordinate_maps</code>, but only the center square blocks,. </p>
<p >If <code>CylindricalDomainParityFlip::z_direction</code> is specified, then the returned maps describe a cylinder with <code>lower_z_bound</code> corresponding to logical coordinate <code>upper_zeta</code> and <code>upper_z_bound</code> corresponding to logical coordinate <code>lower_zeta</code>, and thus the resulting maps are left-handed. <code>CylindricalDomainParityFlip::z_direction</code> is therefore useful only when composing with another map that is also left-handed, so that the composed coordinate system is right-handed.</p>
<p >Returned as a vector of the coordinate maps so that they can be composed with other maps later. </p>

</div>
</div>
<a id="ga1b7f632f810cd61504431c933f9470fd" name="ga1b7f632f810cd61504431c933f9470fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b7f632f810cd61504431c933f9470fd">&#9670;&nbsp;</a></span>cyl_wedge_coord_map_surrounding_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto cyl_wedge_coord_map_surrounding_blocks </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>outer_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lower_z_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>upper_z_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_equiangular_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>inner_circularity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>radial_partitioning</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>partitioning_in_z</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">domain::CoordinateMaps::Distribution</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>radial_distribution</em> = <code>{domain::CoordinateMaps::Distribution::Linear}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">domain::CoordinateMaps::Distribution</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>distribution_in_z</em> = <code>{domain::CoordinateMaps::Distribution::Linear}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CylindricalDomainParityFlip&#160;</td>
          <td class="paramname"><em>parity_flip</em> = <code>CylindricalDomainParityFlip::none</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classdomain_1_1CoordinateMaps_1_1ProductOf2Maps.html">domain::CoordinateMaps::ProductOf2Maps</a>&lt; <a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html">domain::CoordinateMaps::Wedge</a>&lt; 2 &gt;, <a class="el" href="classdomain_1_1CoordinateMaps_1_1Interval.html">domain::CoordinateMaps::Interval</a> &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as cyl_wedge_coordinate_maps, but only the surrounding wedge blocks. </p>
<p >If <code>CylindricalDomainParityFlip::z_direction</code> is specified, then the returned maps describe a cylinder with <code>lower_z_bound</code> corresponding to logical coordinate <code>upper_zeta</code> and <code>upper_z_bound</code> corresponding to logical coordinate <code>lower_zeta</code>, and thus the resulting maps are left-handed. <code>CylindricalDomainParityFlip::z_direction</code> is therefore useful only when composing with another map that is also left-handed, so that the composed coordinate system is right-handed.</p>
<p >Returned as a vector of the coordinate maps so that they can be composed with other maps later. </p>

</div>
</div>
<a id="ga6f9cd607fe3deeb525b1dc14d0b876c6" name="ga6f9cd607fe3deeb525b1dc14d0b876c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f9cd607fe3deeb525b1dc14d0b876c6">&#9670;&nbsp;</a></span>cyl_wedge_coordinate_maps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto cyl_wedge_coordinate_maps </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>outer_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lower_z_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>upper_z_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_equiangular_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>radial_partitioning</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>partitioning_in_z</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">domain::CoordinateMaps::Distribution</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>radial_distribution</em> = <code>{domain::CoordinateMaps::Distribution::Linear}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">domain::CoordinateMaps::Distribution</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>distribution_in_z</em> = <code>{domain::CoordinateMaps::Distribution::Linear}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1BlockLogical.html">Frame::BlockLogical</a>, TargetFrame, 3 &gt; &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These are the CoordinateMaps used in the Cylinder <a class="el" href="classDomainCreator.html" title="Base class for creating Domains from an option string.">DomainCreator</a>. </p>
<p >The <code>radial_partitioning</code> specifies the radial boundaries of sub-shells between <code>inner_radius</code> and <code>outer_radius</code>, while <code>partitioning_in_z</code> specifies the z-boundaries, splitting the cylinder into stacked 3-dimensional disks. The circularity of the shell wedges changes from 0 to 1 within the innermost sub-shell.</p>
<p >Set the <code>radial_distribution</code> to select the radial distribution of grid points in the cylindrical shells. The innermost shell must have <code>domain::CoordinateMaps::Distribution::Linear</code> because it changes the circularity. The distribution along the z-axis for each circular disc is specified through <code>distribution_in_z</code>. </p>

</div>
</div>
<a id="ga24a1fcea4aafb78195851e7bd25394f5" name="ga24a1fcea4aafb78195851e7bd25394f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24a1fcea4aafb78195851e7bd25394f5">&#9670;&nbsp;</a></span>discrete_rotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt; discrete_rotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt; &amp;&#160;</td>
          <td class="paramname"><em>corners_of_aligned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permutes the corner numbers of an n-cube. </p>
<p >Returns the correct ordering of global corner numbers for a rotated block in an otherwise aligned edifice of blocks, given the <a class="el" href="classOrientationMap.html" title="A mapping of the logical coordinate axes of a host to the logical coordinate axes of a neighbor of th...">OrientationMap</a> a block aligned with the edifice has relative to this one, and given the corner numbering the rotated block would have if it were aligned. This is useful in creating domains for testing purposes, e.g. RotatedIntervals, RotatedRectangles, and RotatedBricks. </p>

</div>
</div>
<a id="gafc2f76a2d422ac605ac2c22de56a2bd3" name="gafc2f76a2d422ac605ac2c22de56a2bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc2f76a2d422ac605ac2c22de56a2bd3">&#9670;&nbsp;</a></span>discrete_rotation_jacobian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::Ij&lt; double, VolumeDim, <a class="el" href="structFrame_1_1NoFrame.html">Frame::NoFrame</a> &gt; discrete_rotation_jacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Jacobian of the transformation that is computed by <code><a class="el" href="group__ComputationalDomainGroup.html#ga83a74526fa2d2d6d6b9d4081a76db3c1" title="OrientationMaps define an active rotation of the logical axes that bring the axes of a host block int...">discrete_rotation()</a></code> </p>
<dl class="section note"><dt>Note</dt><dd>This always returns a <code>double</code> because the Jacobian is spatially constant. </dd></dl>

</div>
</div>
<a id="ga8679bb8131f836ff5e2d4deb1f4eff07" name="ga8679bb8131f836ff5e2d4deb1f4eff07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8679bb8131f836ff5e2d4deb1f4eff07">&#9670;&nbsp;</a></span>element_logical_coordinates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto element_logical_coordinates </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>element_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="el" href="structIdPair.html">IdPair</a>&lt; <a class="el" href="classdomain_1_1BlockId.html">domain::BlockId</a>, tnsr::I&lt; double, Dim, typename <a class="el" href="structFrame_1_1BlockLogical.html">Frame::BlockLogical</a> &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_coord_holders</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt;, <a class="el" href="structElementLogicalCoordHolder.html">ElementLogicalCoordHolder</a>&lt; Dim &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of points in block logical coordinates and their <code>BlockIds</code>, as returned from the function <code>block_logical_coordinates</code>, determines which <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code>s in a list of <code><a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a></code>s contains each point, and determines the element logical coordinates of each point. </p>
<h3>Details</h3>
<p >Returns a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a> from <code><a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a></code>s to <code><a class="el" href="structElementLogicalCoordHolder.html" title="Holds element logical coordinates of an arbitrary set of points on a single Element....">ElementLogicalCoordHolder</a></code>s. It is expected that only a subset of the points will be found in the given <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code>s. Boundary points: If a point is on the boundary of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>, it is considered contained in that <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> only if it is on the lower bound of the <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>, or if it is on the upper bound of the element and that upper bound coincides with the upper bound of the containing <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a>. This means that each boundary point is contained in one and only one <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>. We assume that the input block_coord_holders associates a point on a <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> boundary with only a single <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a>, the one with the smaller BlockId, which is always the lower-bounding <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a>.</p>
<div class="fragment"><div class="line"> &lt;---    <a class="code hl_class" href="classBlock.html">Block</a> 0   ---&gt; &lt;---   <a class="code hl_class" href="classBlock.html">Block</a> 1   ---&gt;</div>
<div class="line"> |          |          |          |          |</div>
<div class="line">P_0   E0   P_1   E1   P_2   E2   P_3   E3   P_4</div>
<div class="line"> |          |          |          |          |</div>
<div class="line"> </div>
<div class="line">For example, the above 1D diagram shows four Elements labeled E0</div>
<div class="line">through E3, and five boundary points labeled P_0 through P_4 (where</div>
<div class="line">P_0 and P_4 are external boundaries).  There are two Blocks.  This</div>
<div class="line">algorithm assigns each boundary point to one and only one <a class="code hl_class" href="classElement.html">Element</a> as</div>
<div class="line">follows:</div>
<div class="line">P_0 -&gt; E0</div>
<div class="line">P_1 -&gt; E1</div>
<div class="line">P_2 -&gt; E1 (Note: block_coord_holders includes P_2 only in <a class="code hl_class" href="classBlock.html">Block</a> 0)</div>
<div class="line">P_3 -&gt; E3</div>
<div class="line">P_4 -&gt; E3</div>
<div class="ttc" id="aclassBlock_html"><div class="ttname"><a href="classBlock.html">Block</a></div><div class="ttdoc">A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...</div><div class="ttdef"><b>Definition:</b> Block.hpp:45</div></div>
<div class="ttc" id="aclassElement_html"><div class="ttname"><a href="classElement.html">Element</a></div><div class="ttdoc">A spectral element with knowledge of its neighbors.</div><div class="ttdef"><b>Definition:</b> Element.hpp:29</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gab5a26a3f95902480b4892f296996900e" name="gab5a26a3f95902480b4892f296996900e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5a26a3f95902480b4892f296996900e">&#9670;&nbsp;</a></span>frustum_coordinate_maps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classdomain_1_1CoordinateMaps_1_1Frustum.html">domain::CoordinateMaps::Frustum</a> &gt; frustum_coordinate_maps </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>length_inner_cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>length_outer_cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_equiangular_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin_preimage</em> = <code>{{0.0,&#160;0.0,&#160;0.0}}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>projective_scale_factor</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sphericity</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>opening_angle</em> = <code>M_PI_2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These are the ten Frustums used in the DomainCreators for binary compact objects. The Frustums partition the volume defined by two bounding surfaces: The inner surface is the surface of the two joined inner cubes enveloping the two compact objects, while the outer is the surface of the outer cube. The cubes enveloping the two Shells each have a side length of <code>length_inner_cube</code>. The outer cube has a side length of <code>length_outer_cube</code>. <code>origin_preimage</code> is a parameter that moves the center of the two joined inner cubes away from the origin and to <code>-origin_preimage</code>. <code>projective_scale_factor</code> acts to change the gridpoint distribution in the radial direction. </p>
<dl class="section see"><dt>See also</dt><dd>Frustum for details. The <a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f" title="Returns t.value() if t is a std::optional otherwise returns t.">value</a> for <code>sphericity</code> determines whether the outer surface is a <a class="el" href="group__ConstantExpressionsGroup.html#ga309e8687e65972dcc37a5ff6e9902d56" title="Compute the cube of x">cube</a> (<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f" title="Returns t.value() if t is a std::optional otherwise returns t.">value</a> of 0), a sphere (<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f" title="Returns t.value() if t is a std::optional otherwise returns t.">value</a> of 1) or somewhere in between. The <a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f" title="Returns t.value() if t is a std::optional otherwise returns t.">value</a> for <code>opening_angle</code> determines the gridpoint distribution used in the Frustums such that they conform to the outer sphere of Wedges with the same <a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f" title="Returns t.value() if t is a std::optional otherwise returns t.">value</a> for <code>opening_angle</code>. </dd></dl>

</div>
</div>
<a id="ga7de6fa2c6d431c00ca9fe7d309c10cd2" name="ga7de6fa2c6d431c00ca9fe7d309c10cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7de6fa2c6d431c00ca9fe7d309c10cd2">&#9670;&nbsp;</a></span>functions_of_time_are_ready()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CacheTag , typename Metavariables , typename ArrayIndex , typename Component , size_t N = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool domain::functions_of_time_are_ready </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache</a>&lt; Metavariables &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayIndex &amp;&#160;</td>
          <td class="paramname"><em>array_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Component *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>functions_to_check</em> = <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>,&#160;0&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that functions of time are up-to-date. </p>
<p >Check that functions of time in <code>CacheTag</code> with names in <code>functions_to_check</code> are ready at time <code>time</code>. If no names are listed in <code>functions_to_check</code>, checks all functions in <code>CacheTag</code>. If any function is not ready, schedules a <code><a class="el" href="classParallel_1_1PerformAlgorithmCallback.html" title="Wraps a call to perform_algorithm.">Parallel::PerformAlgorithmCallback</a></code> with the GlobalCache. </p>

</div>
</div>
<a id="ga7277b2f5c68fd943f3e10da1b93485d8" name="ga7277b2f5c68fd943f3e10da1b93485d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7277b2f5c68fd943f3e10da1b93485d8">&#9670;&nbsp;</a></span>index_to_slice_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t index_to_slice_at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the index in the perpendicular dimension of an element boundary. </p>
<p >Optionally provide an <code>offset</code> to find an index offset from the element boundary. </p>

</div>
</div>
<a id="ga3255acdd06d1f41f624e4519a9006082" name="ga3255acdd06d1f41f624e4519a9006082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3255acdd06d1f41f624e4519a9006082">&#9670;&nbsp;</a></span>interface_logical_coordinates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; interface_logical_coordinates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines functions interface_logical_coordinates. </p>
<p >Compute the logical coordinates on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>.</p>
<p ><em>Returns:</em> element logical-frame vector holding coordinates</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classMesh.html">Mesh&lt;2&gt;</a> mesh_3d_zbdry{</div>
<div class="line">      {{5, 3}}, Spectral::Basis::Legendre, Spectral::Quadrature::GaussLobatto};</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> x_3d_lb_zeta = map_3d(</div>
<div class="line">      <a class="code hl_function" href="group__ComputationalDomainGroup.html#ga3255acdd06d1f41f624e4519a9006082">interface_logical_coordinates</a>(mesh_3d_zbdry, <a class="code hl_class" href="classDirection.html">Direction&lt;3&gt;::lower_zeta</a>()));</div>
<div class="ttc" id="aclassDirection_html"><div class="ttname"><a href="classDirection.html">Direction</a></div><div class="ttdoc">A particular Side along a particular coordinate Axis.</div><div class="ttdef"><b>Definition:</b> Direction.hpp:23</div></div>
<div class="ttc" id="aclassMesh_html"><div class="ttname"><a href="classMesh.html">Mesh</a></div><div class="ttdoc">Holds the number of grid points, basis, and quadrature in each direction of the computational grid.</div><div class="ttdef"><b>Definition:</b> Mesh.hpp:49</div></div>
<div class="ttc" id="agroup__ComputationalDomainGroup_html_ga3255acdd06d1f41f624e4519a9006082"><div class="ttname"><a href="group__ComputationalDomainGroup.html#ga3255acdd06d1f41f624e4519a9006082">interface_logical_coordinates</a></div><div class="ttdeci">tnsr::I&lt; DataVector, VolumeDim, Frame::ElementLogical &gt; interface_logical_coordinates(const Mesh&lt; VolumeDim - 1 &gt; &amp;mesh, const Direction&lt; VolumeDim &gt; &amp;direction)</div><div class="ttdoc">Defines functions interface_logical_coordinates.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga22ab91fc5d9d14fca8a1034e69832bf6" name="ga22ab91fc5d9d14fca8a1034e69832bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22ab91fc5d9d14fca8a1034e69832bf6">&#9670;&nbsp;</a></span>jacobian_diagnostic() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; domain::jacobian_diagnostic </td>
          <td>(</td>
          <td class="paramtype">const ::Jacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>analytic_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapped_coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">::Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A diagnostic comparing the analytic and numerical Jacobians for a map. </p>
<p >Specifically, returns </p><p class="formulaDsp">
\[ C_{\hat{i}} = 1 - \frac{\sum_i |\partial_{\hat{i}} x^i|}{\sum_i |D_{\hat{i}} x^i|} \]
</p>
<p>, where \(x^{\hat{i}}\) are the logical coordinates, \(x^i\) are the coordinates in the target frame, \(\partial_{\hat{i}}x^i\) is the analytic Jacobian, and \(D_{\hat{i}} x^i\) is the numerical Jacobian.</p>
<dl class="section note"><dt>Note</dt><dd>This function accepts the analytic jacobian, mapped coordinates, and mesh as a parameter. The numeric jacobian is computed internally by differentiating the mapped coordinates with respect to the logical coordinates. </dd></dl>

</div>
</div>
<a id="gab579049797d1e22b31d7e21288c53370" name="gab579049797d1e22b31d7e21288c53370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab579049797d1e22b31d7e21288c53370">&#9670;&nbsp;</a></span>jacobian_diagnostic() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void domain::jacobian_diagnostic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>jacobian_diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::Jacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>analytic_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapped_coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">::Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A diagnostic comparing the analytic and numerical Jacobians for a map. </p>
<p >Specifically, returns </p><p class="formulaDsp">
\[ C_{\hat{i}} = 1 - \frac{\sum_i |\partial_{\hat{i}} x^i|}{\sum_i |D_{\hat{i}} x^i|} \]
</p>
<p>, where \(x^{\hat{i}}\) are the logical coordinates, \(x^i\) are the coordinates in the target frame, \(\partial_{\hat{i}}x^i\) is the analytic Jacobian, and \(D_{\hat{i}} x^i\) is the numerical Jacobian.</p>
<dl class="section note"><dt>Note</dt><dd>This function accepts the analytic jacobian, mapped coordinates, and mesh as a parameter. The numeric jacobian is computed internally by differentiating the mapped coordinates with respect to the logical coordinates. </dd></dl>

</div>
</div>
<a id="ga45b5650adddebf194bd3d70113a73eb6" name="ga45b5650adddebf194bd3d70113a73eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45b5650adddebf194bd3d70113a73eb6">&#9670;&nbsp;</a></span>jacobian_diagnostic() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void domain::jacobian_diagnostic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, typename <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>jacobian_diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Jacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, typename <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>analytic_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga5e4aece332518b3a95c2a73557aaa596">TensorMetafunctions::prepend_spatial_index</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, Fr &gt;, Dim, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, typename <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>numeric_jacobian_transpose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A diagnostic comparing the analytic and numerical Jacobians for a map. </p>
<p >Specifically, returns </p><p class="formulaDsp">
\[ C_{\hat{i}} = 1 - \frac{\sum_i |\partial_{\hat{i}} x^i|}{\sum_i |D_{\hat{i}} x^i|} \]
</p>
<p>, where \(x^{\hat{i}}\) are the logical coordinates, \(x^i\) are the coordinates in the target frame, \(\partial_{\hat{i}}x^i\) is the analytic Jacobian, and \(D_{\hat{i}} x^i\) is the numerical Jacobian.</p>
<dl class="section note"><dt>Note</dt><dd>This function accepts the transpose of the numeric Jacobian as a parameter, since the numeric Jacobian will typically be computed via <a class="el" href="group__NumericalAlgorithmsGroup.html#gac665845d5ed95426a3c45292300d2263" title="Computes the logical partial derivative of a tensor, prepending the spatial derivative index,...">logical_partial_derivative()</a>, which prepends the logical (source frame) derivative index. Tensors of type Jacobian, in contrast, have the derivative index second. </dd></dl>

</div>
</div>
<a id="ga244443757eca7cce2a735011474c7c20" name="ga244443757eca7cce2a735011474c7c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga244443757eca7cce2a735011474c7c20">&#9670;&nbsp;</a></span>logical_coordinates() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; logical_coordinates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the logical coordinates in an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>. </p>
<h3>Details</h3>
<p >The logical coordinates are the collocation points associated to the spectral basis functions and quadrature of the <code>mesh</code>.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classMesh.html">Mesh&lt;3&gt;</a> mesh_3d{{{5, 3, 2}},</div>
<div class="line">                        Spectral::Basis::Legendre,</div>
<div class="line">                        Spectral::Quadrature::GaussLobatto};</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> CoordinateMaps::Affine x_map{-1.0, 1.0, -3.0, 7.0};</div>
<div class="line">  <span class="keyword">const</span> CoordinateMaps::Affine y_map{-1.0, 1.0, -13.0, 47.0};</div>
<div class="line">  <span class="keyword">const</span> CoordinateMaps::Affine z_map{-1.0, 1.0, -32.0, 74.0};</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> map_3d = make_coordinate_map&lt;Frame::ElementLogical, Frame::Grid&gt;(</div>
<div class="line">      Affine3d{x_map, y_map, z_map});</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> x_3d = map_3d(<a class="code hl_function" href="group__ComputationalDomainGroup.html#ga1b413be413e7562d25ad9c3c9c3cc7f0">logical_coordinates</a>(mesh_3d));</div>
<div class="ttc" id="agroup__ComputationalDomainGroup_html_ga1b413be413e7562d25ad9c3c9c3cc7f0"><div class="ttname"><a href="group__ComputationalDomainGroup.html#ga1b413be413e7562d25ad9c3c9c3cc7f0">logical_coordinates</a></div><div class="ttdeci">void logical_coordinates(gsl::not_null&lt; tnsr::I&lt; DataVector, VolumeDim, Frame::ElementLogical &gt; * &gt; logical_coords, const Mesh&lt; VolumeDim &gt; &amp;mesh)</div><div class="ttdoc">Compute the logical coordinates in an Element.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga1b413be413e7562d25ad9c3c9c3cc7f0" name="ga1b413be413e7562d25ad9c3c9c3cc7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b413be413e7562d25ad9c3c9c3cc7f0">&#9670;&nbsp;</a></span>logical_coordinates() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void logical_coordinates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>logical_coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the logical coordinates in an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>. </p>
<h3>Details</h3>
<p >The logical coordinates are the collocation points associated to the spectral basis functions and quadrature of the <code>mesh</code>.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classMesh.html">Mesh&lt;3&gt;</a> mesh_3d{{{5, 3, 2}},</div>
<div class="line">                        Spectral::Basis::Legendre,</div>
<div class="line">                        Spectral::Quadrature::GaussLobatto};</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> CoordinateMaps::Affine x_map{-1.0, 1.0, -3.0, 7.0};</div>
<div class="line">  <span class="keyword">const</span> CoordinateMaps::Affine y_map{-1.0, 1.0, -13.0, 47.0};</div>
<div class="line">  <span class="keyword">const</span> CoordinateMaps::Affine z_map{-1.0, 1.0, -32.0, 74.0};</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> map_3d = make_coordinate_map&lt;Frame::ElementLogical, Frame::Grid&gt;(</div>
<div class="line">      Affine3d{x_map, y_map, z_map});</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> x_3d = map_3d(<a class="code hl_function" href="group__ComputationalDomainGroup.html#ga1b413be413e7562d25ad9c3c9c3cc7f0">logical_coordinates</a>(mesh_3d));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga772eeed19a2f610810889ac961d06e67" name="ga772eeed19a2f610810889ac961d06e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga772eeed19a2f610810889ac961d06e67">&#9670;&nbsp;</a></span>maps_for_rectilinear_domains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetFrame , size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto maps_for_rectilinear_domains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>domain_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt;, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_demarcations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_indices_to_exclude</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientations_of_all_blocks</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_equiangular_map</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1BlockLogical.html">Frame::BlockLogical</a>, TargetFrame, VolumeDim &gt; &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The CoordinateMaps for a rectilinear domain of n-cubes. </p>
<p >Allows for both Affine and Equiangular maps. </p>

</div>
</div>
<a id="gafa8cb44daebc8f9e080718961530be89" name="gafa8cb44daebc8f9e080718961530be89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa8cb44daebc8f9e080718961530be89">&#9670;&nbsp;</a></span>maximum_number_of_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t maximum_number_of_neighbors </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of neighbors an element can have in <code>dim</code> dimensions. </p>
<dl class="section note"><dt>Note</dt><dd>Assumes a maximum 2-to-1 refinement between two adjacent Elements. </dd></dl>

</div>
</div>
<a id="ga45ff23a83bb3bab32bd30a13bc9a41a0" name="ga45ff23a83bb3bab32bd30a13bc9a41a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45ff23a83bb3bab32bd30a13bc9a41a0">&#9670;&nbsp;</a></span>maximum_number_of_neighbors_per_direction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t maximum_number_of_neighbors_per_direction </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of neighbors in each direction an element can have in <code>dim</code> dimensions. </p>
<dl class="section note"><dt>Note</dt><dd>Assumes a maximum 2-to-1 refinement between two adjacent Elements. </dd></dl>

</div>
</div>
<a id="ga7c1177a899891bf32b1ce4e1100c0ab5" name="ga7c1177a899891bf32b1ce4e1100c0ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c1177a899891bf32b1ce4e1100c0ab5">&#9670;&nbsp;</a></span>orient_variables() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataVector.html">DataVector</a> orient_variables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientation_of_neighbor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orient data in a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;double&gt;</code> or <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code> representing one or more tensor components. </p>
<p >In most cases the <code>Variables</code> version of <code>orient_variables</code> should be called. However, in some cases the tags and thus the type of the data being sent is determined at runtime. In these cases the <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></code> version of <code>orient_variables</code> is useful. A concrete example of this is when hybridizing DG with finite difference methods, where sometimes the data sent is both the variables for reconstruction and the fluxes for either the DG or finite difference scheme, while at other points only one of these three is sent. </p>

</div>
</div>
<a id="gaa7bda3cdc5430928c0ad8b1f2d6909d9" name="gaa7bda3cdc5430928c0ad8b1f2d6909d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7bda3cdc5430928c0ad8b1f2d6909d9">&#9670;&nbsp;</a></span>orient_variables() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; orient_variables </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientation_of_neighbor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orient data in a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;double&gt;</code> or <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code> representing one or more tensor components. </p>
<p >In most cases the <code>Variables</code> version of <code>orient_variables</code> should be called. However, in some cases the tags and thus the type of the data being sent is determined at runtime. In these cases the <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></code> version of <code>orient_variables</code> is useful. A concrete example of this is when hybridizing DG with finite difference methods, where sometimes the data sent is both the variables for reconstruction and the fluxes for either the DG or finite difference scheme, while at other points only one of these three is sent. </p>

</div>
</div>
<a id="ga3619aae9c08e6fe73183d872b2c8c925" name="ga3619aae9c08e6fe73183d872b2c8c925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3619aae9c08e6fe73183d872b2c8c925">&#9670;&nbsp;</a></span>orient_variables() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void orient_variables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientation_of_neighbor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orient variables to the data-storage order of a neighbor element with the given orientation. </p>
<dl class="section warning"><dt>Warning</dt><dd>The result is <em>not</em> resized and assumes to be of the correct size (<code>variables.size()</code>). </dd></dl>

</div>
</div>
<a id="ga49edd246d872be455c3a499ed63e73b6" name="ga49edd246d872be455c3a499ed63e73b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49edd246d872be455c3a499ed63e73b6">&#9670;&nbsp;</a></span>orient_variables_on_slice() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataVector.html">DataVector</a> orient_variables_on_slice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>variables_on_slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>slice_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sliced_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientation_of_neighbor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orient data in a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;double&gt;</code> or <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code> representing one or more tensor components. </p>
<p >In most cases the <code>Variables</code> version of <code>orient_variables</code> should be called. However, in some cases the tags and thus the type of the data being sent is determined at runtime. In these cases the <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></code> version of <code>orient_variables</code> is useful. A concrete example of this is when hybridizing DG with finite difference methods, where sometimes the data sent is both the variables for reconstruction and the fluxes for either the DG or finite difference scheme, while at other points only one of these three is sent. </p>

</div>
</div>
<a id="ga1ea39f708807d4a31ea2429b4357f38b" name="ga1ea39f708807d4a31ea2429b4357f38b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ea39f708807d4a31ea2429b4357f38b">&#9670;&nbsp;</a></span>orient_variables_on_slice() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; orient_variables_on_slice </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables_on_slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>slice_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sliced_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientation_of_neighbor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orient data in a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;double&gt;</code> or <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code> representing one or more tensor components. </p>
<p >In most cases the <code>Variables</code> version of <code>orient_variables</code> should be called. However, in some cases the tags and thus the type of the data being sent is determined at runtime. In these cases the <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></code> version of <code>orient_variables</code> is useful. A concrete example of this is when hybridizing DG with finite difference methods, where sometimes the data sent is both the variables for reconstruction and the fluxes for either the DG or finite difference scheme, while at other points only one of these three is sent. </p>

</div>
</div>
<a id="gae19eebf840f202d53fdb423820236486" name="gae19eebf840f202d53fdb423820236486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae19eebf840f202d53fdb423820236486">&#9670;&nbsp;</a></span>orient_variables_on_slice() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void orient_variables_on_slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>variables_on_slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>slice_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sliced_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientation_of_neighbor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orient variables to the data-storage order of a neighbor element with the given orientation. </p>
<dl class="section warning"><dt>Warning</dt><dd>The result is <em>not</em> resized and assumes to be of the correct size (<code>variables.size()</code>). </dd></dl>

</div>
</div>
<a id="ga55562b21706cdbb5ec553d6122b86eda" name="ga55562b21706cdbb5ec553d6122b86eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55562b21706cdbb5ec553d6122b86eda">&#9670;&nbsp;</a></span>radially_compressed_coordinates() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , size_t Dim, typename CoordsFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::I&lt; DataType, Dim, CoordsFrame &gt; domain::radially_compressed_coordinates </td>
          <td>(</td>
          <td class="paramtype">const tnsr::I&lt; DataType, Dim, CoordsFrame &gt; &amp;&#160;</td>
          <td class="paramname"><em>coordinates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>outer_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">CoordinateMaps::Distribution</a>&#160;</td>
          <td class="paramname"><em>compression</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Coordinates suitable for visualizing large radii by compressing them logarithmically or inversely. </p>
<p >Rescales the coordinates \(\boldsymbol{x}\) as</p>
<p class="formulaDsp">
\begin{equation} \hat{\boldsymbol{x}} = \frac{\hat{r}}{r} \boldsymbol{x} \text{,} \end{equation}
</p>
<p >for \(r &gt; r_0\), where \(r=\sqrt{x^2+y^2+z^2}\) is the Euclidean coordinate radius and \(r_0\) is the <code>inner_radius</code>. The coordinates are compressed from \(r \in [r_0, r_1]\) to \(\hat{r} \in [r_0, \hat{r}_1]\), where the <code>outer_radius</code> \(r_1\) can be incomprehensibly large like \(10^9\) and the compressed outer radius \(\hat{r}_1\) is reasonably small so it can be visualized well. We choose</p>
<p class="formulaDsp">
\begin{equation} \hat{r}_1 = r_0 \log_{10}(r_1) \end{equation}
</p>
<p >so the compressed outer radius is a multiple of the inner radius and increases with the outer radius as well, but exponentials are tamed.</p>
<p >The radial compression map \(\hat{r}(r)\) is just the inverse of the <code><a class="el" href="classdomain_1_1CoordinateMaps_1_1Interval.html" title="Maps  in the 1D interval  to  in the interval  according to a domain::CoordinateMaps::Distribution.">domain::CoordinateMaps::Interval</a></code> map, which is also used to distribute grid points radially. Therefore, radial grid points will be distributed linearly in the radially compressed coordinates if you use the same <code>compression</code> distribution that you used to distribute radial grid points in the <code>CoordsFrame</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdomain_1_1CoordinateMaps_1_1Interval.html" title="Maps  in the 1D interval  to  in the interval  according to a domain::CoordinateMaps::Distribution.">domain::CoordinateMaps::Interval</a> </dd></dl>

</div>
</div>
<a id="gafe0f1e9e5bdbcfd1aa2a7228e894ac52" name="gafe0f1e9e5bdbcfd1aa2a7228e894ac52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe0f1e9e5bdbcfd1aa2a7228e894ac52">&#9670;&nbsp;</a></span>radially_compressed_coordinates() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , size_t Dim, typename CoordsFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void domain::radially_compressed_coordinates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; DataType, Dim, CoordsFrame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, Dim, CoordsFrame &gt; &amp;&#160;</td>
          <td class="paramname"><em>coordinates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>outer_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">CoordinateMaps::Distribution</a>&#160;</td>
          <td class="paramname"><em>compression</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Coordinates suitable for visualizing large radii by compressing them logarithmically or inversely. </p>
<p >Rescales the coordinates \(\boldsymbol{x}\) as</p>
<p class="formulaDsp">
\begin{equation} \hat{\boldsymbol{x}} = \frac{\hat{r}}{r} \boldsymbol{x} \text{,} \end{equation}
</p>
<p >for \(r &gt; r_0\), where \(r=\sqrt{x^2+y^2+z^2}\) is the Euclidean coordinate radius and \(r_0\) is the <code>inner_radius</code>. The coordinates are compressed from \(r \in [r_0, r_1]\) to \(\hat{r} \in [r_0, \hat{r}_1]\), where the <code>outer_radius</code> \(r_1\) can be incomprehensibly large like \(10^9\) and the compressed outer radius \(\hat{r}_1\) is reasonably small so it can be visualized well. We choose</p>
<p class="formulaDsp">
\begin{equation} \hat{r}_1 = r_0 \log_{10}(r_1) \end{equation}
</p>
<p >so the compressed outer radius is a multiple of the inner radius and increases with the outer radius as well, but exponentials are tamed.</p>
<p >The radial compression map \(\hat{r}(r)\) is just the inverse of the <code><a class="el" href="classdomain_1_1CoordinateMaps_1_1Interval.html" title="Maps  in the 1D interval  to  in the interval  according to a domain::CoordinateMaps::Distribution.">domain::CoordinateMaps::Interval</a></code> map, which is also used to distribute grid points radially. Therefore, radial grid points will be distributed linearly in the radially compressed coordinates if you use the same <code>compression</code> distribution that you used to distribute radial grid points in the <code>CoordsFrame</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdomain_1_1CoordinateMaps_1_1Interval.html" title="Maps  in the 1D interval  to  in the interval  according to a domain::CoordinateMaps::Distribution.">domain::CoordinateMaps::Interval</a> </dd></dl>

</div>
</div>
<a id="ga0d5a73eaa01c10f7d3b456318e0880a9" name="ga0d5a73eaa01c10f7d3b456318e0880a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d5a73eaa01c10f7d3b456318e0880a9">&#9670;&nbsp;</a></span>rectilinear_domain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDomain.html">Domain</a>&lt; VolumeDim &gt; rectilinear_domain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>domain_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt;, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_demarcations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_indices_to_exclude</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientations_of_all_blocks</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; bool, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dimension_is_periodic</em> = <code><a class="el" href="group__UtilitiesGroup.html#gaef51773ec780d16fddcda8e5094f2a21">make_array</a>&lt;&#160;VolumeDim&#160;&gt;(false)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="structPairOfFaces.html">PairOfFaces</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>identifications</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_equiangular_map</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a rectilinear <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain.">Domain</a> of multicubes. </p>
<h3>Details</h3>
<p >Useful for constructing domains for testing non-trivially connected rectilinear domains made up of cubes. We refer to a domain of this type as an edifice. The <code>domain_extents</code> provides the size (in the number of blocks) of the initial aligned edifice to construct. The <code>block_indices_to_exclude</code> parameter is used in refining the shape of the edifice from a cube to sometime more non-trivial, such as an L-shape or the net of a tesseract. The <code>block_demarcations</code> and <code>use_equiangular_map</code> parameters determine the CoordinateMaps to be used. <code>orientations_of_all_blocks</code> contains the <a class="el" href="classOrientationMap.html" title="A mapping of the logical coordinate axes of a host to the logical coordinate axes of a neighbor of th...">OrientationMap</a> of the edifice relative to each block.</p>
<p >The <code>identifications</code> parameter is used when identifying the faces of blocks in an edifice. This is used to identify the 1D boundaries in the 2D net for a 3D cube to construct a domain with topology S2. Note: If the user wishes to rotate the blocks as well as manually identify their faces, the user must provide the <a class="el" href="structPairOfFaces.html" title="Each member in PairOfFaces holds the global corner ids of a block face. PairOfFaces is used in settin...">PairOfFaces</a> corresponding to the rotated corners. </p>

</div>
</div>
<a id="gab99ad646c285e1457d42733ff283fba1" name="gab99ad646c285e1457d42733ff283fba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab99ad646c285e1457d42733ff283fba1">&#9670;&nbsp;</a></span>set_internal_boundaries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void set_internal_boundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; VolumeDim, <a class="el" href="classBlockNeighbor.html">BlockNeighbor</a>&lt; VolumeDim &gt; &gt; &gt; * &gt;&#160;</td>
          <td class="paramname"><em>neighbors_of_all_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1BlockLogical.html">Frame::BlockLogical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, VolumeDim &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>maps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up the BlockNeighbors using the corner numbering scheme implied by the maps provided by the user to deduce the correct neighbors and orientations. </p>
<dl class="section warning"><dt>Warning</dt><dd>Does not set up periodic boundary conditions. </dd></dl>

</div>
</div>
<a id="ga3a4bc0136871c65fe8a305576ea2b171" name="ga3a4bc0136871c65fe8a305576ea2b171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a4bc0136871c65fe8a305576ea2b171">&#9670;&nbsp;</a></span>size_of_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, VolumeDim &gt; size_of_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, <a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>logical_to_grid_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>grid_to_inertial_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>functions_of_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the inertial-coordinate size of an element along each of its logical directions. </p>
<p >For each logical direction, compute the distance (in inertial coordinates) between the element's lower and upper faces in that logical direction. The distance is measured between centers of the faces, with the centers defined in the logical coordinates. Note that for curved elements, this is an approximate measurement of size.</p>
<h3>Details</h3>
<p >Because this quantity is defined in terms of specific coordinates, it is not well represented by a <code>Tensor</code>, so we use a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a></code>. </p>

</div>
</div>
<a id="ga6b4c280017c392c47a68ce156010b271" name="ga6b4c280017c392c47a68ce156010b271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b4c280017c392c47a68ce156010b271">&#9670;&nbsp;</a></span>size_of_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, VolumeDim &gt; size_of_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>logical_to_inertial_map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the inertial-coordinate size of an element along each of its logical directions. </p>
<p >For each logical direction, compute the distance (in inertial coordinates) between the element's lower and upper faces in that logical direction. The distance is measured between centers of the faces, with the centers defined in the logical coordinates. Note that for curved elements, this is an approximate measurement of size.</p>
<h3>Details</h3>
<p >Because this quantity is defined in terms of specific coordinates, it is not well represented by a <code>Tensor</code>, so we use a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a></code>. </p>

</div>
</div>
<a id="gac6c9a4469ceecf0541c580bd0a4abb73" name="gac6c9a4469ceecf0541c580bd0a4abb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6c9a4469ceecf0541c580bd0a4abb73">&#9670;&nbsp;</a></span>sph_wedge_coordinate_maps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html">domain::CoordinateMaps::Wedge</a>&lt; 3 &gt; &gt; sph_wedge_coordinate_maps </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>outer_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>inner_sphericity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>outer_sphericity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_equiangular_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_half_wedges</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>radial_partitioning</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">domain::CoordinateMaps::Distribution</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>radial_distribution</em> = <code>{domain::CoordinateMaps::Distribution::Linear}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ComputationalDomainGroup.html#gac672a529d9aaa6a948b8b7eb6ec9b528">ShellWedges</a>&#160;</td>
          <td class="paramname"><em>which_wedges</em> = <code><a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ab1c94ca2fbc3e78fc30069c8d0f01680">ShellWedges::All</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>opening_angle</em> = <code>M_PI_2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >These are the CoordinateMaps of the Wedge&lt;3&gt;s used in the Sphere and binary compact object DomainCreators. This function can also be used to wrap the Sphere in a cube made of six Wedge&lt;3&gt;s.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inner_radius</td><td>Radius of the inner boundary of the shell, or the radius circumscribing the inner cube of a sphere. </td></tr>
    <tr><td class="paramname">outer_radius</td><td>Outer radius of the shell or sphere. </td></tr>
    <tr><td class="paramname">inner_sphericity</td><td>Specifies if the wedges form a spherical inner boundary (1.0) or a cubical inner boundary (0.0). </td></tr>
    <tr><td class="paramname">outer_sphericity</td><td>Specifies if the wedges form a spherical outer boundary (1.0) or a cubical outer boundary (0.0). </td></tr>
    <tr><td class="paramname">use_equiangular_map</td><td>Toggles the equiangular map of the Wedge map. </td></tr>
    <tr><td class="paramname">use_half_wedges</td><td>When <code>true</code>, the wedges in the +z,-z,+y,-y directions are cut in half along their xi-axes. The resulting ten CoordinateMaps are used for the outermost Blocks of the BBH <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain.">Domain</a>. </td></tr>
    <tr><td class="paramname">radial_partitioning</td><td>Specifies the radial boundaries of sub-shells between <code>inner_radius</code> and <code>outer_radius</code>. If the inner and outer sphericities are different, the innermost shell does the transition. </td></tr>
    <tr><td class="paramname">radial_distribution</td><td>Select the radial distribution of grid points in the spherical shells. </td></tr>
    <tr><td class="paramname">which_wedges</td><td>Select a subset of wedges. </td></tr>
    <tr><td class="paramname">opening_angle</td><td>sets the combined opening angle of the two half wedges that open up along the y-z plane. The endcap wedges are then given an angle of pi minus this opening angle. This parameter only has an effect if <code>use_half_wedges</code> is set to <code>true</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga649a7da35c207e46d234256976b33103" name="ga649a7da35c207e46d234256976b33103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga649a7da35c207e46d234256976b33103">&#9670;&nbsp;</a></span>unnormalized_face_normal() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename TargetFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void unnormalized_face_normal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, TargetFrame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inv_jacobian_on_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>. </p>
<h3>Details</h3>
<p >Computes the grid-frame normal by taking the logical-frame unit one-form in the given <a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis.">Direction</a> and mapping it to the grid frame with the given map, or the given inverse Jacobian.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classMesh.html">Mesh&lt;0&gt;</a> mesh_0d;</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> map_1d = make_coordinate_map&lt;Frame::ElementLogical, Frame::Grid&gt;(</div>
<div class="line">      CoordinateMaps::Affine(-1.0, 1.0, -3.0, 7.0));</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> normal_1d_lower =</div>
<div class="line">      <a class="code hl_function" href="group__ComputationalDomainGroup.html#ga649a7da35c207e46d234256976b33103">unnormalized_face_normal</a>(mesh_0d, map_1d, <a class="code hl_class" href="classDirection.html">Direction&lt;1&gt;::lower_xi</a>());</div>
<div class="ttc" id="agroup__ComputationalDomainGroup_html_ga649a7da35c207e46d234256976b33103"><div class="ttname"><a href="group__ComputationalDomainGroup.html#ga649a7da35c207e46d234256976b33103">unnormalized_face_normal</a></div><div class="ttdeci">void unnormalized_face_normal(const gsl::not_null&lt; tnsr::i&lt; DataVector, VolumeDim, TargetFrame &gt; * &gt; result, const Mesh&lt; VolumeDim - 1 &gt; &amp;interface_mesh, const InverseJacobian&lt; DataVector, VolumeDim, Frame::ElementLogical, TargetFrame &gt; &amp;inv_jacobian_on_interface, const Direction&lt; VolumeDim &gt; &amp;direction)</div><div class="ttdoc">Compute the outward grid normal on a face of an Element.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaa27bf2e1f6c4c39085dc8d91d9969931" name="gaa27bf2e1f6c4c39085dc8d91d9969931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa27bf2e1f6c4c39085dc8d91d9969931">&#9670;&nbsp;</a></span>unnormalized_face_normal() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename TargetFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame &gt; unnormalized_face_normal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, TargetFrame, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>. </p>
<h3>Details</h3>
<p >Computes the grid-frame normal by taking the logical-frame unit one-form in the given <a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis.">Direction</a> and mapping it to the grid frame with the given map, or the given inverse Jacobian.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classMesh.html">Mesh&lt;0&gt;</a> mesh_0d;</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> map_1d = make_coordinate_map&lt;Frame::ElementLogical, Frame::Grid&gt;(</div>
<div class="line">      CoordinateMaps::Affine(-1.0, 1.0, -3.0, 7.0));</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> normal_1d_lower =</div>
<div class="line">      <a class="code hl_function" href="group__ComputationalDomainGroup.html#ga649a7da35c207e46d234256976b33103">unnormalized_face_normal</a>(mesh_0d, map_1d, <a class="code hl_class" href="classDirection.html">Direction&lt;1&gt;::lower_xi</a>());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga12b573aba8992f8a67126994057a6ebc" name="ga12b573aba8992f8a67126994057a6ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12b573aba8992f8a67126994057a6ebc">&#9670;&nbsp;</a></span>unnormalized_face_normal() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; unnormalized_face_normal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, <a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>logical_to_grid_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>grid_to_inertial_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>functions_of_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>. </p>
<h3>Details</h3>
<p >Computes the grid-frame normal by taking the logical-frame unit one-form in the given <a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis.">Direction</a> and mapping it to the grid frame with the given map, or the given inverse Jacobian.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classMesh.html">Mesh&lt;0&gt;</a> mesh_0d;</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> map_1d = make_coordinate_map&lt;Frame::ElementLogical, Frame::Grid&gt;(</div>
<div class="line">      CoordinateMaps::Affine(-1.0, 1.0, -3.0, 7.0));</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> normal_1d_lower =</div>
<div class="line">      <a class="code hl_function" href="group__ComputationalDomainGroup.html#ga649a7da35c207e46d234256976b33103">unnormalized_face_normal</a>(mesh_0d, map_1d, <a class="code hl_class" href="classDirection.html">Direction&lt;1&gt;::lower_xi</a>());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga96dfe0dd3fbf25876726e544c1443993" name="ga96dfe0dd3fbf25876726e544c1443993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96dfe0dd3fbf25876726e544c1443993">&#9670;&nbsp;</a></span>unnormalized_face_normal() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename TargetFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame &gt; unnormalized_face_normal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, TargetFrame &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>. </p>
<h3>Details</h3>
<p >Computes the grid-frame normal by taking the logical-frame unit one-form in the given <a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis.">Direction</a> and mapping it to the grid frame with the given map, or the given inverse Jacobian.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classMesh.html">Mesh&lt;0&gt;</a> mesh_0d;</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> map_1d = make_coordinate_map&lt;Frame::ElementLogical, Frame::Grid&gt;(</div>
<div class="line">      CoordinateMaps::Affine(-1.0, 1.0, -3.0, 7.0));</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> normal_1d_lower =</div>
<div class="line">      <a class="code hl_function" href="group__ComputationalDomainGroup.html#ga649a7da35c207e46d234256976b33103">unnormalized_face_normal</a>(mesh_0d, map_1d, <a class="code hl_class" href="classDirection.html">Direction&lt;1&gt;::lower_xi</a>());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gae9feb4e7cd655d238161671644c3cda1" name="gae9feb4e7cd655d238161671644c3cda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9feb4e7cd655d238161671644c3cda1">&#9670;&nbsp;</a></span>unnormalized_face_normal() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename TargetFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame &gt; unnormalized_face_normal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, TargetFrame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inv_jacobian_on_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>. </p>
<h3>Details</h3>
<p >Computes the grid-frame normal by taking the logical-frame unit one-form in the given <a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis.">Direction</a> and mapping it to the grid frame with the given map, or the given inverse Jacobian.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classMesh.html">Mesh&lt;0&gt;</a> mesh_0d;</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> map_1d = make_coordinate_map&lt;Frame::ElementLogical, Frame::Grid&gt;(</div>
<div class="line">      CoordinateMaps::Affine(-1.0, 1.0, -3.0, 7.0));</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> normal_1d_lower =</div>
<div class="line">      <a class="code hl_function" href="group__ComputationalDomainGroup.html#ga649a7da35c207e46d234256976b33103">unnormalized_face_normal</a>(mesh_0d, map_1d, <a class="code hl_class" href="classDirection.html">Direction&lt;1&gt;::lower_xi</a>());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga43b8d40f75ed4eb339bc14c73038e697" name="ga43b8d40f75ed4eb339bc14c73038e697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43b8d40f75ed4eb339bc14c73038e697">&#9670;&nbsp;</a></span>unnormalized_face_normal() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void unnormalized_face_normal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, <a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>logical_to_grid_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>grid_to_inertial_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>functions_of_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>. </p>
<h3>Details</h3>
<p >Computes the grid-frame normal by taking the logical-frame unit one-form in the given <a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis.">Direction</a> and mapping it to the grid frame with the given map, or the given inverse Jacobian.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classMesh.html">Mesh&lt;0&gt;</a> mesh_0d;</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> map_1d = make_coordinate_map&lt;Frame::ElementLogical, Frame::Grid&gt;(</div>
<div class="line">      CoordinateMaps::Affine(-1.0, 1.0, -3.0, 7.0));</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> normal_1d_lower =</div>
<div class="line">      <a class="code hl_function" href="group__ComputationalDomainGroup.html#ga649a7da35c207e46d234256976b33103">unnormalized_face_normal</a>(mesh_0d, map_1d, <a class="code hl_class" href="classDirection.html">Direction&lt;1&gt;::lower_xi</a>());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga146ed5451c212031cd1824d032e0c9fd" name="ga146ed5451c212031cd1824d032e0c9fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga146ed5451c212031cd1824d032e0c9fd">&#9670;&nbsp;</a></span>unnormalized_face_normal() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename TargetFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void unnormalized_face_normal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, TargetFrame, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>. </p>
<h3>Details</h3>
<p >Computes the grid-frame normal by taking the logical-frame unit one-form in the given <a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis.">Direction</a> and mapping it to the grid frame with the given map, or the given inverse Jacobian.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classMesh.html">Mesh&lt;0&gt;</a> mesh_0d;</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> map_1d = make_coordinate_map&lt;Frame::ElementLogical, Frame::Grid&gt;(</div>
<div class="line">      CoordinateMaps::Affine(-1.0, 1.0, -3.0, 7.0));</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> normal_1d_lower =</div>
<div class="line">      <a class="code hl_function" href="group__ComputationalDomainGroup.html#ga649a7da35c207e46d234256976b33103">unnormalized_face_normal</a>(mesh_0d, map_1d, <a class="code hl_class" href="classDirection.html">Direction&lt;1&gt;::lower_xi</a>());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gad35fc33b7c504dd9af13636624d56378" name="gad35fc33b7c504dd9af13636624d56378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad35fc33b7c504dd9af13636624d56378">&#9670;&nbsp;</a></span>unnormalized_face_normal() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename TargetFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void unnormalized_face_normal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, TargetFrame &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>. </p>
<h3>Details</h3>
<p >Computes the grid-frame normal by taking the logical-frame unit one-form in the given <a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis.">Direction</a> and mapping it to the grid frame with the given map, or the given inverse Jacobian.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classMesh.html">Mesh&lt;0&gt;</a> mesh_0d;</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> map_1d = make_coordinate_map&lt;Frame::ElementLogical, Frame::Grid&gt;(</div>
<div class="line">      CoordinateMaps::Affine(-1.0, 1.0, -3.0, 7.0));</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> normal_1d_lower =</div>
<div class="line">      <a class="code hl_function" href="group__ComputationalDomainGroup.html#ga649a7da35c207e46d234256976b33103">unnormalized_face_normal</a>(mesh_0d, map_1d, <a class="code hl_class" href="classDirection.html">Direction&lt;1&gt;::lower_xi</a>());</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
