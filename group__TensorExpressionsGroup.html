<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: Tensor Expressions</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__TensorExpressionsGroup.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Tensor Expressions</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetenex"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetenex.html">tenex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceti"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceti.html">ti</a></td></tr>
<tr class="memdesc:namespaceti"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains definitions for the available <code><a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a></code>s to use in a <code>TensorExpression</code> <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1AddSub.html">tenex::AddSub&lt; T1, T2, ArgsList1, ArgsList2, Sign &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the tensor expression representing the addition or subtraction of two tensor expressions.  <a href="structtenex_1_1AddSub.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorContract.html">tenex::TensorContract&lt; T, X, Symm, IndexList, ArgsList, NumContractedIndices &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1Divide.html">tenex::Divide&lt; T1, T2, Args2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the tensor expression representing the quotient of one tensor expression divided by another tensor expression that evaluates to a rank 0 tensor.  <a href="structtenex_1_1Divide.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1LhsTensorSymmAndIndices.html">tenex::LhsTensorSymmAndIndices&lt; RhsTensorIndexList, LhsTensorIndexList, RhsSymmetry, RhsTensorIndexTypeList, NumLhsIndices, NumRhsIndices, LhsIndexSequence &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines and stores a LHS tensor's symmetry and index list from a RHS tensor expression and desired LHS index order.  <a href="structtenex_1_1LhsTensorSymmAndIndices.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1Negate.html">tenex::Negate&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the tensor expression representing the negation of a tensor expression.  <a href="structtenex_1_1Negate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1MarkAsNumberAsExpression.html">tenex::MarkAsNumberAsExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks a class as being a <code><a class="el" href="structtenex_1_1NumberAsExpression.html" title="Defines an expression representing a number.">NumberAsExpression</a>&lt;DataType&gt;</code>  <a href="structtenex_1_1MarkAsNumberAsExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1NumberAsExpression.html">tenex::NumberAsExpression&lt; DataType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an expression representing a number.  <a href="structtenex_1_1NumberAsExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1OuterProduct.html">tenex::OuterProduct&lt; T1, T2, IndexList1, IndexList2, ArgsList1, ArgsList2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the tensor expression representing the outer product of two tensor expressions.  <a href="structtenex_1_1OuterProduct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1SquareRoot.html">tenex::SquareRoot&lt; T, Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the tensor expression representing the square root of a tensor expression that evaluates to a rank 0 tensor.  <a href="structtenex_1_1SquareRoot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1TensorAsExpression.html">tenex::TensorAsExpression&lt; T, ArgsList &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an expression representing a Tensor.  <a href="structtenex_1_1TensorAsExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structExpression.html">Expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks a class as being a TensorExpression.  <a href="structExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorExpression_3_01Derived_00_01DataType_00_01Symm_00_01tmpl_1_1list_3_01Indices_8_8_8_0325e1bafc70f036ee2f18c4f6a988515.html">TensorExpression&lt; Derived, DataType, Symm, tmpl::list&lt; Indices... &gt;, ArgsList&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class all tensor expression implementations derive from.  <a href="structTensorExpression_3_01Derived_00_01DataType_00_01Symm_00_01tmpl_1_1list_3_01Indices_8_8_8_0325e1bafc70f036ee2f18c4f6a988515.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorIndex.html">TensorIndex&lt; I, &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the geeric indices in a TensorExpression.  <a href="structTensorIndex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtt_1_1is__tensor__index.html">tt::is_tensor_index&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type <code>T</code> is a <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used in TensorExpressions.  <a href="structtt_1_1is__tensor__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1tensorindex__list__is__valid.html">tenex::tensorindex_list_is_valid&lt; TensorIndexList &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether or not a given list of TensorIndexs is valid to be used with a tensor.  <a href="structtenex_1_1tensorindex__list__is__valid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtt_1_1is__time__index.html">tt::is_time_index&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type <code>T</code> is a <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> representing a concrete time index.  <a href="structtt_1_1is__time__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMarkAsVectorImpl.html">MarkAsVectorImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks a class as being a <code><a class="el" href="classVectorImpl.html" title="Base class template for various DataVector and related types.">VectorImpl</a></code>  <a href="structMarkAsVectorImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5c96f0cff493a34d1d2b674c105ae647"><td class="memTemplParams" colspan="2">template&lt;typename TensorIndexList1 , typename TensorIndexList2 &gt; </td></tr>
<tr class="memitem:ga5c96f0cff493a34d1d2b674c105ae647"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga5c96f0cff493a34d1d2b674c105ae647">tenex::generic_indices_at_same_positions</a> = typename detail::generic_indices_at_same_positions_impl&lt; TensorIndexList1, TensorIndexList2, tmpl::size&lt; TensorIndexList1 &gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a>==tmpl::size&lt; TensorIndexList2 &gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a> &gt;::type</td></tr>
<tr class="memdesc:ga5c96f0cff493a34d1d2b674c105ae647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether or not two lists of TensorIndexs contain the same generic indices at the same positions.  <a href="group__TensorExpressionsGroup.html#ga5c96f0cff493a34d1d2b674c105ae647">More...</a><br /></td></tr>
<tr class="separator:ga5c96f0cff493a34d1d2b674c105ae647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d354e2f865124997fa69e3d617dd5e0"><td class="memTemplParams" colspan="2">template&lt;auto &amp;... TensorIndices&gt; </td></tr>
<tr class="memitem:ga8d354e2f865124997fa69e3d617dd5e0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga8d354e2f865124997fa69e3d617dd5e0">make_tensorindex_list</a> = typename tenex::detail::make_tensorindex_list_impl&lt; TensorIndices... &gt;::type</td></tr>
<tr class="memdesc:ga8d354e2f865124997fa69e3d617dd5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> type list from a list of <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> objects.  <a href="group__TensorExpressionsGroup.html#ga8d354e2f865124997fa69e3d617dd5e0">More...</a><br /></td></tr>
<tr class="separator:ga8d354e2f865124997fa69e3d617dd5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga702fc5dbc87cb179f0868e9ce9ff22dd"><td class="memTemplParams" colspan="2"><a id="ga702fc5dbc87cb179f0868e9ce9ff22dd" name="ga702fc5dbc87cb179f0868e9ce9ff22dd"></a>
template&lt;typename T1 , typename T2 , typename X1 , typename X2 , typename Symm1 , typename Symm2 , typename IndexList1 , typename IndexList2 , typename Args1 , typename Args2 &gt; </td></tr>
<tr class="memitem:ga702fc5dbc87cb179f0868e9ce9ff22dd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const TensorExpression&lt; T1, X1, Symm1, IndexList1, Args1 &gt; &amp;t1, const TensorExpression&lt; T2, X2, Symm2, IndexList2, Args2 &gt; &amp;t2)</td></tr>
<tr class="separator:ga702fc5dbc87cb179f0868e9ce9ff22dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad15727391dd98d3862c08b543eed1dde"><td class="memTemplParams" colspan="2"><a id="gad15727391dd98d3862c08b543eed1dde" name="gad15727391dd98d3862c08b543eed1dde"></a>
template&lt;typename T1 , typename T2 , typename X1 , typename X2 , typename Symm1 , typename Symm2 , typename IndexList1 , typename IndexList2 , typename Args1 , typename Args2 &gt; </td></tr>
<tr class="memitem:gad15727391dd98d3862c08b543eed1dde"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const TensorExpression&lt; T1, X1, Symm1, IndexList1, Args1 &gt; &amp;t1, const TensorExpression&lt; T2, X2, Symm2, IndexList2, Args2 &gt; &amp;t2)</td></tr>
<tr class="separator:gad15727391dd98d3862c08b543eed1dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga762436e7479597dc0ebf379d22a068ef"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename... Args2&gt; </td></tr>
<tr class="memitem:ga762436e7479597dc0ebf379d22a068ef"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga762436e7479597dc0ebf379d22a068ef">operator/</a> (const TensorExpression&lt; T1, typename T1::type, typename T1::symmetry, typename T1::index_list, typename T1::args_list &gt; &amp;t1, const TensorExpression&lt; T2, typename T2::type, typename T2::symmetry, typename T2::index_list, tmpl::list&lt; Args2... &gt; &gt; &amp;t2)</td></tr>
<tr class="memdesc:ga762436e7479597dc0ebf379d22a068ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the quotient of one tensor expression over another tensor expression that evaluates to a rank 0 tensor.  <a href="group__TensorExpressionsGroup.html#ga762436e7479597dc0ebf379d22a068ef">More...</a><br /></td></tr>
<tr class="separator:ga762436e7479597dc0ebf379d22a068ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44bc58678768c8978ac7f6d47b2f7d17"><td class="memTemplParams" colspan="2">template&lt;auto &amp;... LhsTensorIndices, typename LhsDataType , typename LhsSymmetry , typename LhsIndexList , typename Derived , typename RhsDataType , typename RhsSymmetry , typename RhsIndexList , typename... RhsTensorIndices&gt; </td></tr>
<tr class="memitem:ga44bc58678768c8978ac7f6d47b2f7d17"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga44bc58678768c8978ac7f6d47b2f7d17">tenex::evaluate</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Tensor&lt; LhsDataType, LhsSymmetry, LhsIndexList &gt; * &gt; lhs_tensor, const TensorExpression&lt; Derived, RhsDataType, RhsSymmetry, RhsIndexList, tmpl::list&lt; RhsTensorIndices... &gt; &gt; &amp;rhs_tensorexpression)</td></tr>
<tr class="memdesc:ga44bc58678768c8978ac7f6d47b2f7d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the result of a RHS tensor expression to a tensor with the LHS index order set in the template parameters.  <a href="group__TensorExpressionsGroup.html#ga44bc58678768c8978ac7f6d47b2f7d17">More...</a><br /></td></tr>
<tr class="separator:ga44bc58678768c8978ac7f6d47b2f7d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fd622eef95abd72b7a0691360bd5344"><td class="memTemplParams" colspan="2">template&lt;auto &amp;... LhsTensorIndices, typename RhsTE , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; std::is_base_of_v&lt; <a class="el" href="structExpression.html">Expression</a>, RhsTE &gt; &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ga9fd622eef95abd72b7a0691360bd5344"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga9fd622eef95abd72b7a0691360bd5344">tenex::evaluate</a> (const RhsTE &amp;rhs_tensorexpression)</td></tr>
<tr class="memdesc:ga9fd622eef95abd72b7a0691360bd5344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the result of a RHS tensor expression to a tensor with the LHS index order set in the template parameters.  <a href="group__TensorExpressionsGroup.html#ga9fd622eef95abd72b7a0691360bd5344">More...</a><br /></td></tr>
<tr class="separator:ga9fd622eef95abd72b7a0691360bd5344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga387632ac6d9e87f550a1cc678d1f6f76"><td class="memTemplParams" colspan="2">template&lt;auto &amp;... LhsTensorIndices, typename LhsDataType , typename RhsDataType , typename LhsSymmetry , typename LhsIndexList , typename Derived , typename RhsSymmetry , typename RhsIndexList , typename... RhsTensorIndices&gt; </td></tr>
<tr class="memitem:ga387632ac6d9e87f550a1cc678d1f6f76"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga387632ac6d9e87f550a1cc678d1f6f76">tenex::update</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Tensor&lt; LhsDataType, LhsSymmetry, LhsIndexList &gt; * &gt; lhs_tensor, const TensorExpression&lt; Derived, RhsDataType, RhsSymmetry, RhsIndexList, tmpl::list&lt; RhsTensorIndices... &gt; &gt; &amp;rhs_tensorexpression)</td></tr>
<tr class="memdesc:ga387632ac6d9e87f550a1cc678d1f6f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the LHS tensor is used in the RHS expression, this should be used to assign a LHS tensor to the result of a RHS tensor expression that contains it.  <a href="group__TensorExpressionsGroup.html#ga387632ac6d9e87f550a1cc678d1f6f76">More...</a><br /></td></tr>
<tr class="separator:ga387632ac6d9e87f550a1cc678d1f6f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga762efb87d8c1cc6996202f848588994f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga762efb87d8c1cc6996202f848588994f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga762efb87d8c1cc6996202f848588994f">operator-</a> (const TensorExpression&lt; T, typename T::type, typename T::symmetry, typename T::index_list, typename T::args_list &gt; &amp;t)</td></tr>
<tr class="memdesc:ga762efb87d8c1cc6996202f848588994f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the negation of a tensor expression.  <a href="group__TensorExpressionsGroup.html#ga762efb87d8c1cc6996202f848588994f">More...</a><br /></td></tr>
<tr class="separator:ga762efb87d8c1cc6996202f848588994f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga078bcec08b0bef602762b194bf6ecb95"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename ArgsList1 , typename ArgsList2 &gt; </td></tr>
<tr class="memitem:ga078bcec08b0bef602762b194bf6ecb95"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga078bcec08b0bef602762b194bf6ecb95">operator*</a> (const TensorExpression&lt; T1, typename T1::type, typename T1::symmetry, typename T1::index_list, ArgsList1 &gt; &amp;t1, const TensorExpression&lt; T2, typename T2::type, typename T2::symmetry, typename T2::index_list, ArgsList2 &gt; &amp;t2)</td></tr>
<tr class="memdesc:ga078bcec08b0bef602762b194bf6ecb95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the product of two tensor expressions.  <a href="group__TensorExpressionsGroup.html#ga078bcec08b0bef602762b194bf6ecb95">More...</a><br /></td></tr>
<tr class="separator:ga078bcec08b0bef602762b194bf6ecb95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68e742f6a0919a54715253d91318d7bb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X , typename Symm , typename IndexList , typename... Args&gt; </td></tr>
<tr class="memitem:ga68e742f6a0919a54715253d91318d7bb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga68e742f6a0919a54715253d91318d7bb">sqrt</a> (const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;t)</td></tr>
<tr class="memdesc:ga68e742f6a0919a54715253d91318d7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the square root of a tensor expression that evaluates to a rank 0 tensor.  <a href="group__TensorExpressionsGroup.html#ga68e742f6a0919a54715253d91318d7bb">More...</a><br /></td></tr>
<tr class="separator:ga68e742f6a0919a54715253d91318d7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga454bb255a6968292c0b394778409f3e9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X , typename Symm , typename IndexList , typename... Args, typename N , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; std::is_arithmetic_v&lt; N &gt; &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ga454bb255a6968292c0b394778409f3e9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga454bb255a6968292c0b394778409f3e9">operator+</a> (const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;t, const N number)</td></tr>
<tr class="memdesc:ga454bb255a6968292c0b394778409f3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the sum of a tensor expression and a number.  <a href="group__TensorExpressionsGroup.html#ga454bb255a6968292c0b394778409f3e9">More...</a><br /></td></tr>
<tr class="separator:ga454bb255a6968292c0b394778409f3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfcd057074f74740127f06eb724ece17"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X , typename Symm , typename IndexList , typename... Args, typename N , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; std::is_arithmetic_v&lt; N &gt; &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:gabfcd057074f74740127f06eb724ece17"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#gabfcd057074f74740127f06eb724ece17">operator+</a> (const N number, const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;t)</td></tr>
<tr class="memdesc:gabfcd057074f74740127f06eb724ece17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the sum of a tensor expression and a number.  <a href="group__TensorExpressionsGroup.html#gabfcd057074f74740127f06eb724ece17">More...</a><br /></td></tr>
<tr class="separator:gabfcd057074f74740127f06eb724ece17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a4c6bafd4c54c510191773c8173cc80"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X , typename Symm , typename IndexList , typename... Args, typename N &gt; </td></tr>
<tr class="memitem:ga7a4c6bafd4c54c510191773c8173cc80"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga7a4c6bafd4c54c510191773c8173cc80">operator+</a> (const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;t, const <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>&lt; N &gt; &amp;number)</td></tr>
<tr class="memdesc:ga7a4c6bafd4c54c510191773c8173cc80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the sum of a tensor expression and a number.  <a href="group__TensorExpressionsGroup.html#ga7a4c6bafd4c54c510191773c8173cc80">More...</a><br /></td></tr>
<tr class="separator:ga7a4c6bafd4c54c510191773c8173cc80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a32622ee4acc5d13d33864e8a55c016"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X , typename Symm , typename IndexList , typename... Args, typename N &gt; </td></tr>
<tr class="memitem:ga0a32622ee4acc5d13d33864e8a55c016"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga0a32622ee4acc5d13d33864e8a55c016">operator+</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>&lt; N &gt; &amp;number, const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;t)</td></tr>
<tr class="memdesc:ga0a32622ee4acc5d13d33864e8a55c016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the sum of a tensor expression and a number.  <a href="group__TensorExpressionsGroup.html#ga0a32622ee4acc5d13d33864e8a55c016">More...</a><br /></td></tr>
<tr class="separator:ga0a32622ee4acc5d13d33864e8a55c016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f9b9c76d017ced5fcb6e4f315c12fed"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X , typename Symm , typename IndexList , typename... Args, typename N , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; std::is_arithmetic_v&lt; N &gt; &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ga8f9b9c76d017ced5fcb6e4f315c12fed"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga8f9b9c76d017ced5fcb6e4f315c12fed">operator-</a> (const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;t, const N number)</td></tr>
<tr class="memdesc:ga8f9b9c76d017ced5fcb6e4f315c12fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the difference of a tensor expression and a number.  <a href="group__TensorExpressionsGroup.html#ga8f9b9c76d017ced5fcb6e4f315c12fed">More...</a><br /></td></tr>
<tr class="separator:ga8f9b9c76d017ced5fcb6e4f315c12fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba8a1d9b27a76b6e308c284b3280d963"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X , typename Symm , typename IndexList , typename... Args, typename N , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; std::is_arithmetic_v&lt; N &gt; &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:gaba8a1d9b27a76b6e308c284b3280d963"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#gaba8a1d9b27a76b6e308c284b3280d963">operator-</a> (const N number, const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;t)</td></tr>
<tr class="memdesc:gaba8a1d9b27a76b6e308c284b3280d963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the difference of a tensor expression and a number.  <a href="group__TensorExpressionsGroup.html#gaba8a1d9b27a76b6e308c284b3280d963">More...</a><br /></td></tr>
<tr class="separator:gaba8a1d9b27a76b6e308c284b3280d963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac29cc2e9d1ef52ae2bae37646a06df6a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X , typename Symm , typename IndexList , typename... Args, typename N &gt; </td></tr>
<tr class="memitem:gac29cc2e9d1ef52ae2bae37646a06df6a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#gac29cc2e9d1ef52ae2bae37646a06df6a">operator-</a> (const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;t, const <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>&lt; N &gt; &amp;number)</td></tr>
<tr class="memdesc:gac29cc2e9d1ef52ae2bae37646a06df6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the difference of a tensor expression and a number.  <a href="group__TensorExpressionsGroup.html#gac29cc2e9d1ef52ae2bae37646a06df6a">More...</a><br /></td></tr>
<tr class="separator:gac29cc2e9d1ef52ae2bae37646a06df6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga446f847b29fbd999f104f5361d5aded1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X , typename Symm , typename IndexList , typename... Args, typename N &gt; </td></tr>
<tr class="memitem:ga446f847b29fbd999f104f5361d5aded1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga446f847b29fbd999f104f5361d5aded1">operator-</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>&lt; N &gt; &amp;number, const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;t)</td></tr>
<tr class="memdesc:ga446f847b29fbd999f104f5361d5aded1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the difference of a tensor expression and a number.  <a href="group__TensorExpressionsGroup.html#ga446f847b29fbd999f104f5361d5aded1">More...</a><br /></td></tr>
<tr class="separator:ga446f847b29fbd999f104f5361d5aded1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e7b522ce858111ef9e3aeae080d53f6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename N , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; std::is_arithmetic_v&lt; N &gt; &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ga5e7b522ce858111ef9e3aeae080d53f6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga5e7b522ce858111ef9e3aeae080d53f6">operator/</a> (const TensorExpression&lt; T, typename T::type, typename T::symmetry, typename T::index_list, typename T::args_list &gt; &amp;t, const N number)</td></tr>
<tr class="memdesc:ga5e7b522ce858111ef9e3aeae080d53f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the quotient of a tensor expression over a number.  <a href="group__TensorExpressionsGroup.html#ga5e7b522ce858111ef9e3aeae080d53f6">More...</a><br /></td></tr>
<tr class="separator:ga5e7b522ce858111ef9e3aeae080d53f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab948105dac50b93438dfca2ca9d95fcb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename N &gt; </td></tr>
<tr class="memitem:gab948105dac50b93438dfca2ca9d95fcb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#gab948105dac50b93438dfca2ca9d95fcb">operator/</a> (const TensorExpression&lt; T, typename T::type, typename T::symmetry, typename T::index_list, typename T::args_list &gt; &amp;t, const <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>&lt; N &gt; &amp;number)</td></tr>
<tr class="memdesc:gab948105dac50b93438dfca2ca9d95fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the quotient of a tensor expression over a number.  <a href="group__TensorExpressionsGroup.html#gab948105dac50b93438dfca2ca9d95fcb">More...</a><br /></td></tr>
<tr class="separator:gab948105dac50b93438dfca2ca9d95fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8620e82d8e3f6c6902eec32396713a2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename N , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; std::is_arithmetic_v&lt; N &gt; &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:gaa8620e82d8e3f6c6902eec32396713a2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#gaa8620e82d8e3f6c6902eec32396713a2">operator/</a> (const N number, const TensorExpression&lt; T, typename T::type, typename T::symmetry, typename T::index_list, typename T::args_list &gt; &amp;t)</td></tr>
<tr class="memdesc:gaa8620e82d8e3f6c6902eec32396713a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the quotient of a number over a tensor expression that evaluates to a rank 0 tensor.  <a href="group__TensorExpressionsGroup.html#gaa8620e82d8e3f6c6902eec32396713a2">More...</a><br /></td></tr>
<tr class="separator:gaa8620e82d8e3f6c6902eec32396713a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2a123499949a57909466e2c864dee0f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename N &gt; </td></tr>
<tr class="memitem:gac2a123499949a57909466e2c864dee0f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#gac2a123499949a57909466e2c864dee0f">operator/</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>&lt; N &gt; &amp;number, const TensorExpression&lt; T, typename T::type, typename T::symmetry, typename T::index_list, typename T::args_list &gt; &amp;t)</td></tr>
<tr class="memdesc:gac2a123499949a57909466e2c864dee0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the quotient of a number over a tensor expression that evaluates to a rank 0 tensor.  <a href="group__TensorExpressionsGroup.html#gac2a123499949a57909466e2c864dee0f">More...</a><br /></td></tr>
<tr class="separator:gac2a123499949a57909466e2c864dee0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20d699d825bbd858f0a430caa182135c"><td class="memTemplParams" colspan="2">template&lt;auto &amp;... LhsTensorIndices, typename X , typename LhsSymmetry , typename LhsIndexList , typename N , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; std::is_arithmetic_v&lt; N &gt; &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ga20d699d825bbd858f0a430caa182135c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga20d699d825bbd858f0a430caa182135c">tenex::evaluate</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Tensor&lt; X, LhsSymmetry, LhsIndexList &gt; * &gt; lhs_tensor, const N rhs_value)</td></tr>
<tr class="memdesc:ga20d699d825bbd858f0a430caa182135c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a number to components of a tensor with the LHS index order set in the template parameters.  <a href="group__TensorExpressionsGroup.html#ga20d699d825bbd858f0a430caa182135c">More...</a><br /></td></tr>
<tr class="separator:ga20d699d825bbd858f0a430caa182135c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21d2d7840cb690cc0990fc2ab7d1b358"><td class="memTemplParams" colspan="2">template&lt;auto &amp;... LhsTensorIndices, typename X , typename LhsSymmetry , typename LhsIndexList , typename N &gt; </td></tr>
<tr class="memitem:ga21d2d7840cb690cc0990fc2ab7d1b358"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga21d2d7840cb690cc0990fc2ab7d1b358">tenex::evaluate</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Tensor&lt; X, LhsSymmetry, LhsIndexList &gt; * &gt; lhs_tensor, const <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>&lt; N &gt; &amp;rhs_value)</td></tr>
<tr class="memdesc:ga21d2d7840cb690cc0990fc2ab7d1b358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a number to components of a tensor with the LHS index order set in the template parameters.  <a href="group__TensorExpressionsGroup.html#ga21d2d7840cb690cc0990fc2ab7d1b358">More...</a><br /></td></tr>
<tr class="separator:ga21d2d7840cb690cc0990fc2ab7d1b358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga680e448e4fd89a80f3a5d4be7e991140"><td class="memTemplParams" colspan="2">template&lt;typename T , typename N , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; std::is_arithmetic_v&lt; N &gt; &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ga680e448e4fd89a80f3a5d4be7e991140"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga680e448e4fd89a80f3a5d4be7e991140">operator*</a> (const TensorExpression&lt; T, typename T::type, typename T::symmetry, typename T::index_list, typename T::args_list &gt; &amp;t, const N number)</td></tr>
<tr class="memdesc:ga680e448e4fd89a80f3a5d4be7e991140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the product of a tensor expression and a number.  <a href="group__TensorExpressionsGroup.html#ga680e448e4fd89a80f3a5d4be7e991140">More...</a><br /></td></tr>
<tr class="separator:ga680e448e4fd89a80f3a5d4be7e991140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc110c460b3a2af84134116b0d90dfa3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename N , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; std::is_arithmetic_v&lt; N &gt; &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:gafc110c460b3a2af84134116b0d90dfa3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#gafc110c460b3a2af84134116b0d90dfa3">operator*</a> (const N number, const TensorExpression&lt; T, typename T::type, typename T::symmetry, typename T::index_list, typename T::args_list &gt; &amp;t)</td></tr>
<tr class="memdesc:gafc110c460b3a2af84134116b0d90dfa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the product of a tensor expression and a number.  <a href="group__TensorExpressionsGroup.html#gafc110c460b3a2af84134116b0d90dfa3">More...</a><br /></td></tr>
<tr class="separator:gafc110c460b3a2af84134116b0d90dfa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17762169a8fc079861193080908481e9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename N &gt; </td></tr>
<tr class="memitem:ga17762169a8fc079861193080908481e9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga17762169a8fc079861193080908481e9">operator*</a> (const TensorExpression&lt; T, typename T::type, typename T::symmetry, typename T::index_list, typename T::args_list &gt; &amp;t, const <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>&lt; N &gt; &amp;number)</td></tr>
<tr class="memdesc:ga17762169a8fc079861193080908481e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the product of a tensor expression and a number.  <a href="group__TensorExpressionsGroup.html#ga17762169a8fc079861193080908481e9">More...</a><br /></td></tr>
<tr class="separator:ga17762169a8fc079861193080908481e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad305da1d26bda872ffff2095bebda4d1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename N &gt; </td></tr>
<tr class="memitem:gad305da1d26bda872ffff2095bebda4d1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#gad305da1d26bda872ffff2095bebda4d1">operator*</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>&lt; N &gt; &amp;number, const TensorExpression&lt; T, typename T::type, typename T::symmetry, typename T::index_list, typename T::args_list &gt; &amp;t)</td></tr>
<tr class="memdesc:gad305da1d26bda872ffff2095bebda4d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the product of a tensor expression and a number.  <a href="group__TensorExpressionsGroup.html#gad305da1d26bda872ffff2095bebda4d1">More...</a><br /></td></tr>
<tr class="separator:gad305da1d26bda872ffff2095bebda4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Tensor Expressions allow writing expressions of tensors in a way similar to what is used with pen and paper.</p>
<p >Tensor expressions are implemented using (smart) expression templates. This allows a domain specific language making expressions such as </p><div class="fragment"><div class="line"><span class="keyword">auto</span> T = evaluate&lt;Indices::_a_t, Indices::_b_t&gt;(F(Indices::_b,</div>
<div class="line">Indices::_a));</div>
</div><!-- fragment --><p> possible. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga5c96f0cff493a34d1d2b674c105ae647" name="ga5c96f0cff493a34d1d2b674c105ae647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c96f0cff493a34d1d2b674c105ae647">&#9670;&nbsp;</a></span>generic_indices_at_same_positions</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorIndexList1 , typename TensorIndexList2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__TensorExpressionsGroup.html#ga5c96f0cff493a34d1d2b674c105ae647">tenex::generic_indices_at_same_positions</a> = typedef typename detail::generic_indices_at_same_positions_impl&lt; TensorIndexList1, TensorIndexList2, tmpl::size&lt;TensorIndexList1&gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a> == tmpl::size&lt;TensorIndexList2&gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a>&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether or not two lists of TensorIndexs contain the same generic indices at the same positions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TensorIndexList1</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> list </td></tr>
    <tr><td class="paramname">TensorIndexList2</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8d354e2f865124997fa69e3d617dd5e0" name="ga8d354e2f865124997fa69e3d617dd5e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d354e2f865124997fa69e3d617dd5e0">&#9670;&nbsp;</a></span>make_tensorindex_list</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto &amp;... TensorIndices&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__TensorExpressionsGroup.html#ga8d354e2f865124997fa69e3d617dd5e0">make_tensorindex_list</a> =  typename tenex::detail::make_tensorindex_list_impl&lt;TensorIndices...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> type list from a list of <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TensorIndices</td><td>list of generic index objects, e.g. <code>ti::a, ti::b</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga44bc58678768c8978ac7f6d47b2f7d17" name="ga44bc58678768c8978ac7f6d47b2f7d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44bc58678768c8978ac7f6d47b2f7d17">&#9670;&nbsp;</a></span>evaluate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto &amp;... LhsTensorIndices, typename LhsDataType , typename LhsSymmetry , typename LhsIndexList , typename Derived , typename RhsDataType , typename RhsSymmetry , typename RhsIndexList , typename... RhsTensorIndices&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tenex::evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Tensor&lt; LhsDataType, LhsSymmetry, LhsIndexList &gt; * &gt;&#160;</td>
          <td class="paramname"><em>lhs_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorExpression&lt; Derived, RhsDataType, RhsSymmetry, RhsIndexList, tmpl::list&lt; RhsTensorIndices... &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_tensorexpression</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the result of a RHS tensor expression to a tensor with the LHS index order set in the template parameters. </p>
<h3>Details</h3>
<p >Uses the right hand side (RHS) TensorExpression's index ordering (<code>RhsTE::args_list</code>) and the desired left hand side (LHS) tensor's index ordering (<code>LhsTensorIndices</code>) to fill the provided LHS Tensor with that LHS index ordering. This can carry out the evaluation of a RHS tensor expression to a LHS tensor with the same index ordering, such as \(L_{ab} = R_{ab}\), or different ordering, such as \(L_{ba} = R_{ab}\).</p>
<p >The symmetry of the provided LHS Tensor need not match the symmetry determined from evaluating the RHS TensorExpression according to its order of operations. This allows one to specify LHS symmetries (via <code>lhs_tensor</code>) that may not be preserved by the RHS expression's order of operations, which depends on how the expression is written and implemented.</p>
<p >The LHS <code>Tensor</code> cannot be part of the RHS expression, e.g. <code>evaluate(make_not_null(&amp;L), L() + R());</code>, because the LHS <code>Tensor</code> will generally not be computed correctly when the RHS <code>TensorExpression</code> is split up and the LHS tensor components are computed by accumulating the result of subtrees (see the section on splitting in the documentation for the <code>TensorExpression</code> class). If you need to use the LHS <code>Tensor</code> on the RHS, use <code><a class="el" href="group__TensorExpressionsGroup.html#ga387632ac6d9e87f550a1cc678d1f6f76" title="If the LHS tensor is used in the RHS expression, this should be used to assign a LHS tensor to the re...">tenex::update</a></code> instead.</p>
<h3><a class="anchor" id="autotoc_md211"></a>
Example usage</h3>
<p >Given <code>Tensor</code>s <code>R</code>, <code>S</code>, <code>T</code>, <code>G</code>, and <code>H</code>, we can compute the LHS tensor \(L\) in the equation \(L_{a} = R_{ab} S^{b} + G_{a} - H_{ba}{}^{b} T\) by doing:</p>
<div class="fragment"><div class="line">  result_tensor_type actual_result_tensor_filled{};</div>
<div class="line">  tenex::evaluate&lt;ti::a&gt;(</div>
<div class="line">      make_not_null(&amp;actual_result_tensor_filled),</div>
<div class="line">      R(ti::a, ti::b) * S(ti::B) + G(ti::a) - H(ti::b, ti::a, ti::B) * T());</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><code>LhsTensorIndices</code> must be passed by reference because non-type template parameters cannot be class types until C++20.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LhsTensorIndices</td><td>the <code><a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a></code>s of the <code>Tensor</code> on the LHS of the tensor expression, e.g. <code>ti::a</code>, <code>ti::b</code>, <code>ti::c</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs_tensor</td><td>pointer to the resultant LHS <code>Tensor</code> to fill </td></tr>
    <tr><td class="paramname">rhs_tensorexpression</td><td>the RHS TensorExpression to be evaluated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga20d699d825bbd858f0a430caa182135c" name="ga20d699d825bbd858f0a430caa182135c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20d699d825bbd858f0a430caa182135c">&#9670;&nbsp;</a></span>evaluate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto &amp;... LhsTensorIndices, typename X , typename LhsSymmetry , typename LhsIndexList , typename N , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; std::is_arithmetic_v&lt; N &gt; &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tenex::evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Tensor&lt; X, LhsSymmetry, LhsIndexList &gt; * &gt;&#160;</td>
          <td class="paramname"><em>lhs_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const N&#160;</td>
          <td class="paramname"><em>rhs_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a number to components of a tensor with the LHS index order set in the template parameters. </p>
<h3>Details</h3>
<p >Example usage: </p><div class="fragment"><div class="line">  tnsr::iab&lt;DataType, 3, Frame::Inertial&gt; L_tensor(used_for_size);</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classgsl_1_1not__null.html">gsl::not_null&lt;tnsr::iab&lt;DataType, 3, Frame::Inertial&gt;</a>*&gt; L =</div>
<div class="line">      make_not_null(&amp;L_tensor);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// \f$L_{itt} = 8.2\f$</span></div>
<div class="line">  tenex::evaluate&lt;ti::i, ti::t, ti::t&gt;(L, 8.2);</div>
<div class="line">  <span class="comment">// \f$L_{itj} = 2.2\f$</span></div>
<div class="line">  tenex::evaluate&lt;ti::i, ti::t, ti::j&gt;(L, 2.2);</div>
<div class="line">  <span class="comment">// \f$L_{ijt} = -1.9\f$</span></div>
<div class="line">  tenex::evaluate&lt;ti::i, ti::j, ti::t&gt;(L, -1.9);</div>
<div class="line">  <span class="comment">// \f$L_{ijk} = -0.5\f$</span></div>
<div class="line">  tenex::evaluate&lt;ti::i, ti::j, ti::k&gt;(L, -0.5);</div>
<div class="ttc" id="aclassgsl_1_1not__null_html"><div class="ttname"><a href="classgsl_1_1not__null.html">gsl::not_null</a></div><div class="ttdoc">Require a pointer to not be a nullptr</div><div class="ttdef"><b>Definition:</b> Gsl.hpp:183</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The components of the LHS <code>Tensor</code> passed in must already be sized because there is no way to infer component size from the RHS</dd>
<dd>
<code>LhsTensorIndices</code> must be passed by reference because non-type template parameters cannot be class types until C++20.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LhsTensorIndices</td><td>the <code><a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a></code>s of the <code>Tensor</code> on the LHS of the tensor expression, e.g. <code>ti::a</code>, <code>ti::b</code>, <code>ti::c</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs_tensor</td><td>pointer to the resultant LHS <code>Tensor</code> to fill </td></tr>
    <tr><td class="paramname">rhs_value</td><td>the RHS value to assign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga21d2d7840cb690cc0990fc2ab7d1b358" name="ga21d2d7840cb690cc0990fc2ab7d1b358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21d2d7840cb690cc0990fc2ab7d1b358">&#9670;&nbsp;</a></span>evaluate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto &amp;... LhsTensorIndices, typename X , typename LhsSymmetry , typename LhsIndexList , typename N &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tenex::evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Tensor&lt; X, LhsSymmetry, LhsIndexList &gt; * &gt;&#160;</td>
          <td class="paramname"><em>lhs_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a number to components of a tensor with the LHS index order set in the template parameters. </p>
<h3>Details</h3>
<p >Example usage: </p><div class="fragment"><div class="line">  tnsr::iab&lt;DataType, 3, Frame::Inertial&gt; L_tensor(used_for_size);</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classgsl_1_1not__null.html">gsl::not_null&lt;tnsr::iab&lt;DataType, 3, Frame::Inertial&gt;</a>*&gt; L =</div>
<div class="line">      make_not_null(&amp;L_tensor);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// \f$L_{itt} = 8.2\f$</span></div>
<div class="line">  tenex::evaluate&lt;ti::i, ti::t, ti::t&gt;(L, 8.2);</div>
<div class="line">  <span class="comment">// \f$L_{itj} = 2.2\f$</span></div>
<div class="line">  tenex::evaluate&lt;ti::i, ti::t, ti::j&gt;(L, 2.2);</div>
<div class="line">  <span class="comment">// \f$L_{ijt} = -1.9\f$</span></div>
<div class="line">  tenex::evaluate&lt;ti::i, ti::j, ti::t&gt;(L, -1.9);</div>
<div class="line">  <span class="comment">// \f$L_{ijk} = -0.5\f$</span></div>
<div class="line">  tenex::evaluate&lt;ti::i, ti::j, ti::k&gt;(L, -0.5);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The components of the LHS <code>Tensor</code> passed in must already be sized because there is no way to infer component size from the RHS</dd>
<dd>
<code>LhsTensorIndices</code> must be passed by reference because non-type template parameters cannot be class types until C++20.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LhsTensorIndices</td><td>the <code><a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a></code>s of the <code>Tensor</code> on the LHS of the tensor expression, e.g. <code>ti::a</code>, <code>ti::b</code>, <code>ti::c</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs_tensor</td><td>pointer to the resultant LHS <code>Tensor</code> to fill </td></tr>
    <tr><td class="paramname">rhs_value</td><td>the RHS value to assign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9fd622eef95abd72b7a0691360bd5344" name="ga9fd622eef95abd72b7a0691360bd5344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fd622eef95abd72b7a0691360bd5344">&#9670;&nbsp;</a></span>evaluate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto &amp;... LhsTensorIndices, typename RhsTE , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; std::is_base_of_v&lt; <a class="el" href="structExpression.html">Expression</a>, RhsTE &gt; &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tenex::evaluate </td>
          <td>(</td>
          <td class="paramtype">const RhsTE &amp;&#160;</td>
          <td class="paramname"><em>rhs_tensorexpression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the result of a RHS tensor expression to a tensor with the LHS index order set in the template parameters. </p>
<h3>Details</h3>
<p >Uses the right hand side (RHS) TensorExpression's index ordering (<code>RhsTE::args_list</code>) and the desired left hand side (LHS) tensor's index ordering (<code>LhsTensorIndices</code>) to construct a LHS Tensor with that LHS index ordering. This can carry out the evaluation of a RHS tensor expression to a LHS tensor with the same index ordering, such as \(L_{ab} = R_{ab}\), or different ordering, such as \(L_{ba} = R_{ab}\).</p>
<p >The symmetry of the returned LHS Tensor depends on the order of operations in the RHS TensorExpression, i.e. how the expression is written. If you would like to specify the symmetry of the LHS Tensor instead of it being determined by the order of operations in the RHS expression, please use the other <code><a class="el" href="group__TensorExpressionsGroup.html#ga44bc58678768c8978ac7f6d47b2f7d17" title="Assign the result of a RHS tensor expression to a tensor with the LHS index order set in the template...">tenex::evaluate</a></code> overload that takes an empty LHS Tensor as its first argument.</p>
<h3><a class="anchor" id="autotoc_md212"></a>
Example usage</h3>
<p >Given <code>Tensor</code>s <code>R</code>, <code>S</code>, <code>T</code>, <code>G</code>, and <code>H</code>, we can compute the LHS tensor \(L\) in the equation \(L_{a} = R_{ab} S^{b} + G_{a} - H_{ba}{}^{b} T\) by doing:</p>
<div class="fragment"><div class="line">  result_tensor_type actual_result_tensor_returned = tenex::evaluate&lt;ti::a&gt;(</div>
<div class="line">      R(ti::a, ti::b) * S(ti::B) + G(ti::a) - H(ti::b, ti::a, ti::B) * T());</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>If a generic spatial index is used for a spacetime index in the RHS tensor, its corresponding index in the LHS tensor type will be a spatial index with the same valence, frame, and number of spatial dimensions. If a concrete time index is used for a spacetime index in the RHS tensor, the index will not appear in the LHS tensor (i.e. there will NOT be a corresponding LHS index where only the time index of that index has been computed and its spatial indices are empty). </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>LhsTensorIndices</code> must be passed by reference because non-type template parameters cannot be class types until C++20. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LhsTensorIndices</td><td>the TensorIndexs of the Tensor on the LHS of the tensor expression, e.g. <code>ti::a</code>, <code>ti::b</code>, <code>ti::c</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs_tensorexpression</td><td>the RHS TensorExpression to be evaluated </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the resultant LHS Tensor with index order specified by LhsTensorIndices </p>

</div>
</div>
<a id="gafc110c460b3a2af84134116b0d90dfa3" name="gafc110c460b3a2af84134116b0d90dfa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc110c460b3a2af84134116b0d90dfa3">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; std::is_arithmetic_v&lt; N &gt; &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator* </td>
          <td>(</td>
          <td class="paramtype">const N&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorExpression&lt; T, typename T::type, typename T::symmetry, typename T::index_list, typename T::args_list &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the product of a tensor expression and a number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tensor expression operand of the product </td></tr>
    <tr><td class="paramname">number</td><td>the numeric operand of the product </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the tensor expression representing the product of the tensor expression and the number </p>

</div>
</div>
<a id="gad305da1d26bda872ffff2095bebda4d1" name="gad305da1d26bda872ffff2095bebda4d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad305da1d26bda872ffff2095bebda4d1">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorExpression&lt; T, typename T::type, typename T::symmetry, typename T::index_list, typename T::args_list &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the product of a tensor expression and a number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tensor expression operand of the product </td></tr>
    <tr><td class="paramname">number</td><td>the numeric operand of the product </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the tensor expression representing the product of the tensor expression and the number </p>

</div>
</div>
<a id="ga680e448e4fd89a80f3a5d4be7e991140" name="ga680e448e4fd89a80f3a5d4be7e991140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga680e448e4fd89a80f3a5d4be7e991140">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; std::is_arithmetic_v&lt; N &gt; &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator* </td>
          <td>(</td>
          <td class="paramtype">const TensorExpression&lt; T, typename T::type, typename T::symmetry, typename T::index_list, typename T::args_list &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const N&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the product of a tensor expression and a number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tensor expression operand of the product </td></tr>
    <tr><td class="paramname">number</td><td>the numeric operand of the product </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the tensor expression representing the product of the tensor expression and the number </p>

</div>
</div>
<a id="ga17762169a8fc079861193080908481e9" name="ga17762169a8fc079861193080908481e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17762169a8fc079861193080908481e9">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator* </td>
          <td>(</td>
          <td class="paramtype">const TensorExpression&lt; T, typename T::type, typename T::symmetry, typename T::index_list, typename T::args_list &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the product of a tensor expression and a number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tensor expression operand of the product </td></tr>
    <tr><td class="paramname">number</td><td>the numeric operand of the product </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the tensor expression representing the product of the tensor expression and the number </p>

</div>
</div>
<a id="ga078bcec08b0bef602762b194bf6ecb95" name="ga078bcec08b0bef602762b194bf6ecb95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga078bcec08b0bef602762b194bf6ecb95">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename ArgsList1 , typename ArgsList2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator* </td>
          <td>(</td>
          <td class="paramtype">const TensorExpression&lt; T1, typename T1::type, typename T1::symmetry, typename T1::index_list, ArgsList1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorExpression&lt; T2, typename T2::type, typename T2::symmetry, typename T2::index_list, ArgsList2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the product of two tensor expressions. </p>
<h3>Details</h3>
<p >If the two operands have N pairs of indices that need to be contracted, the returned expression will be an <code>OuterProduct</code> expression nested inside N <code>TensorContract</code> expressions. This represents computing the inner product of the outer product of the two operands. If the operands do not have any indices to be contracted, the returned expression will be an <code>OuterProduct</code>.</p>
<p >The two arguments are expressions that contain the two operands of the product, where the types of the operands are <code>T1</code> and <code>T2</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>the derived TensorExpression type of the first operand of the product </td></tr>
    <tr><td class="paramname">T2</td><td>the derived TensorExpression type of the second operand of the product </td></tr>
    <tr><td class="paramname">ArgsList1</td><td>the TensorIndexs of the first operand </td></tr>
    <tr><td class="paramname">ArgsList2</td><td>the TensorIndexs of the second operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>first operand expression of the product </td></tr>
    <tr><td class="paramname">t2</td><td>the second operand expression of the product </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the tensor expression representing the product of two tensor expressions </p>

</div>
</div>
<a id="gabfcd057074f74740127f06eb724ece17" name="gabfcd057074f74740127f06eb724ece17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfcd057074f74740127f06eb724ece17">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename... Args, typename N , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; std::is_arithmetic_v&lt; N &gt; &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator+ </td>
          <td>(</td>
          <td class="paramtype">const N&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the sum of a tensor expression and a number. </p>
<h3>Details</h3>
<p >The tensor expression operand must represent an expression that, when evaluated, would be a rank 0 tensor. For example, if <code>R</code> and <code>S</code> are Tensors, here is a non-exhaustive list of some of the acceptable forms that the tensor expression operand could take:</p><ul>
<li><code>R()</code></li>
<li><code>R(ti::A, ti::a)</code></li>
<li><code>(R(ti::A, ti::B) * S(ti::a, ti::b))</code></li>
<li><code>R(ti::t, ti::t)</code></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tensor expression operand of the sum </td></tr>
    <tr><td class="paramname">number</td><td>the numeric operand of the sum </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the tensor expression representing the sum of the tensor expression and the number </p>

</div>
</div>
<a id="ga0a32622ee4acc5d13d33864e8a55c016" name="ga0a32622ee4acc5d13d33864e8a55c016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a32622ee4acc5d13d33864e8a55c016">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename... Args, typename N &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the sum of a tensor expression and a number. </p>
<h3>Details</h3>
<p >The tensor expression operand must represent an expression that, when evaluated, would be a rank 0 tensor. For example, if <code>R</code> and <code>S</code> are Tensors, here is a non-exhaustive list of some of the acceptable forms that the tensor expression operand could take:</p><ul>
<li><code>R()</code></li>
<li><code>R(ti::A, ti::a)</code></li>
<li><code>(R(ti::A, ti::B) * S(ti::a, ti::b))</code></li>
<li><code>R(ti::t, ti::t)</code></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tensor expression operand of the sum </td></tr>
    <tr><td class="paramname">number</td><td>the numeric operand of the sum </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the tensor expression representing the sum of the tensor expression and the number </p>

</div>
</div>
<a id="ga454bb255a6968292c0b394778409f3e9" name="ga454bb255a6968292c0b394778409f3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga454bb255a6968292c0b394778409f3e9">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename... Args, typename N , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; std::is_arithmetic_v&lt; N &gt; &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator+ </td>
          <td>(</td>
          <td class="paramtype">const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const N&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the sum of a tensor expression and a number. </p>
<h3>Details</h3>
<p >The tensor expression operand must represent an expression that, when evaluated, would be a rank 0 tensor. For example, if <code>R</code> and <code>S</code> are Tensors, here is a non-exhaustive list of some of the acceptable forms that the tensor expression operand could take:</p><ul>
<li><code>R()</code></li>
<li><code>R(ti::A, ti::a)</code></li>
<li><code>(R(ti::A, ti::B) * S(ti::a, ti::b))</code></li>
<li><code>R(ti::t, ti::t)</code></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tensor expression operand of the sum </td></tr>
    <tr><td class="paramname">number</td><td>the numeric operand of the sum </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the tensor expression representing the sum of the tensor expression and the number </p>

</div>
</div>
<a id="ga7a4c6bafd4c54c510191773c8173cc80" name="ga7a4c6bafd4c54c510191773c8173cc80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a4c6bafd4c54c510191773c8173cc80">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename... Args, typename N &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator+ </td>
          <td>(</td>
          <td class="paramtype">const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the sum of a tensor expression and a number. </p>
<h3>Details</h3>
<p >The tensor expression operand must represent an expression that, when evaluated, would be a rank 0 tensor. For example, if <code>R</code> and <code>S</code> are Tensors, here is a non-exhaustive list of some of the acceptable forms that the tensor expression operand could take:</p><ul>
<li><code>R()</code></li>
<li><code>R(ti::A, ti::a)</code></li>
<li><code>(R(ti::A, ti::B) * S(ti::a, ti::b))</code></li>
<li><code>R(ti::t, ti::t)</code></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tensor expression operand of the sum </td></tr>
    <tr><td class="paramname">number</td><td>the numeric operand of the sum </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the tensor expression representing the sum of the tensor expression and the number </p>

</div>
</div>
<a id="gaba8a1d9b27a76b6e308c284b3280d963" name="gaba8a1d9b27a76b6e308c284b3280d963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba8a1d9b27a76b6e308c284b3280d963">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename... Args, typename N , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; std::is_arithmetic_v&lt; N &gt; &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator- </td>
          <td>(</td>
          <td class="paramtype">const N&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the difference of a tensor expression and a number. </p>
<h3>Details</h3>
<p >The tensor expression operand must represent an expression that, when evaluated, would be a rank 0 tensor. For example, if <code>R</code> and <code>S</code> are Tensors, here is a non-exhaustive list of some of the acceptable forms that the tensor expression operand could take:</p><ul>
<li><code>R()</code></li>
<li><code>R(ti::A, ti::a)</code></li>
<li><code>(R(ti::A, ti::B) * S(ti::a, ti::b))</code></li>
<li><code>R(ti::t, ti::t)</code></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tensor expression operand of the difference </td></tr>
    <tr><td class="paramname">number</td><td>the numeric operand of the difference </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the tensor expression representing the difference of the tensor expression and the number </p>

</div>
</div>
<a id="ga446f847b29fbd999f104f5361d5aded1" name="ga446f847b29fbd999f104f5361d5aded1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga446f847b29fbd999f104f5361d5aded1">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename... Args, typename N &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the difference of a tensor expression and a number. </p>
<h3>Details</h3>
<p >The tensor expression operand must represent an expression that, when evaluated, would be a rank 0 tensor. For example, if <code>R</code> and <code>S</code> are Tensors, here is a non-exhaustive list of some of the acceptable forms that the tensor expression operand could take:</p><ul>
<li><code>R()</code></li>
<li><code>R(ti::A, ti::a)</code></li>
<li><code>(R(ti::A, ti::B) * S(ti::a, ti::b))</code></li>
<li><code>R(ti::t, ti::t)</code></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tensor expression operand of the difference </td></tr>
    <tr><td class="paramname">number</td><td>the numeric operand of the difference </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the tensor expression representing the difference of the tensor expression and the number </p>

</div>
</div>
<a id="ga762efb87d8c1cc6996202f848588994f" name="ga762efb87d8c1cc6996202f848588994f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga762efb87d8c1cc6996202f848588994f">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator- </td>
          <td>(</td>
          <td class="paramtype">const TensorExpression&lt; T, typename T::type, typename T::symmetry, typename T::index_list, typename T::args_list &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the negation of a tensor expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tensor expression </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the tensor expression representing the negation of <code>t</code> </p>

</div>
</div>
<a id="ga8f9b9c76d017ced5fcb6e4f315c12fed" name="ga8f9b9c76d017ced5fcb6e4f315c12fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f9b9c76d017ced5fcb6e4f315c12fed">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename... Args, typename N , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; std::is_arithmetic_v&lt; N &gt; &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator- </td>
          <td>(</td>
          <td class="paramtype">const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const N&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the difference of a tensor expression and a number. </p>
<h3>Details</h3>
<p >The tensor expression operand must represent an expression that, when evaluated, would be a rank 0 tensor. For example, if <code>R</code> and <code>S</code> are Tensors, here is a non-exhaustive list of some of the acceptable forms that the tensor expression operand could take:</p><ul>
<li><code>R()</code></li>
<li><code>R(ti::A, ti::a)</code></li>
<li><code>(R(ti::A, ti::B) * S(ti::a, ti::b))</code></li>
<li><code>R(ti::t, ti::t)</code></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tensor expression operand of the difference </td></tr>
    <tr><td class="paramname">number</td><td>the numeric operand of the difference </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the tensor expression representing the difference of the tensor expression and the number </p>

</div>
</div>
<a id="gac29cc2e9d1ef52ae2bae37646a06df6a" name="gac29cc2e9d1ef52ae2bae37646a06df6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac29cc2e9d1ef52ae2bae37646a06df6a">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename... Args, typename N &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator- </td>
          <td>(</td>
          <td class="paramtype">const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the difference of a tensor expression and a number. </p>
<h3>Details</h3>
<p >The tensor expression operand must represent an expression that, when evaluated, would be a rank 0 tensor. For example, if <code>R</code> and <code>S</code> are Tensors, here is a non-exhaustive list of some of the acceptable forms that the tensor expression operand could take:</p><ul>
<li><code>R()</code></li>
<li><code>R(ti::A, ti::a)</code></li>
<li><code>(R(ti::A, ti::B) * S(ti::a, ti::b))</code></li>
<li><code>R(ti::t, ti::t)</code></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tensor expression operand of the difference </td></tr>
    <tr><td class="paramname">number</td><td>the numeric operand of the difference </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the tensor expression representing the difference of the tensor expression and the number </p>

</div>
</div>
<a id="gaa8620e82d8e3f6c6902eec32396713a2" name="gaa8620e82d8e3f6c6902eec32396713a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8620e82d8e3f6c6902eec32396713a2">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; std::is_arithmetic_v&lt; N &gt; &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator/ </td>
          <td>(</td>
          <td class="paramtype">const N&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorExpression&lt; T, typename T::type, typename T::symmetry, typename T::index_list, typename T::args_list &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the quotient of a number over a tensor expression that evaluates to a rank 0 tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>the numeric numerator of the quotient </td></tr>
    <tr><td class="paramname">t</td><td>the tensor expression denominator of the quotient </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the tensor expression representing the quotient of the number over the tensor expression </p>

</div>
</div>
<a id="gac2a123499949a57909466e2c864dee0f" name="gac2a123499949a57909466e2c864dee0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2a123499949a57909466e2c864dee0f">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorExpression&lt; T, typename T::type, typename T::symmetry, typename T::index_list, typename T::args_list &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the quotient of a number over a tensor expression that evaluates to a rank 0 tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>the numeric numerator of the quotient </td></tr>
    <tr><td class="paramname">t</td><td>the tensor expression denominator of the quotient </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the tensor expression representing the quotient of the number over the tensor expression </p>

</div>
</div>
<a id="ga5e7b522ce858111ef9e3aeae080d53f6" name="ga5e7b522ce858111ef9e3aeae080d53f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e7b522ce858111ef9e3aeae080d53f6">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; std::is_arithmetic_v&lt; N &gt; &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator/ </td>
          <td>(</td>
          <td class="paramtype">const TensorExpression&lt; T, typename T::type, typename T::symmetry, typename T::index_list, typename T::args_list &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const N&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the quotient of a tensor expression over a number. </p>
<dl class="section note"><dt>Note</dt><dd>The implementation instead uses the operation, <code>t * (1.0 / number)</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tensor expression operand of the quotient </td></tr>
    <tr><td class="paramname">number</td><td>the numeric operand of the quotient </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the tensor expression representing the quotient of the tensor expression over the number </p>

</div>
</div>
<a id="gab948105dac50b93438dfca2ca9d95fcb" name="gab948105dac50b93438dfca2ca9d95fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab948105dac50b93438dfca2ca9d95fcb">&#9670;&nbsp;</a></span>operator/() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator/ </td>
          <td>(</td>
          <td class="paramtype">const TensorExpression&lt; T, typename T::type, typename T::symmetry, typename T::index_list, typename T::args_list &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the quotient of a tensor expression over a number. </p>
<dl class="section note"><dt>Note</dt><dd>The implementation instead uses the operation, <code>t * (1.0 / number)</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tensor expression operand of the quotient </td></tr>
    <tr><td class="paramname">number</td><td>the numeric operand of the quotient </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the tensor expression representing the quotient of the tensor expression over the number </p>

</div>
</div>
<a id="ga762436e7479597dc0ebf379d22a068ef" name="ga762436e7479597dc0ebf379d22a068ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga762436e7479597dc0ebf379d22a068ef">&#9670;&nbsp;</a></span>operator/() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename... Args2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator/ </td>
          <td>(</td>
          <td class="paramtype">const TensorExpression&lt; T1, typename T1::type, typename T1::symmetry, typename T1::index_list, typename T1::args_list &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorExpression&lt; T2, typename T2::type, typename T2::symmetry, typename T2::index_list, tmpl::list&lt; Args2... &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the quotient of one tensor expression over another tensor expression that evaluates to a rank 0 tensor. </p>
<h3>Details</h3>
<p ><code>t2</code> must be an expression that, when evaluated, would be a rank 0 tensor. For example, if <code>R</code> and <code>S</code> are Tensors, here is a non-exhaustive list of some of the acceptable forms that <code>t2</code> could take:</p><ul>
<li><code>R()</code></li>
<li><code>R(ti::A, ti::a)</code></li>
<li><code>(R(ti::A, ti::B) * S(ti::a, ti::b))</code></li>
<li><code>R(ti::t, ti::t) + 1.0</code></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>the tensor expression numerator </td></tr>
    <tr><td class="paramname">t2</td><td>the rank 0 tensor expression denominator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga68e742f6a0919a54715253d91318d7bb" name="ga68e742f6a0919a54715253d91318d7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68e742f6a0919a54715253d91318d7bb">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sqrt </td>
          <td>(</td>
          <td class="paramtype">const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the square root of a tensor expression that evaluates to a rank 0 tensor. </p>
<h3>Details</h3>
<p ><code>t</code> must be an expression that, when evaluated, would be a rank 0 tensor. For example, if <code>R</code> and <code>S</code> are Tensors, here is a non-exhaustive list of some of the acceptable forms that <code>t</code> could take:</p><ul>
<li><code>R()</code></li>
<li><code>R(ti::A, ti::a)</code></li>
<li><code>(R(ti::A, ti::B) * S(ti::a, ti::b))</code></li>
<li><code>R(ti::t, ti::t) + 1.0</code></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tensor expression of which to take the square root </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga387632ac6d9e87f550a1cc678d1f6f76" name="ga387632ac6d9e87f550a1cc678d1f6f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga387632ac6d9e87f550a1cc678d1f6f76">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto &amp;... LhsTensorIndices, typename LhsDataType , typename RhsDataType , typename LhsSymmetry , typename LhsIndexList , typename Derived , typename RhsSymmetry , typename RhsIndexList , typename... RhsTensorIndices&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tenex::update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Tensor&lt; LhsDataType, LhsSymmetry, LhsIndexList &gt; * &gt;&#160;</td>
          <td class="paramname"><em>lhs_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorExpression&lt; Derived, RhsDataType, RhsSymmetry, RhsIndexList, tmpl::list&lt; RhsTensorIndices... &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_tensorexpression</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the LHS tensor is used in the RHS expression, this should be used to assign a LHS tensor to the result of a RHS tensor expression that contains it. </p>
<h3>Details</h3>
<p >See documentation for <code><a class="el" href="group__TensorExpressionsGroup.html#ga44bc58678768c8978ac7f6d47b2f7d17" title="Assign the result of a RHS tensor expression to a tensor with the LHS index order set in the template...">tenex::evaluate</a></code> for basic functionality.</p>
<p ><code><a class="el" href="group__TensorExpressionsGroup.html#ga387632ac6d9e87f550a1cc678d1f6f76" title="If the LHS tensor is used in the RHS expression, this should be used to assign a LHS tensor to the re...">tenex::update</a></code> differs from <code><a class="el" href="group__TensorExpressionsGroup.html#ga44bc58678768c8978ac7f6d47b2f7d17" title="Assign the result of a RHS tensor expression to a tensor with the LHS index order set in the template...">tenex::evaluate</a></code> in that <code><a class="el" href="group__TensorExpressionsGroup.html#ga387632ac6d9e87f550a1cc678d1f6f76" title="If the LHS tensor is used in the RHS expression, this should be used to assign a LHS tensor to the re...">tenex::update</a></code> should be used when some LHS <code>Tensor</code> has been partially computed, and now we would like to update it with a RHS expression that contains it. In other words, this should be used when we would like to emulate assignment operations like <code>LHS +=</code>, <code>LHS -=</code>, <code>LHS *=</code>, etc.</p>
<p >One important difference to note with <code><a class="el" href="group__TensorExpressionsGroup.html#ga387632ac6d9e87f550a1cc678d1f6f76" title="If the LHS tensor is used in the RHS expression, this should be used to assign a LHS tensor to the re...">tenex::update</a></code> is that it cannot split up the RHS expression and evaluate subtrees, while <code><a class="el" href="group__TensorExpressionsGroup.html#ga44bc58678768c8978ac7f6d47b2f7d17" title="Assign the result of a RHS tensor expression to a tensor with the LHS index order set in the template...">tenex::evaluate</a></code> can (see <code>TensorExpression</code> documentation). From benchmarking, it was found that the runtime of <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code> expressions scales poorly as we increase the number of operations. For this reason, when the data type held by the tensors in the expression is <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code>, it's best to avoid passing RHS expressions with a large number of operations (e.g. an inner product that sums over many terms).</p>
<h3><a class="anchor" id="autotoc_md213"></a>
Example usage</h3>
<p >In implementing a large equation with many operations, we can manually break up the equation and evaluate different subexpressions at a time by making one initial call to <code><a class="el" href="group__TensorExpressionsGroup.html#ga44bc58678768c8978ac7f6d47b2f7d17" title="Assign the result of a RHS tensor expression to a tensor with the LHS index order set in the template...">tenex::evaluate</a></code> followed by any number of calls to <code><a class="el" href="group__TensorExpressionsGroup.html#ga387632ac6d9e87f550a1cc678d1f6f76" title="If the LHS tensor is used in the RHS expression, this should be used to assign a LHS tensor to the re...">tenex::update</a></code> that use the LHS tensor in the RHS expression and will compute the rest of the equation:</p>
<div class="fragment"><div class="line">  result_tensor_type actual_result_tensor_filled{};</div>
<div class="line">  tenex::evaluate&lt;ti::a, ti::b&gt;(</div>
<div class="line">      make_not_null(&amp;actual_result_tensor_filled),</div>
<div class="line">      -spacetime_deriv_gauge_function(ti::a, ti::b) -</div>
<div class="line">          spacetime_deriv_gauge_function(ti::b, ti::a) -</div>
<div class="line">          0.5 * pi_two_normals() * <a class="code hl_function" href="group__GeneralRelativityGroup.html#ga30bdff8147f3f06e58ebc0b9b6f08405">pi</a>(ti::a, ti::b) +</div>
<div class="line">          gamma0() *</div>
<div class="line">              (normal_spacetime_one_form(ti::a) * gauge_constraint(ti::b) +</div>
<div class="line">               normal_spacetime_one_form(ti::b) * gauge_constraint(ti::a)) -</div>
<div class="line">          gamma0() * <a class="code hl_function" href="group__GeneralRelativityGroup.html#ga30b4e9ea5a0b87eb9422ad9a975041b9">spacetime_metric</a>(ti::a, ti::b) *</div>
<div class="line">              normal_dot_gauge_constraint() +</div>
<div class="line">          2.0 * <a class="code hl_function" href="group__GeneralRelativityGroup.html#gac0338cd790d56504c9727bcd8b73b7c3">christoffel_second_kind</a>(ti::C, ti::a, ti::b) *</div>
<div class="line">              gauge_function(ti::c) -</div>
<div class="line">          2.0 * <a class="code hl_function" href="group__GeneralRelativityGroup.html#ga30bdff8147f3f06e58ebc0b9b6f08405">pi</a>(ti::a, ti::c) * pi_2_up(ti::b, ti::C));</div>
<div class="line"> </div>
<div class="line">  tenex::update&lt;ti::a, ti::b&gt;(</div>
<div class="line">      make_not_null(&amp;actual_result_tensor_filled),</div>
<div class="line">      actual_result_tensor_filled(ti::a, ti::b) +</div>
<div class="line">          2.0 * phi_1_up(ti::I, ti::a, ti::c) * phi_3_up(ti::i, ti::b, ti::C));</div>
<div class="line"> </div>
<div class="line">  tenex::update&lt;ti::a, ti::b&gt;(</div>
<div class="line">      make_not_null(&amp;actual_result_tensor_filled),</div>
<div class="line">      actual_result_tensor_filled(ti::a, ti::b) -</div>
<div class="line">          2.0 * christoffel_first_kind_3_up(ti::a, ti::d, ti::C) *</div>
<div class="line">              christoffel_first_kind_3_up(ti::b, ti::c, ti::D));</div>
<div class="line"> </div>
<div class="line">  tenex::update&lt;ti::a, ti::b&gt;(</div>
<div class="line">      make_not_null(&amp;actual_result_tensor_filled),</div>
<div class="line">      actual_result_tensor_filled(ti::a, ti::b) -</div>
<div class="line">          pi_one_normal(ti::j) * phi_1_up(ti::J, ti::a, ti::b));</div>
<div class="line"> </div>
<div class="line">  tenex::update&lt;ti::a, ti::b&gt;(make_not_null(&amp;actual_result_tensor_filled),</div>
<div class="line">                              actual_result_tensor_filled(ti::a, ti::b) -</div>
<div class="line">                                  inverse_spatial_metric(ti::J, ti::K) *</div>
<div class="line">                                      d_phi(ti::j, ti::k, ti::a, ti::b));</div>
<div class="line"> </div>
<div class="line">  tenex::update&lt;ti::a, ti::b&gt;(</div>
<div class="line">      make_not_null(&amp;actual_result_tensor_filled),</div>
<div class="line">      actual_result_tensor_filled(ti::a, ti::b) * <a class="code hl_function" href="group__GeneralRelativityGroup.html#gaf6dbe3d6807eb2fd55bf5fefceb79698">lapse</a>() +</div>
<div class="line">          gamma1gamma2() * shift_dot_three_index_constraint(ti::a, ti::b) +</div>
<div class="line">          <a class="code hl_function" href="group__GeneralRelativityGroup.html#ga3fb3aea054f731a598fe07207684e57e">shift</a>(ti::J) * d_pi(ti::j, ti::a, ti::b));</div>
<div class="ttc" id="agroup__GeneralRelativityGroup_html_ga30b4e9ea5a0b87eb9422ad9a975041b9"><div class="ttname"><a href="group__GeneralRelativityGroup.html#ga30b4e9ea5a0b87eb9422ad9a975041b9">gr::spacetime_metric</a></div><div class="ttdeci">void spacetime_metric(gsl::not_null&lt; tnsr::aa&lt; DataType, Dim, Frame &gt; * &gt; spacetime_metric, const Scalar&lt; DataType &gt; &amp;lapse, const tnsr::I&lt; DataType, Dim, Frame &gt; &amp;shift, const tnsr::ii&lt; DataType, Dim, Frame &gt; &amp;spatial_metric)</div><div class="ttdoc">Computes the spacetime metric from the spatial metric, lapse, and shift.</div></div>
<div class="ttc" id="agroup__GeneralRelativityGroup_html_ga30bdff8147f3f06e58ebc0b9b6f08405"><div class="ttname"><a href="group__GeneralRelativityGroup.html#ga30bdff8147f3f06e58ebc0b9b6f08405">gh::pi</a></div><div class="ttdeci">void pi(gsl::not_null&lt; tnsr::aa&lt; DataType, SpatialDim, Frame &gt; * &gt; pi, const Scalar&lt; DataType &gt; &amp;lapse, const Scalar&lt; DataType &gt; &amp;dt_lapse, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;shift, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;dt_shift, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;spatial_metric, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;dt_spatial_metric, const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;phi)</div><div class="ttdoc">Computes the conjugate momentum  of the spacetime metric .</div></div>
<div class="ttc" id="agroup__GeneralRelativityGroup_html_ga3fb3aea054f731a598fe07207684e57e"><div class="ttname"><a href="group__GeneralRelativityGroup.html#ga3fb3aea054f731a598fe07207684e57e">gr::shift</a></div><div class="ttdeci">tnsr::I&lt; DataType, SpatialDim, Frame &gt; shift(const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;spacetime_metric, const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;inverse_spatial_metric)</div><div class="ttdoc">Compute shift from spacetime metric and inverse spatial metric.</div></div>
<div class="ttc" id="agroup__GeneralRelativityGroup_html_gac0338cd790d56504c9727bcd8b73b7c3"><div class="ttname"><a href="group__GeneralRelativityGroup.html#gac0338cd790d56504c9727bcd8b73b7c3">gr::christoffel_second_kind</a></div><div class="ttdeci">void christoffel_second_kind(const gsl::not_null&lt; tnsr::Abb&lt; DataType, SpatialDim, Frame, Index &gt; * &gt; christoffel, const tnsr::abb&lt; DataType, SpatialDim, Frame, Index &gt; &amp;d_metric, const tnsr::AA&lt; DataType, SpatialDim, Frame, Index &gt; &amp;inverse_metric)</div><div class="ttdoc">Computes Christoffel symbol of the second kind from derivative of metric and the inverse metric.</div></div>
<div class="ttc" id="agroup__GeneralRelativityGroup_html_gaf6dbe3d6807eb2fd55bf5fefceb79698"><div class="ttname"><a href="group__GeneralRelativityGroup.html#gaf6dbe3d6807eb2fd55bf5fefceb79698">gr::lapse</a></div><div class="ttdeci">Scalar&lt; DataType &gt; lapse(const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;shift, const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;spacetime_metric)</div><div class="ttdoc">Compute lapse from shift and spacetime metric.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><code>LhsTensorIndices</code> must be passed by reference because non-type template parameters cannot be class types until C++20.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LhsTensorIndices</td><td>the TensorIndexs of the Tensor on the LHS of the tensor expression, e.g. <code>ti_a</code>, <code>ti_b</code>, <code>ti_c</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs_tensor</td><td>pointer to the resultant LHS Tensor to fill </td></tr>
    <tr><td class="paramname">rhs_tensorexpression</td><td>the RHS TensorExpression to be evaluated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
