<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: Metaprogramming with Brigand</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('brigand.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Metaprogramming with Brigand </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Metafunctions">Metafunctions</a><ul><li class="level2"><a href="#lazy">Eager and lazy metafunctions</a></li>
<li class="level2"><a href="#metalambdas">Brigand metalambdas</a></li>
<li class="level2"><a href="#metalambda_structure">Evaluation of metalambdas</a></li>
<li class="level2"><a href="#Examples">Examples</a></li>
</ul>
</li>
<li class="level1"><a href="#metafunction_guidelines">Guidelines for writing metafunctions</a></li>
<li class="level1"><a href="#function_docs">Brigand types and functions</a><ul><li class="level2"><a href="#Containers">Containers</a></li>
<li class="level2"><a href="#Constants">Constants</a></li>
<li class="level2"><a href="#list_constructor">Constructor-like functions for lists</a></li>
<li class="level2"><a href="#list_query">Functions for querying lists</a></li>
<li class="level2"><a href="#list_to_list">Functions producing lists from other lists</a></li>
<li class="level2"><a href="#map_operations">Operations on maps</a></li>
<li class="level2"><a href="#set_operations">Operations on sets</a></li>
<li class="level2"><a href="#math">Mathematical functions</a></li>
<li class="level2"><a href="#misc">Miscellaneous functions</a></li>
<li class="level2"><a href="#runtime">Runtime functionality</a></li>
<li class="level2"><a href="#external">External integration</a></li>
</ul>
</li>
<li class="level1"><a href="#oddities">Bugs/Oddities</a></li>
<li class="level1"><a href="#TODO">TODO</a></li>
</ul>
</div>
<div class="textblock"><p ><a class="anchor" id="md_docs_DevGuide_Brigand"></a></p>
<dl class="section note"><dt>Note</dt><dd>This document covers Brigand as of commit <a href="https://github.com/edouarda/brigand/commit/66b3d9276ed95425ac919ac1841286d088b5f4b1">66b3d9276ed95425ac919ac1841286d088b5f4b1</a> in January 2022.</dd></dl>
<dl class="section user"><dt></dt><dd>In SpECTRE, most complex TMP is done using the <a href="https://github.com/edouarda/brigand">Brigand metaprogramming library</a>. Brigand is a collection of templated classes, type aliases, and functions, primarily intended to help with the manipulation and use of lists of types. This document is organized to roughly parallel the structure of the C++ standard, rather than following Brigand's classifications.</dd></dl>
<dl class="section user"><dt></dt><dd>Brigand provides all of its functionality in the <code>brigand</code> namespace, but in SpECTRE we have aliased this namespace to <code>tmpl</code>, and the latter should be preferred.</dd></dl>
<dl class="section user"><dt></dt><dd>All functionality described here is provided by SpECTRE's Brigand wrapper header: <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Utilities/TMPL.hpp&quot;</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Examples in this document use the following declarations and definitions: <div class="fragment"><div class="line"><span class="keyword">struct </span>Type1;</div>
<div class="line"><span class="keyword">struct </span>Type2;</div>
<div class="line"><span class="keyword">struct </span>Type3;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Sequence containers.  Practical applications will usually use</span></div>
<div class="line"><span class="comment">// tmpl::list in place of these.</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>...&gt;</div>
<div class="line"><span class="keyword">struct </span>List1;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>...&gt;</div>
<div class="line"><span class="keyword">struct </span>List2;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>...&gt;</div>
<div class="line"><span class="keyword">struct </span>List3;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</div>
<div class="line"><span class="keyword">struct </span>Wrapper;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</div>
<div class="line"><span class="keyword">struct </span>lazy_make_list1 {</div>
<div class="line">  <span class="keyword">using</span> type = List1&lt;T...&gt;;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A comparator on the above types defining Type1 &lt; Type2 &lt; Type3</span></div>
<div class="line"><span class="keyword">using</span> CompareType123 = tmpl::and_&lt;tmpl::or_&lt;std::is_same&lt;tmpl::_1, Type1&gt;,</div>
<div class="line">                                            <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same&lt;tmpl::_2, Type3&gt;</a>&gt;,</div>
<div class="line">                                  tmpl::not_&lt;std::is_same&lt;tmpl::_1, tmpl::_2&gt;&gt;&gt;;</div>
<div class="ttc" id="ais_same_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same</a></div></div>
</div><!-- fragment --></dd></dl>
<h1><a class="anchor" id="Metafunctions"></a>
Metafunctions</h1>
<dl class="section user"><dt></dt><dd>A metafunction is an analog of a familiar C++ function that is coded in the C++ type system. It turns out that, using metafunction programming, it is possible to perform arbitrary computations at compile time.</dd></dl>
<dl class="section user"><dt></dt><dd>There are multiple ways to encode a calculation in the type system. When using Brigand, the relevant ones are eager and lazy metafunctions.</dd></dl>
<h2><a class="anchor" id="lazy"></a>
Eager and lazy metafunctions</h2>
<dl class="section user"><dt></dt><dd>Metafunctions commonly appear in two forms: eager and lazy. Lazy metafunctions are templated structs (or templated aliases to structs) with a <code>type</code> member alias that indicates the result: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>lazy_make_list_of_T_and_int {</div>
<div class="line">  <span class="keyword">using</span> type = List1&lt;T, int&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --> The type traits in the standard library, such as <a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same</a>, are lazy metafunctions.</dd></dl>
<dl class="section user"><dt></dt><dd>Eager metafunctions are aliases to their result types. As a trivial case, struct templates can be viewed as eager metafunctions returning themselves. An eager version of the previous example could be implemented as: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">using</span> eager_make_list_of_T_and_int = List1&lt;T, int&gt;;</div>
</div><!-- fragment --> The standard library provides eager versions of some of its metafunctions (generally those that modify a type, rather than predicates) using an <code>_t</code> suffix. When both versions are provided, it is often convenient (and less error prone!) to define the eager version in terms of the lazy version: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">using</span> eager_make_list_of_T_and_int2 =</div>
<div class="line">    <span class="keyword">typename</span> lazy_make_list_of_T_and_int&lt;T&gt;::type;</div>
</div><!-- fragment --> And the two definitions agree: <div class="fragment"><div class="line">assert_same&lt;eager_make_list_of_T_and_int&lt;double&gt;,</div>
<div class="line">            eager_make_list_of_T_and_int2&lt;double&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The standard library also provides versions of many of its type traits with an <code>_v</code> suffix. These evaluate to compile-time <em>values</em>, rather than types. They can be useful for metaprogramming, but are not the types of metafunctions being discussed here.</dd></dl>
<dl class="section user"><dt></dt><dd>Eager metafunctions are usually more convenient to use, so what is the point of additionally creating lazy ones? The answer is that lazy metafunctions can be used as compile-time functors. As a simple example, we can write an (eager) metafunction that calls an arbitrary lazy metafunction twice <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span>... Args&gt;</div>
<div class="line"><span class="keyword">struct </span>apply_lazy_metafunction;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>...&gt; <span class="keyword">typename</span> Func, <span class="keyword">typename</span>... DummyArgs,</div>
<div class="line">          <span class="keyword">typename</span>... Args&gt;</div>
<div class="line"><span class="keyword">struct </span>apply_lazy_metafunction&lt;Func&lt;DummyArgs...&gt;, Args...&gt; {</div>
<div class="line">  <span class="keyword">using</span> type = <span class="keyword">typename</span> Func&lt;Args...&gt;::type;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func&gt;</div>
<div class="line"><span class="keyword">using</span> call_lazy_metafunction_twice =</div>
<div class="line">    List1&lt;typename apply_lazy_metafunction&lt;Func, double&gt;::type,</div>
<div class="line">          <span class="keyword">typename</span> apply_lazy_metafunction&lt;Func, char&gt;::type&gt;;</div>
</div><!-- fragment --> and get the expected output: <div class="fragment"><div class="line"><span class="keyword">struct </span>Dummy;</div>
<div class="line"> </div>
<div class="line">assert_same&lt;call_lazy_metafunction_twice&lt;lazy_make_list_of_T_and_int&lt;Dummy&gt;&gt;,</div>
<div class="line">            List1&lt;List1&lt;double, int&gt;, List1&lt;char, int&gt;&gt;&gt;();</div>
</div><!-- fragment --> But it fails if you try to call an arbitrary <em>eager</em> metafunction twice in the same way, because the function is evaluated too early, resulting in the <code>List1</code> metafunction being acted upon instead of <code>eager_add_list</code>: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span>... Args&gt;</div>
<div class="line"><span class="keyword">struct </span>apply_eager_metafunction;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>...&gt; <span class="keyword">typename</span> Func, <span class="keyword">typename</span>... DummyArgs,</div>
<div class="line">          <span class="keyword">typename</span>... Args&gt;</div>
<div class="line"><span class="keyword">struct </span>apply_eager_metafunction&lt;Func&lt;DummyArgs...&gt;, Args...&gt; {</div>
<div class="line">  <span class="keyword">using</span> type = Func&lt;Args...&gt;;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func&gt;</div>
<div class="line"><span class="keyword">using</span> call_eager_metafunction_twice =</div>
<div class="line">    List1&lt;typename apply_eager_metafunction&lt;Func, double&gt;::type,</div>
<div class="line">          <span class="keyword">typename</span> apply_eager_metafunction&lt;Func, char&gt;::type&gt;;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">assert_same&lt;call_eager_metafunction_twice&lt;eager_make_list_of_T_and_int&lt;Dummy&gt;&gt;,</div>
<div class="line">            List1&lt;List1&lt;double&gt;, List1&lt;char&gt;&gt;&gt;();</div>
</div><!-- fragment --> (In this simple case we could have used a template template parameter to pass the eager metafunction in a form more similar to a runtime lambda, but the possibilities for generic manipulation of parameter lists containing template template parameters are limited, so their use must be minimized in complex metaprogramming.)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In practice, lazy metafunctions are often implemented as empty structs inheriting from other lazy metafunctions. The entire inheritance chain then inherits a <code>type</code> alias from the ultimate base class.</dd></dl>
<dl class="section user"><dt></dt><dd>Most of the standard Brigand functions are eager, but many have lazy versions in the nested <code>tmpl::lazy</code> namespace. These are indicated by calls to the <code>HAS_LAZY_VERSION</code> macro in the examples below.</dd></dl>
<h2><a class="anchor" id="metalambdas"></a>
Brigand metalambdas</h2>
<dl class="section user"><dt></dt><dd>This use of lazy metafunctions is too limited for general use, however, because it requires the definition of a new templated struct for every new function. Brigand uses a more general notation, known as metalambdas. A metalambda is a (possibly nested set of) lazy metafunctions with some template arguments replaced by the placeholders <code>tmpl::_1</code>, <code>tmpl::_2</code>, etc. These are the first, second, etc., arguments of the metalambda, and will be replaced by the actual arguments when the lambda is used. The lazy nature of the metafunctions prevents them from prematurely evaluating to results based on the literal placeholder types. The <a class="el" href="brigand.html#apply">tmpl::apply</a> function can be used to evaluate a metalambda with specified arguments, and many other Brigand functions take metalambdas that are evaluated internally.</dd></dl>
<h2><a class="anchor" id="metalambda_structure"></a>
Evaluation of metalambdas</h2>
<dl class="section note"><dt>Note</dt><dd>None of the terminology introduced in this section is standard.</dd></dl>
<dl class="section user"><dt></dt><dd>When evaluating a metalambda, the values of any <a class="el" href="brigand.html#args">arguments</a> encountered are taken from the evaluation's argument stack. The argument stack is a stack (in the CS sense) of collections of zero or more arguments. The values of any <a class="el" href="brigand.html#args">arguments</a> that are evaluated are taken from the collection at the head of the stack. The remaining collections are arguments captures in closures, and will not be present in code not using <a class="el" href="brigand.html#defer">tmpl::defer</a>.</dd></dl>
<dl class="section user"><dt></dt><dd>The <a class="el" href="brigand.html#apply">tmpl::apply</a> metafunction is the Brigand metafunction for evaluating metalambdas. It can be called explicitly, and is called internally by many other functions. It takes a metalambda and arguments to be passed to that metalambda. The argument stack for the evaluation has one entry: the passed arguments.</dd></dl>
<dl class="section user"><dt></dt><dd>The argument stack can gain additional entries through the creation of metaclosures using <a class="el" href="brigand.html#defer">tmpl::defer</a>. When <a class="el" href="brigand.html#defer">tmpl::defer</a> is evaluated, it produces a <a class="el" href="brigand.html#metalambda_metaclosure">metaclosure</a> containing a copy of the current argument stack, acting as the lambda captures. When that metaclosure is evaluated, the previously active stack is replaced by the stored stack with the head of the old stack pushed onto it.</dd></dl>
<dl class="section user"><dt></dt><dd>This makes <a class="el" href="brigand.html#args">arguments</a> in a <a class="el" href="brigand.html#metalambda_metaclosure">metaclosure</a> refer to the arguments "passed" to it. (No explicit call syntax is used, but the arguments are inherited from the calling context.) The captured arguments are accessible using <a class="el" href="brigand.html#parent">tmpl::parent</a>, which pops off the last entry in the argument stack.</dd></dl>
<dl class="section user"><dt></dt><dd>There are eight forms that a metalambda can take: an argument, a lazy expression, a bind expression, a pin expression, a defer expression, a parent expression, a constant, or a metaclosure.</dd></dl>
<h3><a class="anchor" id="args"></a>
Argument</h3>
<dl class="section user"><dt></dt><dd>An argument is one of the structs <code>tmpl::_1</code>, <code>tmpl::_2</code>, or <code>tmpl::args&lt;n&gt;</code> for <code>unsigned int</code> n. The additional aliases <code>tmpl::_3</code>, <code>tmpl::_4</code>, ..., <code>tmpl::_9</code> are provided to <code>tmpl::args&lt;2&gt;</code>, <code>tmpl::args&lt;3&gt;</code>, ..., <code>tmpl::args&lt;8&gt;</code>. (The first two arguments have dedicated types in addition to the general <code>tmpl::args&lt;0&gt;</code> and <code>tmpl::args&lt;1&gt;</code>. My best guess is for performance reasons.) <div class="fragment"><div class="line"><span class="keyword">static_assert</span>(not std::is_same_v&lt;tmpl::_1, tmpl::args&lt;0&gt;&gt;);</div>
<div class="line"><span class="keyword">static_assert</span>(not std::is_same_v&lt;tmpl::_2, tmpl::args&lt;1&gt;&gt;);</div>
<div class="line"><span class="keyword">static_assert</span>(std::is_same_v&lt;tmpl::_3, tmpl::args&lt;2&gt;&gt;);</div>
<div class="line"><span class="keyword">static_assert</span>(std::is_same_v&lt;tmpl::_4, tmpl::args&lt;3&gt;&gt;);</div>
</div><!-- fragment --> When evaluated, they give the first (<code>tmpl::_1</code>), second (<code>tmpl::_2</code>), or zero-indexed Nth (<code>tmpl::args&lt;N&gt;</code>) entry from the collection of arguments at the top of the argument stack. <div class="fragment"><div class="line">assert_same&lt;tmpl::apply&lt;tmpl::_1, Type1, Type2&gt;, Type1&gt;();</div>
<div class="line">assert_same&lt;tmpl::apply&lt;tmpl::_2, Type1, Type2&gt;, Type2&gt;();</div>
<div class="line">assert_same&lt;tmpl::apply&lt;tmpl::args&lt;0&gt;, Type1, Type2&gt;, Type1&gt;();</div>
</div><!-- fragment --> Additionally, <code>tmpl::_state</code> and <code>tmpl::_element</code> are aliased to <code>tmpl::_1</code> and <code>tmpl::_2</code>, primarily for use with <a class="el" href="brigand.html#fold">tmpl::fold</a>.</dd></dl>
<dl class="section user"><dt></dt><dd>When evaluating a metalambdas, the metalambda must be passed enough arguments to define all argument placeholders in its body. When evaluating using <a class="el" href="brigand.html#apply">tmpl::apply</a>, arguments are passed as template parameters after the metalambda. Other Brigand functions that evaluate metalambdas pass them a specified number of arguments (usually 1 or 2). Failure to pass enough arguments may error or produce unintuitive results.</dd></dl>
<h3><a class="anchor" id="metalambda_lazy"></a>
Lazy expression</h3>
<dl class="section user"><dt></dt><dd>A lazy expression is a fully-specialized struct template with only type template parameters that is not a specialization of <a class="el" href="brigand.html#pin">tmpl::pin</a>, <a class="el" href="brigand.html#defer">tmpl::defer</a>, or <a class="el" href="brigand.html#parent">tmpl::parent</a> and is not a <a class="el" href="brigand.html#metalambda_metaclosure">metaclosure</a>. When evaluated, each of its template parameters is evaluated as a metalambda and replaced by the result, and then the struct's <code>type</code> type alias is the result of the full lazy-expression. <div class="fragment"><div class="line">assert_same&lt;tmpl::apply&lt;lazy_make_list1&lt;tmpl::_1, tmpl::_2&gt;, Type1, Type2&gt;,</div>
<div class="line">            List1&lt;Type1, Type2&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="bind"></a>
Bind expression</h3>
<dl class="section user"><dt></dt><dd>A bind expression is a specialization of <code>tmpl::bind</code>. It wraps an eager metafunction and its arguments. When evaluated, the arguments are each evaluated as metalambdas, and then the results are passed to the eager metafunction. <div class="fragment"><div class="line">assert_same&lt;tmpl::apply&lt;tmpl::bind&lt;List1, tmpl::_1, tmpl::_2&gt;, Type1, Type2&gt;,</div>
<div class="line">            List1&lt;Type1, Type2&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>tmpl::bind</code> metafunction does not convert an eager metafunction to a lazy one. It is handled specially in the evaluation code.</dd></dl>
<h3><a class="anchor" id="pin"></a>
Pin expression</h3>
<dl class="section user"><dt></dt><dd>A pin expression is a specialization of <code>tmpl::pin</code>. Evaluating a pin expression gives the (unevaluated) argument to <code>tmpl::pin</code>. This can be used to force a type to be treated as a <a class="el" href="brigand.html#metalambda_constant">constant</a>, even if it would normally be treated as a different type of metalambda (usually a <a class="el" href="brigand.html#metalambda_lazy">lazy expression</a>). <div class="fragment"><div class="line">assert_same&lt;tmpl::apply&lt;tmpl::pin&lt;List1&lt;Type1&gt;&gt;&gt;, List1&lt;Type1&gt;&gt;();</div>
<div class="line"><span class="comment">// Error: List1 is not a lazy metafunction</span></div>
<div class="line"><span class="comment">// assert_same&lt;tmpl::apply&lt;List1&lt;Type1&gt;&gt;, List1&lt;Type1&gt;&gt;();</span></div>
<div class="line">assert_same&lt;tmpl::apply&lt;tmpl::pin&lt;tmpl::_1&gt;, Type1&gt;, tmpl::_1&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Pin expressions are often used to protect template arguments to eager metafunctions: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">using</span> is_int = tmpl::apply&lt;std::is_same&lt;tmpl::pin&lt;T&gt;, <span class="keywordtype">int</span>&gt;&gt;;</div>
<div class="line"><span class="keyword">static_assert</span>(<a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">is_int&lt;int&gt;::value</a>);</div>
<div class="line"><span class="comment">// Breaks without tmpl::pin: tmpl::list&lt;&gt; has no ::type</span></div>
<div class="line"><span class="keyword">static_assert</span>(not is_int&lt;tmpl::list&lt;&gt;&gt;<a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">::value</a>);</div>
<div class="ttc" id="agroup__UtilitiesGroup_html_ga4316f2ea7fb92cf4a3c5cf53bf36fb82"><div class="ttname"><a href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">value</a></div><div class="ttdeci">constexpr T &amp; value(T &amp;t)</div><div class="ttdoc">Returns t.value() if t is a std::optional otherwise returns t.</div><div class="ttdef"><b>Definition:</b> OptionalHelpers.hpp:32</div></div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="defer"></a>
Defer expression</h3>
<dl class="section user"><dt></dt><dd>A defer expression is a specialization of <code>tmpl::defer</code>. It does not evaluate its argument, but results in a <a class="el" href="brigand.html#metalambda_metaclosure">metaclosure</a> containing the passed metalambda and the current argument stack.</dd></dl>
<dl class="section user"><dt></dt><dd>Example: <div class="fragment"><div class="line">assert_same&lt;</div>
<div class="line">  tmpl::apply&lt;tmpl::apply&lt;tmpl::defer&lt;tmpl::_1&gt;,</div>
<div class="line">                          Type1&gt;,</div>
<div class="line">              Type2&gt;,</div>
<div class="line">  Type2&gt;();</div>
</div><!-- fragment --> The evaluation here proceeds as follows:</dd></dl>
<ol type="1">
<li>The innermost eager metafunction is the second <a class="el" href="brigand.html#apply">tmpl::apply</a>. It creates an argument stack with one collection containing the single argument <code>Type1</code> and proceeds to evaluate <code>tmpl::defer&lt;tmpl::_1&gt;</code>.</li>
<li>Evaluating the defer expression creates a <a class="el" href="brigand.html#metalambda_metaclosure">metaclosure</a> with the contents <code>tmpl::_1</code> and the argument stack from the first apply. This is the result of the inner <a class="el" href="brigand.html#apply">tmpl::apply</a>.</li>
<li>Next the outer <a class="el" href="brigand.html#apply">tmpl::apply</a> is evaluated. It creates an argument stack with one collection containing the single argument<code>Type2</code>, and proceeds to evaluate the <a class="el" href="brigand.html#metalambda_metaclosure">metaclosure</a> created above.</li>
<li>Evaluating the <a class="el" href="brigand.html#metalambda_metaclosure">metaclosure</a> (see that section below) evaluates the contained <code>tmpl::_1</code> with a two-element argument stack: head to tail [(<code>Type2</code>), (<code>Type1</code>)].</li>
<li>The first (and only) argument (<code>tmpl::_1</code>) in the head of the argument stack is <code>Type2</code>, which is the result of the <a class="el" href="brigand.html#metalambda_metaclosure">metaclosure</a> and the entire expression.</li>
</ol>
<dl class="section user"><dt></dt><dd>The primary purposes for <code>tmpl::defer</code> are constructing metalambdas to pass to other metafunctions and preventing "speculative" evaluation of a portion of a metalambda that is not valid for some arguments. See the examples below, in particular <a class="el" href="brigand.html#make_subtracter">make_subtracter</a>, <a class="el" href="brigand.html#multiplication_table">multiplication_table</a>, <a class="el" href="brigand.html#maybe_first">maybe_first</a>, and <a class="el" href="brigand.html#column_with_zeros">column_with_zeros</a>.</dd></dl>
<h3><a class="anchor" id="parent"></a>
Parent expression</h3>
<dl class="section user"><dt></dt><dd>A parent expression is a specialization of <code>tmpl::parent</code>. It evaluates its argument (treated as a metalambda) after popping the top entry off the argument stack. This provides access to the captured arguments in a <a class="el" href="brigand.html#metalambda_metaclosure">metaclosure</a>.</dd></dl>
<dl class="section user"><dt></dt><dd>Example: <div class="fragment"><div class="line">assert_same&lt;</div>
<div class="line">  tmpl::apply&lt;tmpl::apply&lt;tmpl::defer&lt;tmpl::parent&lt;tmpl::_1&gt;&gt;,</div>
<div class="line">                          Type1&gt;,</div>
<div class="line">              Type2&gt;,</div>
<div class="line">  Type1&gt;();</div>
</div><!-- fragment --> The creation of the <a class="el" href="brigand.html#metalambda_metaclosure">metaclosure</a> here is similar to the example for <a class="el" href="brigand.html#defer">tmpl::defer</a>, except that the contained metalambda is <code>tmpl::parent&lt;tmpl::_1&gt;</code> instead of a plain <code>tmpl::_1</code>. The evaluation proceeds as:</dd></dl>
<ol type="1">
<li>As in <a class="el" href="brigand.html#defer">tmpl::defer</a> example.</li>
<li>As in <a class="el" href="brigand.html#defer">tmpl::defer</a> example.</li>
<li>As in <a class="el" href="brigand.html#defer">tmpl::defer</a> example.</li>
<li>The <a class="el" href="brigand.html#metalambda_metaclosure">metaclosure</a> evaluates the contained <code>tmpl::parent&lt;tmpl::_1&gt;</code> with the argument stack [(<code>Type2</code>), (<code>Type1</code>)].</li>
<li>Evaluating the <code>tmpl::parent</code> pops the stack, and so evaluates <code>tmpl::_1</code> with the stack [(<code>Type1</code>)].</li>
<li>The first (and only) argument (<code>tmpl::_1</code>) in the stack's head is now <code>Type1</code>, which is the result of the <a class="el" href="brigand.html#metalambda_metaclosure">metaclosure</a> and the entire expression.</li>
</ol>
<dl class="section warning"><dt>Warning</dt><dd>Do not call <code>tmpl::parent</code> when the argument stack is empty, i.e., do not attempt to access more sets of captured arguments than have been captured. If you want to prevent evaluation of an expression, use <a class="el" href="brigand.html#pin">tmpl::pin</a>.</dd></dl>
<h3><a class="anchor" id="metalambda_constant"></a>
Constant</h3>
<dl class="section user"><dt></dt><dd>A constant metalambda is any type that is not a struct template with only type template parameters, a specialization of <a class="el" href="brigand.html#bind">tmpl::bind</a>, or a metaclosure. A constant metalambda evaluates to itself. <div class="fragment"><div class="line">assert_same&lt;tmpl::apply&lt;Type1&gt;, Type1&gt;();</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="metalambda_metaclosure"></a>
Metaclosure</h3>
<dl class="section user"><dt></dt><dd>A metaclosure is an opaque type produced by <a class="el" href="brigand.html#defer">tmpl::defer</a>, containing a metalambda and an argument stack. When a metaclosure is evaluated, it evaluates the packaged metalambda with an argument stack constructed by pushing the head of the current argument stack onto the argument stack stored in the metaclosure. See <a class="el" href="brigand.html#defer">Defer expression</a> and <a class="el" href="brigand.html#parent">Parent expression</a> for examples.</dd></dl>
<h2><a class="anchor" id="Examples"></a>
Examples</h2>
<h3><a class="anchor" id="evens"></a>
evens</h3>
<dl class="section user"><dt></dt><dd>Finds all numbers in a list that are even. <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> L&gt;</div>
<div class="line"><span class="keyword">using</span> evens = tmpl::filter&lt;</div>
<div class="line">  L, tmpl::equal_to&lt;tmpl::modulo&lt;tmpl::_1, tmpl::integral_constant&lt;int, 2&gt;&gt;,</div>
<div class="line">                    tmpl::integral_constant&lt;int, 0&gt;&gt;&gt;;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">assert_same&lt;evens&lt;tmpl::integral_list&lt;int, 1, 1, 2, 3, 5, 8, 13&gt;&gt;,</div>
<div class="line">            tmpl::integral_list&lt;int, 2, 8&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>The <a class="el" href="brigand.html#filter">tmpl::filter</a> metafunction takes a metalambda as its second argument. The <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a>s have non-type template parameters, so they are treated as constant expressions. The <a class="el" href="brigand.html#math_comparison">tmpl::equal_to</a> and <a class="el" href="brigand.html#math_arithmetic">tmpl::modulo</a> metafunctions are lazy, despite not being in the <code>tmpl::lazy</code> namespace.</dd></dl>
<h3><a class="anchor" id="maybe_first"></a>
maybe_first</h3>
<dl class="section user"><dt></dt><dd>Returns the first element of a list, or <a class="el" href="brigand.html#no_such_type_">tmpl::no_such_type_</a> if the list is empty. <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> L&gt;</div>
<div class="line"><span class="keyword">using</span> maybe_first = <a class="code hl_function" href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">tmpl::apply</a>&lt;<a class="code hl_function" href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">tmpl::apply</a>&lt;</div>
<div class="line">  tmpl::if_&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::bool_constant</a>&lt;(<a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">tmpl::size&lt;L&gt;::value</a> != 0)&gt;,</div>
<div class="line">            tmpl::defer&lt;tmpl::bind&lt;tmpl::front, tmpl::pin&lt;L&gt;&gt;&gt;,</div>
<div class="line">            tmpl::no_such_type_&gt;&gt;&gt;;</div>
<div class="ttc" id="agroup__DataStructuresGroup_html_ga058ade0497757606713948256728c6db"><div class="ttname"><a href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">apply</a></div><div class="ttdeci">auto apply(F &amp;&amp;f, const ObservationBox&lt; ComputeTagsList, DataBoxType &gt; &amp;observation_box, Args &amp;&amp;... args)</div><div class="ttdoc">Apply the function object f using its nested argument_tags list of tags.</div><div class="ttdef"><b>Definition:</b> ObservationBox.hpp:182</div></div>
<div class="ttc" id="aintegral_constant_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::bool_constant</a></div></div>
</div><!-- fragment --> <div class="fragment"><div class="line">assert_same&lt;maybe_first&lt;tmpl::list&lt;Type1&gt;&gt;, Type1&gt;();</div>
<div class="line">assert_same&lt;maybe_first&lt;tmpl::list&lt;Type1, Type2&gt;&gt;, Type1&gt;();</div>
<div class="line">assert_same&lt;maybe_first&lt;tmpl::list&lt;&gt;&gt;, tmpl::no_such_type_&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>In this example, the inner <a class="el" href="brigand.html#apply">tmpl::apply</a> call evaluates the <a class="el" href="brigand.html#if_">tmpl::if_</a> statement, returning either a <a class="el" href="brigand.html#metalambda_metaclosure">metaclosure</a> or <a class="el" href="brigand.html#no_such_type_">tmpl::no_such_type_</a>. The outer <a class="el" href="brigand.html#apply">tmpl::apply</a> either evaluates the metaclosure, calling <a class="el" href="brigand.html#front">tmpl::front</a>, or evaluates <a class="el" href="brigand.html#no_such_type_">tmpl::no_such_type_</a>, which is a constant and gives itself.</dd></dl>
<dl class="section user"><dt></dt><dd>The reason for creating a metaclosure is that all the arguments to <a class="el" href="brigand.html#if_">tmpl::if_</a> are always evaluated (it is an ordinary metafunction with no special treatment during evaluation). This is a problem, because, in a naive attempt at this metafunction, if <code>L</code> is an empty list <code>tmpl::front&lt;tmpl::list&lt;&gt;&gt;</code> would be evaluated for the first branch. To avoid this we use <a class="el" href="brigand.html#defer">tmpl::defer</a> to wrap the call to <a class="el" href="brigand.html#front">tmpl::front</a> in a metaclosure, which we evaluate only if necessary.</dd></dl>
<dl class="section user"><dt></dt><dd>Note that this metaclosure does not capture anything. <code>L</code> is substituted according to normal C++ rules before any Brigand evaluation. This means that the contents of the <code>tmpl::defer</code> are, for the first call above, <code>tmpl::bind&lt;tmpl::front, tmpl::pin&lt;tmpl::list&lt;Type1&gt;&gt;&gt;</code>. Without the <a class="el" href="brigand.html#pin">tmpl::pin</a>, the list would be interpreted as a lazy metafunction, resulting in an error because it does not have a <code>type</code> type alias.</dd></dl>
<dl class="section user"><dt></dt><dd>The <code>L</code> in <code>tmpl::size&lt;L&gt;</code> does not need to be protected by a <a class="el" href="brigand.html#pin">tmpl::pin</a> because <a class="el" href="brigand.html#size">tmpl::size</a> is an eager metafunction, so that expression has been converted to a <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a> before the metalambda evaluation starts.</dd></dl>
<h3><a class="anchor" id="factorial"></a>
factorial</h3>
<dl class="section user"><dt></dt><dd>Calculates the factorial using a simple metalambda passed to a <a class="el" href="brigand.html#fold">tmpl::fold</a>. <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> N&gt;</div>
<div class="line"><span class="keyword">using</span> <a class="code hl_function" href="group__ConstantExpressionsGroup.html#gae51bb94ba82f6abcf6701127fa1e1842">factorial</a> =</div>
<div class="line">  tmpl::fold&lt;tmpl::range&lt;typename N::value_type, 1, N::value + 1&gt;,</div>
<div class="line">             tmpl::integral_constant&lt;typename N::value_type, 1&gt;,</div>
<div class="line">             tmpl::times&lt;tmpl::_state, tmpl::_element&gt;&gt;;</div>
<div class="ttc" id="agroup__ConstantExpressionsGroup_html_gae51bb94ba82f6abcf6701127fa1e1842"><div class="ttname"><a href="group__ConstantExpressionsGroup.html#gae51bb94ba82f6abcf6701127fa1e1842">factorial</a></div><div class="ttdeci">constexpr uint64_t factorial(const uint64_t n)</div><div class="ttdoc">Compute the factorial of .</div><div class="ttdef"><b>Definition:</b> ConstantExpressions.hpp:88</div></div>
</div><!-- fragment --> <div class="fragment"><div class="line">assert_same&lt;factorial&lt;tmpl::size_t&lt;5&gt;&gt;, tmpl::size_t&lt;120&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>A nearly literal rewrite of this into runtime C++ is <div class="fragment"><div class="line"><span class="keywordtype">size_t</span> factorial_cpp(<span class="keyword">const</span> <span class="keywordtype">size_t</span> n) {</div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;size_t&gt;</a> range(n);</div>
<div class="line">  <a class="code hl_function" href="group__UtilitiesGroup.html#ga218ddc950e1c70d86bf6455664d0b5f1">std::iota</a>(range.begin(), range.end(), 1);</div>
<div class="line">  <span class="keywordtype">size_t</span> state = 1;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i : range) {</div>
<div class="line">    state = state * i;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> state;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__UtilitiesGroup_html_ga218ddc950e1c70d86bf6455664d0b5f1"><div class="ttname"><a href="group__UtilitiesGroup.html#ga218ddc950e1c70d86bf6455664d0b5f1">cpp2b::iota</a></div><div class="ttdeci">constexpr void iota(ForwardIterator first, ForwardIterator last, T value)</div><div class="ttdef"><b>Definition:</b> Numeric.hpp:20</div></div>
<div class="ttc" id="avector_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt; size_t &gt;</a></div></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>The equivalent of a range-based for loop is easier to express in functional programming (as a fold) than a standard counting for loop.</dd></dl>
<h3><a class="anchor" id="make_subtracter"></a>
make_subtracter</h3>
<dl class="section user"><dt></dt><dd>Demonstrates the use of captures in metalambdas. <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> N&gt;</div>
<div class="line"><span class="keyword">using</span> make_subtracter =</div>
<div class="line">    tmpl::apply&lt;tmpl::defer&lt;tmpl::minus&lt;tmpl::_1, tmpl::parent&lt;tmpl::_1&gt;&gt;&gt;, N&gt;;</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">using</span> subtract_three = make_subtracter&lt;tmpl::size_t&lt;3&gt;&gt;;</div>
<div class="line">assert_same&lt;tmpl::apply&lt;subtract_three, tmpl::size_t&lt;5&gt;&gt;, tmpl::size_t&lt;2&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>This metafunction returns a <a class="el" href="brigand.html#metalambda_metaclosure">metaclosure</a> that subtracts a given number from it's argument. That metaclosure uses both the argument passed to it (<code>tmpl::_1</code>, which is 5 in the example) and the value captured at it's creation (<code>tmpl::parent&lt;tmpl::_1&gt;</code>, which is 3 in the example).</dd></dl>
<dl class="section user"><dt></dt><dd>(This <code>make_subtracter</code> could be implemented more simply as <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> N&gt;</div>
<div class="line"><span class="keyword">using</span> make_subtracter_simple = tmpl::minus&lt;tmpl::_1, tmpl::pin&lt;N&gt;&gt;;</div>
</div><!-- fragment --> but that doesn't demonstrate metaclosures.)</dd></dl>
<h3><a class="anchor" id="multiplication_table"></a>
multiplication_table</h3>
<dl class="section user"><dt></dt><dd>Constructs a multiplication table. <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> N&gt;</div>
<div class="line"><span class="keyword">using</span> multiplication_table =</div>
<div class="line">  tmpl::transform&lt;</div>
<div class="line">    tmpl::range&lt;typename N::value_type, 1, N::value + 1&gt;,</div>
<div class="line">    tmpl::lazy::transform&lt;</div>
<div class="line">      tmpl::pin&lt;tmpl::range&lt;typename N::value_type, 1, N::value + 1&gt;&gt;,</div>
<div class="line">      tmpl::defer&lt;tmpl::times&lt;tmpl::_1, tmpl::parent&lt;tmpl::_1&gt;&gt;&gt;&gt;&gt;;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">assert_same&lt;multiplication_table&lt;tmpl::size_t&lt;5&gt;&gt;,</div>
<div class="line">            tmpl::list&lt;tmpl::integral_list&lt;size_t, 1, 2, 3, 4, 5&gt;,</div>
<div class="line">                       tmpl::integral_list&lt;size_t, 2, 4, 6, 8, 10&gt;,</div>
<div class="line">                       tmpl::integral_list&lt;size_t, 3, 6, 9, 12, 15&gt;,</div>
<div class="line">                       tmpl::integral_list&lt;size_t, 4, 8, 12, 16, 20&gt;,</div>
<div class="line">                       tmpl::integral_list&lt;size_t, 5, 10, 15, 20, 25&gt;&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>This demonstrates the use of <a class="el" href="brigand.html#defer">tmpl::defer</a> to pass a closure as an argument to a metafunction (<a class="el" href="brigand.html#transform">tmpl::lazy::transform</a>), while capturing an argument from the outer context (the metalambda evaluated for the outer <a class="el" href="brigand.html#transform">tmpl::transform</a>). This is the use most similar to common uses of the C++ lambda.</dd></dl>
<dl class="section user"><dt></dt><dd>The outer (eager) <a class="el" href="brigand.html#transform">tmpl::transform</a> evaluates its second argument as a metalambda. This first evaluates the arguments to the inner <a class="el" href="brigand.html#transform">tmpl::lazy::transform</a>. The first argument is a <a class="el" href="brigand.html#list">tmpl::list</a> of <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a>s (because the <a class="el" href="brigand.html#range">tmpl::range</a> is eager and has already been evaluated). This must be protected by a <a class="el" href="brigand.html#pin">tmpl::pin</a> because it looks like a lazy metafunction. The second argument gives a metaclosure, capturing the value from the outer <a class="el" href="brigand.html#transform">tmpl::transform</a> (available as <code>tmpl::parent&lt;tmpl::_1&gt;</code>). The <a class="el" href="brigand.html#list">tmpl::list</a> (without the <a class="el" href="brigand.html#pin">tmpl::pin</a>, which has already been evaluated) and metaclosure are then passed to the inner <a class="el" href="brigand.html#transform">tmpl::lazy::transform</a>.</dd></dl>
<h3><a class="anchor" id="column_with_zeros"></a>
column_with_zeros</h3>
<dl class="section user"><dt></dt><dd>Extracts a column from a row-major matrix, extending any short rows with zeros. <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Lists, <span class="keyword">typename</span> Column&gt;</div>
<div class="line"><span class="keyword">using</span> column_with_zeros =</div>
<div class="line">  tmpl::transform&lt;</div>
<div class="line">    Lists,</div>
<div class="line">    tmpl::bind&lt;</div>
<div class="line">      <a class="code hl_function" href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">tmpl::apply</a>,</div>
<div class="line">      tmpl::if_&lt;</div>
<div class="line">        tmpl::greater&lt;tmpl::bind&lt;tmpl::size, tmpl::_1&gt;, Column&gt;,</div>
<div class="line">        tmpl::defer&lt;  <span class="comment">// avoid out-of-range call to `at`</span></div>
<div class="line">          tmpl::parent&lt;</div>
<div class="line">            tmpl::bind&lt;tmpl::at, tmpl::_1, Column&gt;&gt;&gt;,</div>
<div class="line">        tmpl::size_t&lt;0&gt;&gt;&gt;&gt;;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">assert_same&lt;</div>
<div class="line">  column_with_zeros&lt;</div>
<div class="line">    tmpl::list&lt;tmpl::integral_list&lt;size_t, 11, 12, 13&gt;,</div>
<div class="line">               tmpl::integral_list&lt;size_t, 21, 22, 23, 24, 25&gt;,</div>
<div class="line">               tmpl::integral_list&lt;size_t, 31, 32, 33, 34&gt;&gt;,</div>
<div class="line">    tmpl::size_t&lt;3&gt;&gt;,</div>
<div class="line">  tmpl::integral_list&lt;size_t, 0, 24, 34&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>This example shows another use of <a class="el" href="brigand.html#defer">tmpl::defer</a> to avoid evaluating an invalid expression, similar to <a class="el" href="brigand.html#maybe_first">maybe_first</a>. The use of an <a class="el" href="brigand.html#args">argument</a> in the deferred branch makes this case more complicated: a <a class="el" href="brigand.html#parent">tmpl::parent</a> expression is used to access arguments from where the <a class="el" href="brigand.html#defer">tmpl::defer</a> occurs to avoid having to pass the argument explicitly using the <a class="el" href="brigand.html#apply">tmpl::apply</a> call.</dd></dl>
<dl class="section user"><dt></dt><dd>This is the "apply-defer-parent" pattern for lazy evaluation. A <a class="el" href="brigand.html#parent">tmpl::parent</a> is placed immediately inside a <a class="el" href="brigand.html#defer">tmpl::defer</a> with a (not immediately) surrounding <a class="el" href="brigand.html#apply">tmpl::apply</a>. The <a class="el" href="brigand.html#apply">tmpl::apply</a> and <a class="el" href="brigand.html#defer">tmpl::defer</a> collectively add an (empty) element to the head of the argument stack, which is then popped off to restore the original value. This causes the interior metalambda to have the same result it would have had without the <a class="el" href="brigand.html#defer">tmpl::defer</a>.</dd></dl>
<h3><a class="anchor" id="factorial_recursion"></a>
factorial_recursion</h3>
<dl class="section user"><dt></dt><dd>Again calculates the factorial, but using a recursive algorithm. <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> N&gt;</div>
<div class="line"><span class="keyword">using</span> factorial_recursion =</div>
<div class="line">  <a class="code hl_function" href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">tmpl::apply</a>&lt;</div>
<div class="line">    tmpl::bind&lt;tmpl::apply, tmpl::_1, tmpl::_1, N&gt;,</div>
<div class="line">    tmpl::bind&lt;  <span class="comment">// recursive metalambda starts here</span></div>
<div class="line">      <a class="code hl_function" href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">tmpl::apply</a>,</div>
<div class="line">      tmpl::if_&lt;</div>
<div class="line">        tmpl::not_equal_to&lt;tmpl::_2, tmpl::size_t&lt;0&gt;&gt;,</div>
<div class="line">        tmpl::defer&lt;  <span class="comment">// prevent speculative recursion</span></div>
<div class="line">          tmpl::parent&lt;</div>
<div class="line">            tmpl::times&lt;</div>
<div class="line">              tmpl::_2,</div>
<div class="line">              tmpl::bind&lt;<a class="code hl_function" href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">tmpl::apply</a>, tmpl::_1,</div>
<div class="line">                         tmpl::_1, tmpl::prev&lt;tmpl::_2&gt;&gt;&gt;&gt;&gt;,</div>
<div class="line">        tmpl::integral_constant&lt;typename N::value_type, 1&gt;&gt;&gt;&gt;;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">assert_same&lt;factorial_recursion&lt;tmpl::size_t&lt;5&gt;&gt;, tmpl::size_t&lt;120&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>This is a direct translation of the common definition \(f(N) = N f(N-1)\) for nonzero \(N\), and \(f(0) = 1\). The metalambda is passed a copy of itself as the first argument and the value to take the factorial of as the second.</dd></dl>
<dl class="section user"><dt></dt><dd>This again uses the "apply-defer-parent" pattern to prevent "speculative" evaluation of conditional branches. In this example, speculative evaluation of the branch is invalid because it would recurse infinitely.</dd></dl>
<h3><a class="anchor" id="primes"></a>
primes</h3>
<dl class="section user"><dt></dt><dd>Generates a list of prime numbers less than <code>N</code> using the sieve of Eratosthenes. This example defines three helper metafunctions. Two, <code>zero</code> and <code>replace_at</code>, are defined only for clarity's sake and could be inlined. The third, <code>range_from_types</code>, is not easily inlinable, and works around Brigand's lack of sequence generating functions without non-type template parameters. <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> N&gt;</div>
<div class="line"><span class="keyword">using</span> zero = tmpl::integral_constant&lt;typename N::value_type, 0&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Return Sequence with the Nth element replaced by NewType.</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Sequence, <span class="keyword">typename</span> N, <span class="keyword">typename</span> NewType&gt;</div>
<div class="line"><span class="keyword">using</span> <a class="code hl_function" href="group__ConstantExpressionsGroup.html#ga9cf860a304a9492f6bf1ce740ce2c151">replace_at</a> =</div>
<div class="line">  tmpl::append&lt;tmpl::front&lt;tmpl::split_at&lt;Sequence, N&gt;&gt;,</div>
<div class="line">               tmpl::list&lt;NewType&gt;,</div>
<div class="line">               tmpl::pop_front&lt;tmpl::back&lt;tmpl::split_at&lt;Sequence, N&gt;&gt;&gt;&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Start, <span class="keyword">typename</span> End&gt;</div>
<div class="line"><span class="keyword">using</span> range_from_types =</div>
<div class="line">  tmpl::range&lt;typename Start::value_type, Start::value, End::value&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> N&gt;</div>
<div class="line"><span class="keyword">using</span> primes =</div>
<div class="line">  tmpl::remove&lt;</div>
<div class="line">    tmpl::fold&lt;</div>
<div class="line">      tmpl::range&lt;typename N::value_type, 2, N::value&gt;,</div>
<div class="line">      <a class="code hl_function" href="group__ComputationalDomainGroup.html#gac81519ee0b09d6e2080198045a195794">tmpl::push_front</a>&lt;</div>
<div class="line">        tmpl::range&lt;typename N::value_type, 2, N::value&gt;, zero&lt;N&gt;, zero&lt;N&gt;&gt;,</div>
<div class="line">      tmpl::bind&lt;</div>
<div class="line">        <a class="code hl_function" href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">tmpl::apply</a>,</div>
<div class="line">        tmpl::if_&lt;  <span class="comment">// Skip work for known-composite entries</span></div>
<div class="line">          tmpl::or_&lt;</div>
<div class="line">            <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same</a>&lt;</div>
<div class="line">              tmpl::bind&lt;tmpl::at, tmpl::_state, tmpl::_element&gt;, zero&lt;N&gt;&gt;,</div>
<div class="line">            <span class="comment">// Only iteration up to sqrt(N) is necessary</span></div>
<div class="line">            tmpl::greater_equal&lt;</div>
<div class="line">              tmpl::times&lt;tmpl::_element, tmpl::_element&gt;, N&gt;&gt;,</div>
<div class="line">          tmpl::defer&lt;  <span class="comment">// Match other branch (don&#39;t execute the state)</span></div>
<div class="line">            tmpl::parent&lt;tmpl::_state&gt;&gt;,</div>
<div class="line">          tmpl::defer&lt;</div>
<div class="line">            tmpl::parent&lt;</div>
<div class="line">              tmpl::lazy::fold&lt;</div>
<div class="line">                tmpl::bind&lt;</div>
<div class="line">                  range_from_types,</div>
<div class="line">                  tmpl::_element,</div>
<div class="line">                  tmpl::next&lt;tmpl::divides&lt;tmpl::prev&lt;N&gt;, tmpl::_element&gt;&gt;&gt;,</div>
<div class="line">                tmpl::_state,</div>
<div class="line">                tmpl::defer&lt;  <span class="comment">// Passed as a closure to the inner fold</span></div>
<div class="line">                  tmpl::bind&lt;</div>
<div class="line">                    <a class="code hl_function" href="group__ConstantExpressionsGroup.html#ga9cf860a304a9492f6bf1ce740ce2c151">replace_at</a>,</div>
<div class="line">                    tmpl::_state,</div>
<div class="line">                    tmpl::times&lt;tmpl::parent&lt;tmpl::_element&gt;, tmpl::_element&gt;,</div>
<div class="line">                    zero&lt;N&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;,</div>
<div class="line">    zero&lt;N&gt;&gt;;</div>
<div class="ttc" id="agroup__ComputationalDomainGroup_html_gac81519ee0b09d6e2080198045a195794"><div class="ttname"><a href="group__ComputationalDomainGroup.html#gac81519ee0b09d6e2080198045a195794">domain::push_front</a></div><div class="ttdeci">CoordinateMap&lt; SourceFrame, TargetFrame, NewMap, Maps... &gt; push_front(CoordinateMap&lt; SourceFrame, TargetFrame, Maps... &gt; old_map, NewMap new_map)</div><div class="ttdoc">Creates a CoordinateMap by prepending the new map to the beginning of the old maps.</div></div>
<div class="ttc" id="agroup__ConstantExpressionsGroup_html_ga9cf860a304a9492f6bf1ce740ce2c151"><div class="ttname"><a href="group__ConstantExpressionsGroup.html#ga9cf860a304a9492f6bf1ce740ce2c151">replace_at</a></div><div class="ttdeci">constexpr std::array&lt; std::decay_t&lt; T &gt;, Size &gt; replace_at(const std::array&lt; T, Size &gt; &amp;arr, T value)</div><div class="ttdoc">Replace at compile time the Ith entry in the array with value</div><div class="ttdef"><b>Definition:</b> ConstantExpressions.hpp:365</div></div>
</div><!-- fragment --> <div class="fragment"><div class="line">assert_same&lt;</div>
<div class="line">  primes&lt;tmpl::size_t&lt;100&gt;&gt;,</div>
<div class="line">  tmpl::integral_list&lt;size_t, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,</div>
<div class="line">                      43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>This is roughly equivalent to the following C++ code with loops converted fo fold expressions over ranges. <div class="fragment"><div class="line"><a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;size_t&gt;</a> primes_cpp(<span class="keyword">const</span> <span class="keywordtype">size_t</span> n) {</div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;size_t&gt;</a> sieve(n, 0);</div>
<div class="line">  <a class="code hl_function" href="group__UtilitiesGroup.html#ga218ddc950e1c70d86bf6455664d0b5f1">std::iota</a>(sieve.begin() + 2, sieve.end(), 2);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 2; i &lt; n; ++i) {</div>
<div class="line">    <span class="keywordflow">if</span> (not (sieve[i] == 0 or i * i &gt;= n)) {</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = i; j &lt; (n - 1) / i + 1; ++j) {</div>
<div class="line">        sieve[i * j] = 0;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;size_t&gt;</a> result;</div>
<div class="line">  std::copy_if(sieve.begin(), sieve.end(),</div>
<div class="line">               <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/iterator/insert_iterator.html">std::insert_iterator</a>(result, result.begin()),</div>
<div class="line">               [](<span class="keyword">const</span> <span class="keywordtype">size_t</span> x) { return x != 0; });</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="ttc" id="ainsert_iterator_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/iterator/insert_iterator.html">std::insert_iterator</a></div></div>
</div><!-- fragment --></dd></dl>
<h1><a class="anchor" id="metafunction_guidelines"></a>
Guidelines for writing metafunctions</h1>
<dl class="section user"><dt></dt><dd>This section covers a few general guidelines for writing metafunctions in SpECTRE. Some of the Brigand functions mentioned below have specific advice as well.</dd></dl>
<ol type="1">
<li>For general metafunctions, write both lazy and eager versions. Follow the STL convention of <code>foo</code> being lazy, <code>foo_t</code> being eager, and <code>foo_v</code> being a constexpr value (if applicable). This does not apply to internal-use or special-purpose metafunctions. <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>always_true : <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::true_type</a> {};</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">using</span> always_true_t = <span class="keyword">typename</span> always_true&lt;T&gt;::type;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">bool</span> always_true_v = <a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">always_true&lt;T&gt;::value</a>;</div>
</div><!-- fragment --></li>
<li>Don't perform unnecessary return-type conversions. We often recommend using STL types over equivalent Brigand types, but if the implementation naturally produces a Brigand type do not do extra work to convert it.</li>
</ol>
<h1><a class="anchor" id="function_docs"></a>
Brigand types and functions</h1>
<dl class="section user"><dt></dt><dd>In this section, CamelCase identifiers indicate <a href="https://en.cppreference.com/w/cpp/language/template_parameters#Type_template_parameter">type template parameters</a> or, occasionally, <a href="https://en.cppreference.com/w/cpp/language/template_parameters#Template_template_parameter">template template parameters</a>. Identifiers in all lowercase indicate <a href="https://en.cppreference.com/w/cpp/language/template_parameters#Non-type_template_parameter">non-type template parameters</a>. Identifiers in [brackets] are optional, and the default value will be identified in the prose description. Identifiers with ellipses... represent zero or more parameters.</dd></dl>
<dl class="section user"><dt></dt><dd>The <em>head</em> of a fully specialized class template is the class template itself (e.g., the head of <code>tmpl::list&lt;T, U, V&gt;</code> is <code>tmpl::list</code>). When taken as a metafunction parameter, these are template template parameters and are usually called <code>Head</code> below.</dd></dl>
<dl class="section user"><dt></dt><dd>An identifier called <code>Sequence</code> must be a full specialization of a class template with no non-type template parameters. Many functions do not make sense on sequences with a fixed length, and these require the head of their sequence arguments to take a variable number of template arguments. In practical applications, sequence arguments will usually be specializations of <a class="el" href="brigand.html#list">tmpl::list</a>.</dd></dl>
<dl class="section user"><dt></dt><dd>Parameters called <code>Predicate</code> must be unary metalambdas returning <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a>s of <code>bool</code> or compatible classes.</dd></dl>
<dl class="section user"><dt></dt><dd>Parameters called <code>Comparator</code> must be binary metalambdas returning <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a>s of <code>bool</code> or compatible classes. They must establish a <a href="https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings">strict weak ordering</a> on the types they will be applied to in the same manner as runtime comparators from the STL.</dd></dl>
<dl class="section user"><dt></dt><dd>Metafunctions documented here are eager unless otherwise noted. In many cases, Brigand provides lazy versions of its metafunctions under the same name in the <code>tmpl::lazy</code> namespace. These cases are indicated by the presence of the <code>HAS_LAZY_VERSION</code> macro in the usage example.</dd></dl>
<h2><a class="anchor" id="Containers"></a>
Containers</h2>
<dl class="section user"><dt></dt><dd>Brigand provides container classes with the sole purpose of wrapping other things.</dd></dl>
<h3><a class="anchor" id="integral_constant"></a>
integral_constant&lt;T, value&gt;</h3>
<dl class="section user"><dt></dt><dd>A compile-time value <code>value</code> of type <code>T</code>. Very similar to <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a>, except that the <code>constexpr</code> specifiers on the member functions have been omitted. <div class="fragment"><div class="line"><span class="keyword">using</span> T = tmpl::integral_constant&lt;int, 3&gt;;</div>
<div class="line">assert_same&lt;T::value_type, int&gt;();</div>
<div class="line">assert_same&lt;T::type, T&gt;();</div>
<div class="line"><span class="keyword">static_assert</span>(<a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">T::value</a> == 3);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// At runtime only</span></div>
<div class="line">CHECK(T{} == 3);</div>
<div class="line">CHECK(T{}() == 3);</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Brigand supplies type aliases for constants of some specific types: <div class="fragment"><div class="line">assert_same&lt;tmpl::int8_t&lt;3&gt;, tmpl::integral_constant&lt;int8_t, 3&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::int16_t&lt;3&gt;, tmpl::integral_constant&lt;int16_t, 3&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::int32_t&lt;3&gt;, tmpl::integral_constant&lt;int32_t, 3&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::int64_t&lt;3&gt;, tmpl::integral_constant&lt;int64_t, 3&gt;&gt;();</div>
<div class="line"> </div>
<div class="line">assert_same&lt;tmpl::uint8_t&lt;3&gt;, tmpl::integral_constant&lt;uint8_t, 3&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::uint16_t&lt;3&gt;, tmpl::integral_constant&lt;uint16_t, 3&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::uint32_t&lt;3&gt;, tmpl::integral_constant&lt;uint32_t, 3&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::uint64_t&lt;3&gt;, tmpl::integral_constant&lt;uint64_t, 3&gt;&gt;();</div>
<div class="line"> </div>
<div class="line">assert_same&lt;tmpl::size_t&lt;3&gt;, tmpl::integral_constant&lt;size_t, 3&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::ptrdiff_t&lt;3&gt;, tmpl::integral_constant&lt;ptrdiff_t, 3&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::bool_&lt;true&gt;, tmpl::integral_constant&lt;bool, true&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Most metafunctions that accept integral_constants will accept any type with a <code>value</code> static member variable.</dd></dl>
<dl class="section user"><dt></dt><dd>Because of the <code>type</code> type alias, integral_constants behave like lazy metafunctions returning themselves. Most lazy metafunctions producing an integral_constant will actually inherit from their result, so <code>value</code> will be directly available without needing to go through the <code>type</code> alias.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Prefer <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a>, except for the convenience wrapper <code>tmpl::size_t</code> or when necessary for type equality comparison.</dd></dl>
<h3><a class="anchor" id="list"></a>
list&lt;T...&gt;</h3>
<dl class="section user"><dt></dt><dd>An empty struct templated on a parameter pack, with no additional functionality. <div class="fragment"><div class="line"><span class="keyword">static_assert</span>(not std::is_same_v&lt;tmpl::list&lt;Type1, Type2&gt;,</div>
<div class="line">                                 tmpl::list&lt;Type2, Type1&gt;&gt;);</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Most metafunctions that operate on lists will work on any struct template.</dd></dl>
<h3><a class="anchor" id="map"></a>
map&lt;Pair...&gt;</h3>
<dl class="section user"><dt></dt><dd>A collection of key-value <a class="el" href="brigand.html#pair">tmpl::pair</a>s with unique keys. See the section on <a class="el" href="brigand.html#map_operations">operations on maps</a> for details. <div class="fragment"><div class="line">assert_same&lt;tmpl::lookup&lt;tmpl::map&lt;tmpl::pair&lt;Type1, int&gt;,</div>
<div class="line">                                   tmpl::pair&lt;Type2, double&gt;&gt;,</div>
<div class="line">                         Type1&gt;,</div>
<div class="line">            <span class="keywordtype">int</span>&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>The actual type of a map is unspecified, but it has the same template parameters as a call to <code>map</code> that would produce it.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Equivalent maps may have different types, depending on the order their keys are stored in internally.</dd></dl>
<h3><a class="anchor" id="pair"></a>
pair&lt;T1, T2&gt;</h3>
<dl class="section user"><dt></dt><dd>A pair of types, with easy access to each type in the pair. <div class="fragment"><div class="line">assert_same&lt;tmpl::pair&lt;Type1, Type2&gt;::first_type, Type1&gt;();</div>
<div class="line">assert_same&lt;tmpl::pair&lt;Type1, Type2&gt;::second_type, Type2&gt;();</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="set"></a>
set&lt;T...&gt;</h3>
<dl class="section user"><dt></dt><dd>An unordered collection of distinct types. Trying to create a <code>set</code> with duplicate entries is an error (but <a class="el" href="brigand.html#set_insert">tmpl::insert</a> ignores duplicate entries). See the section on <a class="el" href="brigand.html#set_operations">operations on sets</a> for details. <div class="fragment"><div class="line">assert_same&lt;tmpl::contains&lt;tmpl::set&lt;Type1, Type2&gt;, Type1&gt;, tmpl::true_type&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>The actual type of a set is unspecified, but it has the same template parameters as a call to <code>set</code> that would produce it.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Equivalent sets may have different types, depending on the order their elements are stored in internally.</dd></dl>
<h3><a class="anchor" id="type_"></a>
type_&lt;T&gt;</h3>
<dl class="section user"><dt></dt><dd>A struct containing a <code>type</code> alias to <code>T</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::type_&lt;Type1&gt;::type, Type1&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>When extracting the type, programmers are encouraged to use <a class="el" href="brigand.html#type_from">tmpl::type_from</a> to make it clear that the <code>::type</code> that would otherwise appear is not an evaluation of a lazy metafunction. See <a class="el" href="brigand.html#always">tmpl::always</a> or <a class="el" href="brigand.html#identity">tmpl::identity</a> for similar functionality that is intended for use as a metafunction.</dd></dl>
<h2><a class="anchor" id="Constants"></a>
Constants</h2>
<dl class="section user"><dt></dt><dd>Brigand defines a few concrete types and type aliases.</dd></dl>
<h3><a class="anchor" id="empty_base"></a>
empty_base</h3>
<dl class="section user"><dt></dt><dd>An empty struct used by <a class="el" href="brigand.html#inherit">tmpl::inherit</a> and <a class="el" href="brigand.html#inherit_linearly">tmpl::inherit_linearly</a>. Primarily for internal use. <div class="fragment"><div class="line">assert_same&lt;tmpl::inherit_linearly&lt;List1&lt;&gt;, List2&lt;&gt;&gt;, tmpl::empty_base&gt;();</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="empty_sequence"></a>
empty_sequence</h3>
<dl class="section user"><dt></dt><dd>An empty <a class="el" href="brigand.html#list">tmpl::list</a>. <div class="fragment"><div class="line">assert_same&lt;tmpl::empty_sequence, tmpl::list&lt;&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Prefer just writing <code>tmpl::list&lt;&gt;</code>.</dd></dl>
<h3><a class="anchor" id="false_type"></a>
false_type</h3>
<dl class="section user"><dt></dt><dd>A <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a> representing <code>false</code>. Similar to <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::false_type</a>. <div class="fragment"><div class="line">assert_same&lt;tmpl::false_type, tmpl::bool_&lt;false&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Prefer <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::false_type</a>.</dd></dl>
<h3><a class="anchor" id="no_such_type_"></a>
no_such_type_</h3>
<dl class="section user"><dt></dt><dd>An empty struct returned as the failure case for various searching operations. <div class="fragment"><div class="line">assert_same&lt;tmpl::index_of&lt;List1&lt;&gt;, Type1&gt;, tmpl::no_such_type_&gt;();</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="true_type"></a>
true_type</h3>
<dl class="section user"><dt></dt><dd>A <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a> representing <code>true</code>. Similar to <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::true_type</a>. <div class="fragment"><div class="line">assert_same&lt;tmpl::true_type, tmpl::bool_&lt;true&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Prefer <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::true_type</a>.</dd></dl>
<h2><a class="anchor" id="list_constructor"></a>
Constructor-like functions for lists</h2>
<dl class="section user"><dt></dt><dd>These functions produce <a class="el" href="brigand.html#list">tmpl::list</a>s from non-list values. They are often similar to constructors in the STL.</dd></dl>
<h3><a class="anchor" id="filled_list"></a>
filled_list&lt;Entry, n, [Head]&gt;</h3>
<dl class="section user"><dt></dt><dd>Creates a list containing <code>n</code> (passed as an <code>unsigned int</code>) of <code>Entry</code>. The head of the list defaults to <a class="el" href="brigand.html#list">tmpl::list</a>. <div class="fragment"><div class="line">assert_same&lt;tmpl::filled_list&lt;Type1, 3, List1&gt;, List1&lt;Type1, Type1, Type1&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::filled_list&lt;Type1, 3&gt;, tmpl::list&lt;Type1, Type1, Type1&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="integral_list"></a>
integral_list&lt;T, n...&gt;</h3>
<dl class="section user"><dt></dt><dd>Shorthand for a <a class="el" href="brigand.html#list">tmpl::list</a> of <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a>s of the type <code>T</code> with values <code>n...</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::integral_list&lt;int, 3, 2, 1&gt;,</div>
<div class="line">            tmpl::list&lt;tmpl::integral_constant&lt;int, 3&gt;,</div>
<div class="line">                       tmpl::integral_constant&lt;int, 2&gt;,</div>
<div class="line">                       tmpl::integral_constant&lt;int, 1&gt;&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Prefer <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::integer_sequence</a> when used for pack expansion. Prefer <code>tmpl::integral_list</code> when the contents need to be manipulated for more complicated metaprogramming.</dd></dl>
<h3><a class="anchor" id="make_sequence"></a>
make_sequence&lt;Start, n, [Next], [Head]&gt;</h3>
<dl class="section user"><dt></dt><dd>Produces a list with first element <code>Start</code> and length <code>n</code> (provided as an <code>unsigned int</code>). The remaining elements are obtained by repeated applications of the <a class="el" href="brigand.html#metalambdas">metalambda</a> <code>Next</code>, defaulting to <a class="el" href="brigand.html#next">tmpl::next</a>. The head of the sequence can be specified, and defaults to <a class="el" href="brigand.html#list">tmpl::list</a>. <div class="fragment"><div class="line">assert_same&lt;tmpl::make_sequence&lt;tmpl::size_t&lt;5&gt;, 3&gt;,</div>
<div class="line">            tmpl::list&lt;tmpl::size_t&lt;5&gt;, tmpl::size_t&lt;6&gt;, tmpl::size_t&lt;7&gt;&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::make_sequence&lt;Type1, 3, lazy_make_list1&lt;tmpl::_1&gt;, List2&gt;,</div>
<div class="line">            List2&lt;Type1, List1&lt;Type1&gt;, List1&lt;List1&lt;Type1&gt;&gt;&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#range">tmpl::range</a>, <a class="el" href="brigand.html#repeat">tmpl::repeat</a></dd></dl>
<h3><a class="anchor" id="range"></a>
range&lt;T, start, stop&gt;</h3>
<dl class="section user"><dt></dt><dd>Produces a <a class="el" href="brigand.html#list">tmpl::list</a> of <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a>s of type <code>T</code> representing adjacent ascending integers from <code>start</code> to <code>stop</code>, including the starting value and excluding the ending value. <div class="fragment"><div class="line">assert_same&lt;tmpl::range&lt;size_t, 4, 7&gt;,</div>
<div class="line">            tmpl::list&lt;tmpl::size_t&lt;4&gt;, tmpl::size_t&lt;5&gt;, tmpl::size_t&lt;6&gt;&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::range&lt;size_t, 4, 4&gt;, tmpl::list&lt;&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#reverse_range">tmpl::reverse_range</a></dd></dl>
<h3><a class="anchor" id="reverse_range"></a>
reverse_range&lt;T, start, stop&gt;</h3>
<dl class="section user"><dt></dt><dd>Produces a <a class="el" href="brigand.html#list">tmpl::list</a> of <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a>s of type <code>T</code> representing adjacent descending integers from <code>start</code> to <code>stop</code>, including the starting value and excluding the ending value. <div class="fragment"><div class="line">assert_same&lt;tmpl::reverse_range&lt;size_t, 7, 4&gt;,</div>
<div class="line">            tmpl::list&lt;tmpl::size_t&lt;7&gt;, tmpl::size_t&lt;6&gt;, tmpl::size_t&lt;5&gt;&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::reverse_range&lt;size_t, 7, 7&gt;, tmpl::list&lt;&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#range">tmpl::range</a></dd></dl>
<h2><a class="anchor" id="list_query"></a>
Functions for querying lists</h2>
<dl class="section user"><dt></dt><dd>These tend to be similar to const member functions in the STL and the non-modifying sequence operations in <code>&lt;algorithm&gt;</code>. They are most frequently used with <a class="el" href="brigand.html#list">tmpl::list</a>, but similar classes will also work.</dd></dl>
<h3><a class="anchor" id="all"></a>
all&lt;Sequence, [Predicate]&gt;</h3>
<dl class="section user"><dt></dt><dd>Checks if <code>Predicate</code> is true for all elements of <code>Sequence</code>. The default predicate checks that the element's <code>value</code> is not equal to zero. <div class="fragment"><div class="line">assert_same&lt;tmpl::all&lt;List1&lt;tmpl::size_t&lt;0&gt;, tmpl::size_t&lt;1&gt;, tmpl::size_t&lt;2&gt;&gt;&gt;,</div>
<div class="line">            tmpl::false_type&gt;();</div>
<div class="line">assert_same&lt;tmpl::all&lt;List1&lt;tmpl::size_t&lt;1&gt;, tmpl::size_t&lt;1&gt;, tmpl::size_t&lt;2&gt;&gt;&gt;,</div>
<div class="line">            tmpl::true_type&gt;();</div>
<div class="line">assert_same&lt;tmpl::all&lt;List1&lt;tmpl::size_t&lt;0&gt;, tmpl::size_t&lt;1&gt;, tmpl::size_t&lt;2&gt;&gt;,</div>
<div class="line">                      tmpl::less&lt;tmpl::_1, tmpl::size_t&lt;2&gt;&gt;&gt;,</div>
<div class="line">            tmpl::false_type&gt;();</div>
<div class="line">assert_same&lt;tmpl::all&lt;List1&lt;tmpl::size_t&lt;0&gt;, tmpl::size_t&lt;1&gt;, tmpl::size_t&lt;0&gt;&gt;,</div>
<div class="line">                      tmpl::less&lt;tmpl::_1, tmpl::size_t&lt;2&gt;&gt;&gt;,</div>
<div class="line">            tmpl::true_type&gt;();</div>
<div class="line">assert_same&lt;tmpl::all&lt;List1&lt;&gt;&gt;, tmpl::true_type&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The predicate must return the same true value for each element for <code>all</code> to return true. <div class="fragment"><div class="line">assert_same&lt;tmpl::all&lt;List1&lt;std::true_type, tmpl::true_type&gt;, tmpl::_1&gt;,</div>
<div class="line">            tmpl::false_type&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#any">tmpl::any</a>, <a class="el" href="brigand.html#none">tmpl::none</a></dd></dl>
<h3><a class="anchor" id="any"></a>
any&lt;Sequence, [Predicate]&gt;</h3>
<dl class="section user"><dt></dt><dd>Checks if <code>Predicate</code> is true for at least one element of <code>Sequence</code>. The default predicate checks that the element's <code>value</code> is not equal to zero. <div class="fragment"><div class="line">assert_same&lt;tmpl::any&lt;List1&lt;tmpl::size_t&lt;0&gt;, tmpl::size_t&lt;1&gt;, tmpl::size_t&lt;2&gt;&gt;&gt;,</div>
<div class="line">            tmpl::true_type&gt;();</div>
<div class="line">assert_same&lt;tmpl::any&lt;List1&lt;tmpl::size_t&lt;0&gt;, tmpl::size_t&lt;0&gt;, tmpl::size_t&lt;0&gt;&gt;&gt;,</div>
<div class="line">            tmpl::false_type&gt;();</div>
<div class="line">assert_same&lt;tmpl::any&lt;List1&lt;tmpl::size_t&lt;0&gt;, tmpl::size_t&lt;1&gt;, tmpl::size_t&lt;2&gt;&gt;,</div>
<div class="line">                      tmpl::less&lt;tmpl::_1, tmpl::size_t&lt;2&gt;&gt;&gt;,</div>
<div class="line">            tmpl::true_type&gt;();</div>
<div class="line">assert_same&lt;tmpl::any&lt;List1&lt;tmpl::size_t&lt;4&gt;, tmpl::size_t&lt;3&gt;, tmpl::size_t&lt;2&gt;&gt;,</div>
<div class="line">                      tmpl::less&lt;tmpl::_1, tmpl::size_t&lt;2&gt;&gt;&gt;,</div>
<div class="line">            tmpl::false_type&gt;();</div>
<div class="line">assert_same&lt;tmpl::any&lt;List1&lt;&gt;&gt;, tmpl::false_type&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="brigand.html#any">tmpl::any</a> and <a class="el" href="brigand.html#none">tmpl::none</a> metafunctions perform the same tasks as <a class="el" href="brigand.html#found">tmpl::found</a> and <a class="el" href="brigand.html#not_found">tmpl::not_found</a>, but use different algorithms. In general, <a class="el" href="brigand.html#any">tmpl::any</a> and <a class="el" href="brigand.html#none">tmpl::none</a> are much faster, but <a class="el" href="brigand.html#found">tmpl::found</a> and <a class="el" href="brigand.html#not_found">tmpl::not_found</a> short-circuit, so they may be preferable with short lists and expensive predicates.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The predicate must return the same false value for each element for <code>any</code> to return false. <div class="fragment"><div class="line">assert_same&lt;tmpl::any&lt;List1&lt;std::false_type, tmpl::false_type&gt;, tmpl::_1&gt;,</div>
<div class="line">            tmpl::true_type&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#all">tmpl::all</a>, <a class="el" href="brigand.html#found">tmpl::found</a>, <a class="el" href="brigand.html#none">tmpl::none</a></dd></dl>
<h3><a class="anchor" id="at"></a>
at&lt;Sequence, Index&gt;</h3>
<dl class="section user"><dt></dt><dd>Retrieves a given element of <code>Sequence</code>, similar to <code>operator[]</code> of the STL containers. The <code><a class="el" href="classIndex.html" title="An integer multi-index.">Index</a></code> is supplied as a <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a> or similar type. <div class="fragment"><div class="line">assert_same&lt;tmpl::at&lt;List1&lt;Type1, Type2, Type3&gt;, tmpl::size_t&lt;0&gt;&gt;, Type1&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>This operator is <a class="el" href="brigand.html#map_at">overloaded for maps</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#at_c">tmpl::at_c</a></dd></dl>
<h3><a class="anchor" id="at_c"></a>
at_c&lt;Sequence, n&gt;</h3>
<dl class="section user"><dt></dt><dd>Retrieves a given element of <code>Sequence</code>, similar to <code>operator[]</code> of the STL containers. The index <code>n</code> is supplied as an <code>unsigned int</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::at_c&lt;List1&lt;Type1, Type2, Type3&gt;, 0&gt;, Type1&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#at">tmpl::at</a></dd></dl>
<h3><a class="anchor" id="back"></a>
back&lt;Sequence&gt;</h3>
<dl class="section user"><dt></dt><dd>Retrieves the last element of <code>Sequence</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::back&lt;List1&lt;Type1, Type2, Type3&gt;&gt;, Type3&gt;();</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="count_if"></a>
count_if&lt;Sequence, Predicate&gt;</h3>
<dl class="section user"><dt></dt><dd>Returns the number of elements of <code>Sequence</code> satisfying <code>Predicate</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::count_if&lt;List1&lt;Type1, Type2, Type1&gt;,</div>
<div class="line">                           <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same&lt;tmpl::_1, Type1&gt;</a>&gt;,</div>
<div class="line">            tmpl::integral_constant&lt;size_t, 2&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="fold"></a>
fold&lt;Sequence, State, Functor&gt;</h3>
<dl class="section user"><dt></dt><dd>Performs a <a href="https://en.wikipedia.org/wiki/Fold_(higher-order_function)">left fold</a>, i.e., given a list <code>Sequence</code>, initial state <code>State</code>, and <a class="el" href="brigand.html#metalambdas">metalambda</a> <code>Functor</code>, updates the state by calling <code>Functor</code> on the state and the first element of <code>Sequence</code>, repeats with the second, and so on, returning the final state. <div class="fragment"><div class="line">assert_same&lt;tmpl::fold&lt;List2&lt;Type1, Type2&gt;, Type3,</div>
<div class="line">                       lazy_make_list1&lt;tmpl::_state, tmpl::_element&gt;&gt;,</div>
<div class="line">            List1&lt;List1&lt;Type3, Type1&gt;, Type2&gt;&gt;();</div>
<div class="line">HAS_LAZY_VERSION(fold);</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Brigand provides <code>tmpl::_state</code> and <code>tmpl::_element</code> aliases to the appropriate <a class="el" href="brigand.html#args">arguments</a> for use in folds.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#reverse_fold">tmpl::reverse_fold</a></dd></dl>
<h3><a class="anchor" id="found"></a>
found&lt;Sequence, [Predicate]&gt;</h3>
<dl class="section user"><dt></dt><dd>Returns, as a <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a> of <code>bool</code>, whether <code>Predicate</code> matches any element of <code>Sequence</code>. The default predicate checks that the element's <code>value</code> is not equal to zero. <div class="fragment"><div class="line">assert_same&lt;</div>
<div class="line">  tmpl::found&lt;List1&lt;Type1, Type2, Type2, Type3&gt;, <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same&lt;tmpl::_1, Type2&gt;</a>&gt;,</div>
<div class="line">  tmpl::true_type&gt;();</div>
<div class="line">assert_same&lt;</div>
<div class="line">  tmpl::found&lt;List1&lt;Type1, Type1, Type1, Type3&gt;, <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same&lt;tmpl::_1, Type2&gt;</a>&gt;,</div>
<div class="line">  tmpl::false_type&gt;();</div>
<div class="line">assert_same&lt;</div>
<div class="line">  tmpl::found&lt;List1&lt;tmpl::size_t&lt;0&gt;, tmpl::size_t&lt;1&gt;, tmpl::size_t&lt;2&gt;&gt;&gt;,</div>
<div class="line">  tmpl::true_type&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function performs the same operation as <a class="el" href="brigand.html#any">tmpl::any</a>. See <a class="el" href="brigand.html#any">tmpl::any</a> for discussion.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#any">tmpl::any</a>, <a class="el" href="brigand.html#find">tmpl::find</a>, <a class="el" href="brigand.html#not_found">tmpl::not_found</a></dd></dl>
<h3><a class="anchor" id="front"></a>
front&lt;Sequence&gt;</h3>
<dl class="section user"><dt></dt><dd>Retrieves the first element of <code>Sequence</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::front&lt;List1&lt;Type1, Type2, Type3&gt;&gt;, Type1&gt;();</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id=""></a>
</h3>
<dl class="section user"><dt></dt><dd>Finds the index as a <code>size_t</code> <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a> of the first type in <code>Sequence</code> satisfying <code>Predicate</code>. Returns <code>NotFound</code>, defaulting to <a class="el" href="brigand.html#no_such_type_">tmpl::no_such_type_</a> if no elements match. <div class="fragment"><div class="line">assert_same&lt;tmpl::index_if&lt;List1&lt;Type1, Type2, Type3&gt;,</div>
<div class="line">                           <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same&lt;Type3, tmpl::_1&gt;</a>&gt;,</div>
<div class="line">            tmpl::size_t&lt;2&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::index_if&lt;List1&lt;Type1, Type3, Type3&gt;,</div>
<div class="line">                           <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same&lt;Type3, tmpl::_1&gt;</a>&gt;,</div>
<div class="line">            tmpl::size_t&lt;1&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::index_if&lt;List1&lt;Type1&gt;, <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same&lt;Type3, tmpl::_1&gt;</a>&gt;,</div>
<div class="line">            tmpl::no_such_type_&gt;();</div>
<div class="line">assert_same&lt;tmpl::index_if&lt;List1&lt;Type1&gt;, <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same&lt;Type3, tmpl::_1&gt;</a>, Type2&gt;,</div>
<div class="line">            Type2&gt;();</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="index_of"></a>
index_of&lt;Sequence, T&gt;</h3>
<dl class="section user"><dt></dt><dd>Finds the index as a <code>size_t</code> <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a> of the first occurrence of <code>T</code> in <code>Sequence</code>. Returns <a class="el" href="brigand.html#no_such_type_">tmpl::no_such_type_</a> if the type is not found. <div class="fragment"><div class="line">assert_same&lt;tmpl::index_of&lt;List1&lt;Type1, Type2, Type3&gt;, Type3&gt;,</div>
<div class="line">            tmpl::size_t&lt;2&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::index_of&lt;List1&lt;Type1, Type3, Type3&gt;, Type3&gt;,</div>
<div class="line">            tmpl::size_t&lt;1&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::index_of&lt;List1&lt;Type1&gt;, Type2&gt;,</div>
<div class="line">            tmpl::no_such_type_&gt;();</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="list_contains"></a>
list_contains&lt;Sequence, T&gt;</h3>
<dl class="section user"><dt></dt><dd>Checks whether <code>T</code> is contained in <code>Sequence</code>, returning a <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a> of <code>bool</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::list_contains&lt;List1&lt;Type1, Type2&gt;, Type1&gt;, tmpl::true_type&gt;();</div>
<div class="line"><span class="keyword">static_assert</span>(tmpl::list_contains_v&lt;List1&lt;Type1, Type2&gt;, Type1&gt;);</div>
<div class="line"><span class="keyword">static_assert</span>(not tmpl::list_contains_v&lt;List1&lt;Type2, Type2&gt;, Type1&gt;);</div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is not a Brigand metafunction. It is implemented in SpECTRE.</dd></dl>
<h3><a class="anchor" id="none"></a>
none&lt;Sequence, [Predicate]&gt;</h3>
<dl class="section user"><dt></dt><dd>Checks if <code>Predicate</code> is false for all elements of <code>Sequence</code>. The default predicate checks that the element's <code>value</code> is not equal to zero. <div class="fragment"><div class="line">assert_same&lt;</div>
<div class="line">  tmpl::none&lt;List1&lt;tmpl::size_t&lt;0&gt;, tmpl::size_t&lt;1&gt;, tmpl::size_t&lt;2&gt;&gt;&gt;,</div>
<div class="line">  tmpl::false_type&gt;();</div>
<div class="line">assert_same&lt;</div>
<div class="line">  tmpl::none&lt;List1&lt;tmpl::size_t&lt;0&gt;, tmpl::size_t&lt;0&gt;, tmpl::size_t&lt;0&gt;&gt;&gt;,</div>
<div class="line">  tmpl::true_type&gt;();</div>
<div class="line">assert_same&lt;</div>
<div class="line">  tmpl::none&lt;List1&lt;tmpl::size_t&lt;0&gt;, tmpl::size_t&lt;1&gt;, tmpl::size_t&lt;2&gt;&gt;,</div>
<div class="line">             tmpl::less&lt;tmpl::_1, tmpl::size_t&lt;2&gt;&gt;&gt;,</div>
<div class="line">  tmpl::false_type&gt;();</div>
<div class="line">assert_same&lt;</div>
<div class="line">  tmpl::none&lt;List1&lt;tmpl::size_t&lt;4&gt;, tmpl::size_t&lt;3&gt;, tmpl::size_t&lt;2&gt;&gt;,</div>
<div class="line">             tmpl::less&lt;tmpl::_1, tmpl::size_t&lt;2&gt;&gt;&gt;,</div>
<div class="line">  tmpl::true_type&gt;();</div>
<div class="line">assert_same&lt;tmpl::none&lt;List1&lt;&gt;&gt;, tmpl::true_type&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function performs the same operation as <a class="el" href="brigand.html#not_found">tmpl::not_found</a>. See <a class="el" href="brigand.html#any">tmpl::any</a> for discussion.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The predicate must return the same false value for each element for <code>none</code> to return true. <div class="fragment"><div class="line">assert_same&lt;tmpl::none&lt;List1&lt;std::false_type, tmpl::false_type&gt;, tmpl::_1&gt;,</div>
<div class="line">            tmpl::false_type&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#all">tmpl::all</a>, <a class="el" href="brigand.html#any">tmpl::any</a>, <a class="el" href="brigand.html#not_found">tmpl::not_found</a></dd></dl>
<h3><a class="anchor" id="not_found"></a>
not_found&lt;Sequence, [Predicate]&gt;</h3>
<dl class="section user"><dt></dt><dd>Returns, as a <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a> of <code>bool</code>, whether <code>Predicate</code> matches no elements of <code>Sequence</code>. The default predicate checks that the element's <code>value</code> is not equal to zero. <div class="fragment"><div class="line">assert_same&lt;</div>
<div class="line">  tmpl::not_found&lt;List1&lt;Type1, Type2, Type2, Type3&gt;,</div>
<div class="line">                  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same&lt;tmpl::_1, Type2&gt;</a>&gt;,</div>
<div class="line">  tmpl::false_type&gt;();</div>
<div class="line">assert_same&lt;</div>
<div class="line">  tmpl::not_found&lt;List1&lt;Type1, Type1, Type1, Type3&gt;,</div>
<div class="line">                  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same&lt;tmpl::_1, Type2&gt;</a>&gt;,</div>
<div class="line">  tmpl::true_type&gt;();</div>
<div class="line">assert_same&lt;</div>
<div class="line">  tmpl::not_found&lt;List1&lt;tmpl::size_t&lt;0&gt;, tmpl::size_t&lt;1&gt;, tmpl::size_t&lt;2&gt;&gt;&gt;,</div>
<div class="line">  tmpl::false_type&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function performs the same operation as <a class="el" href="brigand.html#none">tmpl::none</a>. See <a class="el" href="brigand.html#any">tmpl::any</a> for discussion.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#find">tmpl::find</a>, <a class="el" href="brigand.html#found">tmpl::found</a>, <a class="el" href="brigand.html#none">tmpl::none</a></dd></dl>
<h3><a class="anchor" id="size"></a>
size&lt;Sequence&gt;</h3>
<dl class="section user"><dt></dt><dd>Returns the number of elements in <code>Sequence</code> as a <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a> of type <code>unsigned int</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::size&lt;List1&lt;Type1, Type1&gt;&gt;,</div>
<div class="line">            tmpl::integral_constant&lt;unsigned int, 2&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#count">tmpl::count</a></dd></dl>
<h2><a class="anchor" id="list_to_list"></a>
Functions producing lists from other lists</h2>
<dl class="section user"><dt></dt><dd>These tend to be similar to non-const member functions in the STL and the mutating sequence operations in <code>&lt;algorithm&gt;</code>, but due to the nature of metaprogramming all return a new list rather than modifying an argument. They are most frequently used with <a class="el" href="brigand.html#list">tmpl::list</a>, but similar classes will also work.</dd></dl>
<h3><a class="anchor" id="append"></a>
append&lt;Sequence...&gt;</h3>
<dl class="section user"><dt></dt><dd>Concatenates all of its arguments, keeping the head of the first (or <a class="el" href="brigand.html#list">tmpl::list</a> if passed no arguments). <div class="fragment"><div class="line">assert_same&lt;tmpl::append&lt;List1&lt;Type1, Type2&gt;, List2&lt;&gt;, List2&lt;Type2&gt;&gt;,</div>
<div class="line">            List1&lt;Type1, Type2, Type2&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::append&lt;&gt;, tmpl::list&lt;&gt;&gt;();</div>
<div class="line">HAS_LAZY_VERSION(append);</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#join">tmpl::join</a></dd></dl>
<h3><a class="anchor" id="clear"></a>
clear&lt;Sequence&gt;</h3>
<dl class="section user"><dt></dt><dd>Produces a list with the same head as <code>Sequence</code> but no elements. <div class="fragment"><div class="line">assert_same&lt;tmpl::clear&lt;List1&lt;Type1&gt;&gt;, List1&lt;&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the head is known, prefer writing it explicitly. If the head is irrelevant, write an empty <a class="el" href="brigand.html#list">tmpl::list</a>.</dd></dl>
<h3><a class="anchor" id="erase"></a>
erase&lt;Sequence, Index&gt;</h3>
<dl class="section user"><dt></dt><dd>Produces a copy of <code>Sequence</code> with the element at index <code><a class="el" href="classIndex.html" title="An integer multi-index.">Index</a></code> (passed as a <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a> or similar type) removed. <div class="fragment"><div class="line">assert_same&lt;tmpl::erase&lt;List1&lt;Type1, Type2, Type3&gt;, tmpl::size_t&lt;1&gt;&gt;,</div>
<div class="line">            List1&lt;Type1, Type3&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>This operator is overloaded <a class="el" href="brigand.html#map_erase">for maps</a> and <a class="el" href="brigand.html#set_erase">for sets</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#erase_c">erase_c&lt;Sequence, n&gt;</a></dd></dl>
<h3><a class="anchor" id="erase_c"></a>
erase_c&lt;Sequence, n&gt;</h3>
<dl class="section user"><dt></dt><dd>Produces a copy of <code>Sequence</code> with the element at index <code>n</code> (passed as an <code>unsigned int</code>) removed. <div class="fragment"><div class="line">assert_same&lt;tmpl::erase_c&lt;List1&lt;Type1, Type2, Type3&gt;, 1&gt;,</div>
<div class="line">            List1&lt;Type1, Type3&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="filter"></a>
filter&lt;Sequence, Predicate&gt;</h3>
<dl class="section user"><dt></dt><dd>Removes all types not matching <code>Predicate</code> from <code>Sequence</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::filter&lt;List1&lt;Type1, Type2, Type1, Type3&gt;,</div>
<div class="line">                         <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same&lt;Type1, tmpl::_1&gt;</a>&gt;,</div>
<div class="line">            List1&lt;Type1, Type1&gt;&gt;();</div>
<div class="line">HAS_LAZY_VERSION(filter);</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#remove_if">tmpl::remove_if</a></dd></dl>
<h3><a class="anchor" id="find"></a>
find&lt;Sequence, [Predicate]&gt;</h3>
<dl class="section user"><dt></dt><dd>Returns a list containing the first element of <code>Sequence</code> for which <code>Predicate</code> returns true and all subsequent elements. The default predicate checks that the element's <code>value</code> is not equal to zero. Returns an empty list if the predicate returns false for all elements. <div class="fragment"><div class="line">assert_same&lt;</div>
<div class="line">  tmpl::find&lt;List1&lt;Type1, Type2, Type2, Type3&gt;, <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same&lt;tmpl::_1, Type2&gt;</a>&gt;,</div>
<div class="line">  List1&lt;Type2, Type2, Type3&gt;&gt;();</div>
<div class="line">assert_same&lt;</div>
<div class="line">  tmpl::find&lt;List1&lt;Type1, Type1, Type1, Type3&gt;, <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same&lt;tmpl::_1, Type2&gt;</a>&gt;,</div>
<div class="line">  List1&lt;&gt;&gt;();</div>
<div class="line">assert_same&lt;</div>
<div class="line">  tmpl::find&lt;List1&lt;tmpl::size_t&lt;0&gt;, tmpl::size_t&lt;1&gt;, tmpl::size_t&lt;2&gt;&gt;&gt;,</div>
<div class="line">  List1&lt;tmpl::size_t&lt;1&gt;, tmpl::size_t&lt;2&gt;&gt;&gt;();</div>
<div class="line">HAS_LAZY_VERSION(<a class="code hl_function" href="group__UtilitiesGroup.html#gac84a6c0bd8692c342b9ddf4ba63601e2">find</a>);</div>
<div class="ttc" id="agroup__UtilitiesGroup_html_gac84a6c0bd8692c342b9ddf4ba63601e2"><div class="ttname"><a href="group__UtilitiesGroup.html#gac84a6c0bd8692c342b9ddf4ba63601e2">cpp20::find</a></div><div class="ttdeci">constexpr InputIt find(InputIt first, InputIt last, const T &amp;value)</div><div class="ttdef"><b>Definition:</b> Algorithm.hpp:136</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#found">tmpl::found</a>, <a class="el" href="brigand.html#not_found">tmpl::not_found</a>, <a class="el" href="brigand.html#reverse_find">tmpl::reverse_find</a></dd></dl>
<h3><a class="anchor" id="flatten"></a>
flatten&lt;Sequence&gt;</h3>
<dl class="section user"><dt></dt><dd>Recursively inlines the contents of elements of <code>Sequence</code> that are sequences with the same head. <div class="fragment"><div class="line">assert_same&lt;</div>
<div class="line">  tmpl::flatten&lt;List1&lt;List1&lt;Type1, List1&lt;Type2&gt;&gt;, List2&lt;List1&lt;Type3&gt;&gt;&gt;&gt;,</div>
<div class="line">  List1&lt;Type1, Type2, List2&lt;List1&lt;Type3&gt;&gt;&gt;&gt;();</div>
<div class="line">HAS_LAZY_VERSION(flatten);</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#join">tmpl::join</a></dd></dl>
<h3><a class="anchor" id="join"></a>
join&lt;Sequence&gt;</h3>
<dl class="section user"><dt></dt><dd>Combines lists in the same manner as <a class="el" href="brigand.html#append">tmpl::append</a>, but takes a list of lists instead of multiple arguments. <div class="fragment"><div class="line">assert_same&lt;tmpl::join&lt;List3&lt;List1&lt;Type1, Type2&gt;, List2&lt;&gt;, List2&lt;Type2&gt;&gt;&gt;,</div>
<div class="line">            List1&lt;Type1, Type2, Type2&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::join&lt;List1&lt;&gt;&gt;, tmpl::list&lt;&gt;&gt;();</div>
<div class="line">HAS_LAZY_VERSION(join);</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="list_difference"></a>
list_difference&lt;Sequence1, Sequence2&gt;</h3>
<dl class="section user"><dt></dt><dd>Remove all elements that occur in <code>Sequence2</code> from <code>Sequence1</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::list_difference&lt;List1&lt;Type1, Type2, Type1, Type2&gt;,</div>
<div class="line">                                  List2&lt;Type3, Type2&gt;&gt;,</div>
<div class="line">            List1&lt;Type1, Type1&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is not a Brigand metafunction. It is implemented in SpECTRE.</dd></dl>
<h3><a class="anchor" id="merge"></a>
merge&lt;Sequence1, Sequence2, [Comparator]&gt;</h3>
<dl class="section user"><dt></dt><dd>Given two sorted lists, returns a sorted list containing the elements of both. A comparator metalambda can be provided, defaulting to <a class="el" href="brigand.html#math_comparison">tmpl::less</a>. <div class="fragment"><div class="line">assert_same&lt;</div>
<div class="line">  tmpl::merge&lt;List1&lt;tmpl::size_t&lt;1&gt;, tmpl::size_t&lt;2&gt;, tmpl::size_t&lt;5&gt;&gt;,</div>
<div class="line">              List2&lt;tmpl::size_t&lt;1&gt;, tmpl::size_t&lt;3&gt;, tmpl::size_t&lt;6&gt;&gt;&gt;,</div>
<div class="line">  List1&lt;tmpl::size_t&lt;1&gt;, tmpl::size_t&lt;1&gt;, tmpl::size_t&lt;2&gt;, tmpl::size_t&lt;3&gt;,</div>
<div class="line">        tmpl::size_t&lt;5&gt;, tmpl::size_t&lt;6&gt;&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::merge&lt;List1&lt;Type1, Type2&gt;, List2&lt;Type1, Type3&gt;,</div>
<div class="line">                        CompareType123&gt;,</div>
<div class="line">            List1&lt;Type1, Type1, Type2, Type3&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>If there are equivalent elements, those from the second list are placed earlier. <div class="fragment"><div class="line">assert_same&lt;tmpl::merge&lt;List1&lt;Type1, Type1&gt;, List2&lt;Type2, Type2&gt;,</div>
<div class="line">                        <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::false_type</a>&gt;,</div>
<div class="line">            List1&lt;Type2, Type2, Type1, Type1&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::merge</dd></dl>
<h3><a class="anchor" id="partition"></a>
partition&lt;Sequence, Predicate&gt;</h3>
<dl class="section user"><dt></dt><dd>Returns a <a class="el" href="brigand.html#pair">tmpl::pair</a> containing a list of the elements of <code>Sequence</code> for which the <code>Predicate</code> returns true and a list of the elements of <code>Sequence</code> for which the <code>Predicate</code> returns false. <div class="fragment"><div class="line">assert_same&lt;tmpl::partition&lt;List1&lt;Type1, Type2, Type1, Type3&gt;,</div>
<div class="line">                            <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same&lt;Type1, tmpl::_1&gt;</a>&gt;,</div>
<div class="line">            tmpl::pair&lt;List1&lt;Type1, Type1&gt;, List1&lt;Type2, Type3&gt;&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#filter">tmpl::filter</a>, <a class="el" href="brigand.html#remove_if">tmpl::remove_if</a></dd></dl>
<h3><a class="anchor" id="pop_back"></a>
pop_back&lt;Sequence, [Count]&gt;</h3>
<dl class="section user"><dt></dt><dd>Remove <code>Count</code> elements from the end of <code>Sequence</code>. The number of elements to remove is supplied as a <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a> and defaults to 1. <div class="fragment"><div class="line">assert_same&lt;tmpl::pop_back&lt;List1&lt;Type1, Type2, Type3&gt;&gt;, List1&lt;Type1, Type2&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::pop_back&lt;List1&lt;Type1, Type2, Type3&gt;,</div>
<div class="line">                           tmpl::integral_constant&lt;unsigned int, 2&gt;&gt;,</div>
<div class="line">            List1&lt;Type1&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="pop_front"></a>
pop_front&lt;Sequence, [Count]&gt;</h3>
<dl class="section user"><dt></dt><dd>Remove <code>Count</code> elements from the beginning of <code>Sequence</code>. The number of elements to remove is supplied as a <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a> and defaults to 1. <div class="fragment"><div class="line">assert_same&lt;tmpl::pop_front&lt;List1&lt;Type1, Type2, Type3&gt;&gt;,</div>
<div class="line">            List1&lt;Type2, Type3&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::pop_front&lt;List1&lt;Type1, Type2, Type3&gt;,</div>
<div class="line">                            tmpl::integral_constant&lt;unsigned int, 2&gt;&gt;,</div>
<div class="line">            List1&lt;Type3&gt;&gt;();</div>
<div class="line">HAS_LAZY_VERSION(pop_front);</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="push_back"></a>
push_back&lt;Sequence, T...&gt;</h3>
<dl class="section user"><dt></dt><dd>Appends types <code>T...</code> to <code>Sequence</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::push_back&lt;List1&lt;Type1&gt;, Type2, Type3&gt;,</div>
<div class="line">            List1&lt;Type1, Type2, Type3&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="push_front"></a>
push_front&lt;Sequence, T...&gt;</h3>
<dl class="section user"><dt></dt><dd>Prepends types <code>T...</code> to <code>Sequence</code>. The order of the prepended items is retained: they are pushed as a unit, not one-by-one. <div class="fragment"><div class="line">assert_same&lt;tmpl::push_front&lt;List1&lt;Type1&gt;, Type2, Type3&gt;,</div>
<div class="line">            List1&lt;Type2, Type3, Type1&gt;&gt;();</div>
<div class="line">HAS_LAZY_VERSION(<a class="code hl_function" href="group__ComputationalDomainGroup.html#gac81519ee0b09d6e2080198045a195794">push_front</a>);</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="remove"></a>
remove&lt;Sequence, T&gt;</h3>
<dl class="section user"><dt></dt><dd>Removes all occurrences of <code>T</code> from <code>Sequence</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::remove&lt;List1&lt;Type1, Type2, Type1, Type3&gt;, Type1&gt;,</div>
<div class="line">            List1&lt;Type2, Type3&gt;&gt;();</div>
<div class="line">HAS_LAZY_VERSION(remove);</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="remove_duplicates"></a>
remove_duplicates&lt;Sequence&gt;</h3>
<dl class="section user"><dt></dt><dd>Remove duplicates from <code>Sequence</code>. The first occurrence of each type is kept. <div class="fragment"><div class="line">assert_same&lt;tmpl::remove_duplicates&lt;List1&lt;Type1, Type2, Type1, Type3, Type2&gt;&gt;,</div>
<div class="line">            List1&lt;Type1, Type2, Type3&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is not a Brigand metafunction. It is implemented in SpECTRE.</dd></dl>
<h3><a class="anchor" id="remove_if"></a>
remove_if&lt;Sequence, Predicate&gt;</h3>
<dl class="section user"><dt></dt><dd>Removes all types matching <code>Predicate</code> from <code>Sequence</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::remove_if&lt;List1&lt;Type1, Type2, Type1, Type3&gt;,</div>
<div class="line">                            <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same&lt;Type1, tmpl::_1&gt;</a>&gt;,</div>
<div class="line">            List1&lt;Type2, Type3&gt;&gt;();</div>
<div class="line">HAS_LAZY_VERSION(remove_if);</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#filter">tmpl::filter</a></dd></dl>
<h3><a class="anchor" id="replace"></a>
replace&lt;Sequence, Old, New&gt;</h3>
<dl class="section user"><dt></dt><dd>Replaces all occurrences of <code>Old</code> in <code>Sequence</code> with <code>New</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::replace&lt;List1&lt;Type1, Type2, Type1&gt;, Type1, Type3&gt;,</div>
<div class="line">            List1&lt;Type3, Type2, Type3&gt;&gt;();</div>
<div class="line">HAS_LAZY_VERSION(replace);</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="replace_if"></a>
replace_if&lt;Sequence, Predicate, T&gt;</h3>
<dl class="section user"><dt></dt><dd>Replaces all types in <code>Sequence</code> matching <code>Predicate</code> with <code>T</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::replace_if&lt;List1&lt;Type1, Type2, Type1&gt;,</div>
<div class="line">                             <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same&lt;Type1, tmpl::_1&gt;</a>, Type3&gt;,</div>
<div class="line">            List1&lt;Type3, Type2, Type3&gt;&gt;();</div>
<div class="line">HAS_LAZY_VERSION(replace_if);</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="reverse"></a>
reverse&lt;Sequence&gt;</h3>
<dl class="section user"><dt></dt><dd>Reverses the order of types in <code>Sequence</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::reverse&lt;List1&lt;Type1, Type2, Type3, Type1&gt;&gt;,</div>
<div class="line">            List1&lt;Type1, Type3, Type2, Type1&gt;&gt;();</div>
<div class="line">HAS_LAZY_VERSION(<a class="code hl_function" href="group__UtilitiesGroup.html#ga0465ea9937545d1d3404c6ab6e71b15c">reverse</a>);</div>
<div class="ttc" id="agroup__UtilitiesGroup_html_ga0465ea9937545d1d3404c6ab6e71b15c"><div class="ttname"><a href="group__UtilitiesGroup.html#ga0465ea9937545d1d3404c6ab6e71b15c">cpp20::reverse</a></div><div class="ttdeci">constexpr void reverse(BidirectionalIterator first, BidirectionalIterator last)</div><div class="ttdef"><b>Definition:</b> Algorithm.hpp:79</div></div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="reverse_find"></a>
reverse_find&lt;Sequence, [Predicate]&gt;</h3>
<dl class="section user"><dt></dt><dd>Returns a list containing the last element of <code>Sequence</code> for which <code>Predicate</code> returns true and all preceding elements. The default predicate checks that the element's <code>value</code> is not equal to zero. Returns an empty list if the predicate returns false for all elements. <div class="fragment"><div class="line">assert_same&lt;</div>
<div class="line">  tmpl::reverse_find&lt;List1&lt;Type1, Type2, Type2, Type3&gt;,</div>
<div class="line">                     <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same&lt;tmpl::_1, Type2&gt;</a>&gt;,</div>
<div class="line">  List1&lt;Type1, Type2, Type2&gt;&gt;();</div>
<div class="line">assert_same&lt;</div>
<div class="line">  tmpl::reverse_find&lt;List1&lt;Type1, Type1, Type1, Type3&gt;,</div>
<div class="line">                     <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same&lt;tmpl::_1, Type2&gt;</a>&gt;,</div>
<div class="line">  List1&lt;&gt;&gt;();</div>
<div class="line">assert_same&lt;</div>
<div class="line">  tmpl::reverse_find&lt;List1&lt;tmpl::size_t&lt;0&gt;, tmpl::size_t&lt;1&gt;, tmpl::size_t&lt;2&gt;&gt;&gt;,</div>
<div class="line">  List1&lt;tmpl::size_t&lt;0&gt;, tmpl::size_t&lt;1&gt;, tmpl::size_t&lt;2&gt;&gt;&gt;();</div>
<div class="line">HAS_LAZY_VERSION(reverse_find);</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#find">tmpl::find</a></dd></dl>
<h3><a class="anchor" id="reverse_fold"></a>
reverse_fold&lt;Sequence, State, Functor&gt;</h3>
<dl class="section user"><dt></dt><dd>Performs a <a href="https://en.wikipedia.org/wiki/Fold_(higher-order_function)">right fold</a>, i.e., given a list <code>Sequence</code>, initial state <code>State</code>, and <a class="el" href="brigand.html#metalambdas">metalambda</a> <code>Functor</code>, updates the state by calling <code>Functor</code> on the state and the last element of <code>Sequence</code>, repeats with the second to last, and so on, returning the final state. <div class="fragment"><div class="line">assert_same&lt;tmpl::reverse_fold&lt;List2&lt;Type1, Type2&gt;, Type3,</div>
<div class="line">                               lazy_make_list1&lt;tmpl::_state, tmpl::_element&gt;&gt;,</div>
<div class="line">            List1&lt;List1&lt;Type3, Type2&gt;, Type1&gt;&gt;();</div>
<div class="line">HAS_LAZY_VERSION(reverse_fold);</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Brigand provides <code>tmpl::_state</code> and <code>tmpl::_element</code> aliases to the appropriate <a class="el" href="brigand.html#args">arguments</a> for use in folds.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#fold">tmpl::fold</a></dd></dl>
<h3><a class="anchor" id="sort"></a>
sort&lt;Sequence, [Comparator]&gt;</h3>
<dl class="section user"><dt></dt><dd>Sorts <code>Sequence</code> according to <code>Comparator</code>, which defaults to <a class="el" href="brigand.html#math_comparison">tmpl::less</a>. <div class="fragment"><div class="line">assert_same&lt;tmpl::sort&lt;List1&lt;tmpl::size_t&lt;9&gt;, tmpl::size_t&lt;6&gt;,</div>
<div class="line">                             tmpl::size_t&lt;7&gt;, tmpl::size_t&lt;0&gt;&gt;&gt;,</div>
<div class="line">            List1&lt;tmpl::size_t&lt;0&gt;, tmpl::size_t&lt;6&gt;, tmpl::size_t&lt;7&gt;,</div>
<div class="line">                  tmpl::size_t&lt;9&gt;&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::sort&lt;List1&lt;Type2, Type3, Type3, Type1, Type2, Type3, Type2&gt;,</div>
<div class="line">                       CompareType123&gt;,</div>
<div class="line">            List1&lt;Type1, Type2, Type2, Type2, Type3, Type3, Type3&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The sort is not stable. <div class="fragment"><div class="line">assert_same&lt;tmpl::sort&lt;List1&lt;Type1, Type2, Type3&gt;, <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::false_type</a>&gt;,</div>
<div class="line">            List1&lt;Type3, Type2, Type1&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="split"></a>
split&lt;Sequence, Delimiter&gt;</h3>
<dl class="section user"><dt></dt><dd>Splits <code>Sequence</code> into parts separated by <code>Delimiter</code>, discarding empty parts. <div class="fragment"><div class="line">assert_same&lt;</div>
<div class="line">  tmpl::split&lt;List1&lt;Type1, Type2, Type3, Type2, Type3, Type3, Type1&gt;, Type3&gt;,</div>
<div class="line">  List1&lt;List1&lt;Type1, Type2&gt;, List1&lt;Type2&gt;, List1&lt;Type1&gt;&gt;&gt;();</div>
<div class="line">HAS_LAZY_VERSION(split);</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="split_at"></a>
split_at&lt;Sequence, Index&gt;</h3>
<dl class="section user"><dt></dt><dd>Returns a list of two of lists, the first containing the first <code><a class="el" href="classIndex.html" title="An integer multi-index.">Index</a></code> (supplied as a <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a>) elements or <code>Sequence</code>, and the second containing the remaining elements. <div class="fragment"><div class="line">assert_same&lt;tmpl::split_at&lt;List1&lt;Type1, Type2, Type3&gt;,</div>
<div class="line">                           tmpl::integral_constant&lt;unsigned int, 2&gt;&gt;,</div>
<div class="line">            List1&lt;List1&lt;Type1, Type2&gt;, List1&lt;Type3&gt;&gt;&gt;();</div>
<div class="line">HAS_LAZY_VERSION(split_at);</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="transform"></a>
transform&lt;Sequence, Sequences..., Functor&gt;</h3>
<dl class="section user"><dt></dt><dd>Calls a <code>Functor</code> on each element of <code>Sequence</code>, collecting the results in a new list. If additional <code>Sequences...</code> are supplied, elements from those lists are passed as additional arguments to <code>Functor</code>. <div class="fragment"><div class="line">assert_same&lt;</div>
<div class="line">  tmpl::transform&lt;List2&lt;Type1, Type2, Type3&gt;, List3&lt;Type3, Type2, Type1&gt;,</div>
<div class="line">                  lazy_make_list1&lt;tmpl::_1, tmpl::_2&gt;&gt;,</div>
<div class="line">  List2&lt;List1&lt;Type1, Type3&gt;, List1&lt;Type2, Type2&gt;, List1&lt;Type3, Type1&gt;&gt;&gt;();</div>
<div class="line">HAS_LAZY_VERSION(<a class="code hl_namespace" href="namespacetransform.html">transform</a>);</div>
<div class="ttc" id="anamespacetransform_html"><div class="ttname"><a href="namespacetransform.html">transform</a></div><div class="ttdoc">Holds functions related to transforming between frames.</div><div class="ttdef"><b>Definition:</b> Transform.hpp:17</div></div>
</div><!-- fragment --></dd></dl>
<h2><a class="anchor" id="map_operations"></a>
Operations on maps</h2>
<dl class="section user"><dt></dt><dd>Brigand's <a class="el" href="brigand.html#map">tmpl::map</a> type can be manipulated by several metafunctions.</dd></dl>
<dl class="section user"><dt></dt><dd>Examples in this section use this map as an example: <div class="fragment"><div class="line"><span class="keyword">using</span> example_map =</div>
<div class="line">  tmpl::map&lt;tmpl::pair&lt;Type1, int&gt;, tmpl::pair&lt;Type2, double&gt;&gt;;</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="map_at"></a>
at&lt;Map, Key&gt;</h3>
<dl class="section user"><dt></dt><dd>Returns the value associated with <code>Key</code> in <code>Map</code>. Returns <a class="el" href="brigand.html#no_such_type_">tmpl::no_such_type_</a> if <code>Key</code> is not in the map. <div class="fragment"><div class="line">assert_same&lt;tmpl::at&lt;example_map, Type1&gt;, <span class="keywordtype">int</span>&gt;();</div>
<div class="line">assert_same&lt;tmpl::at&lt;example_map, Type3&gt;, tmpl::no_such_type_&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>This operator is <a class="el" href="brigand.html#at">overloaded for lists</a>. When called on a <a class="el" href="brigand.html#map">tmpl::map</a>, this is the same as <a class="el" href="brigand.html#lookup">tmpl::lookup</a>.</dd></dl>
<h3><a class="anchor" id="map_erase"></a>
erase&lt;Map, Key&gt;</h3>
<dl class="section user"><dt></dt><dd>Produces a copy of <code>Map</code> with the element with the key <code>Key</code> removed. If <code>Key</code> is not in the map, returns <code>Map</code> unchanged. <div class="fragment"><div class="line">assert_maps_same&lt;tmpl::erase&lt;example_map, Type1&gt;,</div>
<div class="line">                 tmpl::map&lt;tmpl::pair&lt;Type2, double&gt;&gt;&gt;();</div>
<div class="line">assert_maps_same&lt;tmpl::erase&lt;example_map, Type3&gt;, example_map&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>This operator is overloaded <a class="el" href="brigand.html#erase">for lists</a> and <a class="el" href="brigand.html#set_erase">for sets</a>.</dd></dl>
<h3><a class="anchor" id="map_has_key"></a>
has_key&lt;Map, Key&gt;</h3>
<dl class="section user"><dt></dt><dd>Returns a <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a> of <code>bool</code> indicating whether <code>Map</code> contains the key <code>Key</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::has_key&lt;example_map, Type2&gt;, tmpl::true_type&gt;();</div>
<div class="line">assert_same&lt;tmpl::has_key&lt;example_map, Type3&gt;, tmpl::false_type&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>This operator is <a class="el" href="brigand.html#set_has_key">overloaded for sets</a>.</dd></dl>
<h3><a class="anchor" id="map_insert"></a>
insert&lt;Map, Pair&gt;</h3>
<dl class="section user"><dt></dt><dd>Returns <code>Map</code> with <code>Pair</code> added. If the key of <code>Pair</code> is already in the map, the map is returned unchanged. <div class="fragment"><div class="line">assert_maps_same&lt;tmpl::insert&lt;example_map, tmpl::pair&lt;Type3, int&gt;&gt;,</div>
<div class="line">                 tmpl::map&lt;tmpl::pair&lt;Type1, int&gt;, tmpl::pair&lt;Type2, double&gt;,</div>
<div class="line">                           tmpl::pair&lt;Type3, int&gt;&gt;&gt;();</div>
<div class="line">assert_maps_same&lt;tmpl::insert&lt;example_map, tmpl::pair&lt;Type1, float&gt;&gt;,</div>
<div class="line">                 example_map&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>This operator is <a class="el" href="brigand.html#set_insert">overloaded for sets</a>.</dd></dl>
<h3><a class="anchor" id="keys_as_sequence"></a>
keys_as_sequence&lt;Map, [Head]&gt;</h3>
<dl class="section user"><dt></dt><dd>Returns the keys from <code>Map</code> as a sequence with head <code>Head</code>, defaulting to <a class="el" href="brigand.html#set">tmpl::set</a>. <div class="fragment"><div class="line">assert_sets_same&lt;tmpl::keys_as_sequence&lt;example_map&gt;,</div>
<div class="line">                 tmpl::set&lt;Type1, Type2&gt;&gt;();</div>
<div class="line"><span class="keyword">static_assert</span>(std::is_same_v&lt;tmpl::keys_as_sequence&lt;example_map, List1&gt;,</div>
<div class="line">                             List1&lt;Type1, Type2&gt;&gt; or</div>
<div class="line">              std::is_same_v&lt;tmpl::keys_as_sequence&lt;example_map, List1&gt;,</div>
<div class="line">                             List1&lt;Type2, Type1&gt;&gt;);</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>If the key-value pairs are required, they can be extracted directly from the template arguments of the <a class="el" href="brigand.html#map">tmpl::map</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#values_as_sequence">tmpl::values_as_sequence</a></dd></dl>
<h3><a class="anchor" id="lookup"></a>
lookup&lt;Map, Key&gt;</h3>
<dl class="section user"><dt></dt><dd>Returns the value associated with <code>Key</code> in <code>Map</code>. Returns <a class="el" href="brigand.html#no_such_type_">tmpl::no_such_type_</a> if <code>Key</code> is not in the map. <div class="fragment"><div class="line">assert_same&lt;tmpl::lookup&lt;example_map, Type1&gt;, <span class="keywordtype">int</span>&gt;();</div>
<div class="line">assert_same&lt;tmpl::lookup&lt;example_map, Type3&gt;, tmpl::no_such_type_&gt;();</div>
<div class="line">HAS_LAZY_VERSION(lookup);</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#map_at">tmpl::at</a></dd></dl>
<h3><a class="anchor" id="lookup_at"></a>
lookup_at&lt;Map, Key&gt;</h3>
<dl class="section user"><dt></dt><dd>Returns the value associated with <code>Key</code> in <code>Map</code>, wrapped in a <a class="el" href="brigand.html#type_">tmpl::type_</a>. Returns <code>type_&lt;no_such_type_&gt;</code> if <code>Key</code> is not in the map. This function has no eager version, but is still in the <code>tmpl::lazy</code> namespace. <div class="fragment"><div class="line">assert_same&lt;tmpl::lazy::lookup_at&lt;example_map, Type1&gt;::type,</div>
<div class="line">            tmpl::type_&lt;int&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::lazy::lookup_at&lt;example_map, Type3&gt;::type,</div>
<div class="line">            tmpl::type_&lt;tmpl::no_such_type_&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#lookup">tmpl::lookup</a></dd></dl>
<h3><a class="anchor" id="values_as_sequence"></a>
values_as_sequence&lt;Map, [Head]&gt;</h3>
<dl class="section user"><dt></dt><dd>Returns the values from <code>Map</code> as a sequence with head <code>Head</code>, defaulting to <a class="el" href="brigand.html#list">tmpl::list</a>. <div class="fragment"><div class="line"><span class="keyword">static_assert</span>(std::is_same_v&lt;tmpl::values_as_sequence&lt;example_map&gt;,</div>
<div class="line">                             tmpl::list&lt;int, double&gt;&gt; or</div>
<div class="line">              std::is_same_v&lt;tmpl::values_as_sequence&lt;example_map&gt;,</div>
<div class="line">                             tmpl::list&lt;double, int&gt;&gt;);</div>
<div class="line"><span class="keyword">static_assert</span>(std::is_same_v&lt;tmpl::values_as_sequence&lt;example_map, List1&gt;,</div>
<div class="line">                             List1&lt;int, double&gt;&gt; or</div>
<div class="line">              std::is_same_v&lt;tmpl::values_as_sequence&lt;example_map, List1&gt;,</div>
<div class="line">                             List1&lt;double, int&gt;&gt;);</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>If the key-value pairs are required, they can be extracted directly from the template arguments of the <a class="el" href="brigand.html#map">tmpl::map</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#keys_as_sequence">tmpl::keys_as_sequence</a></dd></dl>
<h2><a class="anchor" id="set_operations"></a>
Operations on sets</h2>
<dl class="section user"><dt></dt><dd>Brigand's <a class="el" href="brigand.html#set">tmpl::set</a> type can be manipulated by several metafunctions.</dd></dl>
<h3><a class="anchor" id="contains"></a>
contains&lt;Set, T&gt;</h3>
<dl class="section user"><dt></dt><dd>Returns a <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a> of <code>bool</code> indicating whether <code>Set</code> contains <code>T</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::contains&lt;tmpl::set&lt;Type1, Type2&gt;, Type1&gt;, tmpl::true_type&gt;();</div>
<div class="line">assert_same&lt;tmpl::contains&lt;tmpl::set&lt;Type1, Type2&gt;, Type3&gt;, tmpl::false_type&gt;();</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="set_erase"></a>
erase&lt;Set, T&gt;</h3>
<dl class="section user"><dt></dt><dd>Produces a copy of <code>Set</code> with the element <code>T</code> removed. If the element is not in the set, returns the set unchanged. <div class="fragment"><div class="line">assert_sets_same&lt;tmpl::erase&lt;tmpl::set&lt;Type1, Type2&gt;, Type1&gt;,</div>
<div class="line">                 tmpl::set&lt;Type2&gt;&gt;();</div>
<div class="line">assert_sets_same&lt;tmpl::erase&lt;tmpl::set&lt;Type1, Type2&gt;, Type3&gt;,</div>
<div class="line">                 tmpl::set&lt;Type1, Type2&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>This operator is overloaded <a class="el" href="brigand.html#erase">for lists</a> and <a class="el" href="brigand.html#map_erase">for maps</a>.</dd></dl>
<h3><a class="anchor" id="set_has_key"></a>
has_key&lt;Set, T&gt;</h3>
<dl class="section user"><dt></dt><dd>Returns a <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a> of <code>bool</code> indicating whether <code>Set</code> contains <code>T</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::has_key&lt;tmpl::set&lt;Type1, Type2&gt;, Type2&gt;, tmpl::true_type&gt;();</div>
<div class="line">assert_same&lt;tmpl::has_key&lt;tmpl::set&lt;Type1, Type2&gt;, Type3&gt;, tmpl::false_type&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>This operator is <a class="el" href="brigand.html#map_has_key">overloaded for maps</a>.</dd></dl>
<h3><a class="anchor" id="set_insert"></a>
insert&lt;Set, T&gt;</h3>
<dl class="section user"><dt></dt><dd>Returns a copy of <code>Set</code> containing an additional element <code>T</code>. If <code>T</code> is already in the set, the set is returned unchanged. <div class="fragment"><div class="line">assert_sets_same&lt;tmpl::insert&lt;tmpl::set&lt;Type1, Type2&gt;, Type3&gt;,</div>
<div class="line">                 tmpl::set&lt;Type1, Type2, Type3&gt;&gt;();</div>
<div class="line">assert_sets_same&lt;tmpl::insert&lt;tmpl::set&lt;Type1, Type2&gt;, Type1&gt;,</div>
<div class="line">                 tmpl::set&lt;Type1, Type2&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>This operator is <a class="el" href="brigand.html#map_insert">overloaded for maps</a>.</dd></dl>
<h2><a class="anchor" id="math"></a>
Mathematical functions</h2>
<dl class="section user"><dt></dt><dd>These perform the same operations at their language counterparts, but on <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a>s (or anything else with a <code>value</code> static member type of type <code>value_type</code>). The results inherit from <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a>s of types noted below.</dd></dl>
<dl class="section user"><dt></dt><dd>These are all lazy metafunctions.</dd></dl>
<h3><a class="anchor" id="math_arithmetic"></a>
Arithmetic operators</h3>
<dl class="section user"><dt></dt><dd>These operations return classes inheriting from <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a>s of the same type as the result of the language operator on their arguments. The integral promotion and conversion rules are applied. (Contrast the <a class="el" href="brigand.html#math_bitwise">bitwise operators</a>.) <div class="fragment"><div class="line">assert_same&lt;tmpl::plus&lt;tmpl::size_t&lt;10&gt;, tmpl::size_t&lt;3&gt;&gt;::type,</div>
<div class="line">            tmpl::size_t&lt;13&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::minus&lt;tmpl::size_t&lt;10&gt;, tmpl::size_t&lt;3&gt;&gt;::type,</div>
<div class="line">            tmpl::size_t&lt;7&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::times&lt;tmpl::size_t&lt;10&gt;, tmpl::size_t&lt;3&gt;&gt;::type,</div>
<div class="line">            tmpl::size_t&lt;30&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::divides&lt;tmpl::size_t&lt;10&gt;, tmpl::size_t&lt;3&gt;&gt;::type,</div>
<div class="line">            tmpl::size_t&lt;3&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::modulo&lt;tmpl::size_t&lt;10&gt;, tmpl::size_t&lt;3&gt;&gt;::type,</div>
<div class="line">            tmpl::size_t&lt;1&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::negate&lt;tmpl::int64_t&lt;10&gt;&gt;::type, tmpl::int64_t&lt;-10&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>The standard library runtime functors have the same names for <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/plus.html">std::plus</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/minus.html">std::minus</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/divides.html">std::divides</a>, and <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/negate.html">std::negate</a>, but the other two are <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/multiplies.html">std::multiplies</a> and <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/modulus.html">std::modulus</a>.</dd></dl>
<h3><a class="anchor" id="math_bitwise"></a>
Bitwise operators</h3>
<dl class="section user"><dt></dt><dd>These operations return classes inheriting from <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a>s of the same type as their first argument's <code>value</code>. This is <em>not</em> generally the same type as the language operator, even when the types of the values of both arguments are the same. (The integer promotion and conversion rules are not applied.) <div class="fragment"><div class="line">assert_same&lt;tmpl::complement&lt;tmpl::uint8_t&lt;0b10001111&gt;&gt;::type,</div>
<div class="line">                             tmpl::uint8_t&lt;0b01110000&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::bitand_&lt;tmpl::uint8_t&lt;0b00111011&gt;,</div>
<div class="line">                          tmpl::uint8_t&lt;0b01010110&gt;&gt;::type,</div>
<div class="line">                          tmpl::uint8_t&lt;0b00010010&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::bitor_&lt;tmpl::uint8_t&lt;0b01100011&gt;,</div>
<div class="line">                         tmpl::uint8_t&lt;0b10100111&gt;&gt;::type,</div>
<div class="line">                         tmpl::uint8_t&lt;0b11100111&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::bitxor_&lt;tmpl::uint8_t&lt;0b11000011&gt;,</div>
<div class="line">                          tmpl::uint8_t&lt;0b00000110&gt;&gt;::type,</div>
<div class="line">                          tmpl::uint8_t&lt;0b11000101&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::shift_left&lt;tmpl::uint8_t&lt;0b00001110&gt;, tmpl::size_t&lt;3&gt;&gt;::type,</div>
<div class="line">                             tmpl::uint8_t&lt;0b01110000&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::shift_right&lt;tmpl::uint8_t&lt;0b10110011&gt;, tmpl::size_t&lt;4&gt;&gt;::type,</div>
<div class="line">                              tmpl::uint8_t&lt;0b00001011&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>The standard library runtime functors are called <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/bit_not.html">std::bit_not</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/bit_and.html">std::bit_and</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/bit_or.html">std::bit_or</a>, and std::bit_xor.</dd></dl>
<h3><a class="anchor" id="math_comparison"></a>
Comparison operators</h3>
<dl class="section user"><dt></dt><dd>These operations return classes inheriting from <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a>s of <code>bool</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::equal_to&lt;tmpl::size_t&lt;1&gt;, tmpl::size_t&lt;2&gt;&gt;::type,</div>
<div class="line">            tmpl::false_type&gt;();</div>
<div class="line">assert_same&lt;tmpl::not_equal_to&lt;tmpl::size_t&lt;1&gt;, tmpl::size_t&lt;2&gt;&gt;::type,</div>
<div class="line">            tmpl::true_type&gt;();</div>
<div class="line">assert_same&lt;tmpl::greater&lt;tmpl::size_t&lt;1&gt;, tmpl::size_t&lt;2&gt;&gt;::type,</div>
<div class="line">            tmpl::false_type&gt;();</div>
<div class="line">assert_same&lt;tmpl::greater_equal&lt;tmpl::size_t&lt;1&gt;, tmpl::size_t&lt;2&gt;&gt;::type,</div>
<div class="line">            tmpl::false_type&gt;();</div>
<div class="line">assert_same&lt;tmpl::less&lt;tmpl::size_t&lt;1&gt;, tmpl::size_t&lt;2&gt;&gt;::type,</div>
<div class="line">            tmpl::true_type&gt;();</div>
<div class="line">assert_same&lt;tmpl::less_equal&lt;tmpl::size_t&lt;1&gt;, tmpl::size_t&lt;2&gt;&gt;::type,</div>
<div class="line">            tmpl::true_type&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>The standard library runtime functors have the same names, such as <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/equal_to.html">std::equal_to</a>.</dd></dl>
<h3><a class="anchor" id="math_logical"></a>
Logical operators</h3>
<dl class="section user"><dt></dt><dd>These operations return classes inheriting from <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a>s of <code>bool</code>. They should only be used on types wrapping <code>bool</code>s. The <code>and_</code> and <code>or_</code> structs can take any number of arguments. <div class="fragment"><div class="line">assert_same&lt;tmpl::and_&lt;&gt;::type, tmpl::true_type&gt;();</div>
<div class="line">assert_same&lt;tmpl::and_&lt;std::true_type, std::false_type&gt;::type,</div>
<div class="line">            tmpl::false_type&gt;();</div>
<div class="line">assert_same&lt;tmpl::or_&lt;&gt;::type, tmpl::false_type&gt;();</div>
<div class="line">assert_same&lt;tmpl::or_&lt;std::true_type, std::false_type, std::false_type&gt;::type,</div>
<div class="line">            tmpl::true_type&gt;();</div>
<div class="line">assert_same&lt;tmpl::xor_&lt;std::true_type, std::false_type&gt;::type,</div>
<div class="line">            tmpl::true_type&gt;();</div>
<div class="line">assert_same&lt;tmpl::not_&lt;std::true_type&gt;::type, tmpl::false_type&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>The standard library runtime functors are called <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/logical_and.html">std::logical_and</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/logical_or.html">std::logical_or</a>, and <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/logical_not.html">std::logical_not</a>. The xor operation is equivalent to <a class="el" href="brigand.html#math_comparison">tmpl::not_equal_to</a>.</dd></dl>
<h3><a class="anchor" id="identity"></a>
identity&lt;T&gt;</h3>
<dl class="section user"><dt></dt><dd>The identity function. Unlike most math functions, this returns the same type as its argument, even if that is not a <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a>. <div class="fragment"><div class="line">assert_same&lt;tmpl::identity&lt;tmpl::size_t&lt;10&gt;&gt;::type, tmpl::size_t&lt;10&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#always">tmpl::always</a></dd></dl>
<h3><a class="anchor" id="max"></a>
max&lt;T1, T2&gt;</h3>
<dl class="section user"><dt></dt><dd>Computes the larger of <code>T1</code> and <code>T2</code>, returning a <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a> of the common type of its arguments. <div class="fragment"><div class="line">assert_same&lt;tmpl::max&lt;tmpl::size_t&lt;10&gt;, tmpl::int32_t&lt;3&gt;&gt;::type,</div>
<div class="line">            tmpl::size_t&lt;10&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="min"></a>
min&lt;T1, T2&gt;</h3>
<dl class="section user"><dt></dt><dd>Computes the smaller of <code>T1</code> and <code>T2</code>, returning a <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a> of the common type of its arguments. <div class="fragment"><div class="line">assert_same&lt;tmpl::min&lt;tmpl::size_t&lt;10&gt;, tmpl::int32_t&lt;3&gt;&gt;::type,</div>
<div class="line">            tmpl::size_t&lt;3&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="next"></a>
next&lt;T&gt;</h3>
<dl class="section user"><dt></dt><dd>Computes <code>T</code> plus one, returning a <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a> of the same type as its argument. <div class="fragment"><div class="line">assert_same&lt;tmpl::next&lt;tmpl::size_t&lt;10&gt;&gt;::type, tmpl::size_t&lt;11&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="prev"></a>
prev&lt;T&gt;</h3>
<dl class="section user"><dt></dt><dd>Computes <code>T</code> minus one, returning a <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a> of the same type as its argument. <div class="fragment"><div class="line">assert_same&lt;tmpl::prev&lt;tmpl::size_t&lt;10&gt;&gt;::type, tmpl::size_t&lt;9&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<h2><a class="anchor" id="misc"></a>
Miscellaneous functions</h2>
<dl class="section user"><dt></dt><dd>Functions that don't fit into any of the other sections.</dd></dl>
<h3><a class="anchor" id="always"></a>
always&lt;T&gt;</h3>
<dl class="section user"><dt></dt><dd>A lazy identity function. <div class="fragment"><div class="line">assert_same&lt;tmpl::always&lt;Type1&gt;::type, Type1&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#identity">tmpl::identity</a></dd></dl>
<h3><a class="anchor" id="apply"></a>
apply&lt;Lambda, [Arguments...]&gt;</h3>
<dl class="section user"><dt></dt><dd>Calls a <a class="el" href="brigand.html#metalambdas">metalambda</a> <code>Lambda</code> with arguments <code>Arguments...</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::apply&lt;std::is_convertible&lt;tmpl::_1, tmpl::_2&gt;,</div>
<div class="line">                        <span class="keyword">const</span> <span class="keywordtype">char</span>*, <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&gt;,</div>
<div class="line">            <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::true_type</a>&gt;();</div>
<div class="line">assert_same&lt;tmpl::apply&lt;std::is_convertible&lt;tmpl::_2, tmpl::_1&gt;,</div>
<div class="line">                        <span class="keyword">const</span> <span class="keywordtype">char</span>*, <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&gt;,</div>
<div class="line">            <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::false_type</a>&gt;();</div>
<div class="ttc" id="abasic_string_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a></div></div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="count"></a>
count&lt;T...&gt;</h3>
<dl class="section user"><dt></dt><dd>Returns the number of template parameters provided as a <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a> of <code>unsigned int</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::count&lt;Type1, Type2, Type1&gt;,</div>
<div class="line">            tmpl::integral_constant&lt;unsigned int, 3&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="conditional_t"></a>
conditional_t&lt;b, TrueResult, FalseResult&gt;</h3>
<dl class="section user"><dt></dt><dd>Returns <code>TrueResult</code> if the <code>bool</code> <code>b</code> is true, otherwise <code>FalseResult</code>. An optimized version of <a class="elRef" href="http://en.cppreference.com/w/cpp/types/conditional.html">std::conditional_t</a>. <div class="fragment"><div class="line">assert_same&lt;tmpl::conditional_t&lt;true, Type1, Type2&gt;, Type1&gt;();</div>
<div class="line">assert_same&lt;tmpl::conditional_t&lt;false, Type1, Type2&gt;, Type2&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is not a Brigand metafunction. It is implemented in SpECTRE.</dd></dl>
<h3><a class="anchor" id="eval_if"></a>
eval_if&lt;Condition, TrueFunction, FalseFunction&gt;</h3>
<dl class="section user"><dt></dt><dd>A lazy metafunction that, if <code>Condition</code> has a true <code>value</code>, evaluates and returns the result of the lazy metafunction (<em>not</em> metalambda) <code>TrueFunction</code>, otherwise, evaluates and returns the result of the lazy metafunction <code>FalseFunction</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::eval_if&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::true_type</a>,</div>
<div class="line">                          tmpl::plus&lt;tmpl::size_t&lt;1&gt;, tmpl::size_t&lt;2&gt;&gt;,</div>
<div class="line">                          tmpl::plus&lt;Type1, Type2&gt;  <span class="comment">// Invalid expression</span></div>
<div class="line">                          &gt;::type,</div>
<div class="line">            tmpl::size_t&lt;3&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>This performs lazy evaluation of conditional branches outside of a metalambda.</dd></dl>
<h3><a class="anchor" id="eval_if_c"></a>
eval_if_c&lt;b, TrueFunction, FalseFunction&gt;</h3>
<dl class="section user"><dt></dt><dd>The same as <a class="el" href="brigand.html#eval_if">tmpl::eval_if</a>, but takes its first argument as a <code>bool</code> instead of a type. <div class="fragment"><div class="line">assert_same&lt;tmpl::eval_if_c&lt;<span class="keyword">true</span>,</div>
<div class="line">                            tmpl::plus&lt;tmpl::size_t&lt;1&gt;, tmpl::size_t&lt;2&gt;&gt;,</div>
<div class="line">                            tmpl::plus&lt;Type1, Type2&gt;  <span class="comment">// Invalid expression</span></div>
<div class="line">                            &gt;::type,</div>
<div class="line">            tmpl::size_t&lt;3&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="has_type"></a>
has_type&lt;Ignored, [T]&gt;</h3>
<dl class="section user"><dt></dt><dd>A lazy metafunction that returns <code>T</code> (defaulting to <code>void</code>), ignoring its first argument. <div class="fragment"><div class="line">assert_same&lt;tmpl::has_type&lt;Type1, Type2&gt;::type, Type2&gt;();</div>
<div class="line">assert_same&lt;tmpl::has_type&lt;Type1&gt;::type, <span class="keywordtype">void</span>&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>This can be used to expand a parameter pack to repetitions of the same type. <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</div>
<div class="line"><span class="keywordtype">bool</span> check_sizes(<span class="keyword">const</span> T&amp;... containers,</div>
<div class="line">                 <span class="keyword">const</span> <span class="keyword">typename</span> tmpl::has_type&lt;T, size_t&gt;::type... sizes) {</div>
<div class="line">  <span class="keywordflow">return</span> (... and (containers.size() == sizes));</div>
<div class="line">}</div>
</div><!-- fragment --> <div class="fragment"><div class="line">CHECK(check_sizes&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;int&gt;</a>&gt;(<span class="stringliteral">&quot;Hello&quot;</span>, {1, 2, 3}, 5, 3));</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="if_"></a>
if_&lt;Condition, TrueResult, FalseResult&gt;</h3>
<dl class="section user"><dt></dt><dd>A lazy metafunction that returns <code>TrueResult</code> if the <code>value</code> static member value of <code>Condition</code> is true, and otherwise <code>FalseResult</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::if_&lt;std::true_type, Type1, Type2&gt;::type, Type1&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The second and third arguments are both evaluated, independent of which is returned. Use <a class="el" href="brigand.html#defer">tmpl::defer</a> or <a class="el" href="brigand.html#eval_if">tmpl::eval_if</a> if this is undesirable.</dd></dl>
<h3><a class="anchor" id="if_c"></a>
if_c&lt;Condition, TrueResult, FalseResult&gt;</h3>
<dl class="section user"><dt></dt><dd>The same as <a class="elRef" href="http://en.cppreference.com/w/cpp/types/conditional.html">std::conditional</a>. <div class="fragment"><div class="line">assert_same&lt;tmpl::if_c&lt;true, Type1, Type2&gt;::type, Type1&gt;();</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="inherit"></a>
inherit&lt;T...&gt;</h3>
<dl class="section user"><dt></dt><dd>A lazy metafunction that produces a type with all of its template arguments as base classes. All the arguments must be unique. <div class="fragment"><div class="line"><span class="comment">// tmpl::type_ is used in this example because base classes must be</span></div>
<div class="line"><span class="comment">// complete types</span></div>
<div class="line"><span class="keyword">static_assert</span>(</div>
<div class="line">    std::is_base_of_v&lt;tmpl::type_&lt;Type2&gt;,</div>
<div class="line">                      tmpl::inherit&lt;tmpl::type_&lt;Type1&gt;, tmpl::type_&lt;Type2&gt;,</div>
<div class="line">                                    tmpl::type_&lt;Type3&gt;&gt;::type&gt;);</div>
</div><!-- fragment --></dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This task can be performed more simply than the algorithm used by Brigand by directly using pack expansions: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</div>
<div class="line"><span class="keyword">struct </span>inherit_pack {</div>
<div class="line">  <span class="keyword">struct </span>type : T... {};</div>
<div class="line">};</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">static_assert</span>(</div>
<div class="line">    std::is_base_of_v&lt;tmpl::type_&lt;Type2&gt;,</div>
<div class="line">                      inherit_pack&lt;tmpl::type_&lt;Type1&gt;, tmpl::type_&lt;Type2&gt;,</div>
<div class="line">                                   tmpl::type_&lt;Type3&gt;&gt;::type&gt;);</div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="brigand.html#empty_base">tmpl::empty_base</a> type is used internally as a sentinel. The result may or may not inherit from <a class="el" href="brigand.html#empty_base">tmpl::empty_base</a>, independently of whether it is supplied as an argument.</dd></dl>
<h3><a class="anchor" id="inherit_linearly"></a>
inherit_linearly&lt;Sequence, NodePattern, [Root]&gt;</h3>
<dl class="section user"><dt></dt><dd>Transforms <code>Sequence</code> into a linked list. The <code>NodePattern</code> must be a class template (<em>not</em> a lazy metafunction) instantiated with metalambdas. The function performs a <a href="https://en.wikipedia.org/wiki/Fold_(higher-order_function)">left fold</a>, with the <code>Root</code> (defaulting to <a class="el" href="brigand.html#empty_base">tmpl::empty_base</a>) as the initial state and the transform function evaluating the arguments to the node pattern. <div class="fragment"><div class="line">assert_same&lt;tmpl::inherit_linearly&lt;List1&lt;Type1, Type2&gt;,</div>
<div class="line">                                   List2&lt;tmpl::_1, tmpl::_2, Type3&gt;&gt;,</div>
<div class="line">            List2&lt;List2&lt;tmpl::empty_base, Type1, Type3&gt;, Type2, Type3&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::inherit_linearly&lt;List1&lt;Type1, Type2&gt;,</div>
<div class="line">                                   List2&lt;tmpl::_1, tmpl::_2, Type3&gt;, Type3&gt;,</div>
<div class="line">            List2&lt;List2&lt;Type3, Type1, Type3&gt;, Type2, Type3&gt;&gt;();</div>
<div class="line">HAS_LAZY_VERSION(inherit_linearly);</div>
</div><!-- fragment --></dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function handles its function-like argument differently from any other function in Brigand. Prefer <a class="el" href="brigand.html#fold">tmpl::fold</a>, which can perform the same task and has a more standard interface.</dd></dl>
<h3><a class="anchor" id="is_set"></a>
is_set&lt;T...&gt;</h3>
<dl class="section user"><dt></dt><dd>Tests if all of its arguments are distinct, producing a <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a> of <code>bool</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::is_set&lt;Type1, Type2, Type3&gt;, tmpl::true_type&gt;();</div>
<div class="line">assert_same&lt;tmpl::is_set&lt;Type1, Type2, Type1&gt;, tmpl::false_type&gt;();</div>
<div class="line">assert_same&lt;tmpl::is_set&lt;&gt;, tmpl::true_type&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is unrelated to the Brigand <a class="el" href="brigand.html#set">tmpl::set</a> type.</dd></dl>
<h3><a class="anchor" id="real_"></a>
real_&lt;RealType, IntType, value&gt;</h3>
<dl class="section user"><dt></dt><dd>Represents a floating point number of type <code>RealType</code> at compile time via its internal memory representation. The value is stored as a <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a> of type <code>IntType</code> with value <code>value</code> (which must be the same size as <code>RealType</code>) and can be extracted at runtime using the conversion operator. Brigand provides the aliases <code>single_&lt;value&gt;</code> and <code>double_&lt;value&gt;</code> with <code>RealType</code> and <code>IntType</code> set to appropriate values. <div class="fragment"><div class="line"><span class="keyword">using</span> three_eighths = tmpl::single_&lt;0x3EC00000&gt;;</div>
<div class="line"><span class="keyword">using</span> minus_one_hundred_thousand_three = tmpl::double_&lt;0xC0F86A3000000000&gt;;</div>
<div class="line">CHECK(<span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(three_eighths{}) == 0.375f);</div>
<div class="line">CHECK(<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(minus_one_hundred_thousand_three{}) == -100003.0);</div>
<div class="line">assert_same&lt;three_eighths::value_type, float&gt;();</div>
<div class="line">assert_same&lt;minus_one_hundred_thousand_three::value_type, double&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>There are no compile-time mathematical functions provided for floating point types. They are opaque (or sometimes treated as integers) until runtime.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Consider whether you really need to represent floating point values at compile time.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/ratio/ratio.html">std::ratio</a></dd></dl>
<h3><a class="anchor" id="repeat"></a>
repeat&lt;Function, Count, Initial&gt;</h3>
<dl class="section user"><dt></dt><dd>Calls a unary eager metafunction <code>Function</code> on <code>Initial</code>, then on the result of that, then on the result of that, and so on, up to <code>Count</code> calls. <div class="fragment"><div class="line">assert_same&lt;tmpl::repeat&lt;Wrapper, tmpl::size_t&lt;3&gt;, Type1&gt;,</div>
<div class="line">            Wrapper&lt;Wrapper&lt;Wrapper&lt;Type1&gt;&gt;&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::repeat&lt;Wrapper, tmpl::size_t&lt;0&gt;, Type1&gt;, Type1&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function has a lazy version, but it cannot be used in a metalambda because the template template parameter prevents manipulation of the parameter list. <div class="fragment"><div class="line">assert_same&lt;tmpl::lazy::repeat&lt;Wrapper, tmpl::size_t&lt;3&gt;, Type1&gt;::type,</div>
<div class="line">            Wrapper&lt;Wrapper&lt;Wrapper&lt;Type1&gt;&gt;&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#make_sequence">tmpl::make_sequence</a></dd></dl>
<h3><a class="anchor" id="sizeof_"></a>
sizeof_&lt;T&gt;</h3>
<dl class="section user"><dt></dt><dd>A lazy metafunction that computes <code>sizeof</code> its argument as an <code>unsigned int</code> <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a>. <div class="fragment"><div class="line">assert_same&lt;tmpl::sizeof_&lt;double&gt;::type,</div>
<div class="line">            tmpl::integral_constant&lt;<span class="keywordtype">unsigned</span> int, <span class="keyword">sizeof</span>(double)&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="substitute"></a>
substitute&lt;Pattern, ArgumentList&gt;</h3>
<dl class="section user"><dt></dt><dd>Substitutes values from <code>ArgumentList</code> for appearances of <a class="el" href="brigand.html#args">tmpl::args</a> (but <em>not</em> <code>tmpl::_1</code> or <code>tmpl::_2</code>) appearing in <code>Pattern</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::substitute&lt;List1&lt;List2&lt;tmpl::_1, tmpl::_2, tmpl::_3&gt;,</div>
<div class="line">                                   tmpl::args&lt;0&gt;, tmpl::args&lt;1&gt;, tmpl::args&lt;2&gt;&gt;,</div>
<div class="line">                             List3&lt;Type1, Type2, Type3&gt;&gt;,</div>
<div class="line">            List1&lt;List2&lt;tmpl::_1, tmpl::_2, Type3&gt;, Type1, Type2, Type3&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="type_from"></a>
type_from&lt;T&gt;</h3>
<dl class="section user"><dt></dt><dd>Extracts the <code>type</code> from <code>T</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::type_from&lt;tmpl::type_&lt;Type1&gt;&gt;, Type1&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function will work on any class with a <code>type</code> type alias, but, when used outside of a metafunction, it should only be used with <a class="el" href="brigand.html#type_">tmpl::type_</a> for clarity.</dd></dl>
<h3><a class="anchor" id="wrap"></a>
wrap&lt;Sequence, Head&gt;</h3>
<dl class="section user"><dt></dt><dd>Replaces the head of <code>Sequence</code> with <code>Head</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::wrap&lt;List1&lt;Type1, Type2&gt;, List2&gt;, List2&lt;Type1, Type2&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function has a lazy version, but it cannot be used in a metalambda because the template template parameter prevents manipulation of the parameter list. <div class="fragment"><div class="line">assert_same&lt;tmpl::lazy::wrap&lt;List1&lt;Type1, Type2&gt;, List2&gt;::type,</div>
<div class="line">            List2&lt;Type1, Type2&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<h2><a class="anchor" id="runtime"></a>
Runtime functionality</h2>
<dl class="section user"><dt></dt><dd>Brigand provides a few C++ functions that execute at runtime.</dd></dl>
<dl class="section user"><dt></dt><dd>The examples in this section use the following definition: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structNonCopyable.html">NonCopyable</a> {</div>
<div class="line">  <a class="code hl_struct" href="structNonCopyable.html">NonCopyable</a>(T t = T{}) : <a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">value</a>(std::move(t)) {}</div>
<div class="line">  <a class="code hl_struct" href="structNonCopyable.html">NonCopyable</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structNonCopyable.html">NonCopyable</a>&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">  <a class="code hl_struct" href="structNonCopyable.html">NonCopyable</a>(<a class="code hl_struct" href="structNonCopyable.html">NonCopyable</a>&amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <a class="code hl_struct" href="structNonCopyable.html">NonCopyable</a>&amp; operator=(<span class="keyword">const</span> <a class="code hl_struct" href="structNonCopyable.html">NonCopyable</a>&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">  <a class="code hl_struct" href="structNonCopyable.html">NonCopyable</a>&amp; operator=(<a class="code hl_struct" href="structNonCopyable.html">NonCopyable</a>&amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  T <a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">value</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</div>
<div class="line">  <span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="keyword">operator</span>()(Args&amp;&amp;... args) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">value</a>(std::forward&lt;Args&gt;(args)...);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="ttc" id="astructNonCopyable_html"><div class="ttname"><a href="structNonCopyable.html">NonCopyable</a></div><div class="ttdef"><b>Definition:</b> TestHelpers.hpp:303</div></div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="for_each_args"></a>
for_each_args(functor, arguments...)</h3>
<dl class="section user"><dt></dt><dd>Calls <code>functor</code> on each of <code>arguments...</code>, in order. Returns <code>functor</code>. <div class="fragment"><div class="line"><span class="keyword">struct </span>Functor {</div>
<div class="line">  Functor() = <span class="keywordflow">default</span>;</div>
<div class="line">  Functor(<span class="keyword">const</span> Functor&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">  Functor(Functor&amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">  Functor&amp; operator=(<span class="keyword">const</span> Functor&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">  Functor&amp; operator=(Functor&amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a> record;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> operator()(<a class="code hl_struct" href="structNonCopyable.html">NonCopyable&lt;int&gt;</a> x) {</div>
<div class="line">    record.push_back(x.value);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code hl_struct" href="structNonCopyable.html">NonCopyable&lt;double&gt;</a>&amp; x) {</div>
<div class="line">    record.push_back(x.value);</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_struct" href="structNonCopyable.html">NonCopyable&lt;double&gt;</a> three_point_five{3.5};</div>
<div class="line">CHECK(tmpl::for_each_args(Functor{}, <a class="code hl_struct" href="structNonCopyable.html">NonCopyable&lt;int&gt;</a>{2}, three_point_five)</div>
<div class="line">          .record == <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{2.0, 3.5});</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This uses a <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html">std::reference_wrapper</a> internally, but I don't see a reason for that. If it were removed then this function could be constexpr starting in C++14.</dd></dl>
<h3><a class="anchor" id="for_each"></a>
for_each&lt;Sequence&gt;(functor)</h3>
<dl class="section user"><dt></dt><dd>Calls <code>functor</code> on <a class="el" href="brigand.html#type_">tmpl::type_</a> objects wrapping each type in <code>Sequence</code>, in order. Returns <code>functor</code>. <div class="fragment"><div class="line"><span class="keyword">struct </span>Functor {</div>
<div class="line">  Functor() = <span class="keywordflow">default</span>;</div>
<div class="line">  Functor(<span class="keyword">const</span> Functor&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">  Functor(Functor&amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">  Functor&amp; operator=(<span class="keyword">const</span> Functor&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">  Functor&amp; operator=(Functor&amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;std::string&gt;</a> record;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">  <span class="keywordtype">void</span> operator()(T <span class="comment">/*t*/</span>) {</div>
<div class="line">    <span class="keyword">using</span> type = tmpl::type_from&lt;T&gt;;</div>
<div class="line">    <span class="keywordflow">if</span> (std::is_same_v&lt;type, int&gt;) {</div>
<div class="line">      record.push_back(<span class="stringliteral">&quot;int&quot;</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (std::is_same_v&lt;type, double&gt;) {</div>
<div class="line">      record.push_back(<span class="stringliteral">&quot;double&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --> <div class="fragment"><div class="line">CHECK(tmpl::for_each&lt;List1&lt;int, double, int&gt;&gt;(Functor{}).record ==</div>
<div class="line">        <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;std::string&gt;</a>{<span class="stringliteral">&quot;int&quot;</span>, <span class="stringliteral">&quot;double&quot;</span>, <span class="stringliteral">&quot;int&quot;</span>});</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="brigand.html#type_from">tmpl::type_from</a></dd></dl>
<h3><a class="anchor" id="select"></a>
select&lt;Condition&gt;(true_result, false_result)</h3>
<dl class="section user"><dt></dt><dd>Returns <code>true_result</code> if <code>Condition</code>'s <code>value</code> member is true, and <code>false_result</code> if it is false. <div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_struct" href="structNonCopyable.html">NonCopyable&lt;std::string&gt;</a> hi{<span class="stringliteral">&quot;Hi&quot;</span>};</div>
<div class="line">CHECK(tmpl::select&lt;std::true_type&gt;(<a class="code hl_struct" href="structNonCopyable.html">NonCopyable&lt;int&gt;</a>{3}, hi).<a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">value</a> == 3);</div>
<div class="line">CHECK(tmpl::select&lt;std::false_type&gt;(<a class="code hl_struct" href="structNonCopyable.html">NonCopyable&lt;int&gt;</a>{3}, hi).<a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">value</a> == <span class="stringliteral">&quot;Hi&quot;</span>);</div>
</div><!-- fragment --></dd></dl>
<h2><a class="anchor" id="external"></a>
External integration</h2>
<dl class="section user"><dt></dt><dd>Brigand provides metafunctions for interfacing with some types from the standard library and Boost. They usually come in pairs, with <code>as_X</code> taking a list and <code>X_wrapper</code> taking a parameter pack. This makes <code>X_wrapper</code> equivalent to the wrapped class.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Avoid the <code>*_wrapper</code> functions in favor of using the class directly.</dd></dl>
<h3><a class="anchor" id="boost_integration"></a>
Boost</h3>
<dl class="section user"><dt></dt><dd>Brigand provides functions to produce the <code>boost::fusion</code> types <code>deque</code>, <code>list</code>, <code>set</code>, and <code>vector</code>, as well as <code>boost::variant</code>. <div class="fragment"><div class="line">assert_same&lt;tmpl::as_fusion_deque&lt;List1&lt;Type1, Type2, Type3&gt;&gt;,</div>
<div class="line">            boost::fusion::deque&lt;Type1, Type2, Type3&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::as_fusion_list&lt;List1&lt;Type1, Type2, Type3&gt;&gt;,</div>
<div class="line">            boost::fusion::list&lt;Type1, Type2, Type3&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::as_fusion_set&lt;List1&lt;Type1, Type2, Type3&gt;&gt;,</div>
<div class="line">            boost::fusion::set&lt;Type1, Type2, Type3&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::as_fusion_vector&lt;List1&lt;Type1, Type2, Type3&gt;&gt;,</div>
<div class="line">            boost::fusion::vector&lt;Type1, Type2, Type3&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::as_variant&lt;List1&lt;Type1, Type2, Type3&gt;&gt;,</div>
<div class="line">            boost::variant&lt;Type1, Type2, Type3&gt;&gt;();</div>
<div class="line"> </div>
<div class="line">assert_same&lt;tmpl::fusion_deque_wrapper&lt;Type1, Type2, Type3&gt;,</div>
<div class="line">            boost::fusion::deque&lt;Type1, Type2, Type3&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::fusion_list_wrapper&lt;Type1, Type2, Type3&gt;,</div>
<div class="line">            boost::fusion::list&lt;Type1, Type2, Type3&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::fusion_set_wrapper&lt;Type1, Type2, Type3&gt;,</div>
<div class="line">            boost::fusion::set&lt;Type1, Type2, Type3&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::fusion_vector_wrapper&lt;Type1, Type2, Type3&gt;,</div>
<div class="line">            boost::fusion::vector&lt;Type1, Type2, Type3&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::variant_wrapper&lt;Type1, Type2, Type3&gt;,</div>
<div class="line">            boost::variant&lt;Type1, Type2, Type3&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>These functions are unavailable if <code>BRIGAND_NO_BOOST_SUPPORT</code> is defined, as is the case in SpECTRE.</dd></dl>
<h3><a class="anchor" id="stl_integration"></a>
STL</h3>
<dl class="section user"><dt></dt><dd>Brigand provides functions to produce the STL types <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a> and <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>. In addition to the usual functions, Brigand provides <code>pair_wrapper_</code>, which is a lazy form of <code>pair_wrapper</code>. The pair functions all assert that they have received two types. <div class="fragment"><div class="line">assert_same&lt;tmpl::as_pair&lt;List1&lt;Type1, Type2&gt;&gt;, <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;Type1, Type2&gt;</a>&gt;();</div>
<div class="line">assert_same&lt;tmpl::as_tuple&lt;List1&lt;Type1, Type2, Type3&gt;&gt;,</div>
<div class="line">            <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;Type1, Type2, Type3&gt;</a>&gt;();</div>
<div class="line"> </div>
<div class="line">assert_same&lt;tmpl::pair_wrapper&lt;Type1, Type2&gt;, <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;Type1, Type2&gt;</a>&gt;();</div>
<div class="line">assert_same&lt;tmpl::tuple_wrapper&lt;Type1, Type2, Type3&gt;,</div>
<div class="line">            <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;Type1, Type2, Type3&gt;</a>&gt;();</div>
<div class="line"> </div>
<div class="line">assert_same&lt;tmpl::pair_wrapper_&lt;Type1, Type2&gt;::type, <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;Type1, Type2&gt;</a>&gt;();</div>
<div class="ttc" id="apair_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a></div></div>
<div class="ttc" id="atuple_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a></div></div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="make_integral"></a>
integral_constant</h3>
<dl class="section user"><dt></dt><dd>Brigand provides two functions for converting from <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a> (or a similar class with a <code>value_type</code> and a <code>value</code>) to <a class="el" href="brigand.html#integral_constant">tmpl::integral_constant</a>. The lazy metafunction <code>make_integral</code> performs this conversion. The <code>as_integral_list</code> eager metafunction performs this operation on all elements of a list. <div class="fragment"><div class="line">assert_same&lt;tmpl::make_integral&lt;std::integral_constant&lt;char, 3&gt;&gt;::type,</div>
<div class="line">            tmpl::integral_constant&lt;char, 3&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::as_integral_list&lt;List1&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::true_type</a>, <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::true_type</a>,</div>
<div class="line">                                         <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::false_type</a>&gt;&gt;,</div>
<div class="line">            List1&lt;tmpl::true_type, tmpl::true_type, tmpl::false_type&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The standard library <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::integer_sequence</a> is not a list of types, and so cannot be used as input to <code>as_integral_list</code>.</dd></dl>
<h3><a class="anchor" id="as_list"></a>
list</h3>
<dl class="section user"><dt></dt><dd>Brigand provides two metafunctions for converting types to Brigand sequences. The more general function, <code>as_sequence</code>, is equivalent to <a class="el" href="brigand.html#wrap">tmpl::wrap</a>. The specialized version, <code>tmpl::as_list</code>, produces a <a class="el" href="brigand.html#list">tmpl::list</a>. <div class="fragment"><div class="line">assert_same&lt;tmpl::as_sequence&lt;std::pair&lt;Type1, Type2&gt;, List1&gt;,</div>
<div class="line">            List1&lt;Type1, Type2&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::as_list&lt;std::pair&lt;Type1, Type2&gt;&gt;, tmpl::list&lt;Type1, Type2&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Using <code>as_list</code> is often not necessary because most metafunctions operate on arbitrary template classes.</dd></dl>
<h3><a class="anchor" id="as_set"></a>
set</h3>
<dl class="section user"><dt></dt><dd>Brigand provides the standard two metafunctions for converting types to Brigand <a class="el" href="brigand.html#set">tmpl::set</a>s. <div class="fragment"><div class="line">assert_same&lt;tmpl::as_set&lt;std::tuple&lt;Type1, Type2, Type3&gt;&gt;,</div>
<div class="line">            tmpl::set&lt;Type1, Type2, Type3&gt;&gt;();</div>
<div class="line">assert_same&lt;tmpl::set_wrapper&lt;Type1, Type2, Type3&gt;,</div>
<div class="line">            tmpl::set&lt;Type1, Type2, Type3&gt;&gt;();</div>
</div><!-- fragment --></dd></dl>
<h1><a class="anchor" id="oddities"></a>
Bugs/Oddities</h1>
<ul>
<li><a class="el" href="brigand.html#push_front">push_front&lt;Sequence, T...&gt;</a> and <a class="el" href="brigand.html#pop_front">pop_front&lt;Sequence, [Count]&gt;</a> have lazy versions, but <a class="el" href="brigand.html#push_back">push_back&lt;Sequence, T...&gt;</a>, and <a class="el" href="brigand.html#pop_back">pop_back&lt;Sequence, [Count]&gt;</a> do not.</li>
<li><a class="el" href="brigand.html#reverse_range">reverse_range&lt;T, start, stop&gt;</a> validates its arguments, but <a class="el" href="brigand.html#range">range&lt;T, start, stop&gt;</a> does not. (Probably because the former is called incorrectly more often.)</li>
<li>Brigand inconsistently uses <code>unsigned int</code> and <code>size_t</code> for size-related things. (Most blatantly, the result of <a class="el" href="brigand.html#sizeof_">sizeof_&lt;T&gt;</a> is represented as an <code>unsigned int</code>.)</li>
<li>Brigand has a file containing operator overloads for <a class="el" href="brigand.html#integral_constant">integral_constant&lt;T, value&gt;</a>s, but it is not included by the main brigand header. They work poorly, mostly because it inexplicably puts them all in namespace std where the compiler can't find them.</li>
</ul>
<h1><a class="anchor" id="TODO"></a>
TODO</h1>
<div class="fragment"><div class="line">2 tmpl::get_source</div>
<div class="line">2 tmpl::get_destination</div>
<div class="line">2 tmpl::edge</div>
</div><!-- fragment --><div class="fragment"><div class="line">./adapted:</div>
<div class="line">fusion.hpp        - Done</div>
<div class="line">integral_list.hpp - Done</div>
<div class="line">list.hpp          - Done</div>
<div class="line">pair.hpp          - Done</div>
<div class="line">tuple.hpp         - Done</div>
<div class="line">variant.hpp       - Done</div>
<div class="line"> </div>
<div class="line">./algorithms:</div>
<div class="line">all.hpp           - Done</div>
<div class="line">any.hpp           - Done</div>
<div class="line">count.hpp         - Done</div>
<div class="line">find.hpp          - Done</div>
<div class="line">flatten.hpp       - Done</div>
<div class="line">fold.hpp          - Done</div>
<div class="line">for_each.hpp      - Done</div>
<div class="line">for_each_args.hpp - Done</div>
<div class="line">index_of.hpp      - Done</div>
<div class="line">is_set.hpp        - Done</div>
<div class="line">merge.hpp         - Done</div>
<div class="line">none.hpp          - Done</div>
<div class="line">partition.hpp     - Done</div>
<div class="line">remove.hpp        - Done</div>
<div class="line">replace.hpp       - Done</div>
<div class="line">reverse.hpp       - Done</div>
<div class="line">select.hpp        - Done</div>
<div class="line">sort.hpp          - Done</div>
<div class="line">split.hpp         - Done</div>
<div class="line">split_at.hpp      - Done</div>
<div class="line">transform.hpp     - Done</div>
<div class="line">wrap.hpp          - Done</div>
<div class="line"> </div>
<div class="line">./functions:</div>
<div class="line">eval_if.hpp  - Done</div>
<div class="line">if.hpp       - Done</div>
<div class="line"> </div>
<div class="line">./functions/arithmetic:</div>
<div class="line">complement.hpp          - Done</div>
<div class="line">divides.hpp             - Done</div>
<div class="line">identity.hpp            - Done</div>
<div class="line">max.hpp                 - Done</div>
<div class="line">min.hpp                 - Done</div>
<div class="line">minus.hpp               - Done</div>
<div class="line">modulo.hpp              - Done</div>
<div class="line">negate.hpp              - Done</div>
<div class="line">next.hpp                - Done</div>
<div class="line">plus.hpp                - Done</div>
<div class="line">prev.hpp                - Done</div>
<div class="line">times.hpp               - Done</div>
<div class="line"> </div>
<div class="line">./functions/bitwise:</div>
<div class="line">bitand.hpp           - Done</div>
<div class="line">bitor.hpp            - Done</div>
<div class="line">bitxor.hpp           - Done</div>
<div class="line">shift_left.hpp       - Done</div>
<div class="line">shift_right.hpp      - Done</div>
<div class="line"> </div>
<div class="line">./functions/comparison:</div>
<div class="line">equal_to.hpp            - Done</div>
<div class="line">greater.hpp             - Done</div>
<div class="line">greater_equal.hpp       - Done</div>
<div class="line">less.hpp                - Done</div>
<div class="line">less_equal.hpp          - Done</div>
<div class="line">not_equal_to.hpp        - Done</div>
<div class="line"> </div>
<div class="line">./functions/lambda:</div>
<div class="line">apply.hpp           - Done</div>
<div class="line">bind.hpp            - Done</div>
<div class="line">substitute.hpp      - Done</div>
<div class="line"> </div>
<div class="line">./functions/logical:</div>
<div class="line">and.hpp              - Done</div>
<div class="line">not.hpp              - Done</div>
<div class="line">or.hpp               - Done</div>
<div class="line">xor.hpp              - Done</div>
<div class="line"> </div>
<div class="line">./functions/misc:</div>
<div class="line">always.hpp        - Done</div>
<div class="line">repeat.hpp        - Done</div>
<div class="line">sizeof.hpp        - Done</div>
<div class="line"> </div>
<div class="line">./sequences:</div>
<div class="line">append.hpp             - Done</div>
<div class="line">at.hpp                 - Done</div>
<div class="line">back.hpp               - Done</div>
<div class="line">clear.hpp              - Done</div>
<div class="line">contains.hpp           - Done</div>
<div class="line">erase.hpp              - Done</div>
<div class="line">filled_list.hpp        - Done</div>
<div class="line">front.hpp              - Done</div>
<div class="line">has_key.hpp            - Done</div>
<div class="line">insert.hpp             - Done</div>
<div class="line">keys_as_sequence.hpp   - Done</div>
<div class="line">list.hpp               - Done</div>
<div class="line">make_sequence.hpp      - Done</div>
<div class="line">map.hpp                - Done</div>
<div class="line">pair.hpp               - Done</div>
<div class="line">range.hpp              - Done</div>
<div class="line">set.hpp                - Done</div>
<div class="line">size.hpp               - Done</div>
<div class="line">values_as_sequence.hpp - Done</div>
<div class="line"> </div>
<div class="line">./types:</div>
<div class="line">args.hpp              - Done</div>
<div class="line">bool.hpp              - Done</div>
<div class="line">empty_base.hpp        - Done</div>
<div class="line">has_type.hpp          - Done</div>
<div class="line">inherit.hpp           - Done</div>
<div class="line">inherit_linearly.hpp  - Done</div>
<div class="line">integer.hpp           - Done</div>
<div class="line">integral_constant.hpp - Done</div>
<div class="line">no_such_type.hpp      - Done</div>
<div class="line">operators.hpp         - Broken and unused</div>
<div class="line">real.hpp              - Done</div>
<div class="line">type.hpp              - Done</div>
<div class="line">voidp.hpp             - Not included by main header.  Special case of has_type.</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dev_guide.html">Developer Guides</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
