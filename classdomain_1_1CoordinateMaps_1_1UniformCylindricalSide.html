<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: domain::CoordinateMaps::UniformCylindricalSide Class Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classdomain_1_1CoordinateMaps_1_1UniformCylindricalSide.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalSide-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">domain::CoordinateMaps::UniformCylindricalSide Class Reference<div class="ingroups"><a class="el" href="group__CoordinateMapsGroup.html">Coordinate Maps</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Map from 3D unit right cylindrical shell to a volume that connects portions of two spherical surfaces.  
 <a href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalSide.html#details">More...</a></p>

<p><code>#include &lt;UniformCylindricalSide.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5093da0764395e8073d9f23e6b9fbafe"><td class="memItemLeft" align="right" valign="top"><a id="a5093da0764395e8073d9f23e6b9fbafe" name="a5093da0764395e8073d9f23e6b9fbafe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UniformCylindricalSide</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 3 &gt; &amp;center_one, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 3 &gt; &amp;center_two, double radius_one, double radius_two, double z_plane_plus_one, double z_plane_minus_one, double z_plane_plus_two, double z_plane_minus_two)</td></tr>
<tr class="separator:a5093da0764395e8073d9f23e6b9fbafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4e768a7cadb3ccc8f9563d12734a94"><td class="memItemLeft" align="right" valign="top"><a id="a4b4e768a7cadb3ccc8f9563d12734a94" name="a4b4e768a7cadb3ccc8f9563d12734a94"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UniformCylindricalSide</b> (<a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalSide.html">UniformCylindricalSide</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a4b4e768a7cadb3ccc8f9563d12734a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9e798716444631c06afce0e45a2043"><td class="memItemLeft" align="right" valign="top"><a id="a3d9e798716444631c06afce0e45a2043" name="a3d9e798716444631c06afce0e45a2043"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UniformCylindricalSide</b> (const <a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalSide.html">UniformCylindricalSide</a> &amp;)=default</td></tr>
<tr class="separator:a3d9e798716444631c06afce0e45a2043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ed0edf76358c5b881e6c6ab76e12a3"><td class="memItemLeft" align="right" valign="top"><a id="ad2ed0edf76358c5b881e6c6ab76e12a3" name="ad2ed0edf76358c5b881e6c6ab76e12a3"></a>
<a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalSide.html">UniformCylindricalSide</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalSide.html">UniformCylindricalSide</a> &amp;)=default</td></tr>
<tr class="separator:ad2ed0edf76358c5b881e6c6ab76e12a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d07bbe3584050804eb7a006501619bb"><td class="memItemLeft" align="right" valign="top"><a id="a5d07bbe3584050804eb7a006501619bb" name="a5d07bbe3584050804eb7a006501619bb"></a>
<a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalSide.html">UniformCylindricalSide</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalSide.html">UniformCylindricalSide</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a5d07bbe3584050804eb7a006501619bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b207e38072d7c87ed41b66d9c2f7fce"><td class="memTemplParams" colspan="2"><a id="a4b207e38072d7c87ed41b66d9c2f7fce" name="a4b207e38072d7c87ed41b66d9c2f7fce"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b207e38072d7c87ed41b66d9c2f7fce"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; tt::remove_cvref_wrap_t&lt; T &gt;, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator()</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 3 &gt; &amp;source_coords) const</td></tr>
<tr class="separator:a4b207e38072d7c87ed41b66d9c2f7fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305ce3c740e9383ac04b33085f3239ba"><td class="memItemLeft" align="right" valign="top"><a id="a305ce3c740e9383ac04b33085f3239ba" name="a305ce3c740e9383ac04b33085f3239ba"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>inverse</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 3 &gt; &amp;target_coords) const</td></tr>
<tr class="memdesc:a305ce3c740e9383ac04b33085f3239ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse function is only callable with doubles because the inverse might fail if called for a point out of range, and it is unclear what should happen if the inverse were to succeed for some points in a <a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a> but fail for other points. <br /></td></tr>
<tr class="separator:a305ce3c740e9383ac04b33085f3239ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4eb37ac03a838725e27454fbeb1c525"><td class="memTemplParams" colspan="2"><a id="ae4eb37ac03a838725e27454fbeb1c525" name="ae4eb37ac03a838725e27454fbeb1c525"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae4eb37ac03a838725e27454fbeb1c525"><td class="memTemplItemLeft" align="right" valign="top">tnsr::Ij&lt; tt::remove_cvref_wrap_t&lt; T &gt;, 3, <a class="el" href="structFrame_1_1NoFrame.html">Frame::NoFrame</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>jacobian</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 3 &gt; &amp;source_coords) const</td></tr>
<tr class="separator:ae4eb37ac03a838725e27454fbeb1c525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d01640197ed38ffb34a63c97676ee1"><td class="memTemplParams" colspan="2"><a id="a29d01640197ed38ffb34a63c97676ee1" name="a29d01640197ed38ffb34a63c97676ee1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a29d01640197ed38ffb34a63c97676ee1"><td class="memTemplItemLeft" align="right" valign="top">tnsr::Ij&lt; tt::remove_cvref_wrap_t&lt; T &gt;, 3, <a class="el" href="structFrame_1_1NoFrame.html">Frame::NoFrame</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inv_jacobian</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 3 &gt; &amp;source_coords) const</td></tr>
<tr class="separator:a29d01640197ed38ffb34a63c97676ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb407c04509306e02d70a0cfb19c3370"><td class="memItemLeft" align="right" valign="top"><a id="abb407c04509306e02d70a0cfb19c3370" name="abb407c04509306e02d70a0cfb19c3370"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pup</b> (PUP::er &amp;p)</td></tr>
<tr class="separator:abb407c04509306e02d70a0cfb19c3370"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7d9166b4c1565c6e726de644faef3baa"><td class="memItemLeft" align="right" valign="top"><a id="a7d9166b4c1565c6e726de644faef3baa" name="a7d9166b4c1565c6e726de644faef3baa"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_identity</b> ()</td></tr>
<tr class="separator:a7d9166b4c1565c6e726de644faef3baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a45297c28ac26e7a89b025c6c403b079a"><td class="memItemLeft" align="right" valign="top"><a id="a45297c28ac26e7a89b025c6c403b079a" name="a45297c28ac26e7a89b025c6c403b079a"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>dim</b> = 3</td></tr>
<tr class="separator:a45297c28ac26e7a89b025c6c403b079a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0a0f36941ab7f88681e3a5feb8b30135"><td class="memItemLeft" align="right" valign="top"><a id="a0a0f36941ab7f88681e3a5feb8b30135" name="a0a0f36941ab7f88681e3a5feb8b30135"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalSide.html">UniformCylindricalSide</a> &amp;lhs, const <a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalSide.html">UniformCylindricalSide</a> &amp;rhs)</td></tr>
<tr class="separator:a0a0f36941ab7f88681e3a5feb8b30135"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Map from 3D unit right cylindrical shell to a volume that connects portions of two spherical surfaces. </p>
<div class="image">
<object type="image/svg+xml" data="UniformCylSide.svg" style="pointer-events: none;"></object>
<div class="caption">
A hollow cylinder maps to the shaded region.</div></div>
<h3>Details</h3>
<p >Consider two spheres with centers \(C_1\) and \(C_2\), and radii \(R_1\) and \(R_2\). Sphere 1 is assumed to be contained inside Sphere 2. Let sphere 1 be intersected by two planes normal to the \(z\) axis and located at \(z = z^{\pm}_{\mathrm{P}1}\), and let sphere 2 be intersected by two planes normal to the \(z\) axis and located at \(z = z^{\pm}_{\mathrm{P}2}\). Here we assume that \(z^{-}_{\mathrm{P}2} \leq z^{-}_{\mathrm{P}1}&lt; z^{+}_{\mathrm{P}1} \leq z^{+}_{\mathrm{P}2}\).</p>
<p ><a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalSide.html" title="Map from 3D unit right cylindrical shell to a volume that connects portions of two spherical surfaces...">UniformCylindricalSide</a> maps a 3D unit right cylindrical shell (with coordinates \((\bar{x},\bar{y},\bar{z})\) such that \(-1\leq\bar{z}\leq 1\) and \(1 \leq \bar{x}^2+\bar{y}^2 \leq 4\), where the values of 1 and 2 for the inner and outer cylindrical radii are arbitrary choices but are required by <a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalSide.html" title="Map from 3D unit right cylindrical shell to a volume that connects portions of two spherical surfaces...">UniformCylindricalSide</a>) to the shaded area in the figure above (with coordinates \((x,y,z)\)). The "inner surface" of the cylindrical shell \(\bar{x}^2+\bar{y}^2=1\) is mapped to the portion of sphere 1 that has \(z^{-}_{\mathrm{P}1} \leq z \leq z^{+}_{\mathrm{P}1} \), and on this portion of the sphere the cosine of the polar angular coordinate \(\cos\theta_1 =(z-C_1^z)/R_1\) is uniform in \(\bar{z}\), and the angular coordinate \(\phi_1 = \atan((y-C_1^y)/(x-C_1^x))\) is the same as \(\phi = \atan(\bar{y}/\bar{x})\). Likewise, the "outer surface" of the cylindrical shell \(\bar{x}^2+\bar{y}^2=4\) is mapped to the portion of sphere 2 that has \(z^{-}_{\mathrm{P}2} \leq z \leq z^{+}_{\mathrm{P}2} \), and on this portion of the sphere the cosine of the azimuthal angular coordinate \(\cos\theta_2 = (z-C_2^z)/R_2\) is uniform in \(\bar{z}\), and the angular coordinate \(\phi_2 = \atan((y-C_2^y)/(x-C_2^x))\) is the same as \(\phi\).</p>
<p ><a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalSide.html" title="Map from 3D unit right cylindrical shell to a volume that connects portions of two spherical surfaces...">UniformCylindricalSide</a> is different from <a class="el" href="classdomain_1_1CoordinateMaps_1_1CylindricalSide.html" title="Map from a 3D unit right cylindrical shell to a volume that connects portions of two spherical surfac...">CylindricalSide</a> because of the distribution of points on the spheres, and because for <a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalSide.html" title="Map from 3D unit right cylindrical shell to a volume that connects portions of two spherical surfaces...">UniformCylindricalSide</a> the mapped portion of both Sphere 1 and Sphere 2 are bounded by planes of constant \(z\), whereas for <a class="el" href="classdomain_1_1CoordinateMaps_1_1CylindricalSide.html" title="Map from a 3D unit right cylindrical shell to a volume that connects portions of two spherical surfac...">CylindricalSide</a> only one of the mapped portions is bounded by a plane (except for specially chosen map parameters). Note that <a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalSide.html" title="Map from 3D unit right cylindrical shell to a volume that connects portions of two spherical surfaces...">UniformCylindricalSide</a> can be used to construct maps that connect an arbitrary number of nested spheres; this is not possible for <a class="el" href="classdomain_1_1CoordinateMaps_1_1CylindricalSide.html" title="Map from a 3D unit right cylindrical shell to a volume that connects portions of two spherical surfac...">CylindricalSide</a> for more than 3 nested spheres because of this asymmetry between <a class="el" href="classdomain_1_1CoordinateMaps_1_1CylindricalSide.html" title="Map from a 3D unit right cylindrical shell to a volume that connects portions of two spherical surfac...">CylindricalSide</a>'s two spherical surfaces.</p>
<p >Note that the entire region between Sphere 1 and Sphere 2 can be covered by a single cylindrical shell (mapped using <a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalSide.html" title="Map from 3D unit right cylindrical shell to a volume that connects portions of two spherical surfaces...">UniformCylindricalSide</a>) and two cylinders (each mapped by <a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalEndcap.html" title="Map from 3D unit right cylinder to a volume that connects portions of two spherical surfaces.">UniformCylindricalEndcap</a>).</p>
<p ><a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalSide.html" title="Map from 3D unit right cylindrical shell to a volume that connects portions of two spherical surfaces...">UniformCylindricalSide</a> is intended to be composed with <code><a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html" title="Map from a square or cube to a wedge.">Wedge</a>&lt;2&gt;</code> maps to construct a portion of a cylindrical domain for a binary system.</p>
<p ><a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalSide.html" title="Map from 3D unit right cylindrical shell to a volume that connects portions of two spherical surfaces...">UniformCylindricalSide</a> can be used to construct a domain that is similar to, but not identical to, the one described briefly in the Appendix of <a class="el" href="citelist.html#CITEREF_Buchman:2012dw">[30]</a>. <a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalSide.html" title="Map from 3D unit right cylindrical shell to a volume that connects portions of two spherical surfaces...">UniformCylindricalSide</a> is used to construct the Blocks analogous to those labeled 'CA cylinder', 'EA cylinder', 'CB cylinder', 'EE cylinder', and 'EB cylinder' in Figure 20 of that paper.</p>
<p ><a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalSide.html" title="Map from 3D unit right cylindrical shell to a volume that connects portions of two spherical surfaces...">UniformCylindricalSide</a> provides the following functions:</p>
<h2><a class="anchor" id="autotoc_md314"></a>
operator()</h2>
<p ><code>operator()</code> maps \((\bar{x},\bar{y},\bar{z})\) to \((x,y,z)\) according to</p>
<p class="formulaDsp">
\begin{align} x &amp;= C_1^x+\lambda(C_2^x-C_1^x) + \cos\phi\left(R_1\sin\theta_1 + \lambda(R_2\sin\theta_2-R_1\sin\theta_1)\right), \label{eq:x0} \\ y &amp;= C_1^y+\lambda(C_2^y-C_1^y) + \sin\phi\left(R_1\sin\theta_1 + \lambda(R_2\sin\theta_2-R_1\sin\theta_1)\right), \label{eq:x1} \\ z &amp;= C_1^z+\lambda(C_2^z-C_1^z) + R_1\cos\theta_1 + \lambda(R_2\cos\theta_2-R_1\cos\theta_1) \label{eq:x2}. \end{align}
</p>
<p >Here </p><p class="formulaDsp">
\begin{align} \lambda &amp;= \bar{\rho}-1,\label{eq:lambdafromrhobar}\\ \cos\theta_1 &amp;= \cos\theta_{1 \mathrm{max}} + \left(\cos\theta_{1 \mathrm{min}}-\cos\theta_{1 \mathrm{max}}\right) \frac{\bar{z}+1}{2}\label{eq:deftheta1}\\ \cos\theta_2 &amp;= \cos\theta_{2 \mathrm{max}} + \left(\cos\theta_{2 \mathrm{min}}- \cos\theta_{2 \mathrm{max}}\right) \frac{\bar{z}+1}{2}\label{eq:deftheta2}\\ \phi &amp;= \atan(\bar{y}/\bar{x})\label{eq:defphi}, \end{align}
</p>
<p> where \(\theta_{1 \mathrm{min}}\), \(\theta_{2 \mathrm{min}}\), \(\theta_{1 \mathrm{max}}\), and \(\theta_{2 \mathrm{max}}\) are defined by </p><p class="formulaDsp">
\begin{align} \label{eq:deftheta1min} \cos(\theta_{1\mathrm{min}}) &amp;= (z^{+}_{\mathrm{P}1}-C_1^z)/R_1,\\ \cos(\theta_{1\mathrm{max}}) &amp;= (z^{-}_{\mathrm{P}1}-C_1^z)/R_1,\\ \cos(\theta_{2\mathrm{min}}) &amp;= (z^{+}_{\mathrm{P}2}-C_2^z)/R_2,\\ \label{eq:deftheta2max} \cos(\theta_{2\mathrm{max}}) &amp;= (z^{-}_{\mathrm{P}2}-C_2^z)/R_2, \end{align}
</p>
<p> and </p><p class="formulaDsp">
\begin{align} \bar{\rho} &amp;= \sqrt{\bar{x}^2+\bar{y}^2}/\bar{R} \label{eq:defrhobar}, \end{align}
</p>
<p> where \(\bar{R}\) is the inner radius of the cylindrical shell in barred coordinates, which is always unity.</p>
<p >Note that \(\theta_{1\mathrm{min}}&lt;\theta_{1\mathrm{max}}\) but \(\cos\theta_{1\mathrm{min}}&gt;\cos\theta_{1\mathrm{max}}\) (and same for sphere 2).</p>
<p >Also note that Eqs. ( \(\ref{eq:deftheta1}\)) and ( \(\ref{eq:deftheta2}\)) can be simplified using Eqs. ( \(\ref{eq:deftheta1min}\)- \(\ref{eq:deftheta2max}\)): </p><p class="formulaDsp">
\begin{align} R_1\cos\theta_1 &amp;= z^{-}_{\mathrm{P}1}-C_1^z +(z^{+}_{\mathrm{P}1}-z^{-}_{\mathrm{P}1}) \frac{\bar{z}+1}{2}\label{eq:deftheta1alt}\\ R_2\cos\theta_2 &amp;= z^{-}_{\mathrm{P}2}-C_2^z +(z^{+}_{\mathrm{P}2}-z^{-}_{\mathrm{P}2}) \frac{\bar{z}+1}{2}\label{eq:deftheta2alt}\\ \end{align}
</p>
<h2><a class="anchor" id="autotoc_md315"></a>
inverse</h2>
<p >Given \((x,y,z)\) we want to find \((\bar{x},\bar{y},\bar{z})\). From Eqs. ( \(\ref{eq:x2}\)), ( \(\ref{eq:deftheta1alt}\)), and ( \(\ref{eq:deftheta2alt}\)) we can write \(\bar{z}\) as a function of \(\lambda\):</p>
<p class="formulaDsp">
\begin{align} \frac{1+\bar{z}}{2} &amp;= \frac{z + \lambda (z^{-}_{\mathrm{P}1}-z^{-}_{\mathrm{P}2}) - z^{-}_{\mathrm{P}1}} {(1-\lambda)(z^{+}_{\mathrm{P}1}-z^{-}_{\mathrm{P}1}) + \lambda(z^{+}_{\mathrm{P}2}-z^{-}_{\mathrm{P}2})} \label{eq:zbar_from_lambda}, \end{align}
</p>
<p> Note that the denominator of Eq. ( \(\ref{eq:zbar_from_lambda}\)) is always positive because \(0\leq\lambda\leq 1\), \(z^{+}_{\mathrm{P}1}&gt;z^{-}_{\mathrm{P}1}\), and \(z^{+}_{\mathrm{P}2}&gt;z^{-}_{\mathrm{P}2}\).</p>
<p >By eliminating \(\phi\) from Eqs. ( \(\ref{eq:x0}\)) and ( \(\ref{eq:x1}\)) we find that \(\lambda\) is the solution of \(Q(\lambda)=0\), where</p>
<p class="formulaDsp">
\begin{align} Q(\lambda) &amp;= \left(x-C_1^x-\lambda(C_2^x-C_1^x)\right)^2+ \left(y-C_1^y-\lambda(C_2^y-C_1^y)\right)^2- \left((1-\lambda)R_1\sin\theta_1 + \lambda R_2\sin\theta_2\right)^2.\label{eq:defQ} \end{align}
</p>
<p> Here \(\theta_1\) and \(\theta_2\) are functions of \(\bar{z}\) through Eqs. ( \(\ref{eq:deftheta1alt}\)) and ( \(\ref{eq:deftheta2alt}\)), and \(\bar{z}\) is a function of \(\lambda\) through Eq. ( \(\ref{eq:zbar_from_lambda}\)).</p>
<p >We solve \(Q(\lambda)=0\) numerically; it is a one-dimensional root-finding problem.</p>
<p >Once we have determined \(\lambda\), we then obtain \(\bar{z}\) from Eq. ( \(\ref{eq:zbar_from_lambda}\)), and we obtain \(\phi\) from</p>
<p class="formulaDsp">
\begin{align} \tan\phi &amp;= \frac{y-C_1^y-\lambda(C_2^y-C_1^y)}{x-C_1^x-\lambda(C_2^x-C_1^x)}. \end{align}
</p>
<p >Then \(\bar{\rho}\) is obtained from Eq. ( \(\ref{eq:lambdafromrhobar}\)) and \(\bar{x}\) and \(\bar{y}\) are obtained from</p>
<p class="formulaDsp">
\begin{align} \bar{x} &amp;= \bar{\rho}\bar{R}\cos\phi,\\ \bar{y} &amp;= \bar{\rho}\bar{R}\sin\phi. \end{align}
</p>
<h3><a class="anchor" id="autotoc_md316"></a>
Considerations when root-finding.</h3>
<p >We solve \(Q(\lambda)=0\) numerically for \(\lambda\), where \(Q(\lambda)\) is given by Eq. ( \(\ref{eq:defQ}\)).</p>
<p ><a class="anchor" id="autotoc_md317"></a> </p><h5>min/max values of \(\lambda\):</h5>
<p >Note that the root we care about must have \(-1\leq\bar{z}\leq 1\); therefore from Eq. ( \(\ref{eq:zbar_from_lambda}\)) we have</p>
<p class="formulaDsp">
\begin{align} \lambda_{\mathrm{min}} &amp;= \mathrm{max}\left\{0, \frac{z-z^{+}_{\mathrm{P}1}} {(z^{+}_{\mathrm{P}2}-z^{+}_{\mathrm{P}1})}, \frac{z^{-}_{\mathrm{P}1}-z} {(z^{-}_{\mathrm{P}1}-z^{-}_{\mathrm{P}2})} \right\}\label{eq:lambdamin} \end{align}
</p>
<p> In the case where \(z^{+}_{\mathrm{P}2}=z^{+}_{\mathrm{P}1}\) we treat the middle term in Eq.( \(\ref{eq:lambdamin}\)) as zero since in that case \(z-z^{+}_{\mathrm{P}1}\) can never be positive for \(x^2\) in the range of the map, and for \(z=z^{+}_{\mathrm{P}2}=z^{+}_{\mathrm{P}1}\) it turns out that ( \(\ref{eq:zbar_from_lambda}\)) places no restriction on \(\lambda_{\mathrm{min}}\). For the same reason, if \(z^{-}_{\mathrm{P}2}=z^{-}_{\mathrm{P}1}\) we treat the last term in Eq.( \(\ref{eq:lambdamin}\)) as zero.</p>
<p >We look for a root only between \(\lambda_{\mathrm{min}}\) and \(\lambda_{\mathrm{max}}=1\).</p>
<p ><a class="anchor" id="autotoc_md318"></a> </p><h5>Roots within roundoff of min or max \(\lambda\)</h5>
<p >Sometimes a root is within roundoff of \(\lambda_{\mathrm{min}}\). In this case, the root might not be bracketed by \([\lambda_{\mathrm{min}},\lambda_{\mathrm{max}}]\) if the root is slightly outside that interval by roundoff error. If we find that \(Q(\lambda_{\mathrm{min}})\) is near zero but has the wrong sign, then we slightly expand the interval as follows:</p>
<p class="formulaDsp">
\begin{align} \lambda_{\mathrm{min}} \to \lambda_{\mathrm{min}} - 2 \frac{Q(\lambda_{\mathrm{min}})}{Q&#39;(\lambda_{\mathrm{min}})}, \end{align}
</p>
<p >where \(Q&#39;(\lambda_{\mathrm{min}})\) is the derivative of the function in Eq. ( \(\ref{eq:defQ}\)). Note that without the factor of 2, this is a Newton-Raphson step; the factor of 2 is there to overcompensate so that the new \(\lambda_{\mathrm{min}}\) brackets the root.</p>
<p >Note that by differentiating Eqs. ( \(\ref{eq:defQ}\)) and ( \(\ref{eq:zbar_from_lambda}\)), one obtains</p>
<p class="formulaDsp">
\begin{align} Q&#39;(\lambda) =&amp; -2 \left[ \left(x-C_1^x-\lambda(C_2^x-C_1^x)\right)(C_2^x-C_1^x)+ \left(y-C_1^y-\lambda(C_2^y-C_1^y)\right)(C_2^y-C_1^y) \right]\nonumber \\ &amp; -\left[ 2(R_2\sin\theta_2-R_1\sin\theta_1) -(1-\lambda)\cot\theta_1 (z^{+}_{\mathrm{P}1}-z^{-}_{\mathrm{P}1}) \frac{d\bar{z}}{d\lambda} \right. \nonumber \\ &amp; \left.\qquad -\lambda \cot\theta_2 (z^{+}_{\mathrm{P}2}-z^{-}_{\mathrm{P}2}) \frac{d\bar{z}}{d\lambda} \right] \left((1-\lambda)R_1\sin\theta_1 + \lambda R_2\sin\theta_2\right), \label{eq:defQderiv} \end{align}
</p>
<p >where </p><p class="formulaDsp">
\begin{align} \frac{d\bar{z}}{d\lambda} &amp;= \frac{(1-\bar{z})(z^{-}_{\mathrm{P}1}-z^{-}_{\mathrm{P}2}) -(1+\bar{z})(z^{+}_{\mathrm{P}2}-z^{+}_{\mathrm{P}1})} {(1-\lambda)(z^{+}_{\mathrm{P}1}-z^{-}_{\mathrm{P}1}) + \lambda(z^{+}_{\mathrm{P}2}-z^{-}_{\mathrm{P}2})} \label{eq:dzbar_dlambda}. \end{align}
</p>
<p >A root within roundoff of \(\lambda_{\mathrm{max}}\) is treated similarly.</p>
<h4><a class="anchor" id="autotoc_md319"></a>
Special cases:</h4>
<p >For some points on the boundary of the mapped domain, \(\lambda_{\mathrm{min}}\) will be within roundoff of \(\lambda=1\). We check explicitly for this case, and we compute the root as exactly \(\lambda=1\).</p>
<h3><a class="anchor" id="autotoc_md320"></a>
Quick rejection of points out of range of the map.</h3>
<p >It is expected that <code><a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalSide.html#a305ce3c740e9383ac04b33085f3239ba" title="The inverse function is only callable with doubles because the inverse might fail if called for a poi...">inverse()</a></code> will often be passed points \((x,y,z)\) that are out of the range of the map; in this case <code><a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalSide.html#a305ce3c740e9383ac04b33085f3239ba" title="The inverse function is only callable with doubles because the inverse might fail if called for a poi...">inverse()</a></code> returns a <code>std::nullopt</code>. To avoid the difficulty and expense of attempting to solve \(Q(\lambda)=0\) numerically for such points (and then having this solution fail), it is useful to quickly reject points \((x,y,z)\) that are outside the range of the map.</p>
<p >Any point in the range of the map must be inside or on sphere 2, and it must be outside or on sphere 1, so the inverse map can immediately return a default-constructed <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;double, 3&gt;&gt;</code> for a point that does not satisfy these conditions.</p>
<p >Likewise, the inverse map can immediately reject any point with \(z &lt; z^{-}_{\mathrm{P}2}\) or \(z &gt; z^{+}_{\mathrm{P}2}\).</p>
<p >Finally, for \(z^{+}_{\mathrm{P}2}\neq z^{+}_{\mathrm{P}1}\), consider the circle \(S^{+}_1\) defining the intersection of sphere 1 and the plane \(z = z^{+}_{\mathrm{P}1}\); this circle has radius \(r_1 = R_1 \sin\theta_{1\mathrm{min}}\). Similarly, the circle \(S^{+}_2\) defining the intersection of sphere 2 and the plane \(z = z^{+}_{\mathrm{P}2}\) has radius \(r_2 = R_2 \sin\theta_{2\mathrm{min}}\). Now consider the cone that passes through these two circles. A point in the range of the map must be outside (where "outside" means farther from the \(z\) axis) or on this cone. The cone can be defined parametrically as</p>
<p class="formulaDsp">
\begin{align} x_c &amp;= C_1^x + \tilde{\lambda}(C_2^x-C_1^x) + \cos\varphi (r_1 + \tilde{\lambda} (r_2 -r_1)),\\ y_c &amp;= C_1^y + \tilde{\lambda}(C_2^y-C_1^y),+ \sin\varphi (r_1 + \tilde{\lambda} (r_2 -r_1)),\\ z_c &amp;= z^{+}_{\mathrm{P}1} + \tilde{\lambda}(z^{+}_{\mathrm{P}2}-z^{+}_{\mathrm{P}1}), \end{align}
</p>
<p >where \((x_c,y_c,z_c)\) is a point on the cone, and the two parameters defining a point on the cone are the angle \(\varphi\) around the cone and the parameter \(\tilde{\lambda}\), which is defined to be zero on \(S^{+}_1\) and unity on \(S^{+}_2\).</p>
<p >Given an arbitrary point \((x, y, z)\), we can determine whether or not that point is inside the cone as follows. First determine</p>
<p class="formulaDsp">
\begin{align} \tilde{\lambda} &amp;= \frac{z - z^{+}_{\mathrm{P}1}} {z^{+}_{\mathrm{P}2}-z^{+}_{\mathrm{P}1}}, \\ \tilde{x} &amp;= x - C_1^x - \tilde{\lambda} (C_2^x-C_1^x),\\ \tilde{y} &amp;= y - C_1^y - \tilde{\lambda} (C_2^y-C_1^y).\\ \end{align}
</p>
<p >Then the condition for the point to be outside or on the cone is </p><p class="formulaDsp">
\begin{align} \sqrt{\tilde{x}^2+\tilde{y}^2} \ge r_1 + (r_2-r_1)\tilde{\lambda}. \end{align}
</p>
<p >The inverse map therefore rejects any points that do not satisfy this criterion. The cone criterion makes sense only for points with \(z\geq z^{+}_{\mathrm{P}1}\).</p>
<p >For \(z^{-}_{\mathrm{P}2} \neq z^{-}_{\mathrm{P}1}\), a similar cone can be constructed for the southern hemisphere. That cone passes through the circle \(S^{-}_1\) defining the intersection of sphere 1 and the plane \(z = z^{-}_{\mathrm{P}1}\) and the circle \(S^{-}_2\) defining the intersection of sphere 2 and the plane \(z = z^{-}_{\mathrm{P}2}\). The inverse map rejects any point that is inside that cone as well, provided that the point has \(z\leq z^{-}_{\mathrm{P}1}\). For points with \(z &gt; z^{-}_{\mathrm{P}1}\) checking the cone criterion does not make sense.</p>
<h2><a class="anchor" id="autotoc_md321"></a>
jacobian</h2>
<p >From Eqs. ( \(\ref{eq:deftheta1alt}\)) and ( \(\ref{eq:deftheta2alt}\)) we see that \(\theta_1\) and \(\theta_2\) depend on \(\bar{z}\) and are independent of \(\bar{x}\) and \(\bar{y}\), and that </p><p class="formulaDsp">
\begin{align} \frac{\partial (R_1\cos\theta_1)}{\partial\bar{z}} &amp;= \frac{1}{2}(z^{+}_{\mathrm{P}1}-z^{-}_{\mathrm{P}1}), \label{eq:dcostheta1} \\ \frac{\partial (R_2\cos\theta_2)}{\partial\bar{z}} &amp;= \frac{1}{2}(z^{+}_{\mathrm{P}2}-z^{-}_{\mathrm{P}2}), \label{eq:dcostheta2} \\ \frac{\partial (R_1\sin\theta_1)}{\partial\bar{z}} &amp;= -\frac{1}{2}\cot\theta_1 (z^{+}_{\mathrm{P}1}-z^{-}_{\mathrm{P}1}), \label{eq:dsintheta1} \\ \frac{\partial (R_2\sin\theta_2)}{\partial\bar{z}} &amp;= -\frac{1}{2}\cot\theta_2(z^{+}_{\mathrm{P}2}-z^{-}_{\mathrm{P}2}), \label{eq:dsintheta2} \end{align}
</p>
<p >Also, from Eqs. ( \(\ref{eq:defphi}\)) and ( \(\ref{eq:defrhobar}\)) we have </p><p class="formulaDsp">
\begin{align} \frac{\partial\cos\phi}{\partial\bar{x}} &amp;= \frac{\bar{y}^2}{\bar{R}^3\bar{\rho}^3}, \label{eq:dcosphidxbar} \\ \frac{\partial\cos\phi}{\partial\bar{y}} &amp;= -\frac{\bar{x}\bar{y}}{\bar{R}^3\bar{\rho}^3}, \label{eq:dcosphidybar} \\ \frac{\partial\sin\phi}{\partial\bar{x}} &amp;= -\frac{\bar{x}\bar{y}}{\bar{R}^3\bar{\rho}^3}, \label{eq:dsinphidxbar} \\ \frac{\partial\sin\phi}{\partial\bar{y}} &amp;= \frac{\bar{x}^2}{\bar{R}^3\bar{\rho}^3}, \label{eq:dsinphidybar} \end{align}
</p>
<p> and we know that \(\phi\) is independent of \(\bar{z}\).</p>
<p >Finally, from Eqs. ( \(\ref{eq:defrhobar}\)) and ( \(\ref{eq:lambdafromrhobar}\)) we have</p>
<p class="formulaDsp">
\begin{align} \frac{\partial\lambda}{\partial\bar{x}} &amp;= \frac{\bar{x}}{\bar{R}^2\bar{\rho}}, \label{eq:dlambdadxbar} \\ \frac{\partial\lambda}{\partial\bar{y}} &amp;= \frac{\bar{y}}{\bar{R}^2\bar{\rho}}, \label{eq:dlambdadybar} \end{align}
</p>
<p> with no dependence on \(\bar{z}\).</p>
<p >Putting these results together yields </p><p class="formulaDsp">
\begin{align} \frac{\partial x^0}{\partial \bar{x}} &amp;= \frac{\bar{y}^2}{\bar{\rho}^3\bar{R}^3}R_1\sin\theta_1 + (R_2\sin\theta_2-R_1\sin\theta_1) \frac{\lambda \bar{R}^2\bar\rho^2+\bar{x}^2}{\bar\rho^3\bar{R}^3} + \frac{\bar{x}}{\bar\rho\bar{R}^2}(C_2^x-C_1^x),\\ \frac{\partial x^0}{\partial \bar{y}} &amp;= \frac{\bar{x}\bar{y}}{\bar{\rho}^3\bar{R}^3} (R_2\sin\theta_2-2 R_1\sin\theta_1) + \frac{\bar{y}}{\bar\rho\bar{R}^2}(C_2^x-C_1^x),\\ \frac{\partial x^0}{\partial \bar{z}} &amp;= -\frac{1}{2}\frac{\bar{x}}{\bar\rho\bar{R}}\left[ \cot\theta_1(1-\lambda)(z^{+}_{\mathrm{P}1}-z^{-}_{\mathrm{P}1})+ \cot\theta_2\lambda(z^{+}_{\mathrm{P}2}-z^{-}_{\mathrm{P}2})\right],\\ \frac{\partial x^1}{\partial \bar{x}} &amp;= \frac{\bar{x}\bar{y}}{\bar{\rho}^3\bar{R}^3} (R_2\sin\theta_2-2 R_1\sin\theta_1) + \frac{\bar{x}}{\bar\rho\bar{R}^2}(C_2^y-C_1^y),\\ \frac{\partial x^1}{\partial \bar{y}} &amp;= \frac{\bar{x}^2}{\bar{\rho}^3\bar{R}^3}R_1\sin\theta_1 + (R_2\sin\theta_2-R_1\sin\theta_1) \frac{\lambda \bar{R}^2\bar\rho^2+\bar{y}^2}{\bar\rho^3\bar{R}^3} + \frac{\bar{y}}{\bar\rho\bar{R}^2}(C_2^y-C_1^y),\\ \frac{\partial x^1}{\partial \bar{z}} &amp;= -\frac{1}{2}\frac{\bar{y}}{\bar\rho\bar{R}}\left[ \cot\theta_1(1-\lambda)(z^{+}_{\mathrm{P}1}-z^{-}_{\mathrm{P}1})+ \cot\theta_2\lambda(z^{+}_{\mathrm{P}2}-z^{-}_{\mathrm{P}2})\right],\\ \frac{\partial x^2}{\partial \bar{x}} &amp;= \frac{\bar{x}}{\bar\rho\bar{R}^2}\left( C_2^z-C_1^z + R_2\cos\theta_2-R_1\cos\theta_1\right),\\ \frac{\partial x^2}{\partial \bar{y}} &amp;= \frac{\bar{y}}{\bar\rho\bar{R}^2}\left( C_2^z-C_1^z + R_2\cos\theta_2-R_1\cos\theta_1\right),\\ \frac{\partial x^2}{\partial \bar{z}} &amp;= \frac{1}{2}(1-\lambda)(z^{+}_{\mathrm{P}1}-z^{-}_{\mathrm{P}1})+ \frac{1}{2}\lambda(z^{+}_{\mathrm{P}2}-z^{-}_{\mathrm{P}2}). \end{align}
</p>
<h2><a class="anchor" id="autotoc_md322"></a>
inv_jacobian</h2>
<p >The inverse Jacobian is computed by numerically inverting the Jacobian.</p>
<h2><a class="anchor" id="autotoc_md323"></a>
Restrictions on map parameters</h2>
<p >We demand that Sphere 1 is fully contained inside Sphere 2, and that the two spheres have at least some small separation between them. In particular, we demand that </p><p class="formulaDsp">
\begin{align} 0.98 R_2 &amp;\geq R_1 + |C_1-C_2|, \label{eq:spherecontained} \end{align}
</p>
<p> where 0.98 is a safety factor. It is possible to construct a valid map without this assumption, but the assumption simplifies the code, and the expected use cases obey this restriction.</p>
<p >We also demand that \(R_1 \geq 0.08 R_2\). Again, this assumption is made for accuracy purposes and might be relaxed.</p>
<h3><a class="anchor" id="autotoc_md324"></a>
Invertibility condition</h3>
<p >Consider the line segment \(L^+_1\) that connects a point on the circle \(S^+_1\) (the circle formed by the intersection of sphere 1 and the plane \(z=z^+_{\mathrm{P}1}\)) with the center of the circle \(S^+_1\). Consider another line segment \(L^+_2\) that connects the same point on the circle \(S^+_1\) with the corresponding point on the circle \(S^+_2\) (the circle formed by the intersection of sphere 2 and the plane \(z=z^+_{\mathrm{P}2}\)). Now consider the angle between \(L^+_1\) and \(L^+_2\), as measured from the interior of sphere 1, and Let \(\alpha^+\) be the minimum value of this angle over the circle. \(\alpha^+\) is shown in the figure above. If \(\alpha^+ &lt; \theta_{1 \mathrm{min}}\), then the line segment \(L^+_2\) twice intersects the unmapped portion of sphere 1 near the north pole, so the map is ill-defined. Similarly, if \(\alpha^+ &lt; \theta_{2 \mathrm{min}}\), then the line segment \(L^+_2\) twice intersects the mapped portion of sphere 2 near the north pole, and again the map is poorly defined. Therefore we demand that the map parameters satisfy</p><ul>
<li>\(\alpha^+ &gt; 1.1 \theta_{1 \mathrm{min}}\)</li>
<li>\(\alpha^+ &gt; 1.1 \theta_{2 \mathrm{min}}\)</li>
</ul>
<p >where 1.1 is a safety factor.</p>
<p >Similarly, one can define an angle \(\alpha^-\) for the region near the south pole, and we require similar restrictions on that angle.</p>
<h3><a class="anchor" id="autotoc_md325"></a>
Restrictions on z-planes</h3>
<p >We also demand that either \(z^+_{\mathrm{P}1} = z^+_{\mathrm{P}2}\) or that \(z^+_{\mathrm{P}1} &lt;= z^+_{\mathrm{P}2} -0.03 R_2\). Similarly, we demand that either \(z^-_{\mathrm{P}1} = z^-_{\mathrm{P}2}\) or \(z^-_{\mathrm{P}1} &gt;= z^-_{\mathrm{P}2} + 0.03 R_2\). These restrictions follow expected use cases and avoid extreme distortions.</p>
<h3><a class="anchor" id="autotoc_md326"></a>
Restrictions for unequal z planes</h3>
<p >For \(z^+_{\mathrm{P}1} \neq z^+_{\mathrm{P}2}\) and \(z^-_{\mathrm{P}1} \neq z^-_{\mathrm{P}2}\), we assume the following restrictions on other parameters:</p>
<p >We prohibit a tiny Sphere 1 near the edge of Sphere 2 by demanding that </p><p class="formulaDsp">
\begin{align} C^z_1 - R_1 &amp;\leq C^z_2 + R_2/5,\\ C^z_1 + R_1 &amp;\geq C^z_2 - R_2/5. \end{align}
</p>
<p> We also demand that the polar axis of Sphere 2 intersects Sphere 1 somewhere: </p><p class="formulaDsp">
\begin{align} \sqrt{(C^x_1-C^x_2)^2 + (C^y_1-C^y_2)^2} &amp;\leq R_1. \end{align}
</p>
<p> and we demand that Sphere 1 is not too close to the edge of Sphere 2 in the \(x\) or \(y\) directions: </p><p class="formulaDsp">
\begin{align} \sqrt{(C^y_1-C^y_2)^2 + (C^y_1-C^y_2)^2} &amp;\leq \mathrm{max}(0,0.95 R_2-R_1), \end{align}
</p>
<p> where the max avoids problems when \(0.95 R_2-R_1\) is negative (which, if it occurs, means that the \(x\) and \(y\) centers of the two spheres are equal).</p>
<p >We require that the z planes in the above figures lie above/below the centers of the corresponding spheres and are not too close to the centers or edges of those spheres; specificially, we demand that </p><p class="formulaDsp">
\begin{align} \label{eq:theta_1_min_res} 0.15\pi &amp;&lt; \theta_{1 \mathrm{min}} &lt; 0.4\pi \\ \label{eq:theta_1_max_res} 0.6\pi &amp;&lt; \theta_{1 \mathrm{max}} &lt; 0.85\pi \\ \label{eq:theta_2_min_res} 0.15\pi &amp;&lt; \theta_{2 \mathrm{min}} &lt; 0.4\pi \\ \label{eq:theta_2_max_res} 0.6\pi &amp;&lt; \theta_{2 \mathrm{max}} &lt; 0.85\pi . \end{align}
</p>
<p >Here the numerical values are safety factors. These restrictions are not strictly necessary but are made for simplicity. Increasing the range will make the maps less accurate because the domain is more distorted. These parameters can be changed provided the unit tests are changed to test the appropriate parameter ranges.</p>
<h3><a class="anchor" id="autotoc_md327"></a>
Restrictions for equal z planes</h3>
<p >If \(z^+_{\mathrm{P}1} = z^+_{\mathrm{P}2}\) or \(z^-_{\mathrm{P}1} = z^-_{\mathrm{P}2}\) we demand that \(C_1^x=C_2^x\) and \(C_1^y=C_2^y\), which simplifies the cases we need to test and agrees with our expected use cases. We also demand </p><p class="formulaDsp">
\begin{align} z^+_{\mathrm{P}2} &amp;\geq z^-_{\mathrm{P}2} + 0.18 R_2 \end{align}
</p>
<p> This condition is necessary because for unequal z planes, \(\theta_{2 \mathrm{min}}\) and \(\theta_{2 \mathrm{max}}\) are no longer required to be on opposite sides of the equator of sphere 2 (see the paragraph below). Note that for unequal z planes \(\theta_{1 \mathrm{min}}\) and \(\theta_{1 \mathrm{max}}\) are no longer required to be on opposite sides of the equator of sphere 1, but the conditions in the paragraph below guarantee that \(z^+_{\mathrm{P}1} \geq z^-_{\mathrm{P}1}\).</p>
<p >Unlike the case with unequal z planes, we no longer require that the z planes in the above figures lie above/below the centers of the corresponding spheres, but we still require that the z planes are not too close to the edges of those spheres. The restrictions are the same as Eqs. ( \(\ref{eq:theta_1_min_res}\)&ndash; \(\ref{eq:theta_2_max_res}\)) except for the following changes: If \(z^+_{\mathrm{P}1} = z^+_{\mathrm{P}2}\), then we replace Eq. ( \(\ref{eq:theta_1_min_res}\)) with </p><p class="formulaDsp">
\begin{align} \label{eq:equal_plus_theta_1_min_res} 0.15\pi &amp;&lt; \theta_{1 \mathrm{min}} &lt; 0.59\pi, \end{align}
</p>
<p> and furthermore, if \(z^+_{\mathrm{P}1} = z^+_{\mathrm{P}2}\) and \(\theta_{1 \mathrm{min}} &gt; 0.4\pi\) we replace Eqs. ( \(\ref{eq:theta_1_max_res}\)&ndash; \(\ref{eq:theta_2_min_res}\)) with </p><p class="formulaDsp">
\begin{align} \label{eq:equal_plus_high_theta_1_max_res} 0.7\pi &amp;&lt; \theta_{1 \mathrm{max}} &lt; 0.85\pi \\ \label{eq:equal_plus_high_theta_2_min_res} 0.25\pi &amp;&lt; \theta_{2 \mathrm{min}} &lt; 0.75\pi, \end{align}
</p>
<p> but if \(z^+_{\mathrm{P}1} = z^+_{\mathrm{P}2}\) and \(\theta_{1 \mathrm{min}} \leq 0.4\pi\) we replace Eq. ( \(\ref{eq:theta_2_min_res}\)) with </p><p class="formulaDsp">
\begin{align} \label{eq:equal_plus_low_theta_2_min_res} 0.15\pi &amp;&lt; \theta_{2 \mathrm{min}} &lt; 0.75\pi. \end{align}
</p>
<p >Similarly, if \(z^-_{\mathrm{P}1} = z^-_{\mathrm{P}2}\) we replace ( \(\ref{eq:theta_1_max_res}\)) with </p><p class="formulaDsp">
\begin{align} \label{eq:equal_minus_theta_1_max_res} 0.41\pi &amp;&lt; \theta_{1 \mathrm{max}} &lt; 0.85\pi, \end{align}
</p>
<p> and furthermore, if \(z^-_{\mathrm{P}1} = z^-_{\mathrm{P}2}\) and \(\theta_{1 \mathrm{max}} &lt; 0.6\pi\) we replace Eqs. ( \(\ref{eq:theta_1_min_res}\)) and ( \(\ref{eq:theta_2_max_res}\)) with </p><p class="formulaDsp">
\begin{align} \label{eq:equal_minus_high_theta_1_min_res} 0.15\pi &amp;&lt; \theta_{1 \mathrm{min}} &lt; 0.3\pi \\ \label{eq:equal_minus_high_theta_2_max_res} 0.25\pi &amp;&lt; \theta_{2 \mathrm{max}} &lt; 0.75\pi, \end{align}
</p>
<p> but if \(z^-_{\mathrm{P}1} = z^-_{\mathrm{P}2}\) and \(\theta_{1 \mathrm{max}} \geq 0.6\pi\) we replace Eq. ( \(\ref{eq:theta_2_max_res}\)) with </p><p class="formulaDsp">
\begin{align} \label{eq:equal_minus_low_theta_2_max_res} 0.25\pi &amp;&lt; \theta_{2 \mathrm{max}} &lt; 0.85\pi . \end{align}
</p>
 </div><hr/>The documentation for this class was generated from the following file:<ul>
<li>src/Domain/CoordinateMaps/UniformCylindricalSide.hpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedomain.html">domain</a></li><li class="navelem"><a class="el" href="namespacedomain_1_1CoordinateMaps.html">CoordinateMaps</a></li><li class="navelem"><a class="el" href="classdomain_1_1CoordinateMaps_1_1UniformCylindricalSide.html">UniformCylindricalSide</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
