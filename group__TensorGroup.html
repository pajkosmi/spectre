<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: Tensor</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__TensorGroup.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Tensor</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceFrame"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceFrame.html">Frame</a></td></tr>
<tr class="memdesc:namespaceFrame"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> that a <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> is in. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTensorMetafunctions"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTensorMetafunctions.html">TensorMetafunctions</a></td></tr>
<tr class="memdesc:namespaceTensorMetafunctions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all metafunctions related to Tensor manipulations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetnsr"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetnsr.html">tnsr</a></td></tr>
<tr class="memdesc:namespacetnsr"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type aliases to construct common Tensors. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFrame_1_1FrameIsPhysical.html">Frame::FrameIsPhysical</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks a <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> as being "physical" in the sense that it is meaningful to evaluate an analytic solution in that frame.  <a href="structFrame_1_1FrameIsPhysical.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtt_1_1is__tensor__index__type.html">tt::is_tensor_index_type&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inherits from <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::true_type</a> if T is a <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a>.  <a href="structtt_1_1is__tensor__index__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor_3_01X_00_01Symm_00_01IndexList_3_01Indices_8_8_8_01_4_01_4.html">Tensor&lt; X, Symm, IndexList&lt; Indices... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an object with multiple components.  <a href="classTensor_3_01X_00_01Symm_00_01IndexList_3_01Indices_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorMetafunctions_1_1replace__frame__in__tag.html">TensorMetafunctions::replace_frame_in_tag&lt; Tag, NewFrame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces Tag with an equivalent Tag but in frame NewFrame.  <a href="structTensorMetafunctions_1_1replace__frame__in__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga4e16b80d37cb8a3e7c8ab95e72ab8724"><td class="memTemplParams" colspan="2">template&lt;typename CheckFrame &gt; </td></tr>
<tr class="memitem:ga4e16b80d37cb8a3e7c8ab95e72ab8724"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga4e16b80d37cb8a3e7c8ab95e72ab8724">Frame::is_frame_physical</a> = <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a>&lt; bool, <a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_base_of.html">std::is_base_of</a>&lt; <a class="el" href="structFrame_1_1FrameIsPhysical.html">FrameIsPhysical</a>, CheckFrame &gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a> &gt;</td></tr>
<tr class="memdesc:ga4e16b80d37cb8a3e7c8ab95e72ab8724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::true_type</a> if the frame is "physical" in the sense that it is meaningful to evaluate an analytic solution in that frame.  <a href="group__TensorGroup.html#ga4e16b80d37cb8a3e7c8ab95e72ab8724">More...</a><br /></td></tr>
<tr class="separator:ga4e16b80d37cb8a3e7c8ab95e72ab8724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga557beda9bce6c7f236213ec8b24b3ff3"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> Ul, typename Fr &gt; </td></tr>
<tr class="memitem:ga557beda9bce6c7f236213ec8b24b3ff3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a> = Tensor_detail::TensorIndexType&lt; SpatialDim, Ul, Fr, <a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504">IndexType::Spatial</a> &gt;</td></tr>
<tr class="memdesc:ga557beda9bce6c7f236213ec8b24b3ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A SpatialIndex holds information about the number of spatial dimensions, whether the index is covariant or contravariant (<a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28" title="Whether a TensorIndexType is covariant or contravariant.">UpLo</a>), and the <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> the index is in.  <a href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">More...</a><br /></td></tr>
<tr class="separator:ga557beda9bce6c7f236213ec8b24b3ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05c512b755e913cdbddce8634bdb4fa6"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> Ul, typename Fr &gt; </td></tr>
<tr class="memitem:ga05c512b755e913cdbddce8634bdb4fa6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">SpacetimeIndex</a> = Tensor_detail::TensorIndexType&lt; SpatialDim, Ul, Fr, <a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8eaed5df3a695921f514a83c22d119c0f8e">IndexType::Spacetime</a> &gt;</td></tr>
<tr class="memdesc:ga05c512b755e913cdbddce8634bdb4fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A SpacetimeIndex holds information about the number of spatial dimensions, whether the index is covariant or contravariant (<a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28" title="Whether a TensorIndexType is covariant or contravariant.">UpLo</a>), and the <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> the index is in.  <a href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">More...</a><br /></td></tr>
<tr class="separator:ga05c512b755e913cdbddce8634bdb4fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb33fd857700a3fc87b9dce8c877fee7"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classIndex.html">Index</a> &gt; </td></tr>
<tr class="memitem:gacb33fd857700a3fc87b9dce8c877fee7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a> = Tensor_detail::TensorIndexType&lt; Index::index_type==<a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504">IndexType::Spatial</a> ? <a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">Index::value</a> :<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">Index::value</a> - 1, Index::ul==<a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28a258f49887ef8d14ac268c92b02503aaa">UpLo::Up</a> ? <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a> :<a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28a258f49887ef8d14ac268c92b02503aaa">UpLo::Up</a>, typename Index::Frame, Index::index_type &gt;</td></tr>
<tr class="memdesc:gacb33fd857700a3fc87b9dce8c877fee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> to be covariant if it's contravariant and vice-versa.  <a href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">More...</a><br /></td></tr>
<tr class="separator:gacb33fd857700a3fc87b9dce8c877fee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8087fef90d482c58a25934cb9346950"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classIndex.html">Index</a> &gt; </td></tr>
<tr class="memitem:gad8087fef90d482c58a25934cb9346950"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gad8087fef90d482c58a25934cb9346950">change_index_type</a> = Tensor_detail::TensorIndexType&lt; Index::index_type==<a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504">IndexType::Spatial</a> ? Index::dim :Index::dim - 1, Index::ul, typename Index::Frame, Index::index_type==<a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504">IndexType::Spatial</a> ? <a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8eaed5df3a695921f514a83c22d119c0f8e">IndexType::Spacetime</a> :<a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504">IndexType::Spatial</a> &gt;</td></tr>
<tr class="memdesc:gad8087fef90d482c58a25934cb9346950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> to be spacetime if it's spatial and vice versa.  <a href="group__TensorGroup.html#gad8087fef90d482c58a25934cb9346950">More...</a><br /></td></tr>
<tr class="separator:gad8087fef90d482c58a25934cb9346950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6f86692d77435c9721e1ab051232407"><td class="memTemplParams" colspan="2"><a id="gaf6f86692d77435c9721e1ab051232407" name="gaf6f86692d77435c9721e1ab051232407"></a>
template&lt;typename Symm , typename... IndexPack&gt; </td></tr>
<tr class="memitem:gaf6f86692d77435c9721e1ab051232407"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TensorMetafunctions::check_index_symmetry</b> = typename detail::check_index_symmetry_impl&lt; tmpl::size&lt; Symm &gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a>==0 or tmpl::size&lt; Symm &gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a>==1 ? 0 :2 &gt;::template f&lt; Symm, tmpl::map&lt;&gt;, IndexPack... &gt;</td></tr>
<tr class="memdesc:gaf6f86692d77435c9721e1ab051232407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that each of symmetric indices is in the same frame and have the same dimensionality. <br /></td></tr>
<tr class="separator:gaf6f86692d77435c9721e1ab051232407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e4aece332518b3a95c2a73557aaa596"><td class="memTemplParams" colspan="2">template&lt;typename Tensor , <a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">std::size_t</a> VolumeDim, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> Ul, typename Fr  = Frame::Grid&gt; </td></tr>
<tr class="memitem:ga5e4aece332518b3a95c2a73557aaa596"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga5e4aece332518b3a95c2a73557aaa596">TensorMetafunctions::prepend_spatial_index</a> = ::Tensor&lt; typename Tensor::type, tmpl::push_front&lt; typename Tensor::symmetry, tmpl::int32_t&lt; 1+tmpl::fold&lt; typename Tensor::symmetry, tmpl::int32_t&lt; 0 &gt;, tmpl::max&lt; tmpl::_state, tmpl::_element &gt; &gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a> &gt; &gt;, tmpl::push_front&lt; typename Tensor::index_list, <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; VolumeDim, Ul, Fr &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga5e4aece332518b3a95c2a73557aaa596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a spatial index to the front of a Tensor.  <a href="group__TensorGroup.html#ga5e4aece332518b3a95c2a73557aaa596">More...</a><br /></td></tr>
<tr class="separator:ga5e4aece332518b3a95c2a73557aaa596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef68ec7e4373c578d0a5885df8ac89fa"><td class="memTemplParams" colspan="2">template&lt;typename Tensor , <a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">std::size_t</a> VolumeDim, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> Ul, typename Fr  = Frame::Grid&gt; </td></tr>
<tr class="memitem:gaef68ec7e4373c578d0a5885df8ac89fa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gaef68ec7e4373c578d0a5885df8ac89fa">TensorMetafunctions::prepend_spacetime_index</a> = ::Tensor&lt; typename Tensor::type, tmpl::push_front&lt; typename Tensor::symmetry, tmpl::int32_t&lt; 1+tmpl::fold&lt; typename Tensor::symmetry, tmpl::int32_t&lt; 0 &gt;, tmpl::max&lt; tmpl::_state, tmpl::_element &gt; &gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a> &gt; &gt;, tmpl::push_front&lt; typename Tensor::index_list, <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">SpacetimeIndex</a>&lt; VolumeDim, Ul, Fr &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gaef68ec7e4373c578d0a5885df8ac89fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a spacetime index to the front of a Tensor.  <a href="group__TensorGroup.html#gaef68ec7e4373c578d0a5885df8ac89fa">More...</a><br /></td></tr>
<tr class="separator:gaef68ec7e4373c578d0a5885df8ac89fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga897a0492a08b8d3493fe552796c1cf02"><td class="memTemplParams" colspan="2">template&lt;typename Tensor &gt; </td></tr>
<tr class="memitem:ga897a0492a08b8d3493fe552796c1cf02"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga897a0492a08b8d3493fe552796c1cf02">TensorMetafunctions::remove_first_index</a> = ::Tensor&lt; typename Tensor::type, tmpl::pop_front&lt; typename Tensor::symmetry &gt;, tmpl::pop_front&lt; typename Tensor::index_list &gt; &gt;</td></tr>
<tr class="memdesc:ga897a0492a08b8d3493fe552796c1cf02"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove the first index of a tensor  <a href="group__TensorGroup.html#ga897a0492a08b8d3493fe552796c1cf02">More...</a><br /></td></tr>
<tr class="separator:ga897a0492a08b8d3493fe552796c1cf02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25fd6050b5c828f90dd353a44dbd8c1e"><td class="memTemplParams" colspan="2">template&lt;typename NewType , typename Tensor &gt; </td></tr>
<tr class="memitem:ga25fd6050b5c828f90dd353a44dbd8c1e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga25fd6050b5c828f90dd353a44dbd8c1e">TensorMetafunctions::swap_type</a> = ::Tensor&lt; NewType, typename Tensor::symmetry, typename Tensor::index_list &gt;</td></tr>
<tr class="memdesc:ga25fd6050b5c828f90dd353a44dbd8c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the data type of a tensor for a new type.  <a href="group__TensorGroup.html#ga25fd6050b5c828f90dd353a44dbd8c1e">More...</a><br /></td></tr>
<tr class="separator:ga25fd6050b5c828f90dd353a44dbd8c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeb947b3b07da1aaad0ba7aa3c6b7709"><td class="memTemplParams" colspan="2"><a id="gadeb947b3b07da1aaad0ba7aa3c6b7709" name="gadeb947b3b07da1aaad0ba7aa3c6b7709"></a>
template&lt;typename Tensor , typename Frame &gt; </td></tr>
<tr class="memitem:gadeb947b3b07da1aaad0ba7aa3c6b7709"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TensorMetafunctions::any_index_in_frame</b> = tmpl::any&lt; typename Tensor::index_list, tmpl::bind&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">detail::frame_is_the_same</a>, tmpl::_1, Frame &gt; &gt;</td></tr>
<tr class="memdesc:gadeb947b3b07da1aaad0ba7aa3c6b7709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return tmpl::true_type if any indices of the Tensor are in the frame <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a>. <br /></td></tr>
<tr class="separator:gadeb947b3b07da1aaad0ba7aa3c6b7709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b376e9167e178638a1adece2ab22ec9"><td class="memTemplParams" colspan="2">template&lt;std::int32_t... T&gt; </td></tr>
<tr class="memitem:ga3b376e9167e178638a1adece2ab22ec9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a> = typename detail::SymmetryImpl&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::make_index_sequence</a>&lt; sizeof...(T)&gt;, tmpl::integral_list&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int32_t</a>, T... &gt; &gt;::type</td></tr>
<tr class="memdesc:ga3b376e9167e178638a1adece2ab22ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the canonical symmetry from the integers <code>T</code>  <a href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">More...</a><br /></td></tr>
<tr class="separator:ga3b376e9167e178638a1adece2ab22ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06ebcb38a1f13c246e53378b9e8959ce"><td class="memTemplParams" colspan="2"><a id="ga06ebcb38a1f13c246e53378b9e8959ce" name="ga06ebcb38a1f13c246e53378b9e8959ce"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga06ebcb38a1f13c246e53378b9e8959ce"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Scalar</b> = Tensor&lt; T, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt;&gt;, index_list&lt;&gt; &gt;</td></tr>
<tr class="memdesc:ga06ebcb38a1f13c246e53378b9e8959ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar type. <br /></td></tr>
<tr class="separator:ga06ebcb38a1f13c246e53378b9e8959ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ff8546695b9f1a7ec4d319ecd261656"><td class="memTemplParams" colspan="2"><a id="ga3ff8546695b9f1a7ec4d319ecd261656" name="ga3ff8546695b9f1a7ec4d319ecd261656"></a>
template&lt;typename Tag , typename NewFrame &gt; </td></tr>
<tr class="memitem:ga3ff8546695b9f1a7ec4d319ecd261656"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TensorMetafunctions::replace_frame_in_tag_t</b> = typename <a class="el" href="structTensorMetafunctions_1_1replace__frame__in__tag.html">replace_frame_in_tag</a>&lt; Tag, NewFrame &gt;::type</td></tr>
<tr class="memdesc:ga3ff8546695b9f1a7ec4d319ecd261656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces Tag with an equivalent Tag but in frame NewFrame. <br /></td></tr>
<tr class="separator:ga3ff8546695b9f1a7ec4d319ecd261656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade9979cb6841e887fbd4abe1914d4d76"><td class="memTemplParams" colspan="2"><a id="gade9979cb6841e887fbd4abe1914d4d76" name="gade9979cb6841e887fbd4abe1914d4d76"></a>
template&lt;typename TagList , typename NewFrame &gt; </td></tr>
<tr class="memitem:gade9979cb6841e887fbd4abe1914d4d76"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TensorMetafunctions::replace_frame_in_taglist</b> = tmpl::transform&lt; TagList, tmpl::bind&lt; <a class="el" href="group__TensorGroup.html#ga3ff8546695b9f1a7ec4d319ecd261656">replace_frame_in_tag_t</a>, tmpl::_1, NewFrame &gt; &gt;</td></tr>
<tr class="memdesc:gade9979cb6841e887fbd4abe1914d4d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces every Tag in Taglist with an equivalent Tag but in frame NewFrame. <br /></td></tr>
<tr class="separator:gade9979cb6841e887fbd4abe1914d4d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaab1181edf2ab2b664b0f174223f08c28"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> { <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28a258f49887ef8d14ac268c92b02503aaa">UpLo::Up</a>
, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>
 }</td></tr>
<tr class="memdesc:gaab1181edf2ab2b664b0f174223f08c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> is covariant or contravariant.  <a href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">More...</a><br /></td></tr>
<tr class="separator:gaab1181edf2ab2b664b0f174223f08c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga875b107b929ff008a27078792ac0bc8e"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga875b107b929ff008a27078792ac0bc8e">IndexType</a> : char { <a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504">IndexType::Spatial</a>
, <a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8eaed5df3a695921f514a83c22d119c0f8e">IndexType::Spacetime</a>
 }</td></tr>
<tr class="memdesc:ga875b107b929ff008a27078792ac0bc8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> is Spatial or Spacetime.  <a href="group__TensorGroup.html#ga875b107b929ff008a27078792ac0bc8e">More...</a><br /></td></tr>
<tr class="separator:ga875b107b929ff008a27078792ac0bc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga857a0a72bdd43d0977dce1190c13a60a"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename <a class="el" href="classIndex.html">Index</a> &gt; </td></tr>
<tr class="memitem:ga857a0a72bdd43d0977dce1190c13a60a"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga857a0a72bdd43d0977dce1190c13a60a">cross_product</a> (const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;vector_a, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;vector_b)</td></tr>
<tr class="memdesc:ga857a0a72bdd43d0977dce1190c13a60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Euclidean cross product of two vectors or one forms.  <a href="group__TensorGroup.html#ga857a0a72bdd43d0977dce1190c13a60a">More...</a><br /></td></tr>
<tr class="separator:ga857a0a72bdd43d0977dce1190c13a60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fcda549b4589b9697b8483504a6a651"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename <a class="el" href="classIndex.html">Index</a> &gt; </td></tr>
<tr class="memitem:ga9fcda549b4589b9697b8483504a6a651"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga9fcda549b4589b9697b8483504a6a651">cross_product</a> (const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;vector_a, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &gt; &amp;vector_b)</td></tr>
<tr class="memdesc:ga9fcda549b4589b9697b8483504a6a651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Euclidean cross product of a vector and a one form.  <a href="group__TensorGroup.html#ga9fcda549b4589b9697b8483504a6a651">More...</a><br /></td></tr>
<tr class="separator:ga9fcda549b4589b9697b8483504a6a651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga270cbe57c5c07c96d6f22ae678156dcb"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename <a class="el" href="classIndex.html">Index</a> &gt; </td></tr>
<tr class="memitem:ga270cbe57c5c07c96d6f22ae678156dcb"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga270cbe57c5c07c96d6f22ae678156dcb">cross_product</a> (const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;vector_a, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;vector_b, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a>, <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;metric_or_inverse_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;metric_determinant)</td></tr>
<tr class="memdesc:ga270cbe57c5c07c96d6f22ae678156dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cross product of two vectors or one forms.  <a href="group__TensorGroup.html#ga270cbe57c5c07c96d6f22ae678156dcb">More...</a><br /></td></tr>
<tr class="separator:ga270cbe57c5c07c96d6f22ae678156dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf19fdf1807bc54ab5c505787817dd9fd"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename <a class="el" href="classIndex.html">Index</a> &gt; </td></tr>
<tr class="memitem:gaf19fdf1807bc54ab5c505787817dd9fd"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gaf19fdf1807bc54ab5c505787817dd9fd">cross_product</a> (const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;vector_a, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &gt; &amp;vector_b, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a>, <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;metric_or_inverse_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;metric_determinant)</td></tr>
<tr class="memdesc:gaf19fdf1807bc54ab5c505787817dd9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cross product of a vector and a one form.  <a href="group__TensorGroup.html#gaf19fdf1807bc54ab5c505787817dd9fd">More...</a><br /></td></tr>
<tr class="separator:gaf19fdf1807bc54ab5c505787817dd9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d8b65ef0126f9670190c1ae186124a3"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Symm , typename IndexList &gt; </td></tr>
<tr class="memitem:ga3d8b65ef0126f9670190c1ae186124a3"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga3d8b65ef0126f9670190c1ae186124a3">l2_norm</a> (const Tensor&lt; DataType, Symm, IndexList &gt; &amp;tensor)</td></tr>
<tr class="memdesc:ga3d8b65ef0126f9670190c1ae186124a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Euclidean \(L^2\)-norm of arbitrary Tensors reduced over an element.  <a href="group__TensorGroup.html#ga3d8b65ef0126f9670190c1ae186124a3">More...</a><br /></td></tr>
<tr class="separator:ga3d8b65ef0126f9670190c1ae186124a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe8490247c8b21cefc2e06323f55c1c3"><td class="memTemplParams" colspan="2"><a id="gafe8490247c8b21cefc2e06323f55c1c3" name="gafe8490247c8b21cefc2e06323f55c1c3"></a>
template&lt;size_t Dim, typename DataType &gt; </td></tr>
<tr class="memitem:gafe8490247c8b21cefc2e06323f55c1c3"><td class="memTemplItemLeft" align="right" valign="top">tnsr::Ij&lt; DataType, Dim, <a class="el" href="structFrame_1_1NoFrame.html">Frame::NoFrame</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>identity</b> (const DataType &amp;used_for_type)</td></tr>
<tr class="memdesc:gafe8490247c8b21cefc2e06323f55c1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the Identity matrix <br /></td></tr>
<tr class="separator:gafe8490247c8b21cefc2e06323f55c1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b9b1bf910598514cbeb78445c1c4dcc"><td class="memTemplParams" colspan="2">template&lt;typename Fr &gt; </td></tr>
<tr class="memitem:ga1b9b1bf910598514cbeb78445c1c4dcc"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga1b9b1bf910598514cbeb78445c1c4dcc">Frame::prefix</a> ()</td></tr>
<tr class="memdesc:ga1b9b1bf910598514cbeb78445c1c4dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The frame-dependent prefix used when constructing the string returned by the name function of a tag.  <a href="group__TensorGroup.html#ga1b9b1bf910598514cbeb78445c1c4dcc">More...</a><br /></td></tr>
<tr class="separator:ga1b9b1bf910598514cbeb78445c1c4dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5daee96d09341749beb47cfa8046baf"><td class="memTemplParams" colspan="2">template&lt;int I, class... Ts&gt; </td></tr>
<tr class="memitem:gad5daee96d09341749beb47cfa8046baf"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gad5daee96d09341749beb47cfa8046baf">index_dim</a> (const Tensor&lt; Ts... &gt; &amp;)</td></tr>
<tr class="memdesc:gad5daee96d09341749beb47cfa8046baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get dimensionality of i'th tensor index.  <a href="group__TensorGroup.html#gad5daee96d09341749beb47cfa8046baf">More...</a><br /></td></tr>
<tr class="separator:gad5daee96d09341749beb47cfa8046baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga36bbeb0ee2084a06f7d950201cdc0d79"><td class="memTemplParams" colspan="2">template&lt;typename CheckFrame &gt; </td></tr>
<tr class="memitem:ga36bbeb0ee2084a06f7d950201cdc0d79"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga36bbeb0ee2084a06f7d950201cdc0d79">Frame::is_frame_physical_v</a> = <a class="el" href="group__TensorGroup.html#ga4e16b80d37cb8a3e7c8ab95e72ab8724">is_frame_physical</a>&lt;CheckFrame&gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a></td></tr>
<tr class="memdesc:ga36bbeb0ee2084a06f7d950201cdc0d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the frame is "physical" in the sense that it is meaningful to evaluate an analytic solution in that frame.  <a href="group__TensorGroup.html#ga36bbeb0ee2084a06f7d950201cdc0d79">More...</a><br /></td></tr>
<tr class="separator:ga36bbeb0ee2084a06f7d950201cdc0d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ee24c7a8f513fbd7f4a7975922378e1"><td class="memTemplParams" colspan="2"><a id="ga6ee24c7a8f513fbd7f4a7975922378e1" name="ga6ee24c7a8f513fbd7f4a7975922378e1"></a>
template&lt;typename Tensor , typename Frame &gt; </td></tr>
<tr class="memitem:ga6ee24c7a8f513fbd7f4a7975922378e1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TensorMetafunctions::any_index_in_frame_v</b> = <a class="el" href="group__TensorGroup.html#gadeb947b3b07da1aaad0ba7aa3c6b7709">any_index_in_frame</a>&lt;Tensor, Frame&gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a></td></tr>
<tr class="memdesc:ga6ee24c7a8f513fbd7f4a7975922378e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any indices of the Tensor are in the frame <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a>. <br /></td></tr>
<tr class="separator:ga6ee24c7a8f513fbd7f4a7975922378e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89500a25d18e24e68181c4feb72f24ce"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Symm , typename Index0 , typename Index1 &gt; </td></tr>
<tr class="memitem:ga89500a25d18e24e68181c4feb72f24ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga89500a25d18e24e68181c4feb72f24ce">determinant</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; T &gt; * &gt; det_tensor, const Tensor&lt; T, Symm, index_list&lt; Index0, Index1 &gt; &gt; &amp;tensor)</td></tr>
<tr class="memdesc:ga89500a25d18e24e68181c4feb72f24ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the determinant of a rank-2 Tensor <code>tensor</code>.  <a href="group__TensorGroup.html#ga89500a25d18e24e68181c4feb72f24ce">More...</a><br /></td></tr>
<tr class="separator:ga89500a25d18e24e68181c4feb72f24ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga473671277346f583bb9fe702739cb517"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Symm , typename Index0 , typename Index1 &gt; </td></tr>
<tr class="memitem:ga473671277346f583bb9fe702739cb517"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga473671277346f583bb9fe702739cb517">determinant</a> (const Tensor&lt; T, Symm, index_list&lt; Index0, Index1 &gt; &gt; &amp;tensor)</td></tr>
<tr class="memdesc:ga473671277346f583bb9fe702739cb517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the determinant of a rank-2 Tensor <code>tensor</code>.  <a href="group__TensorGroup.html#ga473671277346f583bb9fe702739cb517">More...</a><br /></td></tr>
<tr class="separator:ga473671277346f583bb9fe702739cb517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f4d32242977ea137fd6447874af7a2e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Symm , typename Index0 , typename Index1 &gt; </td></tr>
<tr class="memitem:ga5f4d32242977ea137fd6447874af7a2e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga5f4d32242977ea137fd6447874af7a2e">determinant_and_inverse</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; T &gt; * &gt; det, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Tensor&lt; T, Symm, tmpl::list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index1 &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt; &gt; &gt; * &gt; inv, const Tensor&lt; T, Symm, tmpl::list&lt; Index0, Index1 &gt; &gt; &amp;tensor)</td></tr>
<tr class="memdesc:ga5f4d32242977ea137fd6447874af7a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the determinant and inverse of a rank-2 Tensor.  <a href="group__TensorGroup.html#ga5f4d32242977ea137fd6447874af7a2e">More...</a><br /></td></tr>
<tr class="separator:ga5f4d32242977ea137fd6447874af7a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2e756ad470368b0e809971ac690623f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Symm , typename Index0 , typename Index1 &gt; </td></tr>
<tr class="memitem:gae2e756ad470368b0e809971ac690623f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gae2e756ad470368b0e809971ac690623f">determinant_and_inverse</a> (const Tensor&lt; T, Symm, tmpl::list&lt; Index0, Index1 &gt; &gt; &amp;tensor) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; T &gt;, Tensor&lt; T, Symm, tmpl::list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index1 &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gae2e756ad470368b0e809971ac690623f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the determinant and inverse of a rank-2 Tensor.  <a href="group__TensorGroup.html#gae2e756ad470368b0e809971ac690623f">More...</a><br /></td></tr>
<tr class="separator:gae2e756ad470368b0e809971ac690623f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga060ee2e67a818e4974c95374f721778a"><td class="memTemplParams" colspan="2">template&lt;typename DetTag , typename InvTag , typename T , typename Symm , typename Index0 , typename Index1 &gt; </td></tr>
<tr class="memitem:ga060ee2e67a818e4974c95374f721778a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga060ee2e67a818e4974c95374f721778a">determinant_and_inverse</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; tmpl::list&lt; DetTag, InvTag &gt; &gt; * &gt; det_and_inv, const Tensor&lt; T, Symm, tmpl::list&lt; Index0, Index1 &gt; &gt; &amp;tensor)</td></tr>
<tr class="memdesc:ga060ee2e67a818e4974c95374f721778a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the determinant and inverse of a rank-2 Tensor.  <a href="group__TensorGroup.html#ga060ee2e67a818e4974c95374f721778a">More...</a><br /></td></tr>
<tr class="separator:ga060ee2e67a818e4974c95374f721778a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga923023af6eb533286219401e1e56286e"><td class="memTemplParams" colspan="2">template&lt;typename DetTag , typename InvTag , typename T , typename Symm , typename Index0 , typename Index1 &gt; </td></tr>
<tr class="memitem:ga923023af6eb533286219401e1e56286e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga923023af6eb533286219401e1e56286e">determinant_and_inverse</a> (const Tensor&lt; T, Symm, tmpl::list&lt; Index0, Index1 &gt; &gt; &amp;tensor) -&gt; Variables&lt; tmpl::list&lt; DetTag, InvTag &gt; &gt;</td></tr>
<tr class="memdesc:ga923023af6eb533286219401e1e56286e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the determinant and inverse of a rank-2 Tensor.  <a href="group__TensorGroup.html#ga923023af6eb533286219401e1e56286e">More...</a><br /></td></tr>
<tr class="separator:ga923023af6eb533286219401e1e56286e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04be72967efc01e374b98c8fb833d51b"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename <a class="el" href="classIndex.html">Index</a> &gt; </td></tr>
<tr class="memitem:ga04be72967efc01e374b98c8fb833d51b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga04be72967efc01e374b98c8fb833d51b">dot_product</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt; dot_product, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;vector_a, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;vector_b)</td></tr>
<tr class="memdesc:ga04be72967efc01e374b98c8fb833d51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Euclidean dot product of two vectors or one forms.  <a href="group__TensorGroup.html#ga04be72967efc01e374b98c8fb833d51b">More...</a><br /></td></tr>
<tr class="separator:ga04be72967efc01e374b98c8fb833d51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga728120193a01de46c4d7f61f8130c3e2"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename <a class="el" href="classIndex.html">Index</a> &gt; </td></tr>
<tr class="memitem:ga728120193a01de46c4d7f61f8130c3e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga728120193a01de46c4d7f61f8130c3e2">dot_product</a> (const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;vector_a, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;vector_b)</td></tr>
<tr class="memdesc:ga728120193a01de46c4d7f61f8130c3e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Euclidean dot product of two vectors or one forms.  <a href="group__TensorGroup.html#ga728120193a01de46c4d7f61f8130c3e2">More...</a><br /></td></tr>
<tr class="separator:ga728120193a01de46c4d7f61f8130c3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75555cef48983db9295bfa3879c06dd0"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename <a class="el" href="classIndex.html">Index</a> &gt; </td></tr>
<tr class="memitem:ga75555cef48983db9295bfa3879c06dd0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga75555cef48983db9295bfa3879c06dd0">dot_product</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt; dot_product, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;vector_a, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &gt; &amp;vector_b)</td></tr>
<tr class="memdesc:ga75555cef48983db9295bfa3879c06dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot product of a vector and a one form.  <a href="group__TensorGroup.html#ga75555cef48983db9295bfa3879c06dd0">More...</a><br /></td></tr>
<tr class="separator:ga75555cef48983db9295bfa3879c06dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96ca4b62c235a57502e309519734857b"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename <a class="el" href="classIndex.html">Index</a> &gt; </td></tr>
<tr class="memitem:ga96ca4b62c235a57502e309519734857b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga96ca4b62c235a57502e309519734857b">dot_product</a> (const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;vector_a, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &gt; &amp;vector_b)</td></tr>
<tr class="memdesc:ga96ca4b62c235a57502e309519734857b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot product of a vector and a one form.  <a href="group__TensorGroup.html#ga96ca4b62c235a57502e309519734857b">More...</a><br /></td></tr>
<tr class="separator:ga96ca4b62c235a57502e309519734857b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga634a6e80472bd84d88804fabd067e8ef"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename <a class="el" href="classIndex.html">Index</a> &gt; </td></tr>
<tr class="memitem:ga634a6e80472bd84d88804fabd067e8ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga634a6e80472bd84d88804fabd067e8ef">dot_product</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt; dot_product, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;vector_a, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;vector_b, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &gt; &amp;metric)</td></tr>
<tr class="memdesc:ga634a6e80472bd84d88804fabd067e8ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot_product of two vectors or one forms.  <a href="group__TensorGroup.html#ga634a6e80472bd84d88804fabd067e8ef">More...</a><br /></td></tr>
<tr class="separator:ga634a6e80472bd84d88804fabd067e8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2506c687e3d6db8506877032b8488aec"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename <a class="el" href="classIndex.html">Index</a> &gt; </td></tr>
<tr class="memitem:ga2506c687e3d6db8506877032b8488aec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga2506c687e3d6db8506877032b8488aec">dot_product</a> (const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;vector_a, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;vector_b, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &gt; &amp;metric)</td></tr>
<tr class="memdesc:ga2506c687e3d6db8506877032b8488aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot_product of two vectors or one forms.  <a href="group__TensorGroup.html#ga2506c687e3d6db8506877032b8488aec">More...</a><br /></td></tr>
<tr class="separator:ga2506c687e3d6db8506877032b8488aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga447f2baf57b4cb3f6f2b1bb617f6ee3a"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename <a class="el" href="classIndex.html">Index</a> &gt; </td></tr>
<tr class="memitem:ga447f2baf57b4cb3f6f2b1bb617f6ee3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga447f2baf57b4cb3f6f2b1bb617f6ee3a">magnitude</a> (const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;vector)</td></tr>
<tr class="memdesc:ga447f2baf57b4cb3f6f2b1bb617f6ee3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Euclidean magnitude of a rank-1 tensor.  <a href="group__TensorGroup.html#ga447f2baf57b4cb3f6f2b1bb617f6ee3a">More...</a><br /></td></tr>
<tr class="separator:ga447f2baf57b4cb3f6f2b1bb617f6ee3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafe858306b847b1d56ef7fea21e28af7"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename <a class="el" href="classIndex.html">Index</a> &gt; </td></tr>
<tr class="memitem:gaafe858306b847b1d56ef7fea21e28af7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gaafe858306b847b1d56ef7fea21e28af7">magnitude</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt; magnitude, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;vector)</td></tr>
<tr class="memdesc:gaafe858306b847b1d56ef7fea21e28af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Euclidean magnitude of a rank-1 tensor.  <a href="group__TensorGroup.html#gaafe858306b847b1d56ef7fea21e28af7">More...</a><br /></td></tr>
<tr class="separator:gaafe858306b847b1d56ef7fea21e28af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a23aced3155d37fcfb5f7a5fd46b69e"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename <a class="el" href="classIndex.html">Index</a> &gt; </td></tr>
<tr class="memitem:ga2a23aced3155d37fcfb5f7a5fd46b69e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga2a23aced3155d37fcfb5f7a5fd46b69e">magnitude</a> (const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;vector, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &gt; &amp;metric)</td></tr>
<tr class="memdesc:ga2a23aced3155d37fcfb5f7a5fd46b69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the magnitude of a rank-1 tensor.  <a href="group__TensorGroup.html#ga2a23aced3155d37fcfb5f7a5fd46b69e">More...</a><br /></td></tr>
<tr class="separator:ga2a23aced3155d37fcfb5f7a5fd46b69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30503294818130bc3037ccdee94ed858"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename <a class="el" href="classIndex.html">Index</a> &gt; </td></tr>
<tr class="memitem:ga30503294818130bc3037ccdee94ed858"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga30503294818130bc3037ccdee94ed858">magnitude</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt; magnitude, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;vector, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &gt; &amp;metric)</td></tr>
<tr class="memdesc:ga30503294818130bc3037ccdee94ed858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the magnitude of a rank-1 tensor.  <a href="group__TensorGroup.html#ga30503294818130bc3037ccdee94ed858">More...</a><br /></td></tr>
<tr class="separator:ga30503294818130bc3037ccdee94ed858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc19b7b25eba938fd622a3942e3069de"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Symm , typename IndexList &gt; </td></tr>
<tr class="memitem:gadc19b7b25eba938fd622a3942e3069de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gadc19b7b25eba938fd622a3942e3069de">pointwise_l2_norm</a> (const Tensor&lt; DataType, Symm, IndexList &gt; &amp;tensor)</td></tr>
<tr class="memdesc:gadc19b7b25eba938fd622a3942e3069de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute point-wise Euclidean \(L^2\)-norm of arbitrary Tensors.  <a href="group__TensorGroup.html#gadc19b7b25eba938fd622a3942e3069de">More...</a><br /></td></tr>
<tr class="separator:gadc19b7b25eba938fd622a3942e3069de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cb473fcc3adf0e77383c8a3cce60d53"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Symm , typename IndexList &gt; </td></tr>
<tr class="memitem:ga5cb473fcc3adf0e77383c8a3cce60d53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga5cb473fcc3adf0e77383c8a3cce60d53">pointwise_l2_norm</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt; norm, const Tensor&lt; DataType, Symm, IndexList &gt; &amp;tensor)</td></tr>
<tr class="memdesc:ga5cb473fcc3adf0e77383c8a3cce60d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute point-wise Euclidean \(L^2\)-norm of arbitrary Tensors.  <a href="group__TensorGroup.html#ga5cb473fcc3adf0e77383c8a3cce60d53">More...</a><br /></td></tr>
<tr class="separator:ga5cb473fcc3adf0e77383c8a3cce60d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga575809a99dff3c2a104360a1e4d9200b"><td class="memTemplParams" colspan="2">template&lt;typename DataType , size_t VolumeDim, typename Frame &gt; </td></tr>
<tr class="memitem:ga575809a99dff3c2a104360a1e4d9200b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga575809a99dff3c2a104360a1e4d9200b">orthonormal_oneform</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; DataType, VolumeDim, Frame &gt; * &gt; orthonormal_form, const tnsr::i&lt; DataType, VolumeDim, Frame &gt; &amp;unit_form, const tnsr::II&lt; DataType, VolumeDim, Frame &gt; &amp;inv_spatial_metric)</td></tr>
<tr class="memdesc:ga575809a99dff3c2a104360a1e4d9200b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a spatial one-form orthonormal to the given unit form.  <a href="group__TensorGroup.html#ga575809a99dff3c2a104360a1e4d9200b">More...</a><br /></td></tr>
<tr class="separator:ga575809a99dff3c2a104360a1e4d9200b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8a980cdb5f3cb28a1c0bf6f567d6561"><td class="memTemplParams" colspan="2">template&lt;typename DataType , size_t VolumeDim, typename Frame &gt; </td></tr>
<tr class="memitem:gac8a980cdb5f3cb28a1c0bf6f567d6561"><td class="memTemplItemLeft" align="right" valign="top">tnsr::i&lt; DataType, VolumeDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gac8a980cdb5f3cb28a1c0bf6f567d6561">orthonormal_oneform</a> (const tnsr::i&lt; DataType, VolumeDim, Frame &gt; &amp;unit_form, const tnsr::II&lt; DataType, VolumeDim, Frame &gt; &amp;inv_spatial_metric)</td></tr>
<tr class="memdesc:gac8a980cdb5f3cb28a1c0bf6f567d6561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a spatial one-form orthonormal to the given unit form.  <a href="group__TensorGroup.html#gac8a980cdb5f3cb28a1c0bf6f567d6561">More...</a><br /></td></tr>
<tr class="separator:gac8a980cdb5f3cb28a1c0bf6f567d6561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21685a6a82d5fb9e13e11c88ca403323"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Frame &gt; </td></tr>
<tr class="memitem:ga21685a6a82d5fb9e13e11c88ca403323"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga21685a6a82d5fb9e13e11c88ca403323">orthonormal_oneform</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; DataType, 3, Frame &gt; * &gt; orthonormal_form, const tnsr::i&lt; DataType, 3, Frame &gt; &amp;first_unit_form, const tnsr::i&lt; DataType, 3, Frame &gt; &amp;second_unit_form, const tnsr::ii&lt; DataType, 3, Frame &gt; &amp;spatial_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;det_spatial_metric)</td></tr>
<tr class="memdesc:ga21685a6a82d5fb9e13e11c88ca403323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a spatial one-form orthonormal to two given unit forms.  <a href="group__TensorGroup.html#ga21685a6a82d5fb9e13e11c88ca403323">More...</a><br /></td></tr>
<tr class="separator:ga21685a6a82d5fb9e13e11c88ca403323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac57af89c3a97d86d4cca7c0afa4b2072"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Frame &gt; </td></tr>
<tr class="memitem:gac57af89c3a97d86d4cca7c0afa4b2072"><td class="memTemplItemLeft" align="right" valign="top">tnsr::i&lt; DataType, 3, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gac57af89c3a97d86d4cca7c0afa4b2072">orthonormal_oneform</a> (const tnsr::i&lt; DataType, 3, Frame &gt; &amp;first_unit_form, const tnsr::i&lt; DataType, 3, Frame &gt; &amp;second_unit_form, const tnsr::ii&lt; DataType, 3, Frame &gt; &amp;spatial_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;det_spatial_metric)</td></tr>
<tr class="memdesc:gac57af89c3a97d86d4cca7c0afa4b2072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a spatial one-form orthonormal to two given unit forms.  <a href="group__TensorGroup.html#gac57af89c3a97d86d4cca7c0afa4b2072">More...</a><br /></td></tr>
<tr class="separator:gac57af89c3a97d86d4cca7c0afa4b2072"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Tensor use documentation. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gad8087fef90d482c58a25934cb9346950" name="gad8087fef90d482c58a25934cb9346950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8087fef90d482c58a25934cb9346950">&#9670;&nbsp;</a></span>change_index_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classIndex.html">Index</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__TensorGroup.html#gad8087fef90d482c58a25934cb9346950">change_index_type</a> =  Tensor_detail::TensorIndexType&lt; Index::index_type == <a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504">IndexType::Spatial</a> ? Index::dim : Index::dim - 1, Index::ul, typename Index::Frame, Index::index_type == <a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504">IndexType::Spatial</a> ? <a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8eaed5df3a695921f514a83c22d119c0f8e">IndexType::Spacetime</a> : <a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504">IndexType::Spatial</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> to be spacetime if it's spatial and vice versa. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classIndex.html" title="An integer multi-index.">Index</a></td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> to change </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacb33fd857700a3fc87b9dce8c877fee7" name="gacb33fd857700a3fc87b9dce8c877fee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb33fd857700a3fc87b9dce8c877fee7">&#9670;&nbsp;</a></span>change_index_up_lo</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classIndex.html">Index</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a> =  Tensor_detail::TensorIndexType&lt; Index::index_type == <a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504">IndexType::Spatial</a> ? <a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">Index::value</a> : <a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">Index::value</a> - 1, Index::ul == <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28a258f49887ef8d14ac268c92b02503aaa">UpLo::Up</a> ? <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a> : <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28a258f49887ef8d14ac268c92b02503aaa">UpLo::Up</a>, typename Index::Frame, Index::index_type&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> to be covariant if it's contravariant and vice-versa. </p>
<p >Here is an example of how to use <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7" title="Change the TensorIndexType to be covariant if it&#39;s contravariant and vice-versa.">change_index_up_lo</a> </p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code hl_class" href="classIndex.html">Index</a> = <a class="code hl_typedef" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex&lt;3, UpLo::Lo, Frame::Grid&gt;</a>;</div>
<div class="line"><span class="keyword">using</span> UpIndex = <a class="code hl_typedef" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo&lt;Index&gt;</a>;</div>
<div class="line"><span class="keyword">static_assert</span>(std::is_same_v&lt;UpIndex, SpatialIndex&lt;3, UpLo::Up, Frame::Grid&gt;&gt;,</div>
<div class="line">              <span class="stringliteral">&quot;Failed testing change_index_up_lo&quot;</span>);</div>
<div class="ttc" id="aclassIndex_html"><div class="ttname"><a href="classIndex.html">Index</a></div><div class="ttdoc">An integer multi-index.</div><div class="ttdef"><b>Definition:</b> Index.hpp:31</div></div>
<div class="ttc" id="agroup__TensorGroup_html_ga557beda9bce6c7f236213ec8b24b3ff3"><div class="ttname"><a href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a></div><div class="ttdeci">Tensor_detail::TensorIndexType&lt; SpatialDim, Ul, Fr, IndexType::Spatial &gt; SpatialIndex</div><div class="ttdoc">A SpatialIndex holds information about the number of spatial dimensions, whether the index is covaria...</div><div class="ttdef"><b>Definition:</b> IndexType.hpp:196</div></div>
<div class="ttc" id="agroup__TensorGroup_html_gacb33fd857700a3fc87b9dce8c877fee7"><div class="ttname"><a href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a></div><div class="ttdeci">Tensor_detail::TensorIndexType&lt; Index::index_type==IndexType::Spatial ? Index::value :Index::value - 1, Index::ul==UpLo::Up ? UpLo::Lo :UpLo::Up, typename Index::Frame, Index::index_type &gt; change_index_up_lo</div><div class="ttdoc">Change the TensorIndexType to be covariant if it's contravariant and vice-versa.</div><div class="ttdef"><b>Definition:</b> IndexType.hpp:244</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classIndex.html" title="An integer multi-index.">Index</a></td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> to change </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4e16b80d37cb8a3e7c8ab95e72ab8724" name="ga4e16b80d37cb8a3e7c8ab95e72ab8724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e16b80d37cb8a3e7c8ab95e72ab8724">&#9670;&nbsp;</a></span>is_frame_physical</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CheckFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__TensorGroup.html#ga4e16b80d37cb8a3e7c8ab95e72ab8724">Frame::is_frame_physical</a> = typedef <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a>&lt;bool, <a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_base_of.html">std::is_base_of</a>&lt;<a class="el" href="structFrame_1_1FrameIsPhysical.html">FrameIsPhysical</a>, CheckFrame&gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::true_type</a> if the frame is "physical" in the sense that it is meaningful to evaluate an analytic solution in that frame. </p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="keyword">static_assert</span>(not Frame::is_frame_physical_v&lt;Frame::BlockLogical&gt;,</div>
<div class="line">              <span class="stringliteral">&quot;Failed testing Frame::is_frame_physical&quot;</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(not Frame::is_frame_physical_v&lt;Frame::ElementLogical&gt;,</div>
<div class="line">              <span class="stringliteral">&quot;Failed testing Frame::is_frame_physical&quot;</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(not Frame::is_frame_physical_v&lt;Frame::Distorted&gt;,</div>
<div class="line">              <span class="stringliteral">&quot;Failed testing Frame::is_frame_physical&quot;</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(not Frame::is_frame_physical_v&lt;Frame::Grid&gt;,</div>
<div class="line">              <span class="stringliteral">&quot;Failed testing Frame::is_frame_physical&quot;</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(Frame::is_frame_physical_v&lt;Frame::Inertial&gt;,</div>
<div class="line">              <span class="stringliteral">&quot;Failed testing Frame::is_frame_physical&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaef68ec7e4373c578d0a5885df8ac89fa" name="gaef68ec7e4373c578d0a5885df8ac89fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef68ec7e4373c578d0a5885df8ac89fa">&#9670;&nbsp;</a></span>prepend_spacetime_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tensor , <a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">std::size_t</a> VolumeDim, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> Ul, typename Fr  = Frame::Grid&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__TensorGroup.html#gaef68ec7e4373c578d0a5885df8ac89fa">TensorMetafunctions::prepend_spacetime_index</a> = typedef ::Tensor&lt; typename Tensor::type, tmpl::push_front&lt; typename Tensor::symmetry, tmpl::int32_t&lt; 1 + tmpl::fold&lt;typename Tensor::symmetry, tmpl::int32_t&lt;0&gt;, tmpl::max&lt;tmpl::_state, tmpl::_element&gt; &gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a>&gt; &gt;, tmpl::push_front&lt;typename Tensor::index_list, <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">SpacetimeIndex</a>&lt;VolumeDim, Ul, Fr&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a spacetime index to the front of a Tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tensor</td><td>the tensor type to which the new index is prepended </td></tr>
    <tr><td class="paramname">VolumeDim</td><td>the volume dimension of the tensor index to prepend </td></tr>
    <tr><td class="paramname">Fr</td><td>the <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> of the tensor index to prepend </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5e4aece332518b3a95c2a73557aaa596" name="ga5e4aece332518b3a95c2a73557aaa596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e4aece332518b3a95c2a73557aaa596">&#9670;&nbsp;</a></span>prepend_spatial_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tensor , <a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">std::size_t</a> VolumeDim, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> Ul, typename Fr  = Frame::Grid&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__TensorGroup.html#ga5e4aece332518b3a95c2a73557aaa596">TensorMetafunctions::prepend_spatial_index</a> = typedef ::Tensor&lt; typename Tensor::type, tmpl::push_front&lt; typename Tensor::symmetry, tmpl::int32_t&lt; 1 + tmpl::fold&lt;typename Tensor::symmetry, tmpl::int32_t&lt;0&gt;, tmpl::max&lt;tmpl::_state, tmpl::_element&gt; &gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a>&gt; &gt;, tmpl::push_front&lt;typename Tensor::index_list, <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt;VolumeDim, Ul, Fr&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a spatial index to the front of a Tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tensor</td><td>the tensor type to which the new index is prepended </td></tr>
    <tr><td class="paramname">VolumeDim</td><td>the volume dimension of the tensor index to prepend </td></tr>
    <tr><td class="paramname">Fr</td><td>the <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> of the tensor index to prepend </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga897a0492a08b8d3493fe552796c1cf02" name="ga897a0492a08b8d3493fe552796c1cf02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga897a0492a08b8d3493fe552796c1cf02">&#9670;&nbsp;</a></span>remove_first_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tensor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__TensorGroup.html#ga897a0492a08b8d3493fe552796c1cf02">TensorMetafunctions::remove_first_index</a> = typedef ::Tensor&lt;typename Tensor::type, tmpl::pop_front&lt;typename Tensor::symmetry&gt;, tmpl::pop_front&lt;typename Tensor::index_list&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>remove the first index of a tensor </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tensor</td><td>the tensor type whose first index is removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga05c512b755e913cdbddce8634bdb4fa6" name="ga05c512b755e913cdbddce8634bdb4fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05c512b755e913cdbddce8634bdb4fa6">&#9670;&nbsp;</a></span>SpacetimeIndex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> Ul, typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">SpacetimeIndex</a> =  Tensor_detail::TensorIndexType&lt;SpatialDim, Ul, Fr, <a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8eaed5df3a695921f514a83c22d119c0f8e">IndexType::Spacetime</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A SpacetimeIndex holds information about the number of spatial dimensions, whether the index is covariant or contravariant (<a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28" title="Whether a TensorIndexType is covariant or contravariant.">UpLo</a>), and the <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> the index is in. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SpatialDim</td><td>the spatial dimensionality of the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> </td></tr>
    <tr><td class="paramname">Ul</td><td>either <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28a258f49887ef8d14ac268c92b02503aaa" title="Contravariant, or Upper index.">UpLo::Up</a> or <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911" title="Covariant, or Lower index.">UpLo::Lo</a> for contra or covariant </td></tr>
    <tr><td class="paramname">Fr</td><td>the <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> is in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga557beda9bce6c7f236213ec8b24b3ff3" name="ga557beda9bce6c7f236213ec8b24b3ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga557beda9bce6c7f236213ec8b24b3ff3">&#9670;&nbsp;</a></span>SpatialIndex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> Ul, typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a> =  Tensor_detail::TensorIndexType&lt;SpatialDim, Ul, Fr, <a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504">IndexType::Spatial</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A SpatialIndex holds information about the number of spatial dimensions, whether the index is covariant or contravariant (<a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28" title="Whether a TensorIndexType is covariant or contravariant.">UpLo</a>), and the <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> the index is in. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SpatialDim</td><td>the spatial dimensionality of the <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">TensorIndexType</a> </td></tr>
    <tr><td class="paramname">Ul</td><td>either <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28a258f49887ef8d14ac268c92b02503aaa" title="Contravariant, or Upper index.">UpLo::Up</a> or <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911" title="Covariant, or Lower index.">UpLo::Lo</a> for contra or covariant </td></tr>
    <tr><td class="paramname">Fr</td><td>the <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> the <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">TensorIndexType</a> is in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga25fd6050b5c828f90dd353a44dbd8c1e" name="ga25fd6050b5c828f90dd353a44dbd8c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25fd6050b5c828f90dd353a44dbd8c1e">&#9670;&nbsp;</a></span>swap_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NewType , typename Tensor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__TensorGroup.html#ga25fd6050b5c828f90dd353a44dbd8c1e">TensorMetafunctions::swap_type</a> = typedef ::Tensor&lt;NewType, typename Tensor::symmetry, typename Tensor::index_list&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap the data type of a tensor for a new type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NewType</td><td>the new data type </td></tr>
    <tr><td class="paramname">Tensor</td><td>the tensor from which to keep symmetry and index information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3b376e9167e178638a1adece2ab22ec9" name="ga3b376e9167e178638a1adece2ab22ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b376e9167e178638a1adece2ab22ec9">&#9670;&nbsp;</a></span>Symmetry</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::int32_t... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a> =  typename detail::SymmetryImpl&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::make_index_sequence</a>&lt;sizeof...(T)&gt;, tmpl::integral_list&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int32_t</a>, T...&gt; &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the canonical symmetry from the integers <code>T</code> </p>
<h3>Details</h3>
<p >Compute the canonical symmetry typelist given a set of integers, T. The resulting typelist is in ascending order of the integers, from right to left. For example, the result of <code>Symmetry&lt;1, 2, 1, 3&gt;</code> is <code>integral_list&lt;int32_t, 2, 3, 2, 1&gt;</code>. Anti-symmetries are not currently supported.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the integers denoting the symmetry of the Tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga875b107b929ff008a27078792ac0bc8e" name="ga875b107b929ff008a27078792ac0bc8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga875b107b929ff008a27078792ac0bc8e">&#9670;&nbsp;</a></span>IndexType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="group__TensorGroup.html#ga875b107b929ff008a27078792ac0bc8e">IndexType</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> is Spatial or Spacetime. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504" name="gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504"></a>Spatial&#160;</td><td class="fielddoc"><p >The <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">TensorIndexType</a> is purely spatial. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga875b107b929ff008a27078792ac0bc8eaed5df3a695921f514a83c22d119c0f8e" name="gga875b107b929ff008a27078792ac0bc8eaed5df3a695921f514a83c22d119c0f8e"></a>Spacetime&#160;</td><td class="fielddoc"><p >The <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> is a spacetime index. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaab1181edf2ab2b664b0f174223f08c28" name="gaab1181edf2ab2b664b0f174223f08c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab1181edf2ab2b664b0f174223f08c28">&#9670;&nbsp;</a></span>UpLo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether a <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> is covariant or contravariant. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaab1181edf2ab2b664b0f174223f08c28a258f49887ef8d14ac268c92b02503aaa" name="ggaab1181edf2ab2b664b0f174223f08c28a258f49887ef8d14ac268c92b02503aaa"></a>Up&#160;</td><td class="fielddoc"><p >Contravariant, or Upper index. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911" name="ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911"></a>Lo&#160;</td><td class="fielddoc"><p >Covariant, or Lower index. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9fcda549b4589b9697b8483504a6a651" name="ga9fcda549b4589b9697b8483504a6a651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fcda549b4589b9697b8483504a6a651">&#9670;&nbsp;</a></span>cross_product() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename <a class="el" href="classIndex.html">Index</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &gt; cross_product </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Euclidean cross product of a vector and a one form. </p>
<h3>Details</h3>
<p >Returns \(A^j B_l \delta^{lk} \epsilon_{ijk}\) for input vector \(A^j\) and input one form \(B_l\) or \(A_j B^l \delta_{lk} \epsilon^{ijk}\) for input one form \(A_j\) and input vector \(B^l\). Note that this function returns a vector if <code>vector_b</code> is a vector and a one form if <code>vector_b</code> is a one form. </p>

</div>
</div>
<a id="gaf19fdf1807bc54ab5c505787817dd9fd" name="gaf19fdf1807bc54ab5c505787817dd9fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf19fdf1807bc54ab5c505787817dd9fd">&#9670;&nbsp;</a></span>cross_product() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename <a class="el" href="classIndex.html">Index</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &gt; cross_product </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a>, <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>metric_or_inverse_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>metric_determinant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the cross product of a vector and a one form. </p>
<h3>Details</h3>
<p >Returns \(\sqrt{g} A^j B_l g^{lk} \epsilon_{ijk}\) for input vector \(A^j\) and input one form \(B_l\). In this case, the argument <code>vector_a</code> should be a vector, <code>vector_b</code> should be a one form, <code>metric_or_inverse_metric</code> should be the inverse spatial metric \(g^{ij}\), and <code>metric_determinant</code> should be the determinant of the spatial metric \(\det(g_{ij})\). Or, returns \(\sqrt{g}^{-1} A_j B^l g_{lk} \epsilon^{ijk}\) for input one form \(A_j\) and input vector \(B^l\). In this case, the argument <code>vector_a</code> should be a one form, <code>vector_b</code> should be a vector, <code>metric_or_inverse_metric</code> should be the spatial metric \(g_{ij}\), and <code>metric_determinant</code> should be the determinant of the spatial metric \(\det(g_{ij})\). Note that this function returns a vector if <code>vector_b</code> is a vector and a one form if <code>vector_b</code> is a one form. </p>

</div>
</div>
<a id="ga857a0a72bdd43d0977dce1190c13a60a" name="ga857a0a72bdd43d0977dce1190c13a60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga857a0a72bdd43d0977dce1190c13a60a">&#9670;&nbsp;</a></span>cross_product() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename <a class="el" href="classIndex.html">Index</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; cross_product </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Euclidean cross product of two vectors or one forms. </p>
<h3>Details</h3>
<p >Returns \(A^j B^k \epsilon_{ljk} \delta^{il}\) for input vectors \(A^j\) and \(B^k\) or \(A_j B_k \epsilon^{ljk} \delta_{il}\) for input one forms \(A_j\) and \(B_k\). </p>

</div>
</div>
<a id="ga270cbe57c5c07c96d6f22ae678156dcb" name="ga270cbe57c5c07c96d6f22ae678156dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga270cbe57c5c07c96d6f22ae678156dcb">&#9670;&nbsp;</a></span>cross_product() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename <a class="el" href="classIndex.html">Index</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; cross_product </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a>, <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>metric_or_inverse_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>metric_determinant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the cross product of two vectors or one forms. </p>
<h3>Details</h3>
<p >Returns \(\sqrt{g} g^{li} A^j B^k \epsilon_{ljk}\), where \(A^j\) and \(B^k\) are vectors and \(g^{li}\) and \(g\) are the inverse and determinant, respectively, of the spatial metric (computed via <code>determinant_and_inverse</code>). In this case, the arguments <code>vector_a</code> and <code>vector_b</code> should be vectors, the argument <code>metric_or_inverse_metric</code> should be the inverse spatial metric \(g^{ij}\), and the argument <code>metric_determinant</code> should be the determinant of the spatial metric \(\det(g_{ij})\). Or, returns \(\sqrt{g}^{-1} g_{li} A_j B_k \epsilon^{ljk}\), where \(A_j\) and \(B_k\) are one forms and \(g_{li}\) and \(g\) are the spatial metric and its determinant. In this case, the arguments <code>vector_a</code> and <code>vector_b</code> should be one forms, the argument <code>metric_or_inverse_metric</code> should be the spatial metric \(g_{ij}\), and the argument <code>metric_determinant</code> should be the determinant of the spatial metric \(\det(g_{ij})\). </p>

</div>
</div>
<a id="ga89500a25d18e24e68181c4feb72f24ce" name="ga89500a25d18e24e68181c4feb72f24ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89500a25d18e24e68181c4feb72f24ce">&#9670;&nbsp;</a></span>determinant() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Symm , typename Index0 , typename Index1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void determinant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; T &gt; * &gt;&#160;</td>
          <td class="paramname"><em>det_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; T, Symm, index_list&lt; Index0, Index1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the determinant of a rank-2 Tensor <code>tensor</code>. </p>
<p ><em>Requires:</em> That <code>tensor</code> be a rank-2 Tensor, with both indices sharing the same dimension and type. </p>

</div>
</div>
<a id="ga473671277346f583bb9fe702739cb517" name="ga473671277346f583bb9fe702739cb517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga473671277346f583bb9fe702739cb517">&#9670;&nbsp;</a></span>determinant() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Symm , typename Index0 , typename Index1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; T &gt; determinant </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; T, Symm, index_list&lt; Index0, Index1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the determinant of a rank-2 Tensor <code>tensor</code>. </p>
<p ><em>Requires:</em> That <code>tensor</code> be a rank-2 Tensor, with both indices sharing the same dimension and type. </p>

</div>
</div>
<a id="ga5f4d32242977ea137fd6447874af7a2e" name="ga5f4d32242977ea137fd6447874af7a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f4d32242977ea137fd6447874af7a2e">&#9670;&nbsp;</a></span>determinant_and_inverse() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Symm , typename Index0 , typename Index1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void determinant_and_inverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; T &gt; * &gt;&#160;</td>
          <td class="paramname"><em>det</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Tensor&lt; T, Symm, tmpl::list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index1 &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt; &gt; &gt; * &gt;&#160;</td>
          <td class="paramname"><em>inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; T, Symm, tmpl::list&lt; Index0, Index1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the determinant and inverse of a rank-2 Tensor. </p>
<p >Computes the determinant and inverse together, because this leads to fewer operations compared to computing the determinant independently.</p>
<h3>Details</h3>
<p >Treats the input rank-2 tensor as a matrix. The first (second) index of the tensor corresponds to the rows (columns) of the matrix. The determinant is a scalar tensor. The inverse is a rank-2 tensor whose indices are reversed and of opposite valence relative to the input tensor, i.e. given \(T_a^b\) returns \((Tinv)_b^a\).</p>
<dl class="section note"><dt>Note</dt><dd>When inverting a 4x4 spacetime metric, it is typically more efficient to use the 3+1 decomposition of the 4-metric in terms of lapse, shift, and spatial 3-metric, in which only the spatial 3-metric needs to be inverted. </dd></dl>

</div>
</div>
<a id="ga060ee2e67a818e4974c95374f721778a" name="ga060ee2e67a818e4974c95374f721778a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga060ee2e67a818e4974c95374f721778a">&#9670;&nbsp;</a></span>determinant_and_inverse() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DetTag , typename InvTag , typename T , typename Symm , typename Index0 , typename Index1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void determinant_and_inverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; tmpl::list&lt; DetTag, InvTag &gt; &gt; * &gt;&#160;</td>
          <td class="paramname"><em>det_and_inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; T, Symm, tmpl::list&lt; Index0, Index1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the determinant and inverse of a rank-2 Tensor. </p>
<p >Computes the determinant and inverse together, because this leads to fewer operations compared to computing the determinant independently.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DetTag</td><td>the Tag for the determinant of input Tensor. </td></tr>
    <tr><td class="paramname">InvTag</td><td>the Tag for the inverse of input Tensor.</td></tr>
  </table>
  </dd>
</dl>
<h3>Details</h3>
<p >See <a class="el" href="group__TensorGroup.html#ga5f4d32242977ea137fd6447874af7a2e" title="Computes the determinant and inverse of a rank-2 Tensor.">determinant_and_inverse()</a>. </p>

</div>
</div>
<a id="gae2e756ad470368b0e809971ac690623f" name="gae2e756ad470368b0e809971ac690623f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2e756ad470368b0e809971ac690623f">&#9670;&nbsp;</a></span>determinant_and_inverse() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Symm , typename Index0 , typename Index1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto determinant_and_inverse </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; T, Symm, tmpl::list&lt; Index0, Index1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td> -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt;<a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt;T&gt;, Tensor&lt;T, Symm,
                                   tmpl::list&lt;<a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt;Index1&gt;,
                                              <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt;Index0&gt;&gt;&gt;&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the determinant and inverse of a rank-2 Tensor. </p>
<p >Computes the determinant and inverse together, because this leads to fewer operations compared to computing the determinant independently.</p>
<h3>Details</h3>
<p >Treats the input rank-2 tensor as a matrix. The first (second) index of the tensor corresponds to the rows (columns) of the matrix. The determinant is a scalar tensor. The inverse is a rank-2 tensor whose indices are reversed and of opposite valence relative to the input tensor, i.e. given \(T_a^b\) returns \((Tinv)_b^a\).</p>
<dl class="section note"><dt>Note</dt><dd>When inverting a 4x4 spacetime metric, it is typically more efficient to use the 3+1 decomposition of the 4-metric in terms of lapse, shift, and spatial 3-metric, in which only the spatial 3-metric needs to be inverted. </dd></dl>

</div>
</div>
<a id="ga923023af6eb533286219401e1e56286e" name="ga923023af6eb533286219401e1e56286e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga923023af6eb533286219401e1e56286e">&#9670;&nbsp;</a></span>determinant_and_inverse() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DetTag , typename InvTag , typename T , typename Symm , typename Index0 , typename Index1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto determinant_and_inverse </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; T, Symm, tmpl::list&lt; Index0, Index1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td> -&gt; Variables&lt;tmpl::list&lt;DetTag, InvTag&gt;&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the determinant and inverse of a rank-2 Tensor. </p>
<p >Computes the determinant and inverse together, because this leads to fewer operations compared to computing the determinant independently.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DetTag</td><td>the Tag for the determinant of input Tensor. </td></tr>
    <tr><td class="paramname">InvTag</td><td>the Tag for the inverse of input Tensor.</td></tr>
  </table>
  </dd>
</dl>
<h3>Details</h3>
<p >See <a class="el" href="group__TensorGroup.html#ga5f4d32242977ea137fd6447874af7a2e" title="Computes the determinant and inverse of a rank-2 Tensor.">determinant_and_inverse()</a>. </p>

</div>
</div>
<a id="ga75555cef48983db9295bfa3879c06dd0" name="ga75555cef48983db9295bfa3879c06dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75555cef48983db9295bfa3879c06dd0">&#9670;&nbsp;</a></span>dot_product() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename <a class="el" href="classIndex.html">Index</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dot_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt;&#160;</td>
          <td class="paramname"><em>dot_product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the dot product of a vector and a one form. </p>
<h3>Details</h3>
<p >Returns \(A^a B_b \delta_{a}^b\) for input vector \(A^a\) and input one form \(B_b\) or \(A_a B^b \delta^a_b\) for input one form \(A_a\) and input vector \(B^b\). </p>

</div>
</div>
<a id="ga04be72967efc01e374b98c8fb833d51b" name="ga04be72967efc01e374b98c8fb833d51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04be72967efc01e374b98c8fb833d51b">&#9670;&nbsp;</a></span>dot_product() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename <a class="el" href="classIndex.html">Index</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dot_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt;&#160;</td>
          <td class="paramname"><em>dot_product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Euclidean dot product of two vectors or one forms. </p>
<h3>Details</h3>
<p >Returns \(A^a B^b \delta_{ab}\) for input vectors \(A^a\) and \(B^b\) or \(A_a B_b \delta^{ab}\) for input one forms \(A_a\) and \(B_b\). </p>

</div>
</div>
<a id="ga634a6e80472bd84d88804fabd067e8ef" name="ga634a6e80472bd84d88804fabd067e8ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga634a6e80472bd84d88804fabd067e8ef">&#9670;&nbsp;</a></span>dot_product() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename <a class="el" href="classIndex.html">Index</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dot_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt;&#160;</td>
          <td class="paramname"><em>dot_product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the dot_product of two vectors or one forms. </p>
<h3>Details</h3>
<p >Returns \(g_{ab} A^a B^b\), where \(g_{ab}\) is the metric, \(A^a\) is vector_a, and \(B^b\) is vector_b. Or, returns \(g^{ab} A_a B_b\) when given one forms \(A_a\) and \(B_b\) with an inverse metric \(g^{ab}\). </p>

</div>
</div>
<a id="ga96ca4b62c235a57502e309519734857b" name="ga96ca4b62c235a57502e309519734857b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96ca4b62c235a57502e309519734857b">&#9670;&nbsp;</a></span>dot_product() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename <a class="el" href="classIndex.html">Index</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; dot_product </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the dot product of a vector and a one form. </p>
<h3>Details</h3>
<p >Returns \(A^a B_b \delta_{a}^b\) for input vector \(A^a\) and input one form \(B_b\) or \(A_a B^b \delta^a_b\) for input one form \(A_a\) and input vector \(B^b\). </p>

</div>
</div>
<a id="ga728120193a01de46c4d7f61f8130c3e2" name="ga728120193a01de46c4d7f61f8130c3e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga728120193a01de46c4d7f61f8130c3e2">&#9670;&nbsp;</a></span>dot_product() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename <a class="el" href="classIndex.html">Index</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; dot_product </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Euclidean dot product of two vectors or one forms. </p>
<h3>Details</h3>
<p >Returns \(A^a B^b \delta_{ab}\) for input vectors \(A^a\) and \(B^b\) or \(A_a B_b \delta^{ab}\) for input one forms \(A_a\) and \(B_b\). </p>

</div>
</div>
<a id="ga2506c687e3d6db8506877032b8488aec" name="ga2506c687e3d6db8506877032b8488aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2506c687e3d6db8506877032b8488aec">&#9670;&nbsp;</a></span>dot_product() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename <a class="el" href="classIndex.html">Index</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; dot_product </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the dot_product of two vectors or one forms. </p>
<h3>Details</h3>
<p >Returns \(g_{ab} A^a B^b\), where \(g_{ab}\) is the metric, \(A^a\) is vector_a, and \(B^b\) is vector_b. Or, returns \(g^{ab} A_a B_b\) when given one forms \(A_a\) and \(B_b\) with an inverse metric \(g^{ab}\). </p>

</div>
</div>
<a id="gad5daee96d09341749beb47cfa8046baf" name="gad5daee96d09341749beb47cfa8046baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5daee96d09341749beb47cfa8046baf">&#9670;&nbsp;</a></span>index_dim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int I, class... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t index_dim </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get dimensionality of i'th tensor index. </p>
<div class="fragment"><div class="line">    <span class="keyword">using</span> T = Tensor&lt;double, Symmetry&lt;1, 2, 3&gt;,</div>
<div class="line">                     index_list&lt;SpacetimeIndex&lt;2, UpLo::Up, Frame::Inertial&gt;,</div>
<div class="line">                                <a class="code hl_typedef" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex&lt;1, UpLo::Up, Frame::Inertial&gt;</a>,</div>
<div class="line">                                <a class="code hl_typedef" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex&lt;2, UpLo::Up, Frame::Inertial&gt;</a>&gt;&gt;;</div>
<div class="line">    <span class="keyword">const</span> T t{};</div>
<div class="line">    CHECK(index_dim&lt;0&gt;(t) == 3);</div>
<div class="line">    CHECK(index_dim&lt;1&gt;(t) == 1);</div>
<div class="line">    CHECK(index_dim&lt;2&gt;(t) == 2);</div>
<div class="line">    CHECK(<a class="code hl_function" href="group__TensorGroup.html#gad5daee96d09341749beb47cfa8046baf">T::index_dim</a>(0) == 3);</div>
<div class="line">    CHECK(<a class="code hl_function" href="group__TensorGroup.html#gad5daee96d09341749beb47cfa8046baf">T::index_dim</a>(1) == 1);</div>
<div class="line">    CHECK(<a class="code hl_function" href="group__TensorGroup.html#gad5daee96d09341749beb47cfa8046baf">T::index_dim</a>(2) == 2);</div>
<div class="line">    CHECK(T::index_dims() == <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;size_t, 3&gt;</a>{{3, 1, 2}});</div>
<div class="ttc" id="aarray_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt; size_t, 3 &gt;</a></div></div>
<div class="ttc" id="agroup__TensorGroup_html_gad5daee96d09341749beb47cfa8046baf"><div class="ttname"><a href="group__TensorGroup.html#gad5daee96d09341749beb47cfa8046baf">index_dim</a></div><div class="ttdeci">constexpr size_t index_dim(const Tensor&lt; Ts... &gt; &amp;)</div><div class="ttdoc">Get dimensionality of i'th tensor index.</div><div class="ttdef"><b>Definition:</b> Tensor.hpp:563</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga3d8b65ef0126f9670190c1ae186124a3" name="ga3d8b65ef0126f9670190c1ae186124a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d8b65ef0126f9670190c1ae186124a3">&#9670;&nbsp;</a></span>l2_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Symm , typename IndexList &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double l2_norm </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; DataType, Symm, IndexList &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Euclidean \(L^2\)-norm of arbitrary Tensors reduced over an element. </p>
<h3>Details</h3>
<p >Computes the RMS value of the point-wise Frobenius norm of a given Tensor with arbitrary rank over all grid points in an element. If the Tensor \(A\) has rank \(n\) and dimensionality \(D\), and the element (of order \(N\)) has \(N+1\) points, then its element-reduced Frobenius norm is computed as:</p>
<p class="formulaDsp">
\begin{equation} ||A||_2 = \left(\frac{1}{N+1}\sum^{N}_{p=0} \left(\sum^{D-1}_{i_1=0}\sum^{D-1}_{i_2=0}\cdots \sum^{D-1}_{i_n=0} |A^p_{i_1 i_2 \cdots i_n}|^2 \right) \right)^{1/2}, \end{equation}
</p>
<p >where both contra-variant and co-variant indices are shown as lower indices, and \(p\) indexes grid points in the element.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function reduces the Frobenius norm over the element, not the whole domain. </dd></dl>

</div>
</div>
<a id="gaafe858306b847b1d56ef7fea21e28af7" name="gaafe858306b847b1d56ef7fea21e28af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafe858306b847b1d56ef7fea21e28af7">&#9670;&nbsp;</a></span>magnitude() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename <a class="el" href="classIndex.html">Index</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void magnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt;&#160;</td>
          <td class="paramname"><em>magnitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Euclidean magnitude of a rank-1 tensor. </p>
<h3>Details</h3>
<p >Computes the square root of the sum of the squares of the components of the rank-1 tensor. </p>

</div>
</div>
<a id="ga30503294818130bc3037ccdee94ed858" name="ga30503294818130bc3037ccdee94ed858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30503294818130bc3037ccdee94ed858">&#9670;&nbsp;</a></span>magnitude() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename <a class="el" href="classIndex.html">Index</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void magnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt;&#160;</td>
          <td class="paramname"><em>magnitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the magnitude of a rank-1 tensor. </p>
<h3>Details</h3>
<p >Returns the square root of the input tensor contracted twice with the given metric. </p>

</div>
</div>
<a id="ga447f2baf57b4cb3f6f2b1bb617f6ee3a" name="ga447f2baf57b4cb3f6f2b1bb617f6ee3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga447f2baf57b4cb3f6f2b1bb617f6ee3a">&#9670;&nbsp;</a></span>magnitude() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename <a class="el" href="classIndex.html">Index</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; magnitude </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Euclidean magnitude of a rank-1 tensor. </p>
<h3>Details</h3>
<p >Computes the square root of the sum of the squares of the components of the rank-1 tensor. </p>

</div>
</div>
<a id="ga2a23aced3155d37fcfb5f7a5fd46b69e" name="ga2a23aced3155d37fcfb5f7a5fd46b69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a23aced3155d37fcfb5f7a5fd46b69e">&#9670;&nbsp;</a></span>magnitude() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename <a class="el" href="classIndex.html">Index</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; magnitude </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the magnitude of a rank-1 tensor. </p>
<h3>Details</h3>
<p >Returns the square root of the input tensor contracted twice with the given metric. </p>

</div>
</div>
<a id="gac57af89c3a97d86d4cca7c0afa4b2072" name="gac57af89c3a97d86d4cca7c0afa4b2072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac57af89c3a97d86d4cca7c0afa4b2072">&#9670;&nbsp;</a></span>orthonormal_oneform() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Frame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::i&lt; DataType, 3, Frame &gt; orthonormal_oneform </td>
          <td>(</td>
          <td class="paramtype">const tnsr::i&lt; DataType, 3, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_unit_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; DataType, 3, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_unit_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, 3, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>det_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a spatial one-form orthonormal to two given unit forms. </p>
<p >Given a unit spatial one-form \(s_i\) and another form \(t_i\) that is orthonormal to \(s_i\), compute a new form \(u_i\) which is orthonormal to both \(s_i\) and \(t_i\), in the sense that \(\gamma^{ij}s_i u_j = \gamma^{ij}t_i u_j = 0\), for the given inverse spatial metric \(\gamma^{ij}\). The normalization of \(u_i\) is such that \(\gamma^{ij}u_iu_j = 1\).</p>
<h3>Details</h3>
<p >The new form is obtained by taking the covariant cross product of \(s_i\) and \( t_i\), for which the spatial metric as well as its determinant must be provided. </p>

</div>
</div>
<a id="gac8a980cdb5f3cb28a1c0bf6f567d6561" name="gac8a980cdb5f3cb28a1c0bf6f567d6561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8a980cdb5f3cb28a1c0bf6f567d6561">&#9670;&nbsp;</a></span>orthonormal_oneform() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , size_t VolumeDim, typename Frame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::i&lt; DataType, VolumeDim, Frame &gt; orthonormal_oneform </td>
          <td>(</td>
          <td class="paramtype">const tnsr::i&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>unit_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inv_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a spatial one-form orthonormal to the given unit form. </p>
<p >Given a unit spatial one-form \(s_i\), compute a new form \(t_i\) which is orthonormal to \(s_i\), in the sense that \(\gamma^{ij}s_i t_j = 0\), for the given inverse spatial metric \(\gamma^{ij}\). The normalization of \(t_i\) is such that \(\gamma^{ij}t_it_j = 1\).</p>
<h3>Details</h3>
<p >The new form is obtained via Gram-Schmidt process, starting from a form whose components are \(t_i = \delta_i^I\), where \(I\) is the index of the component of \(s_i\) with the smallest absolute value. </p>

</div>
</div>
<a id="ga21685a6a82d5fb9e13e11c88ca403323" name="ga21685a6a82d5fb9e13e11c88ca403323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21685a6a82d5fb9e13e11c88ca403323">&#9670;&nbsp;</a></span>orthonormal_oneform() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Frame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void orthonormal_oneform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; DataType, 3, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>orthonormal_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; DataType, 3, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_unit_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; DataType, 3, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_unit_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, 3, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>det_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a spatial one-form orthonormal to two given unit forms. </p>
<p >Given a unit spatial one-form \(s_i\) and another form \(t_i\) that is orthonormal to \(s_i\), compute a new form \(u_i\) which is orthonormal to both \(s_i\) and \(t_i\), in the sense that \(\gamma^{ij}s_i u_j = \gamma^{ij}t_i u_j = 0\), for the given inverse spatial metric \(\gamma^{ij}\). The normalization of \(u_i\) is such that \(\gamma^{ij}u_iu_j = 1\).</p>
<h3>Details</h3>
<p >The new form is obtained by taking the covariant cross product of \(s_i\) and \( t_i\), for which the spatial metric as well as its determinant must be provided. </p>

</div>
</div>
<a id="ga575809a99dff3c2a104360a1e4d9200b" name="ga575809a99dff3c2a104360a1e4d9200b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga575809a99dff3c2a104360a1e4d9200b">&#9670;&nbsp;</a></span>orthonormal_oneform() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , size_t VolumeDim, typename Frame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void orthonormal_oneform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; DataType, VolumeDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>orthonormal_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>unit_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inv_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a spatial one-form orthonormal to the given unit form. </p>
<p >Given a unit spatial one-form \(s_i\), compute a new form \(t_i\) which is orthonormal to \(s_i\), in the sense that \(\gamma^{ij}s_i t_j = 0\), for the given inverse spatial metric \(\gamma^{ij}\). The normalization of \(t_i\) is such that \(\gamma^{ij}t_it_j = 1\).</p>
<h3>Details</h3>
<p >The new form is obtained via Gram-Schmidt process, starting from a form whose components are \(t_i = \delta_i^I\), where \(I\) is the index of the component of \(s_i\) with the smallest absolute value. </p>

</div>
</div>
<a id="ga5cb473fcc3adf0e77383c8a3cce60d53" name="ga5cb473fcc3adf0e77383c8a3cce60d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cb473fcc3adf0e77383c8a3cce60d53">&#9670;&nbsp;</a></span>pointwise_l2_norm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Symm , typename IndexList &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pointwise_l2_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt;&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, Symm, IndexList &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute point-wise Euclidean \(L^2\)-norm of arbitrary Tensors. </p>
<h3>Details</h3>
<p >At each grid point \(p\) in the element, this function computes the point-wise Frobenius norm of a given Tensor with arbitrary rank. If the Tensor \(A\) has rank \(n\) and dimensionality \(D\), then its Frobenius norm at point \(p\) is computed as:</p>
<p class="formulaDsp">
\begin{equation} ||A||_2(p) = \left(\sum^{D-1}_{i_1=0}\sum^{D-1}_{i_2=0}\cdots \sum^{D-1}_{i_n=0} |A_{i_1 i_2 \cdots i_n}(p)|^2 \right)^{1/2}, \end{equation}
</p>
<p >where both contra-variant and co-variant indices are shown as lower indices. </p>

</div>
</div>
<a id="gadc19b7b25eba938fd622a3942e3069de" name="gadc19b7b25eba938fd622a3942e3069de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc19b7b25eba938fd622a3942e3069de">&#9670;&nbsp;</a></span>pointwise_l2_norm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Symm , typename IndexList &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; pointwise_l2_norm </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; DataType, Symm, IndexList &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute point-wise Euclidean \(L^2\)-norm of arbitrary Tensors. </p>
<h3>Details</h3>
<p >At each grid point \(p\) in the element, this function computes the point-wise Frobenius norm of a given Tensor with arbitrary rank. If the Tensor \(A\) has rank \(n\) and dimensionality \(D\), then its Frobenius norm at point \(p\) is computed as:</p>
<p class="formulaDsp">
\begin{equation} ||A||_2(p) = \left(\sum^{D-1}_{i_1=0}\sum^{D-1}_{i_2=0}\cdots \sum^{D-1}_{i_n=0} |A_{i_1 i_2 \cdots i_n}(p)|^2 \right)^{1/2}, \end{equation}
</p>
<p >where both contra-variant and co-variant indices are shown as lower indices. </p>

</div>
</div>
<a id="ga1b9b1bf910598514cbeb78445c1c4dcc" name="ga1b9b1bf910598514cbeb78445c1c4dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b9b1bf910598514cbeb78445c1c4dcc">&#9670;&nbsp;</a></span>prefix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> Frame::prefix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The frame-dependent prefix used when constructing the string returned by the name function of a tag. </p>
<p >For <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> it is the empty string, otherwise, it is the name of the <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> followed by an underscore (as the name will be used in I/O). </p>
<h3>Example</h3>
<div class="fragment"><div class="line">  TestHelpers::db::test_simple_tag&lt;</div>
<div class="line">      <a class="code hl_struct" href="structhydro_1_1Tags_1_1SpatialVelocity.html">hydro::Tags::SpatialVelocity&lt;DataVector, 3, Frame::Grid&gt;</a>&gt;(</div>
<div class="line">      <span class="stringliteral">&quot;Grid_SpatialVelocity&quot;</span>);</div>
<div class="line">  TestHelpers::db::test_simple_tag&lt;<a class="code hl_struct" href="structhydro_1_1Tags_1_1SpatialVelocityOneForm.html">hydro::Tags::SpatialVelocityOneForm</a>&lt;</div>
<div class="line">      <a class="code hl_class" href="classDataVector.html">DataVector</a>, 3, <a class="code hl_struct" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>&gt;&gt;(</div>
<div class="line">      <span class="stringliteral">&quot;ElementLogical_SpatialVelocityOneForm&quot;</span>);</div>
<div class="ttc" id="aclassDataVector_html"><div class="ttname"><a href="classDataVector.html">DataVector</a></div><div class="ttdoc">Stores a collection of function values.</div><div class="ttdef"><b>Definition:</b> DataVector.hpp:48</div></div>
<div class="ttc" id="astructFrame_1_1ElementLogical_html"><div class="ttname"><a href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a></div><div class="ttdef"><b>Definition:</b> IndexType.hpp:43</div></div>
<div class="ttc" id="astructhydro_1_1Tags_1_1SpatialVelocityOneForm_html"><div class="ttname"><a href="structhydro_1_1Tags_1_1SpatialVelocityOneForm.html">hydro::Tags::SpatialVelocityOneForm</a></div><div class="ttdoc">The spatial velocity one-form , where  is raised and lowered with the spatial metric.</div><div class="ttdef"><b>Definition:</b> Tags.hpp:201</div></div>
<div class="ttc" id="astructhydro_1_1Tags_1_1SpatialVelocity_html"><div class="ttname"><a href="structhydro_1_1Tags_1_1SpatialVelocity.html">hydro::Tags::SpatialVelocity</a></div><div class="ttdoc">The spatial velocity  of the fluid, where . Here  is the spatial part of the 4-velocity of the fluid,...</div><div class="ttdef"><b>Definition:</b> Tags.hpp:193</div></div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga36bbeb0ee2084a06f7d950201cdc0d79" name="ga36bbeb0ee2084a06f7d950201cdc0d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36bbeb0ee2084a06f7d950201cdc0d79">&#9670;&nbsp;</a></span>is_frame_physical_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CheckFrame &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Frame::is_frame_physical_v = <a class="el" href="group__TensorGroup.html#ga4e16b80d37cb8a3e7c8ab95e72ab8724">is_frame_physical</a>&lt;CheckFrame&gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the frame is "physical" in the sense that it is meaningful to evaluate an analytic solution in that frame. </p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="keyword">static_assert</span>(not Frame::is_frame_physical_v&lt;Frame::BlockLogical&gt;,</div>
<div class="line">              <span class="stringliteral">&quot;Failed testing Frame::is_frame_physical&quot;</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(not Frame::is_frame_physical_v&lt;Frame::ElementLogical&gt;,</div>
<div class="line">              <span class="stringliteral">&quot;Failed testing Frame::is_frame_physical&quot;</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(not Frame::is_frame_physical_v&lt;Frame::Distorted&gt;,</div>
<div class="line">              <span class="stringliteral">&quot;Failed testing Frame::is_frame_physical&quot;</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(not Frame::is_frame_physical_v&lt;Frame::Grid&gt;,</div>
<div class="line">              <span class="stringliteral">&quot;Failed testing Frame::is_frame_physical&quot;</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(Frame::is_frame_physical_v&lt;Frame::Inertial&gt;,</div>
<div class="line">              <span class="stringliteral">&quot;Failed testing Frame::is_frame_physical&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
