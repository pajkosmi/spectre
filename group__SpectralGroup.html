<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: Spectral</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__SpectralGroup.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Spectral</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceSpectral"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html">Spectral</a></td></tr>
<tr class="memdesc:namespaceSpectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functionality associated with a particular choice of basis functions and quadrature for spectral operations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceSpectral_1_1Swsh"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral_1_1Swsh.html">Spectral::Swsh</a></td></tr>
<tr class="memdesc:namespaceSpectral_1_1Swsh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for spin-weighted spherical harmonic utilities. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceSpectral_1_1filtering"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral_1_1filtering.html">Spectral::filtering</a></td></tr>
<tr class="memdesc:namespaceSpectral_1_1filtering"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrices for filtering spectral coefficients. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classylm_1_1Spherepack.html">ylm::Spherepack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the C++ interface to SPHEREPACK.  <a href="classylm_1_1Spherepack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpherepackIterator.html">SpherepackIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over spectral coefficients stored in SPHEREPACK format.  <a href="classSpherepackIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5d3e95021414531f2b911ebc69c52890"><td class="memTemplParams" colspan="2">template&lt;typename DerivativeTagList , <a class="el" href="namespaceSpectral_1_1Swsh.html#ab1fa85ae53abba64a770e7e806bf12f6">ComplexRepresentation</a> Representation = ComplexRepresentation::Interleaved&gt; </td></tr>
<tr class="memitem:ga5d3e95021414531f2b911ebc69c52890"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SpectralGroup.html#ga5d3e95021414531f2b911ebc69c52890">Spectral::Swsh::AngularDerivatives</a> = detail::AngularDerivativesImpl&lt; DerivativeTagList, typename detail::unique_derived_from_list&lt; DerivativeTagList &gt;::type, Representation &gt;</td></tr>
<tr class="memdesc:ga5d3e95021414531f2b911ebc69c52890"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="group__DataBoxGroup.html">DataBox</a> mutate-compatible computational struct for computing a set of spin-weighted spherical harmonic derivatives by grouping and batch-computing spin-weighted spherical harmonic transforms.  <a href="group__SpectralGroup.html#ga5d3e95021414531f2b911ebc69c52890">More...</a><br /></td></tr>
<tr class="separator:ga5d3e95021414531f2b911ebc69c52890"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga37c9c17d05dccca652060d117f72ee21"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SpectralGroup.html#ga37c9c17d05dccca652060d117f72ee21">Spectral::Basis</a> { <b>Chebyshev</b>
, <b>Legendre</b>
, <b>FiniteDifference</b>
, <b>SphericalHarmonic</b>
 }</td></tr>
<tr class="memdesc:ga37c9c17d05dccca652060d117f72ee21"><td class="mdescLeft">&#160;</td><td class="mdescRight">The choice of basis functions for computing collocation points and weights.  <a href="group__SpectralGroup.html#ga37c9c17d05dccca652060d117f72ee21">More...</a><br /></td></tr>
<tr class="separator:ga37c9c17d05dccca652060d117f72ee21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7744e520f6d553caf358a6f09f5978c1"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SpectralGroup.html#ga7744e520f6d553caf358a6f09f5978c1">Spectral::Quadrature</a> { <br />
&#160;&#160;<b>Gauss</b>
, <b>GaussLobatto</b>
, <b>CellCentered</b>
, <b>FaceCentered</b>
, <br />
&#160;&#160;<b>Equiangular</b>
<br />
 }</td></tr>
<tr class="memdesc:ga7744e520f6d553caf358a6f09f5978c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The choice of quadrature method to compute integration weights.  <a href="group__SpectralGroup.html#ga7744e520f6d553caf358a6f09f5978c1">More...</a><br /></td></tr>
<tr class="separator:ga7744e520f6d553caf358a6f09f5978c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7a207399084b0a58f9fc7e09dd9779cb"><td class="memTemplParams" colspan="2">template&lt;int Spin&gt; </td></tr>
<tr class="memitem:ga7a207399084b0a58f9fc7e09dd9779cb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SpectralGroup.html#ga7a207399084b0a58f9fc7e09dd9779cb">Spectral::Swsh::swsh_buffer</a> (const size_t l_max, const size_t number_of_radial_points)</td></tr>
<tr class="memdesc:ga7a207399084b0a58f9fc7e09dd9779cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a <code><a class="el" href="structSpinWeighted.html" title="Make a spin-weighted type T with spin-weight Spin. Mathematical operators are restricted to addition,...">SpinWeighted</a>&lt;<a class="el" href="classComplexModalVector.html" title="A class for storing complex spectral coefficients on a spectral grid.">ComplexModalVector</a>, Spin&gt;</code> of the appropriate size to be used as a modal buffer for <code><a class="el" href="group__SpectralGroup.html#ga5d3e95021414531f2b911ebc69c52890" title="A DataBox mutate-compatible computational struct for computing a set of spin-weighted spherical harmo...">Spectral::Swsh::AngularDerivatives</a></code> or <code><a class="el" href="group__SpectralGroup.html#ga9264acddba199cce62e09b047b4f7018" title="Evaluate all of the spin-weighted derivatives in DerivKindList on input SpinWeighted&lt;ComplexDataVecto...">Spectral::Swsh::angular_derivatives</a></code>.  <a href="group__SpectralGroup.html#ga7a207399084b0a58f9fc7e09dd9779cb">More...</a><br /></td></tr>
<tr class="separator:ga7a207399084b0a58f9fc7e09dd9779cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9264acddba199cce62e09b047b4f7018"><td class="memTemplParams" colspan="2">template&lt;typename DerivativeKindList , <a class="el" href="namespaceSpectral_1_1Swsh.html#ab1fa85ae53abba64a770e7e806bf12f6">ComplexRepresentation</a> Representation = ComplexRepresentation::Interleaved, typename... ArgumentTypes&gt; </td></tr>
<tr class="memitem:ga9264acddba199cce62e09b047b4f7018"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SpectralGroup.html#ga9264acddba199cce62e09b047b4f7018">Spectral::Swsh::angular_derivatives</a> (const size_t l_max, const size_t number_of_radial_points, const ArgumentTypes &amp;... arguments)</td></tr>
<tr class="memdesc:ga9264acddba199cce62e09b047b4f7018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate all of the spin-weighted derivatives in <code>DerivKindList</code> on input <code><a class="el" href="structSpinWeighted.html" title="Make a spin-weighted type T with spin-weight Spin. Mathematical operators are restricted to addition,...">SpinWeighted</a>&lt;<a class="el" href="classComplexDataVector.html" title="Stores a collection of complex function values.">ComplexDataVector</a>, Spin&gt;</code> collocation data, returning by pointer.  <a href="group__SpectralGroup.html#ga9264acddba199cce62e09b047b4f7018">More...</a><br /></td></tr>
<tr class="separator:ga9264acddba199cce62e09b047b4f7018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a26d8825ce7766195d3ef7df7542a44"><td class="memTemplParams" colspan="2"><a id="ga1a26d8825ce7766195d3ef7df7542a44" name="ga1a26d8825ce7766195d3ef7df7542a44"></a>
template&lt;typename DerivKind , <a class="el" href="namespaceSpectral_1_1Swsh.html#ab1fa85ae53abba64a770e7e806bf12f6">ComplexRepresentation</a> Representation = ComplexRepresentation::Interleaved, int Spin&gt; </td></tr>
<tr class="memitem:ga1a26d8825ce7766195d3ef7df7542a44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, Tags::derivative_spin_weight&lt; DerivKind &gt;+Spin &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Spectral::Swsh::angular_derivative</b> (size_t l_max, size_t number_of_radial_points, const <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, Spin &gt; &amp;to_differentiate)</td></tr>
<tr class="memdesc:ga1a26d8825ce7766195d3ef7df7542a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the spin-weighted derivative <code>DerivKind</code> on the provided <code><a class="el" href="structSpinWeighted.html" title="Make a spin-weighted type T with spin-weight Spin. Mathematical operators are restricted to addition,...">SpinWeighted</a>&lt;<a class="el" href="classComplexDataVector.html" title="Stores a collection of complex function values.">ComplexDataVector</a>, Spin&gt;</code> collocation data, returning by value. <br /></td></tr>
<tr class="separator:ga1a26d8825ce7766195d3ef7df7542a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga573c26c78bd668fc6c108f9469698225"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ga573c26c78bd668fc6c108f9469698225"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SpectralGroup.html#ga573c26c78bd668fc6c108f9469698225">to_modal_coefficients</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> * &gt; modal_coefficients, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;nodal_coefficients, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga573c26c78bd668fc6c108f9469698225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the modal coefficients from the nodal coefficients.  <a href="group__SpectralGroup.html#ga573c26c78bd668fc6c108f9469698225">More...</a><br /></td></tr>
<tr class="separator:ga573c26c78bd668fc6c108f9469698225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b06cbc6fc9cab9eaac517d604faab14"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ga6b06cbc6fc9cab9eaac517d604faab14"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SpectralGroup.html#ga6b06cbc6fc9cab9eaac517d604faab14">to_modal_coefficients</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classModalVector.html">ModalVector</a> * &gt; modal_coefficients, const <a class="el" href="classDataVector.html">DataVector</a> &amp;nodal_coefficients, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga6b06cbc6fc9cab9eaac517d604faab14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the modal coefficients from the nodal coefficients.  <a href="group__SpectralGroup.html#ga6b06cbc6fc9cab9eaac517d604faab14">More...</a><br /></td></tr>
<tr class="separator:ga6b06cbc6fc9cab9eaac517d604faab14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72480edebe2ba5ab9dce80fc826188ee"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ga72480edebe2ba5ab9dce80fc826188ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classModalVector.html">ModalVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SpectralGroup.html#ga72480edebe2ba5ab9dce80fc826188ee">to_modal_coefficients</a> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;nodal_coefficients, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga72480edebe2ba5ab9dce80fc826188ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the modal coefficients from the nodal coefficients.  <a href="group__SpectralGroup.html#ga72480edebe2ba5ab9dce80fc826188ee">More...</a><br /></td></tr>
<tr class="separator:ga72480edebe2ba5ab9dce80fc826188ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba48908f5db7b7e4c924a62a067e6cd8"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:gaba48908f5db7b7e4c924a62a067e6cd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classComplexModalVector.html">ComplexModalVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SpectralGroup.html#gaba48908f5db7b7e4c924a62a067e6cd8">to_modal_coefficients</a> (const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;nodal_coefficients, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh)</td></tr>
<tr class="memdesc:gaba48908f5db7b7e4c924a62a067e6cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the modal coefficients from the nodal coefficients.  <a href="group__SpectralGroup.html#gaba48908f5db7b7e4c924a62a067e6cd8">More...</a><br /></td></tr>
<tr class="separator:gaba48908f5db7b7e4c924a62a067e6cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4437aa4b72e08aead8cd23af669a161"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:gab4437aa4b72e08aead8cd23af669a161"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SpectralGroup.html#gab4437aa4b72e08aead8cd23af669a161">to_nodal_coefficients</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> * &gt; nodal_coefficients, const <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &amp;modal_coefficients, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh)</td></tr>
<tr class="memdesc:gab4437aa4b72e08aead8cd23af669a161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nodal coefficients from the modal coefficients.  <a href="group__SpectralGroup.html#gab4437aa4b72e08aead8cd23af669a161">More...</a><br /></td></tr>
<tr class="separator:gab4437aa4b72e08aead8cd23af669a161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56c43516ab467513d56375b734d870e9"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ga56c43516ab467513d56375b734d870e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SpectralGroup.html#ga56c43516ab467513d56375b734d870e9">to_nodal_coefficients</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt; nodal_coefficients, const <a class="el" href="classModalVector.html">ModalVector</a> &amp;modal_coefficients, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga56c43516ab467513d56375b734d870e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nodal coefficients from the modal coefficients.  <a href="group__SpectralGroup.html#ga56c43516ab467513d56375b734d870e9">More...</a><br /></td></tr>
<tr class="separator:ga56c43516ab467513d56375b734d870e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e01278ed8346f1f7f3e1b445309f8c3"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ga5e01278ed8346f1f7f3e1b445309f8c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDataVector.html">DataVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SpectralGroup.html#ga5e01278ed8346f1f7f3e1b445309f8c3">to_nodal_coefficients</a> (const <a class="el" href="classModalVector.html">ModalVector</a> &amp;modal_coefficients, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga5e01278ed8346f1f7f3e1b445309f8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nodal coefficients from the modal coefficients.  <a href="group__SpectralGroup.html#ga5e01278ed8346f1f7f3e1b445309f8c3">More...</a><br /></td></tr>
<tr class="separator:ga5e01278ed8346f1f7f3e1b445309f8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4cfaaa6ffedd023b8276904d96fefed"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:gae4cfaaa6ffedd023b8276904d96fefed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classComplexDataVector.html">ComplexDataVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SpectralGroup.html#gae4cfaaa6ffedd023b8276904d96fefed">to_nodal_coefficients</a> (const <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &amp;modal_coefficients, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh)</td></tr>
<tr class="memdesc:gae4cfaaa6ffedd023b8276904d96fefed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nodal coefficients from the modal coefficients.  <a href="group__SpectralGroup.html#gae4cfaaa6ffedd023b8276904d96fefed">More...</a><br /></td></tr>
<tr class="separator:gae4cfaaa6ffedd023b8276904d96fefed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga380b79de66295d0a7e0213b3a39fa2bd"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ga380b79de66295d0a7e0213b3a39fa2bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SpectralGroup.html#ga380b79de66295d0a7e0213b3a39fa2bd">PowerMonitors::power_monitors</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim &gt; * &gt; result, const <a class="el" href="classDataVector.html">DataVector</a> &amp;input_data_vector, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga380b79de66295d0a7e0213b3a39fa2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns array of power monitors in each spatial dimension.  <a href="group__SpectralGroup.html#ga380b79de66295d0a7e0213b3a39fa2bd">More...</a><br /></td></tr>
<tr class="separator:ga380b79de66295d0a7e0213b3a39fa2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2b1c2c6ec45492d6da13fb950f3b3f2"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:gaf2b1c2c6ec45492d6da13fb950f3b3f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SpectralGroup.html#gaf2b1c2c6ec45492d6da13fb950f3b3f2">PowerMonitors::power_monitors</a> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;input_data_vector, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh)</td></tr>
<tr class="memdesc:gaf2b1c2c6ec45492d6da13fb950f3b3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns array of power monitors in each spatial dimension.  <a href="group__SpectralGroup.html#gaf2b1c2c6ec45492d6da13fb950f3b3f2">More...</a><br /></td></tr>
<tr class="separator:gaf2b1c2c6ec45492d6da13fb950f3b3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13dd114cf3e63d2b51d0006366129c8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SpectralGroup.html#ga13dd114cf3e63d2b51d0006366129c8c">real_spherical_harmonic</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt; spherical_harmonic, const <a class="el" href="classDataVector.html">DataVector</a> &amp;theta, const <a class="el" href="classDataVector.html">DataVector</a> &amp;phi, size_t l, int m)</td></tr>
<tr class="memdesc:ga13dd114cf3e63d2b51d0006366129c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a real spherical harmonic of order l at the requested angles \(\theta\) and \(\phi\).  <a href="group__SpectralGroup.html#ga13dd114cf3e63d2b51d0006366129c8c">More...</a><br /></td></tr>
<tr class="separator:ga13dd114cf3e63d2b51d0006366129c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0448163c8cbc5ed6b1eabe1ce1b13c62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDataVector.html">DataVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SpectralGroup.html#ga0448163c8cbc5ed6b1eabe1ce1b13c62">real_spherical_harmonic</a> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;theta, const <a class="el" href="classDataVector.html">DataVector</a> &amp;phi, size_t l, int m)</td></tr>
<tr class="memdesc:ga0448163c8cbc5ed6b1eabe1ce1b13c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a real spherical harmonic of order l at the requested angles \(\theta\) and \(\phi\).  <a href="group__SpectralGroup.html#ga0448163c8cbc5ed6b1eabe1ce1b13c62">More...</a><br /></td></tr>
<tr class="separator:ga0448163c8cbc5ed6b1eabe1ce1b13c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Things related to spectral transformations. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga5d3e95021414531f2b911ebc69c52890" name="ga5d3e95021414531f2b911ebc69c52890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d3e95021414531f2b911ebc69c52890">&#9670;&nbsp;</a></span>AngularDerivatives</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivativeTagList , <a class="el" href="namespaceSpectral_1_1Swsh.html#ab1fa85ae53abba64a770e7e806bf12f6">ComplexRepresentation</a> Representation = ComplexRepresentation::Interleaved&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__SpectralGroup.html#ga5d3e95021414531f2b911ebc69c52890">Spectral::Swsh::AngularDerivatives</a> = typedef detail::AngularDerivativesImpl&lt; DerivativeTagList, typename detail::unique_derived_from_list&lt;DerivativeTagList&gt;::type, Representation&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="group__DataBoxGroup.html">DataBox</a> mutate-compatible computational struct for computing a set of spin-weighted spherical harmonic derivatives by grouping and batch-computing spin-weighted spherical harmonic transforms. </p>
<h3>Details</h3>
<p >A derivative is evaluated for each tag in <code>DerivativeTagList</code>. All entries in <code>DerivativeTagList</code> must be the tag <code><a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Derivative.html" title="Prefix tag representing the spin-weighted derivative of a spin-weighted scalar.">Spectral::Swsh::Tags::Derivative</a>&lt;Tag, DerivativeKind&gt;</code> prefixing the <code>Tag</code> to be differentiated, and indicating the spin-weighted derivative <code>DerivativeKind</code> to be taken. A <a class="el" href="group__DataBoxGroup.html">DataBox</a> on which this struct is invoked must contain:</p><ul>
<li>each of the tags in <code>DerivativeTagList</code> (the results of the computation)</li>
<li>each of the tags <code>Tag</code> prefixed by <code><a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Derivative.html" title="Prefix tag representing the spin-weighted derivative of a spin-weighted scalar.">Spectral::Swsh::Tags::Derivative</a></code> in <code>DerivativeTagList</code> (the inputs of the computation).</li>
<li>each of the tags <code><a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1SwshTransform.html" title="Prefix tag representing the spin-weighted spherical harmonic transform of a spin-weighted scalar.">Spectral::Swsh::Tags::SwshTransform</a>&lt;DerivativeTag&gt;</code> for <code>DerivativeTag</code>in <code>DerivativeTagList</code> (the buffers for the derivative applied to the modes)</li>
<li>each of the tags <code><a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1SwshTransform.html" title="Prefix tag representing the spin-weighted spherical harmonic transform of a spin-weighted scalar.">Spectral::Swsh::Tags::SwshTransform</a>&lt;Tag&gt;</code> for <code>Tag</code> prefixed by any <code>DerivativeTag</code> in <code>DerivativeTagList</code> (the buffers for the transforms of the input data).</li>
</ul>
<p >This function optimizes the derivative taking process by clustering like spins of tags, forward-transforming each spin cluster together, applying the factor for the derivative to each modal vector, re-clustering according to the new spin weights (the derivatives alter the spin weights), and finally inverse-transforming in clusters. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga37c9c17d05dccca652060d117f72ee21" name="ga37c9c17d05dccca652060d117f72ee21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37c9c17d05dccca652060d117f72ee21">&#9670;&nbsp;</a></span>Basis</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="group__SpectralGroup.html#ga37c9c17d05dccca652060d117f72ee21">Spectral::Basis</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The choice of basis functions for computing collocation points and weights. </p>
<h3>Details</h3>
<p >Choose <code>Legendre</code> for a general-purpose DG mesh, unless you have a particular reason for choosing another basis.</p>
<dl class="section warning"><dt>Warning</dt><dd>The <code>FiniteDifference</code> "basis" is used to denote that only the collocation points are defined, but that differentiation, integration, and interpolation schemes are to be chosen locally wherever a <code>FiniteDifference</code> mesh is being used. The reason is that there isn't a requirement that the basis and collocation point locations are at all related to the differentiation, integration, or interpolation methods - it is merely a convenient choice in a lot of cases. For <code>FiniteDifference</code> we need to choose the order of the scheme (and hence the weights, differentiation matrix, integration weights, and interpolant) locally in space and time to handle discontinuous solutions. Our current implementation of the weights is such that integration of a function uses the midpoint method, but the weights are ONLY useful to perform integration and no longer have any other meaning. </dd></dl>

</div>
</div>
<a id="ga7744e520f6d553caf358a6f09f5978c1" name="ga7744e520f6d553caf358a6f09f5978c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7744e520f6d553caf358a6f09f5978c1">&#9670;&nbsp;</a></span>Quadrature</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="group__SpectralGroup.html#ga7744e520f6d553caf358a6f09f5978c1">Spectral::Quadrature</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The choice of quadrature method to compute integration weights. </p>
<h3>Details</h3>
<p >Integrals using \(N\) collocation points with Gauss quadrature are exact to polynomial order \(p=2N-1\). Gauss-Lobatto quadrature is exact only to polynomial order \(p=2N-3\), but includes collocation points at the domain boundary.</p>
<dl class="section warning"><dt>Warning</dt><dd><code>CellCentered</code> and <code>FaceCentered</code> are intended to be used with the <code>FiniteDifference</code> basis (though in principle they could be used with any basis), and thus do not implement differentiation matrices and interpolation matrices. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9264acddba199cce62e09b047b4f7018" name="ga9264acddba199cce62e09b047b4f7018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9264acddba199cce62e09b047b4f7018">&#9670;&nbsp;</a></span>angular_derivatives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivativeKindList , <a class="el" href="namespaceSpectral_1_1Swsh.html#ab1fa85ae53abba64a770e7e806bf12f6">ComplexRepresentation</a> Representation = ComplexRepresentation::Interleaved, typename... ArgumentTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Spectral::Swsh::angular_derivatives </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>l_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>number_of_radial_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArgumentTypes &amp;...&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate all of the spin-weighted derivatives in <code>DerivKindList</code> on input <code><a class="el" href="structSpinWeighted.html" title="Make a spin-weighted type T with spin-weight Spin. Mathematical operators are restricted to addition,...">SpinWeighted</a>&lt;<a class="el" href="classComplexDataVector.html" title="Stores a collection of complex function values.">ComplexDataVector</a>, Spin&gt;</code> collocation data, returning by pointer. </p>
<h3>Details</h3>
<p >This function provides two interfaces, one in which the caller provides the intermediate coefficient buffers needed during the computation of the derivatives, and one in which those buffers are temporarily allocated during the derivative function calls.</p>
<p >For the interface in which the caller does not provide buffers, the arguments must take the following structure (enforced by internal function calls):</p>
<ul>
<li><code>size_t l_max</code> : angular resolution for the spherical representation</li>
<li><code>size_t number_of_radial_points</code> : radial resolution (number of consecutive blocks to evaluate derivatives, for each input vector )</li>
<li>for each <code>DerivKind</code> in <code>DerivKindList</code>, a <code><a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a>&lt;<a class="el" href="structSpinWeighted.html" title="Make a spin-weighted type T with spin-weight Spin. Mathematical operators are restricted to addition,...">SpinWeighted</a>&lt;<a class="el" href="classComplexDataVector.html" title="Stores a collection of complex function values.">ComplexDataVector</a>, Spin + Tags::derivative_spin_weight&lt;DerivKind&gt;&gt;&gt;</code> : the output of the derivative evaluation</li>
<li>for each <code>DerivKind</code> in <code>DerivKindList</code>, a <code>const <a class="el" href="structSpinWeighted.html" title="Make a spin-weighted type T with spin-weight Spin. Mathematical operators are restricted to addition,...">SpinWeighted</a>&lt;<a class="el" href="classComplexDataVector.html" title="Stores a collection of complex function values.">ComplexDataVector</a>, Spin&gt;&amp;</code> (where the <code>Spin</code> for these arguments matches the corresponding vector from the previous set) : the input to the derivative evaluation.</li>
</ul>
<p >For the interface in which the caller does provide buffers, the arguments must take the following structure (enforced by internal function calls):</p>
<ul>
<li><code>size_t l_max</code> : angular resolution for the spherical representation</li>
<li><code>size_t number_of_radial_points</code> : radial resolution (number of consecutive blocks to evaluate derivatives, for each input vector )</li>
<li>for each <code>DerivKind</code> in <code>DerivKindList</code>, a <code><a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a>&lt;<a class="el" href="structSpinWeighted.html" title="Make a spin-weighted type T with spin-weight Spin. Mathematical operators are restricted to addition,...">SpinWeighted</a>&lt;<a class="el" href="classComplexModalVector.html" title="A class for storing complex spectral coefficients on a spectral grid.">ComplexModalVector</a>, Spin + Tags::derivative_spin_weight&lt;DerivKind&gt;&gt;&gt;</code> : the buffer for the spin-weighted spherical harmonic modes of the derivative quantities.</li>
<li>for each <code>DerivKind</code> in <code>DerivKindList</code>, a <code>const <a class="el" href="structSpinWeighted.html" title="Make a spin-weighted type T with spin-weight Spin. Mathematical operators are restricted to addition,...">SpinWeighted</a>&lt;<a class="el" href="classComplexModalVector.html" title="A class for storing complex spectral coefficients on a spectral grid.">ComplexModalVector</a>, Spin&gt;</code> (where the <code>Spin</code> for these arguments matches the corresponding vector from the previous set) : the buffer for the spin-weighted spherical harmonic modes of the input quantities.</li>
<li>for each <code>DerivKind</code> in <code>DerivKindList</code>, a <code><a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a>&lt;<a class="el" href="structSpinWeighted.html" title="Make a spin-weighted type T with spin-weight Spin. Mathematical operators are restricted to addition,...">SpinWeighted</a>&lt;<a class="el" href="classComplexDataVector.html" title="Stores a collection of complex function values.">ComplexDataVector</a>, Spin + Tags::derivative_spin_weight&lt;DerivKind&gt;&gt;&gt;</code> : the output of the derivative evaluation</li>
<li>for each <code>DerivKind</code> in <code>DerivKindList</code>, a <code>const <a class="el" href="structSpinWeighted.html" title="Make a spin-weighted type T with spin-weight Spin. Mathematical operators are restricted to addition,...">SpinWeighted</a>&lt;<a class="el" href="classComplexDataVector.html" title="Stores a collection of complex function values.">ComplexDataVector</a>, Spin&gt;</code> (where the <code>Spin</code> for these arguments matches the corresponding vector from the previous set) : the input to the derivative evaluation.</li>
</ul>
<p >The function <code>swsh_buffer</code> assists in generating the modal buffers of appropriate size. </p>

</div>
</div>
<a id="gaf2b1c2c6ec45492d6da13fb950f3b3f2" name="gaf2b1c2c6ec45492d6da13fb950f3b3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2b1c2c6ec45492d6da13fb950f3b3f2">&#9670;&nbsp;</a></span>power_monitors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim &gt; PowerMonitors::power_monitors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>input_data_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns array of power monitors in each spatial dimension. </p>
<p >Computed following Sec. 5.1 of Ref. <a class="el" href="citelist.html#CITEREF_Szilagyi2014fna">[156]</a>. For example, in the x dimension (indexed by \( k_0 \)), we compute</p>
<p class="formulaDsp">
\begin{align*} P_{k_0}[\psi] = \sqrt{ \frac{1}{N_1 N_2} \sum_{k_1,k_2} \left| C_{k_0,k_1,k_2} \right|^2} , \end{align*}
</p>
<p >where \( C_{k_0,k_1,k_2}\) are the modal coefficients of variable \( \psi \). </p>

</div>
</div>
<a id="ga380b79de66295d0a7e0213b3a39fa2bd" name="ga380b79de66295d0a7e0213b3a39fa2bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga380b79de66295d0a7e0213b3a39fa2bd">&#9670;&nbsp;</a></span>power_monitors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void PowerMonitors::power_monitors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim &gt; * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>input_data_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns array of power monitors in each spatial dimension. </p>
<p >Computed following Sec. 5.1 of Ref. <a class="el" href="citelist.html#CITEREF_Szilagyi2014fna">[156]</a>. For example, in the x dimension (indexed by \( k_0 \)), we compute</p>
<p class="formulaDsp">
\begin{align*} P_{k_0}[\psi] = \sqrt{ \frac{1}{N_1 N_2} \sum_{k_1,k_2} \left| C_{k_0,k_1,k_2} \right|^2} , \end{align*}
</p>
<p >where \( C_{k_0,k_1,k_2}\) are the modal coefficients of variable \( \psi \). </p>

</div>
</div>
<a id="ga0448163c8cbc5ed6b1eabe1ce1b13c62" name="ga0448163c8cbc5ed6b1eabe1ce1b13c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0448163c8cbc5ed6b1eabe1ce1b13c62">&#9670;&nbsp;</a></span>real_spherical_harmonic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataVector.html">DataVector</a> real_spherical_harmonic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates a real spherical harmonic of order l at the requested angles \(\theta\) and \(\phi\). </p>
<p >The real spherical harmonics are defined as: </p><p class="formulaDsp">
\begin{equation} Y_{lm}(\theta, \phi) = \begin{cases} \sqrt{2} (-1)^m \mathcal{I}[Y_l^{|m|}] &amp; \text{if } m &lt; 0 \\ Y_l^{0} &amp; \text{if } m = 0 \\ \sqrt{2} (-1)^m \mathcal{R}[Y_l^{m}] &amp; \text{if } m &gt; 0 \end{cases} \end{equation}
</p>
<p >where \(Y_l^m\) are the complex spherical harmonics and \(\mathcal{R}\) denotes the real part and \(\mathcal{I}\) denotes the imaginary part.</p>
<dl class="section note"><dt>Note</dt><dd>This implementation uses the boost implementation of spherical harmonics. The calculation is not vectorized and may be slow. Stability has not been tested for large l. </dd></dl>

</div>
</div>
<a id="ga13dd114cf3e63d2b51d0006366129c8c" name="ga13dd114cf3e63d2b51d0006366129c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13dd114cf3e63d2b51d0006366129c8c">&#9670;&nbsp;</a></span>real_spherical_harmonic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void real_spherical_harmonic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt;&#160;</td>
          <td class="paramname"><em>spherical_harmonic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates a real spherical harmonic of order l at the requested angles \(\theta\) and \(\phi\). </p>
<p >The real spherical harmonics are defined as: </p><p class="formulaDsp">
\begin{equation} Y_{lm}(\theta, \phi) = \begin{cases} \sqrt{2} (-1)^m \mathcal{I}[Y_l^{|m|}] &amp; \text{if } m &lt; 0 \\ Y_l^{0} &amp; \text{if } m = 0 \\ \sqrt{2} (-1)^m \mathcal{R}[Y_l^{m}] &amp; \text{if } m &gt; 0 \end{cases} \end{equation}
</p>
<p >where \(Y_l^m\) are the complex spherical harmonics and \(\mathcal{R}\) denotes the real part and \(\mathcal{I}\) denotes the imaginary part.</p>
<dl class="section note"><dt>Note</dt><dd>This implementation uses the boost implementation of spherical harmonics. The calculation is not vectorized and may be slow. Stability has not been tested for large l. </dd></dl>

</div>
</div>
<a id="ga7a207399084b0a58f9fc7e09dd9779cb" name="ga7a207399084b0a58f9fc7e09dd9779cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a207399084b0a58f9fc7e09dd9779cb">&#9670;&nbsp;</a></span>swsh_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Spin&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Spectral::Swsh::swsh_buffer </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>l_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>number_of_radial_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produces a <code><a class="el" href="structSpinWeighted.html" title="Make a spin-weighted type T with spin-weight Spin. Mathematical operators are restricted to addition,...">SpinWeighted</a>&lt;<a class="el" href="classComplexModalVector.html" title="A class for storing complex spectral coefficients on a spectral grid.">ComplexModalVector</a>, Spin&gt;</code> of the appropriate size to be used as a modal buffer for <code><a class="el" href="group__SpectralGroup.html#ga5d3e95021414531f2b911ebc69c52890" title="A DataBox mutate-compatible computational struct for computing a set of spin-weighted spherical harmo...">Spectral::Swsh::AngularDerivatives</a></code> or <code><a class="el" href="group__SpectralGroup.html#ga9264acddba199cce62e09b047b4f7018" title="Evaluate all of the spin-weighted derivatives in DerivKindList on input SpinWeighted&lt;ComplexDataVecto...">Spectral::Swsh::angular_derivatives</a></code>. </p>
<h3>Details</h3>
<p >The <code><a class="el" href="group__SpectralGroup.html#ga9264acddba199cce62e09b047b4f7018" title="Evaluate all of the spin-weighted derivatives in DerivKindList on input SpinWeighted&lt;ComplexDataVecto...">Spectral::Swsh::angular_derivatives</a></code> and <code><a class="el" href="group__SpectralGroup.html#ga5d3e95021414531f2b911ebc69c52890" title="A DataBox mutate-compatible computational struct for computing a set of spin-weighted spherical harmo...">Spectral::Swsh::AngularDerivatives</a></code> interfaces require that calling code provides a buffer for the intermediate transform results, to ensure that callers are aware of the allocations and can suitably reuse buffers if possible. This utility eases the creation of those buffers. </p>

</div>
</div>
<a id="gaba48908f5db7b7e4c924a62a067e6cd8" name="gaba48908f5db7b7e4c924a62a067e6cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba48908f5db7b7e4c924a62a067e6cd8">&#9670;&nbsp;</a></span>to_modal_coefficients() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComplexModalVector.html">ComplexModalVector</a> to_modal_coefficients </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>nodal_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the modal coefficients from the nodal coefficients. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#ad171b511dad33f36f55fdc6431d956d3" title="Matrix used to transform from the nodal coefficients of a function to its spectral coefficients (mode...">Spectral::nodal_to_modal_matrix</a> </dd></dl>

</div>
</div>
<a id="ga72480edebe2ba5ab9dce80fc826188ee" name="ga72480edebe2ba5ab9dce80fc826188ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72480edebe2ba5ab9dce80fc826188ee">&#9670;&nbsp;</a></span>to_modal_coefficients() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModalVector.html">ModalVector</a> to_modal_coefficients </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>nodal_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the modal coefficients from the nodal coefficients. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#ad171b511dad33f36f55fdc6431d956d3" title="Matrix used to transform from the nodal coefficients of a function to its spectral coefficients (mode...">Spectral::nodal_to_modal_matrix</a> </dd></dl>

</div>
</div>
<a id="ga573c26c78bd668fc6c108f9469698225" name="ga573c26c78bd668fc6c108f9469698225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga573c26c78bd668fc6c108f9469698225">&#9670;&nbsp;</a></span>to_modal_coefficients() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void to_modal_coefficients </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> * &gt;&#160;</td>
          <td class="paramname"><em>modal_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>nodal_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the modal coefficients from the nodal coefficients. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#ad171b511dad33f36f55fdc6431d956d3" title="Matrix used to transform from the nodal coefficients of a function to its spectral coefficients (mode...">Spectral::nodal_to_modal_matrix</a> </dd></dl>

</div>
</div>
<a id="ga6b06cbc6fc9cab9eaac517d604faab14" name="ga6b06cbc6fc9cab9eaac517d604faab14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b06cbc6fc9cab9eaac517d604faab14">&#9670;&nbsp;</a></span>to_modal_coefficients() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void to_modal_coefficients </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classModalVector.html">ModalVector</a> * &gt;&#160;</td>
          <td class="paramname"><em>modal_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>nodal_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the modal coefficients from the nodal coefficients. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#ad171b511dad33f36f55fdc6431d956d3" title="Matrix used to transform from the nodal coefficients of a function to its spectral coefficients (mode...">Spectral::nodal_to_modal_matrix</a> </dd></dl>

</div>
</div>
<a id="gae4cfaaa6ffedd023b8276904d96fefed" name="gae4cfaaa6ffedd023b8276904d96fefed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4cfaaa6ffedd023b8276904d96fefed">&#9670;&nbsp;</a></span>to_nodal_coefficients() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComplexDataVector.html">ComplexDataVector</a> to_nodal_coefficients </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &amp;&#160;</td>
          <td class="paramname"><em>modal_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the nodal coefficients from the modal coefficients. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#a591b528982971725adfc34b98b0b9114" title="Matrix used to transform from the spectral coefficients (modes) of a function to its nodal coefficien...">Spectral::modal_to_nodal_matrix</a> </dd></dl>

</div>
</div>
<a id="ga5e01278ed8346f1f7f3e1b445309f8c3" name="ga5e01278ed8346f1f7f3e1b445309f8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e01278ed8346f1f7f3e1b445309f8c3">&#9670;&nbsp;</a></span>to_nodal_coefficients() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataVector.html">DataVector</a> to_nodal_coefficients </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classModalVector.html">ModalVector</a> &amp;&#160;</td>
          <td class="paramname"><em>modal_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the nodal coefficients from the modal coefficients. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#a591b528982971725adfc34b98b0b9114" title="Matrix used to transform from the spectral coefficients (modes) of a function to its nodal coefficien...">Spectral::modal_to_nodal_matrix</a> </dd></dl>

</div>
</div>
<a id="gab4437aa4b72e08aead8cd23af669a161" name="gab4437aa4b72e08aead8cd23af669a161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4437aa4b72e08aead8cd23af669a161">&#9670;&nbsp;</a></span>to_nodal_coefficients() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void to_nodal_coefficients </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> * &gt;&#160;</td>
          <td class="paramname"><em>nodal_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &amp;&#160;</td>
          <td class="paramname"><em>modal_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the nodal coefficients from the modal coefficients. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#a591b528982971725adfc34b98b0b9114" title="Matrix used to transform from the spectral coefficients (modes) of a function to its nodal coefficien...">Spectral::modal_to_nodal_matrix</a> </dd></dl>

</div>
</div>
<a id="ga56c43516ab467513d56375b734d870e9" name="ga56c43516ab467513d56375b734d870e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56c43516ab467513d56375b734d870e9">&#9670;&nbsp;</a></span>to_nodal_coefficients() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void to_nodal_coefficients </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt;&#160;</td>
          <td class="paramname"><em>nodal_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classModalVector.html">ModalVector</a> &amp;&#160;</td>
          <td class="paramname"><em>modal_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the nodal coefficients from the modal coefficients. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#a591b528982971725adfc34b98b0b9114" title="Matrix used to transform from the spectral coefficients (modes) of a function to its nodal coefficien...">Spectral::modal_to_nodal_matrix</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
