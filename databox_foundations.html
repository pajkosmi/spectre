<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: Motivation for SpECTRE&#39;s DataBox</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('databox_foundations.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Motivation for SpECTRE's DataBox </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#databox_introduction">Introduction</a></li>
<li class="level1"><a href="#databox_towards_spectres_databox">Towards SpECTRE&#39;s DataBox</a><ul><li class="level2"><a href="#databox_working_without_databoxes">Working without DataBoxes</a></li>
<li class="level2"><a href="#databox_a_std_map_databox">A std::map DataBox</a></li>
<li class="level2"><a href="#databox_a_std_tuple_databox">A std::tuple DataBox</a></li>
<li class="level2"><a href="#databox_a_taggedtuple_databox">A TaggedTuple DataBox</a></li>
</ul>
</li>
<li class="level1"><a href="#databox_a_proper_databox">SpECTRE&#39;s DataBox</a><ul><li class="level2"><a href="#databox_documentation_for_simple_tags">SimpleTags</a></li>
<li class="level2"><a href="#databox_documentation_for_compute_tags">ComputeTags</a></li>
<li class="level2"><a href="#databox_documentation_for_mutate_tags">Mutating DataBox items</a></li>
</ul>
</li>
<li class="level1"><a href="#databox_towards_actions">Toward SpECTRE&#39;s Actions</a><ul><li class="level2"><a href="#databox_documentation_for_mutators">Mutators</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p ><a class="anchor" id="md_docs_DevGuide_Databox"></a></p>
<h1><a class="anchor" id="databox_introduction"></a>
Introduction</h1>
<p >This page walks the user through the iterative process that led to SpECTRE's DataBox. At each stage, it discusses the advances and challenges that result from each improvement.</p>
<h1><a class="anchor" id="databox_towards_spectres_databox"></a>
Towards SpECTRE's DataBox</h1>
<h2><a class="anchor" id="databox_working_without_databoxes"></a>
Working without DataBoxes</h2>
<p >In a small C++ program, it is common to use the built-in fundamental types (bool, int, double, etc.) in computations, and to give variable names to objects of these types. For example, a section of a small program may look like this:</p>
<div class="fragment"><div class="line"><span class="comment">// Set up variables:</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> velocity = 4.0;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code hl_function" href="namespaceStrahlkorperFunctions.html#af5d43839dae3dc9be8c07b780d543579">radius</a> = 2.0;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> density = 0.5;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> volume = 10.0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use variables:</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> mass = density * volume;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> acceleration = velocity * velocity / <a class="code hl_function" href="namespaceStrahlkorperFunctions.html#af5d43839dae3dc9be8c07b780d543579">radius</a>;</div>
<div class="line"><span class="keywordflow">return</span> mass * acceleration;</div>
<div class="ttc" id="anamespaceStrahlkorperFunctions_html_af5d43839dae3dc9be8c07b780d543579"><div class="ttname"><a href="namespaceStrahlkorperFunctions.html#af5d43839dae3dc9be8c07b780d543579">StrahlkorperFunctions::radius</a></div><div class="ttdeci">Scalar&lt; DataVector &gt; radius(const Strahlkorper&lt; Fr &gt; &amp;strahlkorper)</div></div>
</div><!-- fragment --><p >What changes as our program's size increases in scale? In SpECTRE, one of our driving design goals is modularity. In other words, functionality should be easy to swap in and out as desired. These smaller modules are easier to test, and keep the code flexible. We could wrap our calculation in such a module, which would then allow us to decouple the initial setup of the variables from where they are used in calculations:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> mass_compute(<span class="keyword">const</span> <span class="keywordtype">double</span> density, <span class="keyword">const</span> <span class="keywordtype">double</span> volume) {</div>
<div class="line">  <span class="keywordflow">return</span> density * volume;</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">double</span> acceleration_compute(</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> velocity, <span class="keyword">const</span> <span class="keywordtype">double</span> radius) {</div>
<div class="line">  <span class="keywordflow">return</span> velocity * velocity / <a class="code hl_function" href="namespaceStrahlkorperFunctions.html#af5d43839dae3dc9be8c07b780d543579">radius</a>;</div>
<div class="line">}</div>
</div><!-- fragment --><p >Our small program can now be written as:</p>
<div class="fragment"><div class="line"><span class="comment">// Set up variables:</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> velocity = 4.0;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code hl_function" href="namespaceStrahlkorperFunctions.html#af5d43839dae3dc9be8c07b780d543579">radius</a> = 2.0;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> density = 0.5;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> volume = 10.0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use variables:</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> mass = mass_compute(density, volume);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> acceleration = acceleration_compute(velocity, radius);</div>
<div class="line"><span class="keywordflow">return</span> mass * acceleration;</div>
</div><!-- fragment --><p >One advantage is immediate: we are free to add other computation modules that are independently testable and reusable. As the number of routines grows, we can even begin to write routines that work on top of existing ones.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> force_compute(<span class="keyword">const</span> <span class="keywordtype">double</span> velocity, <span class="keyword">const</span> <span class="keywordtype">double</span> radius,</div>
<div class="line">                     <span class="keyword">const</span> <span class="keywordtype">double</span> density, <span class="keyword">const</span> <span class="keywordtype">double</span> volume) {</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mass = mass_compute(density, volume);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> acceleration = acceleration_compute(velocity, radius);</div>
<div class="line">  <span class="keywordflow">return</span> mass *  acceleration;</div>
<div class="line">}</div>
</div><!-- fragment --><p >While we have made progress, two problems arise. Our first problem is that as the number of quantities grows, it becomes more unwieldy to have to specify each function argument in our routine. The second problem is worse: the arguments passed to functions can be transposed and the program will still compile and run, but produce incorrect output. For example, the following two lines are equally well-formed from the point of view of the program:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> velocity = 4.0;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code hl_function" href="namespaceStrahlkorperFunctions.html#af5d43839dae3dc9be8c07b780d543579">radius</a> = 2.0;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> acceleration = acceleration_compute(velocity, radius);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> failed_acceleration = acceleration_compute(radius, velocity);</div>
</div><!-- fragment --><p >Every time we call <code>acceleration_compute</code> we need to make sure we pass in the arguments in the correct order. In large programs where <code>acceleration_compute</code> is called many times, it becomes inevitable that the arguments will be accidentally transposed. We can address the two problems described above with a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a></code>, the first container we'll consider in this series.</p>
<h2><a class="anchor" id="databox_a_std_map_databox"></a>
A std::map DataBox</h2>
<p >We can encapsulate the variables we use in a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a></code>, and the first half of our small program example now looks like this:</p>
<div class="fragment"><div class="line"><span class="comment">// Set up variables:</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> velocity = 4.0;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code hl_function" href="namespaceStrahlkorperFunctions.html#af5d43839dae3dc9be8c07b780d543579">radius</a> = 2.0;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> density = 0.5;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> volume = 10.0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set up databox:</span></div>
<div class="line"><a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map&lt;std::string, double&gt;</a> naive_databox;</div>
<div class="line">naive_databox[<span class="stringliteral">&quot;Velocity&quot;</span>] = velocity;</div>
<div class="line">naive_databox[<span class="stringliteral">&quot;Radius&quot;</span>] = <a class="code hl_function" href="namespaceStrahlkorperFunctions.html#af5d43839dae3dc9be8c07b780d543579">radius</a>;</div>
<div class="line">naive_databox[<span class="stringliteral">&quot;Density&quot;</span>] = density;</div>
<div class="line">naive_databox[<span class="stringliteral">&quot;Volume&quot;</span>] = volume;</div>
<div class="ttc" id="amap_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a></div></div>
</div><!-- fragment --><p >We have not yet taken full advantage of the encapsulation that <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a></code> provides. We do so by rewriting our other routines to take only a single argument, i.e. the <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a></code> itself:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> mass_compute(<span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map&lt;std::string, double&gt;</a>&amp; box) {</div>
<div class="line">  <span class="keywordflow">return</span> box.at(<span class="stringliteral">&quot;Density&quot;</span>) * box.at(<span class="stringliteral">&quot;Volume&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">double</span> acceleration_compute(<span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map&lt;std::string, double&gt;</a>&amp; box) {</div>
<div class="line">  <span class="keywordflow">return</span> box.at(<span class="stringliteral">&quot;Velocity&quot;</span>) * box.at(<span class="stringliteral">&quot;Velocity&quot;</span>) / box.at(<span class="stringliteral">&quot;Radius&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p >Notice that this solves the problem of having to provide the arguments in the correct order to every function call of <code>acceleration_compute</code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> force_compute(<span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map&lt;std::string, double&gt;</a>&amp; box) {</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mass = mass_compute(box);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> acceleration = acceleration_compute(box);</div>
<div class="line">  <span class="keywordflow">return</span> mass * acceleration;</div>
<div class="line">}</div>
</div><!-- fragment --><p >Our small program now looks like:</p>
<div class="fragment"><div class="line"><span class="comment">// Set up variables:</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> velocity = 4.0;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code hl_function" href="namespaceStrahlkorperFunctions.html#af5d43839dae3dc9be8c07b780d543579">radius</a> = 2.0;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> density = 0.5;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> volume = 10.0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set up databox:</span></div>
<div class="line"><a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map&lt;std::string, double&gt;</a> naive_databox;</div>
<div class="line">naive_databox[<span class="stringliteral">&quot;Velocity&quot;</span>] = velocity;</div>
<div class="line">naive_databox[<span class="stringliteral">&quot;Radius&quot;</span>] = <a class="code hl_function" href="namespaceStrahlkorperFunctions.html#af5d43839dae3dc9be8c07b780d543579">radius</a>;</div>
<div class="line">naive_databox[<span class="stringliteral">&quot;Density&quot;</span>] = density;</div>
<div class="line">naive_databox[<span class="stringliteral">&quot;Volume&quot;</span>] = volume;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use variables:</span></div>
<div class="line"><span class="keywordflow">return</span> force_compute(naive_databox);</div>
</div><!-- fragment --><p >Within each function, we no longer need to worry about passing in the arguments in the correct order. This is a great improvement, but our reliance on proper names does leave us open to the following mistake:</p>
<div class="fragment"><div class="line"><span class="comment">// returns 0 without emitting an error!</span></div>
<div class="line"><span class="keywordflow">return</span> naive_databox[<span class="stringliteral">&quot;MisspelledKey&quot;</span>];</div>
</div><!-- fragment --><p >In the above example, the map is asked to return a value given a key that does not exist! As written, however, the program is well-formed and no error is emitted. (In the case of <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>, [a value is created.] (<a href="https://en.cppreference.com/w/cpp/container/map/operator_at">https://en.cppreference.com/w/cpp/container/map/operator_at</a>)) Because the keys are indistinguishable from their type alone, the mistake cannot be caught at compile time. In our example, the mistake won't even be caught at run time. The run time portion of a SpECTRE calculation will typically be much longer (up to thousands of times longer!) than the compile time portion, so it is critical to catch costly mistakes like this as early into the calculation as possible. Although names encoded as <code><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a></code> cannot be distinguished by the compiler, names encoded as types <em>can</em> be. This is possible with C++'s static typing, and to take advantage of this we need a container that is <em>heterogeneous</em>, that is, capable of holding objects of different types.</p>
<h2><a class="anchor" id="databox_a_std_tuple_databox"></a>
A std::tuple DataBox</h2>
<p >A well-documented example of a fixed-size heterogeneous container of types is <a href="https://en.cppreference.com/w/cpp/utility/tuple">std::tuple</a>:</p>
<div class="fragment"><div class="line"><a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;double, size_t, bool&gt;</a> sophomore_databox =</div>
<div class="line">  std::make_tuple(1.2, 8, <span class="keyword">true</span>);</div>
<div class="ttc" id="atuple_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a></div></div>
</div><!-- fragment --><p >The contents of the <code>std_tuple</code> are obtained using <a href="https://en.cppreference.com/w/cpp/utility/tuple/get">std::get</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> bool_quantity = std::get&lt;bool&gt;(sophomore_databox);</div>
<div class="line"><span class="comment">// value obtained is `true`</span></div>
</div><!-- fragment --><p >In the above, we can see that we have promoted our keys from different values all of type <code><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a></code> to different types entirely. We are not limited to fundamental types, we are free to make our own structs that serve as keys. These user-created types are called <em>tags</em>.</p>
<p >As the sole purpose of the tag is to provide the compiler with a type distinguishable from other types, they can be as simple as the following:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Velocity{};</div>
<div class="line"><span class="keyword">struct </span>Radius{};</div>
<div class="line"><span class="keyword">struct </span>Density{};</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_enumvalue" href="group__ObserversGroup.html#gga9601b9f188609201444e989ee8825b45abd7a9717d29c5ddcab1bc175eda1e298">Volume</a>{};</div>
<div class="ttc" id="agroup__ObserversGroup_html_gga9601b9f188609201444e989ee8825b45abd7a9717d29c5ddcab1bc175eda1e298"><div class="ttname"><a href="group__ObserversGroup.html#gga9601b9f188609201444e989ee8825b45abd7a9717d29c5ddcab1bc175eda1e298">observers::TypeOfObservation::Volume</a></div><div class="ttdeci">@ Volume</div><div class="ttdoc">The sender will only perform volume observations.</div></div>
</div><!-- fragment --><p >Note that we have now promoted <code>Velocity</code>, <code>Radius</code>, etc. from being <em>values</em> associated with <code><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a></code>s at run time, to <em>types</em> distinguishable from other types at compile time. A large portion of SpECTRE is designed with the philosophy of enlisting the help of the compiler in assuring the correctness of our programs. An example of a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a></code> making use of these tags might look like:</p>
<div class="fragment"><div class="line"><span class="comment">// Note: This won&#39;t work!</span></div>
<div class="line"><a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;Velocity, Radius, Density, Volume&gt;</a> sophomore_databox =</div>
<div class="line">  std::make_tuple(4.0, 2.0, 0.5, 10.0);</div>
</div><!-- fragment --><p >Unfortunately, this will not work. The types passed as template parameters to <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a></code> must also be the types of the arguments passed to <code>std::make_tuple</code>. Using a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a></code>, we could write the above as:</p>
<div class="fragment"><div class="line"><a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;std::pair&lt;Velocity,double&gt;</a>,</div>
<div class="line">           <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;Radius, double&gt;</a>, <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;Density, double&gt;</a>,</div>
<div class="line">           <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;Volume, double&gt;</a>&gt; sophomore_databox =</div>
<div class="line">  std::make_tuple(std::make_pair(Velocity{}, 4.0),</div>
<div class="line">                  std::make_pair(Radius{}, 2.0), std::make_pair(Density{}, 0.5),</div>
<div class="line">                  std::make_pair(Volume{}, 10.0));</div>
<div class="ttc" id="apair_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a></div></div>
</div><!-- fragment --><p >What remains is to rewrite our functions to use <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a></code> instead of <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a></code>. Note that since we are now using a heterogeneous container of potentially unknown type, our functions must be templated on the pairs used to create the <code>sophomore_databox</code>. Our functions then look like:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Pairs&gt;</div>
<div class="line"><span class="keywordtype">double</span> mass_compute(<span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;Pairs...&gt;</a>&amp; box) {</div>
<div class="line">  <span class="keywordflow">return</span> std::get&lt;std::pair&lt;Density, double&gt;&gt;(box).second *</div>
<div class="line">         <a class="code hl_function" href="group__DataBoxGroup.html#gaa36fa9cf94ab1cb05c5a6e23d56f79ae">std::get</a>&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;Volume, double&gt;</a>&gt;(box).second;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__DataBoxGroup_html_gaa36fa9cf94ab1cb05c5a6e23d56f79ae"><div class="ttname"><a href="group__DataBoxGroup.html#gaa36fa9cf94ab1cb05c5a6e23d56f79ae">db::get</a></div><div class="ttdeci">const auto &amp; get(const DataBox&lt; TagList &gt; &amp;box)</div><div class="ttdoc">Retrieve the item with tag Tag from the DataBox.</div><div class="ttdef"><b>Definition:</b> DataBox.hpp:850</div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Pairs&gt;</div>
<div class="line"><span class="keywordtype">double</span> acceleration_compute(<span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;Pairs...&gt;</a>&amp; box) {</div>
<div class="line">  <span class="keywordflow">return</span> std::get&lt;std::pair&lt;Velocity, double&gt;&gt;(box).second *</div>
<div class="line">         <a class="code hl_function" href="group__DataBoxGroup.html#gaa36fa9cf94ab1cb05c5a6e23d56f79ae">std::get</a>&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;Velocity, double&gt;</a>&gt;(box).second /</div>
<div class="line">         std::get&lt;std::pair&lt;Radius, double&gt;&gt;(box).second;</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Pairs&gt;</div>
<div class="line"><span class="keywordtype">double</span> force_compute(<span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;Pairs...&gt;</a>&amp; box) {</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mass = mass_compute(box);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> acceleration = acceleration_compute(box);</div>
<div class="line">  <span class="keywordflow">return</span> mass * acceleration;</div>
<div class="line">}</div>
</div><!-- fragment --><p >Using all these <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a></code>s to get our <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a></code> to work is a bit cumbersome. There is another way to package together the tagging ability of the struct names with the type information of the values we wish to store. To do this we need to make modifications to both our tags as well as our Databox implementation. This is what is done in SpECTRE's <code><a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs.">tuples::TaggedTuple</a></code>, which is an improved implementation of <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a></code> in terms of both performance and interface.</p>
<h2><a class="anchor" id="databox_a_taggedtuple_databox"></a>
A TaggedTuple DataBox</h2>
<p >TaggedTuple is an implementation of a compile time container where the keys are tags.</p>
<p >Tags that are compatible with SpECTRE's <code><a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs.">tuples::TaggedTuple</a></code> must have the type alias <code>type</code> in their structs. This type alias carries the type information of the data we wish to store in the databox. <code><a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs.">tuples::TaggedTuple</a></code> is able to make use of this type information so we won't need auxiliary constructs such as <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a></code> to package this information together anymore. Our new tags now look like:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Velocity {</div>
<div class="line">  <span class="keyword">using</span> type = double;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>Radius {</div>
<div class="line">  <span class="keyword">using</span> type = double;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>Density {</div>
<div class="line">  <span class="keyword">using</span> type = double;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_enumvalue" href="group__ObserversGroup.html#gga9601b9f188609201444e989ee8825b45abd7a9717d29c5ddcab1bc175eda1e298">Volume</a> {</div>
<div class="line">  <span class="keyword">using</span> type = double;</div>
<div class="line">};</div>
</div><!-- fragment --><p >We are now able to create the <code>junior_databox</code> below in the same way we initially wished to create the <code>sophomore_databox</code> above:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple&lt;Velocity, Radius, Density, Volume&gt;</a> junior_databox{</div>
<div class="line">  4.0, 2.0, 0.5, 10.0};</div>
<div class="ttc" id="aclasstuples_1_1TaggedTuple_html"><div class="ttname"><a href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a></div><div class="ttdoc">An associative container that is indexed by structs.</div><div class="ttdef"><b>Definition:</b> TaggedTuple.hpp:261</div></div>
</div><!-- fragment --><p >Our functions similarly simplify:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Tags&gt;</div>
<div class="line"><span class="keywordtype">double</span> mass_compute(<span class="keyword">const</span> <a class="code hl_class" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple&lt;Tags...&gt;</a>&amp; box) {</div>
<div class="line">  <span class="keywordflow">return</span> tuples::get&lt;Density&gt;(box) * tuples::get&lt;Volume&gt;(box);</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Tags&gt;</div>
<div class="line"><span class="keywordtype">double</span> acceleration_compute(<span class="keyword">const</span> <a class="code hl_class" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple&lt;Tags...&gt;</a>&amp; box) {</div>
<div class="line">  <span class="keywordflow">return</span> tuples::get&lt;Velocity&gt;(box) * tuples::get&lt;Velocity&gt;(box) /</div>
<div class="line">         tuples::get&lt;Radius&gt;(box);</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Tags&gt;</div>
<div class="line"><span class="keywordtype">double</span> force_compute(<span class="keyword">const</span> <a class="code hl_class" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple&lt;Tags...&gt;</a>&amp; box) {</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mass = mass_compute(box);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> acceleration = acceleration_compute(box);</div>
<div class="line">  <span class="keywordflow">return</span> mass * acceleration;</div>
<div class="line">}</div>
</div><!-- fragment --><p >In each of these iterations of the Databox, we started with initial quantities and computed subsequent quantities. Let us consider again <code>force_compute</code>, in which <code>mass</code> and <code>acceleration</code> are recomputed for every call to <code>force_compute</code>. If <code>Mass</code> and <code>Acceleration</code> were tags somewhow, that is, if we could compute them once, place them in the databox, and get them back out through the use of tags, we could get around this problem. We are now ready to consider SpECTRE's DataBox, which provides the solution to this problem in the form of <code>ComputeTags</code>.</p>
<h1><a class="anchor" id="databox_a_proper_databox"></a>
SpECTRE's DataBox</h1>
<p >A brief description of SpECTRE's DataBox: a TaggedTuple with compute-on-demand. For a detailed description of SpECTRE's DataBox, see the <a class="el" href="group__DataBoxGroup.html">DataBox documentation</a>.</p>
<h2><a class="anchor" id="databox_documentation_for_simple_tags"></a>
SimpleTags</h2>
<p >Just as we needed to modify our tags to make them compatible with <code>TaggedTuple</code>, we need to again modify them for use with DataBox. Our ordinary tags become SpECTRE's SimpleTags:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Velocity : <a class="code hl_struct" href="structdb_1_1SimpleTag.html">db::SimpleTag</a> {</div>
<div class="line">  <span class="keyword">using</span> type = double;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>Radius : <a class="code hl_struct" href="structdb_1_1SimpleTag.html">db::SimpleTag</a> {</div>
<div class="line">  <span class="keyword">using</span> type = double;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>Density : <a class="code hl_struct" href="structdb_1_1SimpleTag.html">db::SimpleTag</a> {</div>
<div class="line">  <span class="keyword">using</span> type = double;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_enumvalue" href="group__ObserversGroup.html#gga9601b9f188609201444e989ee8825b45abd7a9717d29c5ddcab1bc175eda1e298">Volume</a> : <a class="code hl_struct" href="structdb_1_1SimpleTag.html">db::SimpleTag</a> {</div>
<div class="line">  <span class="keyword">using</span> type = double;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>Mass : <a class="code hl_struct" href="structdb_1_1SimpleTag.html">db::SimpleTag</a> {</div>
<div class="line">  <span class="keyword">using</span> type = double;</div>
<div class="line">};</div>
<div class="ttc" id="astructdb_1_1SimpleTag_html"><div class="ttname"><a href="structdb_1_1SimpleTag.html">db::SimpleTag</a></div><div class="ttdoc">Mark a struct as a simple tag by inheriting from this.</div><div class="ttdef"><b>Definition:</b> Tag.hpp:36</div></div>
</div><!-- fragment --><p >As seen above, SimpleTags have a <code>type</code> and a <code>name</code> in their struct. When creating tags for use with a DataBox, we must make sure to the tag inherits from one of the existing DataBox tag types such as <code><a class="el" href="structdb_1_1SimpleTag.html" title="Mark a struct as a simple tag by inheriting from this.">db::SimpleTag</a></code>. We now create our first DataBox using these <code>SimpleTags</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> refined_databox = <a class="code hl_function" href="group__DataBoxGroup.html#ga190fd7a31cd2424701e03faea2d03247">db::create</a>&lt;</div>
<div class="line">    <a class="code hl_typedef" href="group__DataBoxGroup.html#ga3dc674ba575ece4a8be1c23fa6c2cdcb">db::AddSimpleTags</a>&lt;</div>
<div class="line">      Velocity, Radius, Density, <a class="code hl_enumvalue" href="group__ObserversGroup.html#gga9601b9f188609201444e989ee8825b45abd7a9717d29c5ddcab1bc175eda1e298">Volume</a>&gt;&gt;(4.0, 2.0, 0.5, 10.0);</div>
<div class="ttc" id="agroup__DataBoxGroup_html_ga190fd7a31cd2424701e03faea2d03247"><div class="ttname"><a href="group__DataBoxGroup.html#ga190fd7a31cd2424701e03faea2d03247">db::create</a></div><div class="ttdeci">constexpr auto create(Args &amp;&amp;... args)</div><div class="ttdoc">Create a new DataBox.</div><div class="ttdef"><b>Definition:</b> DataBox.hpp:1069</div></div>
<div class="ttc" id="agroup__DataBoxGroup_html_ga3dc674ba575ece4a8be1c23fa6c2cdcb"><div class="ttname"><a href="group__DataBoxGroup.html#ga3dc674ba575ece4a8be1c23fa6c2cdcb">db::AddSimpleTags</a></div><div class="ttdeci">tmpl::flatten&lt; tmpl::list&lt; Tags... &gt; &gt; AddSimpleTags</div><div class="ttdoc">List of Tags to add to the DataBox.</div><div class="ttdef"><b>Definition:</b> DataBox.hpp:1018</div></div>
</div><!-- fragment --><p >We can get our quantities out of the DataBox by using <code><a class="el" href="group__DataBoxGroup.html#gaa36fa9cf94ab1cb05c5a6e23d56f79ae" title="Retrieve the item with tag Tag from the DataBox.">db::get</a></code>:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> velocity = db::get&lt;Velocity&gt;(refined_databox);</div>
</div><!-- fragment --><p >So far, the usage of DataBox has been similar to the usage of TaggedTuple. To address the desire to combine the functionality of tags with the modularity of functions, DataBox provides ComputeTags.</p>
<h2><a class="anchor" id="databox_documentation_for_compute_tags"></a>
ComputeTags</h2>
<p >ComputeTags are used to tag functions that are used in conjunction with a DataBox to produce a new quantity. ComputeTags look like:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MassCompute : <a class="code hl_struct" href="structdb_1_1ComputeTag.html">db::ComputeTag</a>, Mass {</div>
<div class="line">  <span class="keyword">using</span> base = Mass;</div>
<div class="line">  <span class="keyword">using</span> return_type = double;</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> function = &amp;mass_from_density_and_volume;</div>
<div class="line">  <span class="keyword">using</span> argument_tags = tmpl::list&lt;Density, Volume&gt;;</div>
<div class="line">};</div>
<div class="ttc" id="astructdb_1_1ComputeTag_html"><div class="ttname"><a href="structdb_1_1ComputeTag.html">db::ComputeTag</a></div><div class="ttdoc">Mark a struct as a compute tag by inheriting from this.</div><div class="ttdef"><b>Definition:</b> Tag.hpp:157</div></div>
</div><!-- fragment --><p >ComputeTags inherit from <code><a class="el" href="structdb_1_1ComputeTag.html" title="Mark a struct as a compute tag by inheriting from this.">db::ComputeTag</a></code>, and it is convenient to have them additionally inherit from an existing SimpleTag (in this case <code>Mass</code>) so that the quantity <code>MassCompute</code> can be obtained through the SimpleTag <code>Mass</code>. We use the naming convention <code>TagNameCompute</code> so that <code>TagNameCompute</code> and <code>TagName</code> appear next to each other in documentation that lists tags in alphabetical order.</p>
<p >We have also added the type alias <code>argument_tags</code>, which is necessary in order to refer to the correct tagged quantities in the DataBox.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>tmpl::list</code> used in the type alias is a contiguous container only holding types. That is, there is no variable runtime data associated with it like there is for <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a></code>, which is a container associating types with values. <code>tmpl::list</code>s are useful in situations when one is working with multiple tags at once.</dd></dl>
<p>Using nested type aliases to pass around information at compile time is a common pattern in SpECTRE. Let us see how we can compute our beloved quantity of mass times acceleration:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Force : <a class="code hl_struct" href="structdb_1_1SimpleTag.html">db::SimpleTag</a> {</div>
<div class="line">  <span class="keyword">using</span> type = double;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>ForceCompute : <a class="code hl_struct" href="structdb_1_1ComputeTag.html">db::ComputeTag</a>, Force {</div>
<div class="line">  <span class="keyword">using</span> base = Force;</div>
<div class="line">  <span class="keyword">using</span> return_type = double;</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> function(<span class="keyword">const</span> <a class="code hl_class" href="classgsl_1_1not__null.html">gsl::not_null&lt;double*&gt;</a> result,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> mass, <span class="keyword">const</span> <span class="keywordtype">double</span> acceleration) {</div>
<div class="line">    *result = mass * acceleration; }</div>
<div class="line">  <span class="keyword">using</span> argument_tags = tmpl::list&lt;Mass, Acceleration&gt;;</div>
<div class="line">};</div>
<div class="ttc" id="aclassgsl_1_1not__null_html"><div class="ttname"><a href="classgsl_1_1not__null.html">gsl::not_null</a></div><div class="ttdoc">Require a pointer to not be a nullptr</div><div class="ttdef"><b>Definition:</b> Gsl.hpp:183</div></div>
</div><!-- fragment --><p >And that's it! <code><a class="el" href="group__DataBoxGroup.html#gaa36fa9cf94ab1cb05c5a6e23d56f79ae" title="Retrieve the item with tag Tag from the DataBox.">db::get</a></code> utilizes the <code>argument_tags</code> specified in <code>ForceCompute</code> to determine which items to get out of the <code>refined_databox</code>. With the corresponding quantities in hand, <code><a class="el" href="group__DataBoxGroup.html#gaa36fa9cf94ab1cb05c5a6e23d56f79ae" title="Retrieve the item with tag Tag from the DataBox.">db::get</a></code> passes them as arguments to the <code>function</code> specified in <code>ForceCompute</code>. This is why every <code>ComputeTag</code> must have an <code>argument_tags</code> as well as a <code>function</code> specified; this is the contract with DataBox they must satisfy in order to enjoy the full benefits of DataBox's generality.</p>
<h2><a class="anchor" id="databox_documentation_for_mutate_tags"></a>
Mutating DataBox items</h2>
<p >It is reasonable to expect that in a complicated calculation, we will encounter time-dependent or iteration-dependent variables. As a result, in addition to adding and retrieving items from our DataBox, we also need a way to <em>mutate</em> quantities already present in the DataBox. This can be done via <code><a class="el" href="group__DataBoxGroup.html#ga0b881127ceee8ff9dd456b98eeb00128" title="Apply the invokable f mutating items MutateTags and taking as additional arguments ArgumentTags and a...">db::mutate_apply</a></code> and can look like the following:</p>
<dl class="section note"><dt>Note</dt><dd>There is an alternative to <code><a class="el" href="group__DataBoxGroup.html#ga0b881127ceee8ff9dd456b98eeb00128" title="Apply the invokable f mutating items MutateTags and taking as additional arguments ArgumentTags and a...">db::mutate_apply</a></code>, <code><a class="el" href="group__DataBoxGroup.html#ga3c45b057d676d9f2cd90cf07185e653e" title="Allows changing the state of one or more non-computed elements in the DataBox.">db::mutate</a></code>. See the <a class="el" href="group__DataBoxGroup.html">DataBox documentation</a> for more details.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_class" href="classTime.html">Time</a> : <a class="code hl_struct" href="structdb_1_1SimpleTag.html">db::SimpleTag</a> {</div>
<div class="line">  <span class="keyword">using</span> type = double;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>TimeStep : <a class="code hl_struct" href="structdb_1_1SimpleTag.html">db::SimpleTag</a> {</div>
<div class="line">  <span class="keyword">using</span> type = double;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>EarthGravity : <a class="code hl_struct" href="structdb_1_1SimpleTag.html">db::SimpleTag</a> {</div>
<div class="line">  <span class="keyword">using</span> type = double;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>FallingSpeed : <a class="code hl_struct" href="structdb_1_1SimpleTag.html">db::SimpleTag</a> {</div>
<div class="line">  <span class="keyword">using</span> type = double;</div>
<div class="line">};</div>
<div class="ttc" id="aclassTime_html"><div class="ttname"><a href="classTime.html">Time</a></div><div class="ttdoc">The time in a simulation. Times can be safely compared for exact equality as long as they do not belo...</div><div class="ttdef"><b>Definition:</b> Time.hpp:29</div></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">auto</span> time_dependent_databox = <a class="code hl_function" href="group__DataBoxGroup.html#ga190fd7a31cd2424701e03faea2d03247">db::create</a>&lt;</div>
<div class="line">    <a class="code hl_typedef" href="group__DataBoxGroup.html#ga3dc674ba575ece4a8be1c23fa6c2cdcb">db::AddSimpleTags</a>&lt;</div>
<div class="line">      <a class="code hl_class" href="classTime.html">Time</a>, TimeStep, EarthGravity, FallingSpeed&gt;&gt;(0.0, 0.1, -9.8, -10.0);</div>
<div class="line"><a class="code hl_function" href="group__DataBoxGroup.html#ga0b881127ceee8ff9dd456b98eeb00128">db::mutate_apply</a>&lt;</div>
<div class="line">  <span class="comment">//MutateTags</span></div>
<div class="line">  tmpl::list&lt;Time, FallingSpeed&gt;,</div>
<div class="line">  <span class="comment">//ArgumentTags</span></div>
<div class="line">  tmpl::list&lt;TimeStep, EarthGravity&gt;&gt;(</div>
<div class="line">  [](<span class="keyword">const</span> <a class="code hl_class" href="classgsl_1_1not__null.html">gsl::not_null&lt;double*&gt;</a> <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/chrono/c/time.html">time</a>,</div>
<div class="line">     <span class="keyword">const</span> <a class="code hl_class" href="classgsl_1_1not__null.html">gsl::not_null&lt;double*&gt;</a> falling_speed,</div>
<div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> time_step,</div>
<div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> earth_gravity) {</div>
<div class="line">    *<a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/chrono/c/time.html">time</a> += time_step;</div>
<div class="line">    *falling_speed += time_step * earth_gravity;</div>
<div class="line">  },</div>
<div class="line">  make_not_null(&amp;time_dependent_databox));</div>
<div class="ttc" id="agroup__DataBoxGroup_html_ga0b881127ceee8ff9dd456b98eeb00128"><div class="ttname"><a href="group__DataBoxGroup.html#ga0b881127ceee8ff9dd456b98eeb00128">db::mutate_apply</a></div><div class="ttdeci">constexpr decltype(auto) mutate_apply(F &amp;&amp;f, const gsl::not_null&lt; DataBox&lt; BoxTags &gt; * &gt; box, Args &amp;&amp;... args)</div><div class="ttdoc">Apply the invokable f mutating items MutateTags and taking as additional arguments ArgumentTags and a...</div><div class="ttdef"><b>Definition:</b> DataBox.hpp:1310</div></div>
<div class="ttc" id="atime_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/chrono/c/time.html">std::time</a></div><div class="ttdeci">T time(T... args)</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The <code>not_null</code>s here are used to give us the assurance that the pointers <code>time</code> and <code>falling_speed</code> are not null pointers. Using raw pointers alone, we risk running into segmentation faults if we dereference null pointers. With <code>not_null</code>s we instead run into a run time error that tells us what went wrong. For information on the usage of <code>not_null</code>, see the documentation for Gsl.hpp.</dd></dl>
<p>In the above <code><a class="el" href="group__DataBoxGroup.html#ga0b881127ceee8ff9dd456b98eeb00128" title="Apply the invokable f mutating items MutateTags and taking as additional arguments ArgumentTags and a...">db::mutate_apply</a></code> example, we are changing two values in the DataBox using four values from the DataBox. The mutated quantities must be passed in as <code><a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a></code>s to the lambda. The non-mutated quantities are passed in as const references to the lambda.</p>
<dl class="section note"><dt>Note</dt><dd>It is critical to guarantee that there is a strict demarcation between pre-<code><a class="el" href="group__DataBoxGroup.html#ga3c45b057d676d9f2cd90cf07185e653e" title="Allows changing the state of one or more non-computed elements in the DataBox.">db::mutate</a></code> and post-<code><a class="el" href="group__DataBoxGroup.html#ga3c45b057d676d9f2cd90cf07185e653e" title="Allows changing the state of one or more non-computed elements in the DataBox.">db::mutate</a></code> quantities. <code><a class="el" href="group__DataBoxGroup.html#ga3c45b057d676d9f2cd90cf07185e653e" title="Allows changing the state of one or more non-computed elements in the DataBox.">db::mutate</a></code> provides this guarantee via a locking mechanism; within one mutate call, all initial pre-mutated quantities are obtained from the DataBox before performing a single mutation.</dd>
<dd>
The mutate functions described above are the only accepted ways to edit data in the Databox. It is technically possible to use pointers or references to edit data stored in the Databox, but this bypasses the compute tags architecture. All changes to the Databox must be made by the Databox itself via mutate functions.</dd></dl>
<p>From the above, we can see that the different kinds of tags are provided in two different <code>tmpl::list</code>s. The <code>MutateTags</code>, also called <code>ReturnTags</code>, refer to the quantities in the DataBox we wish to mutate, and the <code>ArgumentTags</code> refer to additional quantities we need from the DataBox to complete our computation. We now return to the recurring question of how to make this construction more modular.</p>
<p >We have now worked our way up to SpECTRE's DataBox, but as we can see in the above <code><a class="el" href="group__DataBoxGroup.html#ga0b881127ceee8ff9dd456b98eeb00128" title="Apply the invokable f mutating items MutateTags and taking as additional arguments ArgumentTags and a...">db::mutate_apply</a></code> example, the lambda used to perform the mutation ends up being independent of any tags or template parameters! This means we can factor it out and place it in its own module, where it can be tested independently of the DataBox.</p>
<h1><a class="anchor" id="databox_towards_actions"></a>
Toward SpECTRE's Actions</h1>
<h2><a class="anchor" id="databox_documentation_for_mutators"></a>
Mutators</h2>
<p >These constructs that exist independently of the DataBox are the precursors to SpECTRE's <em>Actions</em>. As they are designed to be used with <code><a class="el" href="group__DataBoxGroup.html#ga3c45b057d676d9f2cd90cf07185e653e" title="Allows changing the state of one or more non-computed elements in the DataBox.">db::mutate</a></code> and <code><a class="el" href="group__DataBoxGroup.html#ga0b881127ceee8ff9dd456b98eeb00128" title="Apply the invokable f mutating items MutateTags and taking as additional arguments ArgumentTags and a...">db::mutate_apply</a></code>, we give them the name <em>Mutators</em>. Here is the above lambda written as a Mutator-prototype, a struct-with-void-apply:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>IntendedMutation {</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code hl_function" href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">apply</a>(<span class="keyword">const</span> <a class="code hl_class" href="classgsl_1_1not__null.html">gsl::not_null&lt;double*&gt;</a> time,</div>
<div class="line">     <span class="keyword">const</span> <a class="code hl_class" href="classgsl_1_1not__null.html">gsl::not_null&lt;double*&gt;</a> falling_speed,</div>
<div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> time_step,</div>
<div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> earth_gravity) {</div>
<div class="line">    *<a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/chrono/c/time.html">time</a> += time_step;</div>
<div class="line">    *falling_speed += time_step * earth_gravity;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="ttc" id="agroup__DataStructuresGroup_html_ga058ade0497757606713948256728c6db"><div class="ttname"><a href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">apply</a></div><div class="ttdeci">auto apply(F &amp;&amp;f, const ObservationBox&lt; ComputeTagsList, DataBoxType &gt; &amp;observation_box, Args &amp;&amp;... args)</div><div class="ttdoc">Apply the function object f using its nested argument_tags list of tags.</div><div class="ttdef"><b>Definition:</b> ObservationBox.hpp:182</div></div>
</div><!-- fragment --><p >The call to <code><a class="el" href="group__DataBoxGroup.html#ga0b881127ceee8ff9dd456b98eeb00128" title="Apply the invokable f mutating items MutateTags and taking as additional arguments ArgumentTags and a...">db::mutate_apply</a></code> has now been made much simpler:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__DataBoxGroup.html#ga0b881127ceee8ff9dd456b98eeb00128">db::mutate_apply</a>&lt;</div>
<div class="line">  tmpl::list&lt;Time, FallingSpeed&gt;,</div>
<div class="line">  tmpl::list&lt;TimeStep, EarthGravity&gt;&gt;(</div>
<div class="line">    IntendedMutation{}, make_not_null(&amp;time_dependent_databox));</div>
</div><!-- fragment --><p >There is a key step that we take here after this point, to make our struct-with-void-apply into a proper Mutator. As we will see, this addition will allow us to entirely divorce the internal details of <code>IntendedMutation</code> from the mechanism through which we update the DataBox. The key step is to add type aliases to <code>IntendedMutation</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>IntendedMutation2 {</div>
<div class="line">  <span class="keyword">using</span> return_tags = tmpl::list&lt;Time, FallingSpeed&gt;;</div>
<div class="line">  <span class="keyword">using</span> argument_tags = tmpl::list&lt;TimeStep, EarthGravity&gt;;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code hl_function" href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">apply</a>(<span class="keyword">const</span> <a class="code hl_class" href="classgsl_1_1not__null.html">gsl::not_null&lt;double*&gt;</a> time,</div>
<div class="line">     <span class="keyword">const</span> <a class="code hl_class" href="classgsl_1_1not__null.html">gsl::not_null&lt;double*&gt;</a> falling_speed,</div>
<div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> time_step,</div>
<div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> earth_gravity) {</div>
<div class="line">    *<a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/chrono/c/time.html">time</a> += time_step;</div>
<div class="line">    *falling_speed += time_step * earth_gravity;</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p >We are now able to write our call to <code><a class="el" href="group__DataBoxGroup.html#ga0b881127ceee8ff9dd456b98eeb00128" title="Apply the invokable f mutating items MutateTags and taking as additional arguments ArgumentTags and a...">db::mutate_apply</a></code> in the following way:</p>
<div class="fragment"><div class="line">db::mutate_apply&lt;IntendedMutation2&gt;(make_not_null(&amp;time_dependent_databox));</div>
</div><!-- fragment --><p >As we saw earlier with <code>QuantityCompute</code>, we found that we were able to imbue structs with the ability to "read in" types specified in other structs, through the use of templates and member type aliases. This liberated us from having to hard-code in specific types. We notice immediately that <code>IntendedMutation</code> is a hard-coded type that we can factor out in favor of a template parameter:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Mutator&gt;</div>
<div class="line"><span class="keyword">struct </span>MyFirstAction{</div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> DbTagsList&gt;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code hl_function" href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">apply</a>(</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt;db::DataBox&lt;DbTagsList&gt;*&gt; time_dependent_databox)</div>
<div class="line">      {</div>
<div class="line">    db::mutate_apply&lt;Mutator&gt;(time_dependent_databox);</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p >Note how the <code>return_tags</code> and <code>argument_tags</code> are used as metavariables and are resolved by the compiler. Our call to <code><a class="el" href="group__DataBoxGroup.html#ga0b881127ceee8ff9dd456b98eeb00128" title="Apply the invokable f mutating items MutateTags and taking as additional arguments ArgumentTags and a...">db::mutate_apply</a></code> has been fully wrapped and now takes the form:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">MyFirstAction&lt;IntendedMutation2&gt;::apply</a>(make_not_null(&amp;time_dependent_databox));</div>
</div><!-- fragment --><p >The details of applying Mutators to the DataBox are entirely handled by <code>MyFirstAction</code>, with the details of the specific Mutator itself entirely encapsulated in <code>IntendedMutation</code>.</p>
<p >SpECTRE algorithms are decomposed into Actions which can depend on more things than we have considered here. Feel free to look at the existing <a class="el" href="group__ActionsGroup.html">actions that have been written.</a> The intricacies of Actions at the level that SpECTRE uses them is the subject of a future addition to the <a class="el" href="dev_guide.html">Developer's Guide.</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dev_guide.html">Developer Guides</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
