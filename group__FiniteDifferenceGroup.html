<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: Finite Difference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__FiniteDifferenceGroup.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Finite Difference</div></div>
</div><!--header-->
<div class="contents">

<p>Functions needed for (conservative) finite difference methods.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacefd"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefd.html">fd</a></td></tr>
<tr class="memdesc:namespacefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions and classes for finite difference methods. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacefd_1_1reconstruction"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefd_1_1reconstruction.html">fd::reconstruction</a></td></tr>
<tr class="memdesc:namespacefd_1_1reconstruction"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable and flux vector splitting reconstruction schemes for finite difference methods. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga6911a7cdbcf635d67c38a26a311a4cd3"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FiniteDifferenceGroup.html#ga6911a7cdbcf635d67c38a26a311a4cd3">fd::reconstruction::FallbackReconstructorType</a> { <b>Minmod</b>
, <b>MonotonisedCentral</b>
, <b>None</b>
 }</td></tr>
<tr class="memdesc:ga6911a7cdbcf635d67c38a26a311a4cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible types of reconstruction routines to fall back to from higher-order reconstruction when using adaptive method.  <a href="group__FiniteDifferenceGroup.html#ga6911a7cdbcf635d67c38a26a311a4cd3">More...</a><br /></td></tr>
<tr class="separator:ga6911a7cdbcf635d67c38a26a311a4cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaff945c93a8e0e2c45f781f356110377d"><td class="memTemplParams" colspan="2">template&lt;size_t NonlinearWeightExponent, size_t Dim&gt; </td></tr>
<tr class="memitem:gaff945c93a8e0e2c45f781f356110377d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FiniteDifferenceGroup.html#gaff945c93a8e0e2c45f781f356110377d">fd::reconstruction::aoweno_53</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt; reconstructed_upper_side_of_face_vars, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt; reconstructed_lower_side_of_face_vars, const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;volume_vars, const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &gt; &amp;ghost_cell_vars, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;volume_extents, const size_t number_of_variables, const double gamma_hi, const double gamma_lo, const double epsilon)</td></tr>
<tr class="memdesc:gaff945c93a8e0e2c45f781f356110377d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an adaptive order (AO) WENO reconstruction using a single 5th order stencil and a 3rd-order CWENO scheme.  <a href="group__FiniteDifferenceGroup.html#gaff945c93a8e0e2c45f781f356110377d">More...</a><br /></td></tr>
<tr class="separator:gaff945c93a8e0e2c45f781f356110377d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bdab395aed44581aca0a1f9f76ba767"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ga2bdab395aed44581aca0a1f9f76ba767"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FiniteDifferenceGroup.html#ga2bdab395aed44581aca0a1f9f76ba767">fd::reconstruction::minmod</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt; reconstructed_upper_side_of_face_vars, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt; reconstructed_lower_side_of_face_vars, const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;volume_vars, const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &gt; &amp;ghost_cell_vars, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;volume_extents, const size_t number_of_variables)</td></tr>
<tr class="memdesc:ga2bdab395aed44581aca0a1f9f76ba767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs minmod reconstruction on the <code>volume_vars</code> in each direction.  <a href="group__FiniteDifferenceGroup.html#ga2bdab395aed44581aca0a1f9f76ba767">More...</a><br /></td></tr>
<tr class="separator:ga2bdab395aed44581aca0a1f9f76ba767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac122f9299ba78fc69f7225d0f87105b3"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:gac122f9299ba78fc69f7225d0f87105b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FiniteDifferenceGroup.html#gac122f9299ba78fc69f7225d0f87105b3">fd::reconstruction::monotonicity_preserving_5</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt; reconstructed_upper_side_of_face_vars, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt; reconstructed_lower_side_of_face_vars, const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;volume_vars, const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &gt; &amp;ghost_cell_vars, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;volume_extents, const size_t number_of_variables, const double alpha, const double epsilon)</td></tr>
<tr class="memdesc:gac122f9299ba78fc69f7225d0f87105b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the fifth order monotonicity-preserving (MP5) reconstruction <a class="el" href="citelist.html#CITEREF_Suresh1997">[154]</a>.  <a href="group__FiniteDifferenceGroup.html#gac122f9299ba78fc69f7225d0f87105b3">More...</a><br /></td></tr>
<tr class="separator:gac122f9299ba78fc69f7225d0f87105b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga142fa2864a4047d526d350adea7c8085"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ga142fa2864a4047d526d350adea7c8085"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FiniteDifferenceGroup.html#ga142fa2864a4047d526d350adea7c8085">fd::reconstruction::monotonised_central</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt; reconstructed_upper_side_of_face_vars, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt; reconstructed_lower_side_of_face_vars, const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;volume_vars, const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &gt; &amp;ghost_cell_vars, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;volume_extents, const size_t number_of_variables)</td></tr>
<tr class="memdesc:ga142fa2864a4047d526d350adea7c8085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs monotonised central-difference reconstruction on the <code>vars</code> in each direction.  <a href="group__FiniteDifferenceGroup.html#ga142fa2864a4047d526d350adea7c8085">More...</a><br /></td></tr>
<tr class="separator:ga142fa2864a4047d526d350adea7c8085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f8b3572d823b4037ba780220781a668"><td class="memTemplParams" colspan="2">template&lt;size_t StencilSize&gt; </td></tr>
<tr class="memitem:ga1f8b3572d823b4037ba780220781a668"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, StencilSize &gt;, StencilSize &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FiniteDifferenceGroup.html#ga1f8b3572d823b4037ba780220781a668">fd::non_uniform_1d_weights</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>&lt; double &gt; &amp;times)</td></tr>
<tr class="memdesc:ga1f8b3572d823b4037ba780220781a668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the weights for a 1D non-uniform finite difference stencil.  <a href="group__FiniteDifferenceGroup.html#ga1f8b3572d823b4037ba780220781a668">More...</a><br /></td></tr>
<tr class="separator:ga1f8b3572d823b4037ba780220781a668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e01d24df6e3aa4865024639dab44a89"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">Side</a> LowerOrUpperSide, typename Reconstructor , bool UseExteriorCell = true, size_t NumberOfGhostPoints = (Reconstructor::stencil_width() / 2 + 1), size_t Dim, typename... ArgsForReconstructor&gt; </td></tr>
<tr class="memitem:ga3e01d24df6e3aa4865024639dab44a89"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FiniteDifferenceGroup.html#ga3e01d24df6e3aa4865024639dab44a89">fd::reconstruction::reconstruct_neighbor</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt; face_data, const <a class="el" href="classDataVector.html">DataVector</a> &amp;volume_data, const <a class="el" href="classDataVector.html">DataVector</a> &amp;neighbor_data, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;volume_extents, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;ghost_data_extents, const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;direction_to_reconstruct, const ArgsForReconstructor &amp;... args_for_reconstructor)</td></tr>
<tr class="memdesc:ga3e01d24df6e3aa4865024639dab44a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">In a given direction, reconstruct the cells in the neighboring <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> (or cluster of cells) nearest to the shared boundary between the current and neighboring <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> (or cluster of cells).  <a href="group__FiniteDifferenceGroup.html#ga3e01d24df6e3aa4865024639dab44a89">More...</a><br /></td></tr>
<tr class="separator:ga3e01d24df6e3aa4865024639dab44a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fa54523ac5d0ec175be2af88e1be697"><td class="memTemplParams" colspan="2">template&lt;size_t Degree, size_t Dim&gt; </td></tr>
<tr class="memitem:ga0fa54523ac5d0ec175be2af88e1be697"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FiniteDifferenceGroup.html#ga0fa54523ac5d0ec175be2af88e1be697">fd::reconstruction::unlimited</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt; reconstructed_upper_side_of_face_vars, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt; reconstructed_lower_side_of_face_vars, const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;volume_vars, const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &gt; &amp;ghost_cell_vars, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;volume_extents, const size_t number_of_variables)</td></tr>
<tr class="memdesc:ga0fa54523ac5d0ec175be2af88e1be697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs unlimited reconstruction on the <code>vars</code> in each direction.  <a href="group__FiniteDifferenceGroup.html#ga0fa54523ac5d0ec175be2af88e1be697">More...</a><br /></td></tr>
<tr class="separator:ga0fa54523ac5d0ec175be2af88e1be697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga206cdb85bef8ff7fb02e7b0df91c430a"><td class="memTemplParams" colspan="2">template&lt;size_t NonlinearWeightExponent, class FallbackReconstructor , size_t Dim&gt; </td></tr>
<tr class="memitem:ga206cdb85bef8ff7fb02e7b0df91c430a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FiniteDifferenceGroup.html#ga206cdb85bef8ff7fb02e7b0df91c430a">fd::reconstruction::wcns5z</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt; reconstructed_upper_side_of_face_vars, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt; reconstructed_lower_side_of_face_vars, const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;volume_vars, const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &gt; &amp;ghost_cell_vars, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;volume_extents, const size_t number_of_variables, const double epsilon, const size_t max_number_of_extrema)</td></tr>
<tr class="memdesc:ga206cdb85bef8ff7fb02e7b0df91c430a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs fifth order weighted compact nonlinear scheme reconstruction based on the WENO-Z method (WCNS-5Z). Adaptive fallback combined with an auxiliary reconstruction method (e.g. monotonised central) is also supported.  <a href="group__FiniteDifferenceGroup.html#ga206cdb85bef8ff7fb02e7b0df91c430a">More...</a><br /></td></tr>
<tr class="separator:ga206cdb85bef8ff7fb02e7b0df91c430a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga212a14873595df3b34cc01172f25c5bd"><td class="memTemplParams" colspan="2">template&lt;typename LowOrderReconstructor , bool PositivityPreserving, bool Use9thOrder, bool Use7thOrder, size_t Dim&gt; </td></tr>
<tr class="memitem:ga212a14873595df3b34cc01172f25c5bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FiniteDifferenceGroup.html#ga212a14873595df3b34cc01172f25c5bd">fd::reconstruction::positivity_preserving_adaptive_order</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt; reconstructed_upper_side_of_face_vars, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt; reconstructed_lower_side_of_face_vars, const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;volume_vars, const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &gt; &amp;ghost_cell_vars, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;volume_extents, const size_t number_of_variables, const double four_to_the_alpha_5, const double six_to_the_alpha_7, const double eight_to_the_alpha_9)</td></tr>
<tr class="memdesc:ga212a14873595df3b34cc01172f25c5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs positivity-preserving adaptive-order FD reconstruction.  <a href="group__FiniteDifferenceGroup.html#ga212a14873595df3b34cc01172f25c5bd">More...</a><br /></td></tr>
<tr class="separator:ga212a14873595df3b34cc01172f25c5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fe2f5cf33b4b74b221e1fc43159fc7f"><td class="memTemplParams" colspan="2">template&lt;typename LowOrderReconstructor , bool PositivityPreserving, bool Use9thOrder, bool Use7thOrder, size_t Dim&gt; </td></tr>
<tr class="memitem:ga2fe2f5cf33b4b74b221e1fc43159fc7f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FiniteDifferenceGroup.html#ga2fe2f5cf33b4b74b221e1fc43159fc7f">fd::reconstruction::positivity_preserving_adaptive_order</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt; reconstructed_upper_side_of_face_vars, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt; reconstructed_lower_side_of_face_vars, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint8_t</a> &gt;, Dim &gt; &gt; * &gt; reconstruction_order, const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;volume_vars, const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &gt; &amp;ghost_cell_vars, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;volume_extents, const size_t number_of_variables, const double four_to_the_alpha_5, const double six_to_the_alpha_7, const double eight_to_the_alpha_9)</td></tr>
<tr class="memdesc:ga2fe2f5cf33b4b74b221e1fc43159fc7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs positivity-preserving adaptive-order FD reconstruction.  <a href="group__FiniteDifferenceGroup.html#ga2fe2f5cf33b4b74b221e1fc43159fc7f">More...</a><br /></td></tr>
<tr class="separator:ga2fe2f5cf33b4b74b221e1fc43159fc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Functions needed for (conservative) finite difference methods. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga6911a7cdbcf635d67c38a26a311a4cd3" name="ga6911a7cdbcf635d67c38a26a311a4cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6911a7cdbcf635d67c38a26a311a4cd3">&#9670;&nbsp;</a></span>FallbackReconstructorType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="group__FiniteDifferenceGroup.html#ga6911a7cdbcf635d67c38a26a311a4cd3">fd::reconstruction::FallbackReconstructorType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Possible types of reconstruction routines to fall back to from higher-order reconstruction when using adaptive method. </p>
<dl class="section note"><dt>Note</dt><dd>FD reconstructions with input arguments or options (e.g. AoWeno, Wcns5z, ..) are currently not supported as fallback types. We <em>may</em> need it at some point in the future but it would require using a different option parsing method (e.g. factory creation). </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaff945c93a8e0e2c45f781f356110377d" name="gaff945c93a8e0e2c45f781f356110377d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff945c93a8e0e2c45f781f356110377d">&#9670;&nbsp;</a></span>aoweno_53()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NonlinearWeightExponent, size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fd::reconstruction::aoweno_53 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt;&#160;</td>
          <td class="paramname"><em>reconstructed_upper_side_of_face_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt;&#160;</td>
          <td class="paramname"><em>reconstructed_lower_side_of_face_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_cell_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>number_of_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>gamma_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>gamma_lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an adaptive order (AO) WENO reconstruction using a single 5th order stencil and a 3rd-order CWENO scheme. </p>
<p >The AO-WENO(5,3) scheme is based on the scheme presented in <a class="el" href="citelist.html#CITEREF_Balsara2016780">[9]</a> but adjusted to do reconstruction on variables instead of fluxes. The Legendre basis functions on the domain \(\xi\in[-1/2,1/2]\) are given by:</p>
<p class="formulaDsp">
\begin{align*} L_0(\xi) &amp;= 1 \\ L_1(\xi) &amp;= \xi \\ L_2(\xi) &amp;= \xi^2-\frac{1}{12} \\ L_3(\xi) &amp;= \xi^3 - \frac{3}{20} \xi \\ L_4(\xi) &amp;= \xi^4 - \frac{3}{14} \xi^2 + \frac{3}{560} \end{align*}
</p>
<p >The oscillation indicators are given by</p>
<p class="formulaDsp">
\begin{align*} \beta_l = \sum_{k=1}^{p}\sum_{m=1}^{p}\sigma_{km} u_{k,l} u_{m,l} \end{align*}
</p>
<p >where \(p\) is the maximum degree of the basis function used for the stencil \(l\), and</p>
<p class="formulaDsp">
\begin{align*} \sigma_{km}=\sum_{i=1}^{p}\int_{-1/2}^{1/2} \frac{d^i L_k(\xi)}{d\xi^i}\frac{d^i L_m(\xi)}{d\xi^i}d\xi \end{align*}
</p>
<p >We write the 3rd-order reconstructed polynomial \(P^{r3}_l(\xi)\) associated with the stencil \(S^{r3}_l\) as</p>
<p class="formulaDsp">
\begin{align*} P^{r3}_l(\xi) = u_0 +u_{\xi} L_1(\xi) + u_{\xi 2} L_2(\xi) \end{align*}
</p>
<p >For the stencil \(S^{r3}_1\) we get</p>
<p class="formulaDsp">
\begin{align*} u_0 &amp;= \frac{25}{24} u_{j} -\frac{1}{12} u_{j-1} + \frac{1}{24} u_{j-2} \\ u_{\xi} &amp;= \frac{1}{2}u_{j-2} - 2 u_{j-1} + \frac{3}{2} u_j \\ u_{\xi2} &amp;= \frac{1}{2} u_{j-2} - u_{j-1} + \frac{1}{2} u_j \end{align*}
</p>
<p >For the stencil \(S^{r3}_2\) we get</p>
<p class="formulaDsp">
\begin{align*} u_0 &amp;= \frac{1}{24} u_{j-1} + \frac{11}{12} u_{j} + \frac{1}{24} u_{j+1} \\ u_{\xi} &amp;= \frac{1}{2}(u_{j+1} - u_{j-1}) \\ u_{\xi2} &amp;= \frac{1}{2} u_{j-1} - u_{j} + \frac{1}{2} u_{j+1} \end{align*}
</p>
<p >For the stencil \(S^{r3}_3\) we get</p>
<p class="formulaDsp">
\begin{align*} u_0 &amp;= \frac{25}{24} u_{j} -\frac{1}{12} u_{j+1} + \frac{1}{24} u_{j+2} \\ u_{\xi} &amp;= -\frac{1}{2}u_{j+2} + 2 u_{j+1} - \frac{3}{2} u_j \\ u_{\xi2} &amp;= \frac{1}{2} u_{j+2} - u_{j+1} + \frac{1}{2} u_j \end{align*}
</p>
<p >The oscillation indicator for the 3rd-order stencils is given by</p>
<p class="formulaDsp">
\begin{align*} \beta^{r3}_l = \left(u_{\xi}\right)^2+\frac{13}{3}\left(u_{\xi2}\right)^2 \end{align*}
</p>
<p >We write the 5th-order reconstructed polynomial \(P^{r5}(\xi)\) as</p>
<p class="formulaDsp">
\begin{align*} P^{r5}_l(\xi) = u_0 +u_{\xi} L_1(\xi) + u_{\xi 2} L_2(\xi) + u_{\xi3} L_3(\xi) + u_{\xi4} L_4(\xi) \end{align*}
</p>
<p >with</p>
<p class="formulaDsp">
\begin{align*} u_0 &amp;= -\frac{17}{5760} u_{j-2} + \frac{77}{1440} u_{j-1} + \frac{863}{960} u_{j} + \frac{77}{1440} u_{j+1} - \frac{17}{5760} u_{j+2} \\ u_{\xi} &amp;= \frac{17}{240} u_{j-2} - \frac{77}{120} u_{j-1} + \frac{77}{120} u_{j+1} - \frac{17}{240} u_{j+2} \\ u_{\xi2} &amp;= -\frac{11}{336} u_{j-2} + \frac{53}{84} u_{j-1} - \frac{67}{56} u_{j} + \frac{53}{84} u_{j+1} - \frac{11}{336} u_{j+2} \\ u_{\xi3} &amp;= -\frac{1}{12} u_{j-2} + \frac{1}{6} u_{j-1} -\frac{1}{6} u_{j+1} + \frac{1}{12} u_{j+2} \\ u_{\xi4} &amp;= \frac{1}{24} u_{j-2} -\frac{1}{6} u_{j-1} +\frac{1}{4} u_{j} - \frac{1}{6}u_{j+1}+\frac{1}{24}u_{j+2} \end{align*}
</p>
<p >The oscillation indicator is given by</p>
<p class="formulaDsp">
\begin{align*} \beta^{r5}&amp;=\left(u_{\xi}+\frac{1}{10}u_{\xi3}\right)^2 \\ &amp;+\frac{13}{3}\left(u_{\xi2}+\frac{123}{455}u_{\xi4}\right)^2\\ &amp;+\frac{781}{20}(u_{\xi3})^2+\frac{1421461}{2275}(u_{\xi4})^2 \end{align*}
</p>
<p >There are two linear weights \(\gamma_{\mathrm{hi}}\) and \(\gamma_{\mathrm{lo}}\). \(\gamma_{\mathrm{hi}}\) controls how much of the 5th-order stencil is used in smooth regions, while \(\gamma_{\mathrm{lo}}\) controls the linear weight of the central 3rd-order stencil. For larger \(\gamma_{\mathrm{lo}}\), the 3rd-order method is more centrally weighted. The linear weights for the stencils are given by</p>
<p class="formulaDsp">
\begin{align*} \gamma^{r5}&amp;=\gamma_{\mathrm{hi}} \\ \gamma^{r3}_1&amp; = (1-\gamma_{\mathrm{hi}})(1-\gamma_{\mathrm{lo}})/2 \\ \gamma^{r3}_2&amp; = (1-\gamma_{\mathrm{hi}})\gamma_{\mathrm{lo}} \\ \gamma^{r3}_3&amp; = (1-\gamma_{\mathrm{hi}})(1-\gamma_{\mathrm{lo}})/2 \end{align*}
</p>
<p >We use the standard nonlinear weights instead of the "Z" weights of <a class="el" href="citelist.html#CITEREF_Borges20083191">[22]</a></p>
<p class="formulaDsp">
\begin{align*} w^{r5}&amp;=\frac{\gamma^{r5}}{(\beta^{r5}+\epsilon)^q} \\ w^{r3}_l&amp;=\frac{\gamma^{r3}_l}{(\beta^{r3}_l+\epsilon)^q} \end{align*}
</p>
<p >where \(\epsilon\) is a small number used to avoid division by zero. The normalized nonlinear weights are denoted by \(\bar{w}^{r5}\) and \(\bar{w}_l^{r3}\). The final reconstructed polynomial \(P(\xi)\) is given by</p>
<p class="formulaDsp">
\begin{align*} P(\xi)&amp;=\frac{\bar{w}^{r5}}{\gamma^{r5}} \left(P^{r5}(\xi)-\gamma^{r3}_1P^{r3}_1(\xi) -\gamma^{r3}_2P^{r3}_2(\xi)-\gamma^{r3}_3P^{r3}_3(\xi)\right) \\ &amp;+\bar{w}^{r3}_1P^{r3}_1(\xi)+\bar{w}^{r3}_2P^{r3}_2(\xi) +\bar{w}^{r3}_3P^{r3}_3(\xi) \end{align*}
</p>
<p >The weights \(\gamma_{\mathrm{hi}}\) and \(\gamma_{\mathrm{lo}}\) are typically chosen to be in the range \([0.85,0.95]\).</p>
<h3><a class="anchor" id="autotoc_md350"></a>
First alternative oscillation indicators</h3>
<p >Instead of integrating over just the cell, we can instead integrate the basis functions over the entire fit interval, \([-5/2,5/2]\). Using this interval for the \(S^{r3}_l\) and the \(S^{r5}\) stencils we get</p>
<p class="formulaDsp">
\begin{align*} \beta^{r3}_l&amp;=(u_{\xi})^2 + \frac{37}{3} (u_{\xi2})^2 \\ \beta^{r5} &amp;=\left(u_{\xi}+\frac{61}{10}u_{\xi3}\right)^2 + \frac{569}{4}u_{\xi3}^2 \\ &amp;+ \frac{1}{8190742}\left(5383 u_{\xi2} + 167158 u_{\xi4}\right)^2 +\frac{4410763}{501474}(u_{\xi2})^2 \\ &amp;=u_{\xi}^2 + \frac{61}{5}u_{\xi}u_{\xi3} + \frac{37}{3}u_{\xi2}^2 + \frac{1538}{7}u_{\xi2}u_{\xi4} \\ &amp;+ \frac{8973}{50}u_{\xi3}^2 + \frac{167158}{49}u_{\xi4}^2 \end{align*}
</p>
<p >Note that the indicator is manifestly non-negative, a required property of oscillation indicators. These indicators weight high modes more, which means the scheme is more sensitive to high-frequency features in the solution.</p>
<dl class="section note"><dt>Note</dt><dd>currently it is the alternative indicators that are used. However, an option to control which are used can readily be added, probably best done as a template parameter with <code>if constexpr</code> to avoid conditionals inside tight loops. </dd></dl>

</div>
</div>
<a id="ga2bdab395aed44581aca0a1f9f76ba767" name="ga2bdab395aed44581aca0a1f9f76ba767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bdab395aed44581aca0a1f9f76ba767">&#9670;&nbsp;</a></span>minmod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fd::reconstruction::minmod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt;&#160;</td>
          <td class="paramname"><em>reconstructed_upper_side_of_face_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt;&#160;</td>
          <td class="paramname"><em>reconstructed_lower_side_of_face_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_cell_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>number_of_variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs minmod reconstruction on the <code>volume_vars</code> in each direction. </p>
<p >On a 1d mesh with spacing \(\Delta x\) we denote the solution at the \(j\)th point by \(u_j\). The minmod reconstruction <a class="el" href="citelist.html#CITEREF_RezzollaBook">[140]</a> first computes:</p>
<p class="formulaDsp">
\begin{align} \sigma_j\equiv \textrm{minmod}\left(\frac{u_j-u_{j-1}}{\Delta x}, \frac{u_{j+1}-u_j}{\Delta x}\right) \end{align}
</p>
<p >where</p>
<p class="formulaDsp">
\begin{align} \mathrm{minmod}(a,b)= \left\{ \begin{array}{ll} \mathrm{sgn}(a)\min(\lvert a\rvert, \lvert b\rvert) &amp; \mathrm{if} \; \mathrm{sgn}(a)=\mathrm{sgn}(b) \\ 0 &amp; \mathrm{otherwise} \end{array}\right. \end{align}
</p>
<p >The reconstructed solution \(u_j(x)\) in the \(j\)th cell is given by</p>
<p class="formulaDsp">
\begin{align} u_j(x)=u_j + \sigma_j (x-x_j), \end{align}
</p>
<p >where \(x_j\) is the coordinate \(x\) at the center of the cell. </p>

</div>
</div>
<a id="gac122f9299ba78fc69f7225d0f87105b3" name="gac122f9299ba78fc69f7225d0f87105b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac122f9299ba78fc69f7225d0f87105b3">&#9670;&nbsp;</a></span>monotonicity_preserving_5()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fd::reconstruction::monotonicity_preserving_5 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt;&#160;</td>
          <td class="paramname"><em>reconstructed_upper_side_of_face_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt;&#160;</td>
          <td class="paramname"><em>reconstructed_lower_side_of_face_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_cell_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>number_of_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the fifth order monotonicity-preserving (MP5) reconstruction <a class="el" href="citelist.html#CITEREF_Suresh1997">[154]</a>. </p>
<p >First, calculate the original interface value \(q_{j+1/2}^\text{OR}\) with the (unlimited) fifth order finite difference reconstruction</p>
<p class="formulaDsp">
\begin{align} q_{j+1/2}^\text{OR} = \frac{1}{128}( 3 q_{j-2} - 20 q_{j-1} + 90 q_{j} + 60 q_{j+1} - 5 q_{j+2}) . \end{align}
</p>
<p >and compute</p>
<p class="formulaDsp">
\begin{align} q^\text{MP} = q_j + \text{minmod}(q_{j+1} - q_j, \alpha(q_j - q_{j-1})) \end{align}
</p>
<p >for a given value of \(\alpha\), which is usually set to \(\alpha=4\).</p>
<p >If \( (q_{j+1/2}^\text{OR} - q_j)(q_{j+1/2}^\text{OR} - q^\text{MP}) \leq \epsilon\) where \(\epsilon\) is a small tolerance value, use \(q_{1/2} = q_{j+1/2}^\text{OR}\).</p>
<dl class="section note"><dt>Note</dt><dd>A proper value of \(\epsilon\) may depend on the scale of the quantity \(q\) to be reconstructed; reference <a class="el" href="citelist.html#CITEREF_Suresh1997">[154]</a> suggests 1e-10. For hydro simulations with atmosphere treatment, setting \(\epsilon=0.0\) would be safe.</dd></dl>
<p>Otherwise, calculate</p>
<p class="formulaDsp">
\begin{align} d_{j+1} &amp; = q_{j+2} - 2q_{j+1} + q_{j} \\ d_j &amp; = q_{j+1} - 2q_j + q_{j-1} \\ d_{j-1} &amp; = q_{j} - 2q_{j-1} + q_{j-2} , \end{align}
</p>
<p class="formulaDsp">
\begin{align} d^\text{M4}_{j+1/2} = \text{minmod}(4d_j - d_{j+1}, 4d_{j+1}-d_j, d_j, d_{j+1}) \\ d^\text{M4}_{j-1/2} = \text{minmod}(4d_j - d_{j-1}, 4d_{j-1}-d_j, d_j, d_{j-1}), \end{align}
</p>
<p class="formulaDsp">
\begin{align} q^\text{UL} &amp; = q_j + \alpha(q_j - q_{j-1}) \\ q^\text{AV} &amp; = (q_j + q_{j+1}) / 2 \\ q^\text{MD} &amp; = q^\text{AV} - d^\text{M4}_{j+1/2} / 2 \\ q^\text{LC} &amp; = q_j + (q_j - q_{j-1}) / 2 + (4/3) d^\text{M4}_{j-1/2} \end{align}
</p>
<p >and </p><p class="formulaDsp">
\begin{align} q^\text{min} &amp; = \text{max}[ \text{min}(q_j, q_{j+1}, q^\text{MD}), \text{min}(q_j, q^\text{UL}, q^\text{LC}) ] \\ q^\text{max} &amp; = \text{min}[ \text{max}(q_j, q_{j+1}, q^\text{MD}), \text{max}(q_j, q^\text{UL}, q^\text{LC}) ]. \end{align}
</p>
<p >The reconstructed value is given as </p><p class="formulaDsp">
\begin{align} q_{i+1/2} = \text{median}(q_{j+1/2}^\text{OR}, q^\text{min}, q^\text{max}) \end{align}
</p>
<p> where the median function can be expressed as </p><p class="formulaDsp">
\begin{align} \text{median}(x,y,z) = x + \text{minmod}(y-x, z-x). \end{align}
</p>
 
</div>
</div>
<a id="ga142fa2864a4047d526d350adea7c8085" name="ga142fa2864a4047d526d350adea7c8085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga142fa2864a4047d526d350adea7c8085">&#9670;&nbsp;</a></span>monotonised_central()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fd::reconstruction::monotonised_central </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt;&#160;</td>
          <td class="paramname"><em>reconstructed_upper_side_of_face_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt;&#160;</td>
          <td class="paramname"><em>reconstructed_lower_side_of_face_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_cell_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>number_of_variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs monotonised central-difference reconstruction on the <code>vars</code> in each direction. </p>
<p >On a 1d mesh with spacing \(\Delta x\) we denote the solution at the \(j\)th point by \(u_j\). The monotonised central-difference reconstruction <a class="el" href="citelist.html#CITEREF_RezzollaBook">[140]</a> first computes:</p>
<p class="formulaDsp">
\begin{align} \sigma_j\equiv \textrm{minmod} \left(\frac{u_{j+1} - u_{j-1}}{2\Delta x}, 2\frac{u_j-u_{j-1}}{\Delta x}, 2\frac{u_{j+1}-u_j}{\Delta x}\right) \end{align}
</p>
<p >where</p>
<p class="formulaDsp">
\begin{align} \mathrm{minmod}(a,b,c)= \left\{ \begin{array}{ll} \mathrm{sgn}(a)\min(\lvert a\rvert, \lvert b\rvert, \lvert c\rvert) &amp; \mathrm{if} \; \mathrm{sgn}(a)=\mathrm{sgn}(b)=\mathrm{sgn}(c) \\ 0 &amp; \mathrm{otherwise} \end{array}\right. \end{align}
</p>
<p >The reconstructed solution \(u_j(x)\) in the \(j\)th cell is given by</p>
<p class="formulaDsp">
\begin{align} u_j(x)=u_j + \sigma_j (x-x_j) \end{align}
</p>
<p >where \(x_j\) is the coordinate \(x\) at the center of the cell. </p>

</div>
</div>
<a id="ga1f8b3572d823b4037ba780220781a668" name="ga1f8b3572d823b4037ba780220781a668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f8b3572d823b4037ba780220781a668">&#9670;&nbsp;</a></span>non_uniform_1d_weights()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t StencilSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, StencilSize &gt;, StencilSize &gt; fd::non_uniform_1d_weights </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>times</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the weights for a 1D non-uniform finite difference stencil. </p>
<p >These weights are for the Lagrange interpolation polynomial and its derivatives evaluated at <code>times[0]</code>. If the number of times is not the same as <code>StencilSize</code>, then an error will occur.</p>
<p >The reason that <code>times</code> was chosen to be monotonically decreasing is because the intended use of this function is with data that is stored in a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/deque.html">std::deque</a></code> where the zeroth element is the "most recent" in time and then later elements are further in the "past".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">times</td><td>A monotonically <em>decreasing</em> sequence of times </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> A 2D array of all finite difference weights that correspond to the input times. The outer dimension is the Nth derivative, and the inner dimension loops over the weights for each of the times.</p>
<dl class="section note"><dt>Note</dt><dd>Only stencil sizes 2, 3, and 4 are implemented right now. If you need more, you'll either need to add it yourself or generalize the algorithm. </dd></dl>

</div>
</div>
<a id="ga2fe2f5cf33b4b74b221e1fc43159fc7f" name="ga2fe2f5cf33b4b74b221e1fc43159fc7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fe2f5cf33b4b74b221e1fc43159fc7f">&#9670;&nbsp;</a></span>positivity_preserving_adaptive_order() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LowOrderReconstructor , bool PositivityPreserving, bool Use9thOrder, bool Use7thOrder, size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fd::reconstruction::positivity_preserving_adaptive_order </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt;&#160;</td>
          <td class="paramname"><em>reconstructed_upper_side_of_face_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt;&#160;</td>
          <td class="paramname"><em>reconstructed_lower_side_of_face_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint8_t</a> &gt;, Dim &gt; &gt; * &gt;&#160;</td>
          <td class="paramname"><em>reconstruction_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_cell_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>number_of_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>four_to_the_alpha_5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>six_to_the_alpha_7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>eight_to_the_alpha_9</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs positivity-preserving adaptive-order FD reconstruction. </p>
<p >Performs a fifth-order unlimited reconstruction. If the reconstructed values at the interfaces aren't positive (when <code>PositivityPreserving</code> is <code>true</code>) or when the Persson TCI condition:</p>
<p class="formulaDsp">
\begin{align} 4^\alpha \int_{x_{i-5/2}}^{x_{i+5/2}} \hat{u}^2(x) dx &gt; \int_{x_{i-5/2}}^{x_{i+5/2}} u^2(x) dx \end{align}
</p>
<p >is satisfied, where \(\hat{u}\) is the polynomial with only the largest modal coefficient non-zero, then the <code>LowOrderReconstructor</code> is used.</p>
<p >If <code>PositivityPreserving</code> is <code>true</code> then if the low-order reconstructed solution isn't positive we use first-order (constant in space) reconstruction.</p>
<p >If <code>Use9thOrder</code> is <code>true</code> then first a ninth-order reconstruction is used, followed by fifth-order. If <code>Use7thOrder</code> is <code>true</code> then seventh-order reconstruction is used before fifth-order (but after ninth-order if <code>Use9thOrder</code> is also <code>true</code>). This allows using the highest possible order locally for reconstruction.</p>
<p >Fifth order unlimited reconstruction is:</p>
<p class="formulaDsp">
\begin{align} \hat{u}_{i+1/2}=\frac{3}{128}u_{i-2} - \frac{5}{32}u_{i-1} + \frac{45}{64}u_{i} + \frac{15}{32}u_{i+1} - \frac{5}{128}u_{i+2} \end{align}
</p>
<p >Seventh order unlimited reconstruction is:</p>
<p class="formulaDsp">
\begin{align} \hat{u}_{i+1/2}&amp;=-\frac{5}{1024}u_{i-3} + \frac{21}{512}u_{i-2} - \frac{175}{1024}u_{i-1} + \frac{175}{256}u_{i} \\ &amp;+ \frac{525}{1024}u_{i+1} - \frac{35}{512}u_{i+2} + \frac{7}{1024}u_{i+3} \end{align}
</p>
<p >Ninth order unlimited reconstruction is:</p>
<p class="formulaDsp">
\begin{align} \hat{u}_{i+1/2}&amp;=\frac{35}{32768}u_{i-4} - \frac{45}{4096}u_{i-3} + \frac{441}{8291}u_{i-2} - \frac{735}{4096}u_{i-1} \\ &amp;+ \frac{11025}{16384}u_{i} + \frac{2205}{4096}u_{i+1} - \frac{735}{8192}u_{i+2} + \frac{63}{4096}u_{i+3} \\ &amp;- \frac{45}{32768}u_{i+4} \end{align}
</p>
 
</div>
</div>
<a id="ga212a14873595df3b34cc01172f25c5bd" name="ga212a14873595df3b34cc01172f25c5bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga212a14873595df3b34cc01172f25c5bd">&#9670;&nbsp;</a></span>positivity_preserving_adaptive_order() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LowOrderReconstructor , bool PositivityPreserving, bool Use9thOrder, bool Use7thOrder, size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fd::reconstruction::positivity_preserving_adaptive_order </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt;&#160;</td>
          <td class="paramname"><em>reconstructed_upper_side_of_face_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt;&#160;</td>
          <td class="paramname"><em>reconstructed_lower_side_of_face_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_cell_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>number_of_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>four_to_the_alpha_5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>six_to_the_alpha_7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>eight_to_the_alpha_9</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs positivity-preserving adaptive-order FD reconstruction. </p>
<p >Performs a fifth-order unlimited reconstruction. If the reconstructed values at the interfaces aren't positive (when <code>PositivityPreserving</code> is <code>true</code>) or when the Persson TCI condition:</p>
<p class="formulaDsp">
\begin{align} 4^\alpha \int_{x_{i-5/2}}^{x_{i+5/2}} \hat{u}^2(x) dx &gt; \int_{x_{i-5/2}}^{x_{i+5/2}} u^2(x) dx \end{align}
</p>
<p >is satisfied, where \(\hat{u}\) is the polynomial with only the largest modal coefficient non-zero, then the <code>LowOrderReconstructor</code> is used.</p>
<p >If <code>PositivityPreserving</code> is <code>true</code> then if the low-order reconstructed solution isn't positive we use first-order (constant in space) reconstruction.</p>
<p >If <code>Use9thOrder</code> is <code>true</code> then first a ninth-order reconstruction is used, followed by fifth-order. If <code>Use7thOrder</code> is <code>true</code> then seventh-order reconstruction is used before fifth-order (but after ninth-order if <code>Use9thOrder</code> is also <code>true</code>). This allows using the highest possible order locally for reconstruction.</p>
<p >Fifth order unlimited reconstruction is:</p>
<p class="formulaDsp">
\begin{align} \hat{u}_{i+1/2}=\frac{3}{128}u_{i-2} - \frac{5}{32}u_{i-1} + \frac{45}{64}u_{i} + \frac{15}{32}u_{i+1} - \frac{5}{128}u_{i+2} \end{align}
</p>
<p >Seventh order unlimited reconstruction is:</p>
<p class="formulaDsp">
\begin{align} \hat{u}_{i+1/2}&amp;=-\frac{5}{1024}u_{i-3} + \frac{21}{512}u_{i-2} - \frac{175}{1024}u_{i-1} + \frac{175}{256}u_{i} \\ &amp;+ \frac{525}{1024}u_{i+1} - \frac{35}{512}u_{i+2} + \frac{7}{1024}u_{i+3} \end{align}
</p>
<p >Ninth order unlimited reconstruction is:</p>
<p class="formulaDsp">
\begin{align} \hat{u}_{i+1/2}&amp;=\frac{35}{32768}u_{i-4} - \frac{45}{4096}u_{i-3} + \frac{441}{8291}u_{i-2} - \frac{735}{4096}u_{i-1} \\ &amp;+ \frac{11025}{16384}u_{i} + \frac{2205}{4096}u_{i+1} - \frac{735}{8192}u_{i+2} + \frac{63}{4096}u_{i+3} \\ &amp;- \frac{45}{32768}u_{i+4} \end{align}
</p>
 
</div>
</div>
<a id="ga3e01d24df6e3aa4865024639dab44a89" name="ga3e01d24df6e3aa4865024639dab44a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e01d24df6e3aa4865024639dab44a89">&#9670;&nbsp;</a></span>reconstruct_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">Side</a> LowerOrUpperSide, typename Reconstructor , bool UseExteriorCell = true, size_t NumberOfGhostPoints = (Reconstructor::stencil_width() / 2 + 1), size_t Dim, typename... ArgsForReconstructor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fd::reconstruction::reconstruct_neighbor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt;&#160;</td>
          <td class="paramname"><em>face_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>volume_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>neighbor_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_data_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction_to_reconstruct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArgsForReconstructor &amp;...&#160;</td>
          <td class="paramname"><em>args_for_reconstructor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In a given direction, reconstruct the cells in the neighboring <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> (or cluster of cells) nearest to the shared boundary between the current and neighboring <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> (or cluster of cells). </p>
<p >This is needed if one is sending reconstruction and flux data separately, or if one is using DG-FD hybrid schemes. Below is an ASCII diagram of what is reconstructed.</p>
<div class="fragment"><div class="line">Self      |  Neighbor</div>
<div class="line">x x x x x | o o o</div>
<div class="line">          ^+</div>
<div class="line">          Reconstruct to right/+ side of the interface</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga0fa54523ac5d0ec175be2af88e1be697" name="ga0fa54523ac5d0ec175be2af88e1be697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fa54523ac5d0ec175be2af88e1be697">&#9670;&nbsp;</a></span>unlimited()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Degree, size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fd::reconstruction::unlimited </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt;&#160;</td>
          <td class="paramname"><em>reconstructed_upper_side_of_face_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt;&#160;</td>
          <td class="paramname"><em>reconstructed_lower_side_of_face_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_cell_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>number_of_variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs unlimited reconstruction on the <code>vars</code> in each direction. </p>
<p >On a 1d mesh with spacing \(\Delta x\) we denote the solution at the \(j\)th point by \(u_j\). The degree 2 reconstruction is</p>
<p class="formulaDsp">
\begin{align} u_{j+1/2} &amp;= -\frac{1}{8} u_{j-1} + \frac{3}{4} u_j + \frac{3}{8} u_{j+1}, \\ u_{j-1/2} &amp;= \frac{3}{8} u_{j-1} + \frac{3}{4} u_j - \frac{1}{8} u_{j+1}. \end{align}
</p>
<p >The degree 4 reconstruction is</p>
<p class="formulaDsp">
\begin{align} u_{j-1/2} &amp;= - \frac{5}{128}u_{j-2} + \frac{15}{32}u_{j-1} + \frac{45}{64}u_{j} -\frac{5}{32}u_{j+1} + \frac{3}{128}u_{j+2}, \\ u_{j+1/2} &amp;= \frac{3}{128}u_{j-2} - \frac{5}{32}u_{j-1} + \frac{45}{64}u_{j} + \frac{15}{32}u_{j+1} - \frac{5}{128}u_{j+2}. \end{align}
</p>
<p >Degree 6 and 8 reconstruction is also supported. </p>

</div>
</div>
<a id="ga206cdb85bef8ff7fb02e7b0df91c430a" name="ga206cdb85bef8ff7fb02e7b0df91c430a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga206cdb85bef8ff7fb02e7b0df91c430a">&#9670;&nbsp;</a></span>wcns5z()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NonlinearWeightExponent, class FallbackReconstructor , size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fd::reconstruction::wcns5z </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt;&#160;</td>
          <td class="paramname"><em>reconstructed_upper_side_of_face_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; double &gt;, Dim &gt; * &gt;&#160;</td>
          <td class="paramname"><em>reconstructed_lower_side_of_face_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_cell_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>number_of_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>max_number_of_extrema</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs fifth order weighted compact nonlinear scheme reconstruction based on the WENO-Z method (WCNS-5Z). Adaptive fallback combined with an auxiliary reconstruction method (e.g. monotonised central) is also supported. </p>
<p >Using the WENO oscillation indicators given by <a class="el" href="citelist.html#CITEREF_Jiang1996">[86]</a></p>
<p class="formulaDsp">
\begin{align} \beta_0 &amp; = \frac{13}{12} (q_{i-2} - 2q_{i-1} + q_{i})^2 + \frac{1}{4} (q_{i-2} - 4q_{i-1} + 3q_{i})^2 \\ \beta_1 &amp; = \frac{13}{12} (q_{i-1} - 2q_{i} + q_{i+1})^2 + \frac{1}{4} (q_{i+1} - q_{i-1})^2 \\ \beta_2 &amp; = \frac{13}{12} (q_{i} - 2q_{i+1} + q_{i+2})^2 + \frac{1}{4} (3q_{i} - 4q_{i+1} + q_{i+2})^2 , \end{align}
</p>
<p >compute the modified nonlinear weights (cf. WENO-Z scheme: see Eq. 42 of <a class="el" href="citelist.html#CITEREF_Borges20083191">[22]</a>)</p>
<p class="formulaDsp">
\begin{align} \omega_k^z = \frac{\alpha_k^z}{\sum_{l=0}^z \alpha_l^z}, \quad \alpha_k^z = c_k \left(1 + \left( \frac{\tau_5}{\beta_k + \epsilon_k} \right)^q \right), \quad k = 0, 1, 2 \end{align}
</p>
<p >where \(\epsilon_k\) is a factor used to avoid division by zero and is set to</p>
<p class="formulaDsp">
\begin{align} \epsilon_k = \varepsilon (1 + |q_{i+k}| + |q_{i+k-1}| + |q_{i+k-2}|), \quad k = 0, 1, 2, \end{align}
</p>
<p >linear weights \(c_k\) are adopted from <a class="el" href="citelist.html#CITEREF_Nonomura2013">[123]</a> (see Table 17 of it)</p>
<p class="formulaDsp">
\begin{align} c_0 = 1/16, \quad c_1 = 10/16, \quad c_2 = 5/16, \end{align}
</p>
<p >and \(\tau_5 \equiv |\beta_2-\beta_0|\).</p>
<p >Reconstruction stencils are given by Lagrange interpolations (e.g. see Eq. 29d - 29f of <a class="el" href="citelist.html#CITEREF_Brehm2015">[26]</a>) </p><p class="formulaDsp">
\begin{align} q_{i+1/2}^0 &amp;= \frac{3}{8}q_{i-2} -\frac{5}{4}q_{i-1} +\frac{15}{8}q_{i} \\ q_{i+1/2}^1 &amp;= -\frac{1}{8}q_{i-1} +\frac{3}{4}q_{i} +\frac{3}{8}q_{i+1} \\ q_{i+1/2}^2 &amp;= \frac{3}{8}q_{i} +\frac{3}{4}q_{i+1} -\frac{1}{8}q_{i+2} \end{align}
</p>
<p >and the final reconstructed solution is given by </p><p class="formulaDsp">
\begin{align} q_{i+1/2} = \sum_{k=0}^2 \omega_k q_{i+1/2}^k . \end{align}
</p>
<p >The nonlinear weights exponent \(q (=1 \text{ or } 2)\) and the small factor \(\varepsilon\) can be chosen via an input file.</p>
<p >If the template parameter <code>FallbackReconstructor</code> is set to one of the FD reconstructor structs of which names are listed in <code><a class="el" href="group__FiniteDifferenceGroup.html#ga6911a7cdbcf635d67c38a26a311a4cd3" title="Possible types of reconstruction routines to fall back to from higher-order reconstruction when using...">fd::reconstruction::FallbackReconstructorType</a></code>, adaptive reconstruction is performed as follows. For each finite difference stencils, first check how many extrema are in the stencil. If the number of local extrema is less than or equal to a non-negative integer <code>max_number_of_extrema</code> which is given as an input parameter, perform the WCNS-5Z reconstruction; otherwise switch to the given <code>FallbackReconstructor</code> for performing reconstruction. If <code>FallbackReconstructor</code> is set to <code>void</code>, the adaptive method is disabled and WCNS-5Z is always used. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
