<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: tenex::AddSub&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt; Struct Template Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Argsccd256955c5fde688d2717c8a05a5445.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tenex::AddSub&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8f2d8fd3de44869df72ccbe32ec6f6e0"><td class="memItemLeft" align="right" valign="top"><a id="a8f2d8fd3de44869df72ccbe32ec6f6e0" name="a8f2d8fd3de44869df72ccbe32ec6f6e0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>type</b> = typename detail::AddSubType&lt; T1, T2 &gt;::type</td></tr>
<tr class="memdesc:a8f2d8fd3de44869df72ccbe32ec6f6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the data being stored in the result of the expression. <br /></td></tr>
<tr class="separator:a8f2d8fd3de44869df72ccbe32ec6f6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0176be46d56a19397cee0131d9475949"><td class="memItemLeft" align="right" valign="top"><a id="a0176be46d56a19397cee0131d9475949" name="a0176be46d56a19397cee0131d9475949"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>symmetry</b> = typename detail::AddSubType&lt; T1, T2 &gt;::symmetry</td></tr>
<tr class="memdesc:a0176be46d56a19397cee0131d9475949"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9" title="Computes the canonical symmetry from the integers T">Symmetry</a> of the result of the expression. <br /></td></tr>
<tr class="separator:a0176be46d56a19397cee0131d9475949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9d59f34356638802c94d5b68912e4c"><td class="memItemLeft" align="right" valign="top"><a id="a5c9d59f34356638802c94d5b68912e4c" name="a5c9d59f34356638802c94d5b68912e4c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>index_list</b> = typename detail::AddSubType&lt; T1, T2 &gt;::index_list</td></tr>
<tr class="memdesc:a5c9d59f34356638802c94d5b68912e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a>s of the result of the expression. <br /></td></tr>
<tr class="separator:a5c9d59f34356638802c94d5b68912e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579febb018cc8490ffd8a10b40db9044"><td class="memItemLeft" align="right" valign="top"><a id="a579febb018cc8490ffd8a10b40db9044" name="a579febb018cc8490ffd8a10b40db9044"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>args_list</b> = typename T1::args_list</td></tr>
<tr class="memdesc:a579febb018cc8490ffd8a10b40db9044"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of generic <code><a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a></code>s of the result of the expression. <br /></td></tr>
<tr class="separator:a579febb018cc8490ffd8a10b40db9044"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7cc2fd149294e6a6a4aded46b6bf6138"><td class="memItemLeft" align="right" valign="top"><a id="a7cc2fd149294e6a6a4aded46b6bf6138" name="a7cc2fd149294e6a6a4aded46b6bf6138"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AddSub</b> (T1 t1, T2 t2)</td></tr>
<tr class="separator:a7cc2fd149294e6a6a4aded46b6bf6138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab73c7940eb24041d084511cc79f90a"><td class="memTemplParams" colspan="2"><a id="a1ab73c7940eb24041d084511cc79f90a" name="a1ab73c7940eb24041d084511cc79f90a"></a>
template&lt;typename LhsTensor &gt; </td></tr>
<tr class="memitem:a1ab73c7940eb24041d084511cc79f90a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assert_lhs_tensor_not_in_rhs_expression</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; LhsTensor * &gt; lhs_tensor) const</td></tr>
<tr class="memdesc:a1ab73c7940eb24041d084511cc79f90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert that the LHS tensor of the equation does not also appear in this expression's subtree. <br /></td></tr>
<tr class="separator:a1ab73c7940eb24041d084511cc79f90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5907f82a47febea4c66120c352b9d0b"><td class="memTemplParams" colspan="2">template&lt;typename LhsTensorIndices , typename LhsTensor &gt; </td></tr>
<tr class="memitem:ac5907f82a47febea4c66120c352b9d0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#ac5907f82a47febea4c66120c352b9d0b">assert_lhs_tensorindices_same_in_rhs</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; LhsTensor * &gt; lhs_tensor) const</td></tr>
<tr class="memdesc:ac5907f82a47febea4c66120c352b9d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert that each instance of the LHS tensor in the RHS tensor expression uses the same generic index order that the LHS uses.  <a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#ac5907f82a47febea4c66120c352b9d0b">More...</a><br /></td></tr>
<tr class="separator:ac5907f82a47febea4c66120c352b9d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2306b3464d1d74633a6bd819889e235"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#ad2306b3464d1d74633a6bd819889e235">get_rhs_tensor_component_size</a> () const</td></tr>
<tr class="memdesc:ad2306b3464d1d74633a6bd819889e235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of a component from a <code>Tensor</code> in this expression's subtree of the RHS <code>TensorExpression</code>  <a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#ad2306b3464d1d74633a6bd819889e235">More...</a><br /></td></tr>
<tr class="separator:ad2306b3464d1d74633a6bd819889e235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63a521baa373a1259078105196a4f9d"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a3347e9cb059d80268d7069dda9621596">num_tensor_indices_op2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#ac63a521baa373a1259078105196a4f9d">get_op2_multi_index</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a1dfe3cdb5c78642134874671e5b000bc">num_tensor_indices</a> &gt; &amp;op1_multi_index) const</td></tr>
<tr class="memdesc:ac63a521baa373a1259078105196a4f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the second operand's multi-index given the first operand's multi-index.  <a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#ac63a521baa373a1259078105196a4f9d">More...</a><br /></td></tr>
<tr class="separator:ac63a521baa373a1259078105196a4f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b57e333c3006c17a5656b7edc503d0"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#ac3b57e333c3006c17a5656b7edc503d0">add_or_subtract</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a1dfe3cdb5c78642134874671e5b000bc">num_tensor_indices</a> &gt; &amp;op1_multi_index, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a3347e9cb059d80268d7069dda9621596">num_tensor_indices_op2</a> &gt; &amp;op2_multi_index) const</td></tr>
<tr class="memdesc:ac3b57e333c3006c17a5656b7edc503d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for computing the sum of or difference between components at given multi-indices from both operands of the expression.  <a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#ac3b57e333c3006c17a5656b7edc503d0">More...</a><br /></td></tr>
<tr class="separator:ac3b57e333c3006c17a5656b7edc503d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692e81bebb4e5535485869ac6fef1dbe"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a692e81bebb4e5535485869ac6fef1dbe">get</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a1dfe3cdb5c78642134874671e5b000bc">num_tensor_indices</a> &gt; &amp;result_multi_index) const</td></tr>
<tr class="memdesc:a692e81bebb4e5535485869ac6fef1dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the component at the given multi-index of the tensor resulting from addition or subtraction.  <a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a692e81bebb4e5535485869ac6fef1dbe">More...</a><br /></td></tr>
<tr class="separator:a692e81bebb4e5535485869ac6fef1dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c98a13788318b762e37e0bdf69cbd6"><td class="memTemplParams" colspan="2">template&lt;typename ResultType &gt; </td></tr>
<tr class="memitem:a55c98a13788318b762e37e0bdf69cbd6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a55c98a13788318b762e37e0bdf69cbd6">add_or_subtract_primary_children</a> (ResultType &amp;result_component, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a1dfe3cdb5c78642134874671e5b000bc">num_tensor_indices</a> &gt; &amp;op1_multi_index, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a3347e9cb059d80268d7069dda9621596">num_tensor_indices_op2</a> &gt; &amp;op2_multi_index) const</td></tr>
<tr class="memdesc:a55c98a13788318b762e37e0bdf69cbd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for evaluating the LHS Tensor's result component at this subtree by evaluating the two operand's subtrees separately and adding or subtracting them.  <a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a55c98a13788318b762e37e0bdf69cbd6">More...</a><br /></td></tr>
<tr class="separator:a55c98a13788318b762e37e0bdf69cbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf73234e98281f69907dffb6a15f1546"><td class="memTemplParams" colspan="2">template&lt;typename ResultType &gt; </td></tr>
<tr class="memitem:acf73234e98281f69907dffb6a15f1546"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#acf73234e98281f69907dffb6a15f1546">evaluate_primary_children</a> (ResultType &amp;result_component, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a1dfe3cdb5c78642134874671e5b000bc">num_tensor_indices</a> &gt; &amp;result_multi_index) const</td></tr>
<tr class="memdesc:acf73234e98281f69907dffb6a15f1546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the LHS Tensor's result component at this subtree by evaluating the two operand's subtrees separately and adding or subtracting them.  <a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#acf73234e98281f69907dffb6a15f1546">More...</a><br /></td></tr>
<tr class="separator:acf73234e98281f69907dffb6a15f1546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524ece706d901586272a4cf1d1911d17"><td class="memTemplParams" colspan="2">template&lt;typename ResultType &gt; </td></tr>
<tr class="memitem:a524ece706d901586272a4cf1d1911d17"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a524ece706d901586272a4cf1d1911d17">add_or_subtract_primary</a> (const ResultType &amp;result_component, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a1dfe3cdb5c78642134874671e5b000bc">num_tensor_indices</a> &gt; &amp;op1_multi_index, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a3347e9cb059d80268d7069dda9621596">num_tensor_indices_op2</a> &gt; &amp;op2_multi_index) const</td></tr>
<tr class="memdesc:a524ece706d901586272a4cf1d1911d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for returning the sum of or difference between components at given multi-indices from both operands of the expression.  <a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a524ece706d901586272a4cf1d1911d17">More...</a><br /></td></tr>
<tr class="separator:a524ece706d901586272a4cf1d1911d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76178279e85614d81e98f9726afa3a09"><td class="memTemplParams" colspan="2">template&lt;typename ResultType &gt; </td></tr>
<tr class="memitem:a76178279e85614d81e98f9726afa3a09"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a76178279e85614d81e98f9726afa3a09">get_primary</a> (const ResultType &amp;result_component, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a1dfe3cdb5c78642134874671e5b000bc">num_tensor_indices</a> &gt; &amp;result_multi_index) const</td></tr>
<tr class="memdesc:a76178279e85614d81e98f9726afa3a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the component at the given multi-index of the tensor resulting from addition or subtraction.  <a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a76178279e85614d81e98f9726afa3a09">More...</a><br /></td></tr>
<tr class="separator:a76178279e85614d81e98f9726afa3a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb095ad3c25d0bf277729990d46c6b9"><td class="memTemplParams" colspan="2">template&lt;typename ResultType &gt; </td></tr>
<tr class="memitem:a7fb095ad3c25d0bf277729990d46c6b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a7fb095ad3c25d0bf277729990d46c6b9">evaluate_primary_subtree</a> (ResultType &amp;result_component, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a1dfe3cdb5c78642134874671e5b000bc">num_tensor_indices</a> &gt; &amp;result_multi_index) const</td></tr>
<tr class="memdesc:a7fb095ad3c25d0bf277729990d46c6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Successively evaluate the LHS Tensor's result component at each leg in this expression's subtree.  <a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a7fb095ad3c25d0bf277729990d46c6b9">More...</a><br /></td></tr>
<tr class="separator:a7fb095ad3c25d0bf277729990d46c6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a1dfe3cdb5c78642134874671e5b000bc"><td class="memItemLeft" align="right" valign="top"><a id="a1dfe3cdb5c78642134874671e5b000bc" name="a1dfe3cdb5c78642134874671e5b000bc"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>num_tensor_indices</b> = tmpl::size&lt;<a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a5c9d59f34356638802c94d5b68912e4c">index_list</a>&gt;<a class="el" href="group__UtilitiesGroup.html#ga2cb8822c810d5eec9a7ecc6d271bda8f">::value</a></td></tr>
<tr class="memdesc:a1dfe3cdb5c78642134874671e5b000bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of tensor indices in the result of the expression. This also doubles as the left operand's number of indices. <br /></td></tr>
<tr class="separator:a1dfe3cdb5c78642134874671e5b000bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3347e9cb059d80268d7069dda9621596"><td class="memItemLeft" align="right" valign="top"><a id="a3347e9cb059d80268d7069dda9621596" name="a3347e9cb059d80268d7069dda9621596"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>num_tensor_indices_op2</b> = sizeof...(Args2)</td></tr>
<tr class="memdesc:a3347e9cb059d80268d7069dda9621596"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of tensor indices in the right operand expression. <br /></td></tr>
<tr class="separator:a3347e9cb059d80268d7069dda9621596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe7c833629ba5d8afb7860daef8b387"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a3347e9cb059d80268d7069dda9621596">num_tensor_indices_op2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#adbe7c833629ba5d8afb7860daef8b387">operand_index_transformation</a></td></tr>
<tr class="memdesc:adbe7c833629ba5d8afb7860daef8b387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping from the left operand's index order to the right operand's index order.  <a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#adbe7c833629ba5d8afb7860daef8b387">More...</a><br /></td></tr>
<tr class="separator:adbe7c833629ba5d8afb7860daef8b387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0c5bb7cdc859c408b83267d1b00795"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#abe0c5bb7cdc859c408b83267d1b00795">op1_spatial_spacetime_index_positions</a></td></tr>
<tr class="memdesc:abe0c5bb7cdc859c408b83267d1b00795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positions of indices in first operand where generic spatial indices are used for spacetime indices.  <a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#abe0c5bb7cdc859c408b83267d1b00795">More...</a><br /></td></tr>
<tr class="separator:abe0c5bb7cdc859c408b83267d1b00795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b270d2b9ca400f533c85f73fe9cc9a6"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a0b270d2b9ca400f533c85f73fe9cc9a6">op2_spatial_spacetime_index_positions</a></td></tr>
<tr class="memdesc:a0b270d2b9ca400f533c85f73fe9cc9a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positions of indices in second operand where generic spatial indices are used for spacetime indices.  <a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a0b270d2b9ca400f533c85f73fe9cc9a6">More...</a><br /></td></tr>
<tr class="separator:a0b270d2b9ca400f533c85f73fe9cc9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80294cd08a338087105716a252b15c9"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#af80294cd08a338087105716a252b15c9">ops_have_generic_indices_at_same_positions</a></td></tr>
<tr class="memdesc:af80294cd08a338087105716a252b15c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not the two operands have the same <code><a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a></code>s in the same order (including concrete time indices)  <a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#af80294cd08a338087105716a252b15c9">More...</a><br /></td></tr>
<tr class="separator:af80294cd08a338087105716a252b15c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e3434e1f29ea6fd56df97cc5db1229"><td class="memItemLeft" align="right" valign="top"><a id="a22e3434e1f29ea6fd56df97cc5db1229" name="a22e3434e1f29ea6fd56df97cc5db1229"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_ops_left_child</b> = T1::num_ops_subtree</td></tr>
<tr class="memdesc:a22e3434e1f29ea6fd56df97cc5db1229"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of arithmetic tensor operations done in the subtree for the left operand. <br /></td></tr>
<tr class="separator:a22e3434e1f29ea6fd56df97cc5db1229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf32f403573b543536d728f1787cf7e5"><td class="memItemLeft" align="right" valign="top"><a id="aaf32f403573b543536d728f1787cf7e5" name="aaf32f403573b543536d728f1787cf7e5"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_ops_right_child</b> = T2::num_ops_subtree</td></tr>
<tr class="memdesc:aaf32f403573b543536d728f1787cf7e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of arithmetic tensor operations done in the subtree for the right operand. <br /></td></tr>
<tr class="separator:aaf32f403573b543536d728f1787cf7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107984e96b0a5a7b45d08e86071460e3"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a107984e96b0a5a7b45d08e86071460e3">num_ops_subtree</a></td></tr>
<tr class="memdesc:a107984e96b0a5a7b45d08e86071460e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of arithmetic tensor operations done in this expression's whole subtree.  <a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a107984e96b0a5a7b45d08e86071460e3">More...</a><br /></td></tr>
<tr class="separator:a107984e96b0a5a7b45d08e86071460e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fab2da63cdde5104425db92ff4a5b67"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a4fab2da63cdde5104425db92ff4a5b67">height_relative_to_closest_tensor_leaf_in_subtree</a></td></tr>
<tr class="memdesc:a4fab2da63cdde5104425db92ff4a5b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">The height of this expression's node in the expression tree relative to the closest <code><a class="el" href="structtenex_1_1TensorAsExpression.html" title="Defines an expression representing a Tensor.">TensorAsExpression</a></code> leaf in its subtree.  <a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a4fab2da63cdde5104425db92ff4a5b67">More...</a><br /></td></tr>
<tr class="separator:a4fab2da63cdde5104425db92ff4a5b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e5072efff9a24b3e617782ba2635f7"><td class="memItemLeft" align="right" valign="top"><a id="ac5e5072efff9a24b3e617782ba2635f7" name="ac5e5072efff9a24b3e617782ba2635f7"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_primary_end</b> = T1::is_primary_start</td></tr>
<tr class="memdesc:ac5e5072efff9a24b3e617782ba2635f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">If on the primary path, whether or not the expression is an ending point of a leg. <br /></td></tr>
<tr class="separator:ac5e5072efff9a24b3e617782ba2635f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21208e976121839b0f2c07b73b2dc722"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a21208e976121839b0f2c07b73b2dc722">num_ops_to_evaluate_primary_left_child</a></td></tr>
<tr class="memdesc:a21208e976121839b0f2c07b73b2dc722"><td class="mdescLeft">&#160;</td><td class="mdescRight">If on the primary path, this is the remaining number of arithmetic tensor operations that need to be done in the subtree of the child along the primary path, given that we will have already computed the whole subtree at the next lowest leg's starting point.  <a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a21208e976121839b0f2c07b73b2dc722">More...</a><br /></td></tr>
<tr class="separator:a21208e976121839b0f2c07b73b2dc722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49922d1efe2e0e067e3688bc5f592672"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a49922d1efe2e0e067e3688bc5f592672">num_ops_to_evaluate_primary_right_child</a></td></tr>
<tr class="memdesc:a49922d1efe2e0e067e3688bc5f592672"><td class="mdescLeft">&#160;</td><td class="mdescRight">If on the primary path, this is the remaining number of arithmetic tensor operations that need to be done in the right operand's subtree. No splitting is currently done, so this is just <code>num_ops_right_child</code>.  <a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a49922d1efe2e0e067e3688bc5f592672">More...</a><br /></td></tr>
<tr class="separator:a49922d1efe2e0e067e3688bc5f592672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0022d3d8129f35a4b108f36119ac34bf"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a0022d3d8129f35a4b108f36119ac34bf">num_ops_to_evaluate_primary_subtree</a></td></tr>
<tr class="memdesc:a0022d3d8129f35a4b108f36119ac34bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">If on the primary path, this is the remaining number of arithmetic tensor operations that need to be done for this expression's subtree, given that we will have already computed the subtree at the next lowest leg's starting point.  <a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a0022d3d8129f35a4b108f36119ac34bf">More...</a><br /></td></tr>
<tr class="separator:a0022d3d8129f35a4b108f36119ac34bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedaa6c82bd321f5925e801f43056fc05"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#aedaa6c82bd321f5925e801f43056fc05">is_primary_start</a></td></tr>
<tr class="memdesc:aedaa6c82bd321f5925e801f43056fc05"><td class="mdescLeft">&#160;</td><td class="mdescRight">If on the primary path, whether or not the expression is a starting point of a leg.  <a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#aedaa6c82bd321f5925e801f43056fc05">More...</a><br /></td></tr>
<tr class="separator:aedaa6c82bd321f5925e801f43056fc05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad18f298352f710418d001f011bc2141"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#aad18f298352f710418d001f011bc2141">evaluate_children_separately</a></td></tr>
<tr class="memdesc:aad18f298352f710418d001f011bc2141"><td class="mdescLeft">&#160;</td><td class="mdescRight">When evaluating along a primary path, whether each operand's subtrees should be evaluated separately. Since <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code> expression runtime scales poorly with increased number of operations, evaluating the two expression subtrees separately like this is beneficial when at least one of the subtrees contains a large number of operations.  <a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#aad18f298352f710418d001f011bc2141">More...</a><br /></td></tr>
<tr class="separator:aad18f298352f710418d001f011bc2141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2698b63b0777fc01df3e91100de330"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a8b2698b63b0777fc01df3e91100de330">primary_child_subtree_contains_primary_start</a></td></tr>
<tr class="memdesc:a8b2698b63b0777fc01df3e91100de330"><td class="mdescLeft">&#160;</td><td class="mdescRight">If on the primary path, whether or not the expression's child along the primary path is a subtree that contains a starting point of a leg along the primary path.  <a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a8b2698b63b0777fc01df3e91100de330">More...</a><br /></td></tr>
<tr class="separator:a8b2698b63b0777fc01df3e91100de330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30619c0c1d379945b643b30d3191f48e"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a30619c0c1d379945b643b30d3191f48e">primary_subtree_contains_primary_start</a></td></tr>
<tr class="memdesc:a30619c0c1d379945b643b30d3191f48e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If on the primary path, whether or not this subtree contains a starting point of a leg along the primary path.  <a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a30619c0c1d379945b643b30d3191f48e">More...</a><br /></td></tr>
<tr class="separator:a30619c0c1d379945b643b30d3191f48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac3b57e333c3006c17a5656b7edc503d0" name="ac3b57e333c3006c17a5656b7edc503d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b57e333c3006c17a5656b7edc503d0">&#9670;&nbsp;</a></span>add_or_subtract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , template&lt; typename... &gt; class ArgsList1, template&lt; typename... &gt; class ArgsList2, typename... Args1, typename... Args2, int Sign&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="structtenex_1_1AddSub.html">tenex::AddSub</a>&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::add_or_subtract </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a1dfe3cdb5c78642134874671e5b000bc">num_tensor_indices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op1_multi_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a3347e9cb059d80268d7069dda9621596">num_tensor_indices_op2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op2_multi_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for computing the sum of or difference between components at given multi-indices from both operands of the expression. </p>
<h3>Details</h3>
<p >Both multi-index arguments must be ordered according to their operand's respective generic index ordering</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1_multi_index</td><td>the multi-index of the component of the first operand </td></tr>
    <tr><td class="paramname">op2_multi_index</td><td>the multi-index of the component of the second operand </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the sum of or difference between the two components' values </p>

</div>
</div>
<a id="a524ece706d901586272a4cf1d1911d17" name="a524ece706d901586272a4cf1d1911d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a524ece706d901586272a4cf1d1911d17">&#9670;&nbsp;</a></span>add_or_subtract_primary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , template&lt; typename... &gt; class ArgsList1, template&lt; typename... &gt; class ArgsList2, typename... Args1, typename... Args2, int Sign&gt; </div>
<div class="memtemplate">
template&lt;typename ResultType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="structtenex_1_1AddSub.html">tenex::AddSub</a>&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::add_or_subtract_primary </td>
          <td>(</td>
          <td class="paramtype">const ResultType &amp;&#160;</td>
          <td class="paramname"><em>result_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a1dfe3cdb5c78642134874671e5b000bc">num_tensor_indices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op1_multi_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a3347e9cb059d80268d7069dda9621596">num_tensor_indices_op2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op2_multi_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for returning the sum of or difference between components at given multi-indices from both operands of the expression. </p>
<h3>Details</h3>
<p >This function differs from <code>add_or_subtract</code> in that it takes into account whether we have already computed part of the result component at a lower subtree. In recursively computing this sum/difference, the current result component will be substituted in for the most recent (highest) subtree below it that has already been evaluated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result_component</td><td>the LHS tensor component to evaluate </td></tr>
    <tr><td class="paramname">op1_multi_index</td><td>the multi-index of the component of the first operand </td></tr>
    <tr><td class="paramname">op2_multi_index</td><td>the multi-index of the component of the second operand </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the sum of or difference between the two components' values </p>

</div>
</div>
<a id="a55c98a13788318b762e37e0bdf69cbd6" name="a55c98a13788318b762e37e0bdf69cbd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55c98a13788318b762e37e0bdf69cbd6">&#9670;&nbsp;</a></span>add_or_subtract_primary_children()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , template&lt; typename... &gt; class ArgsList1, template&lt; typename... &gt; class ArgsList2, typename... Args1, typename... Args2, int Sign&gt; </div>
<div class="memtemplate">
template&lt;typename ResultType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structtenex_1_1AddSub.html">tenex::AddSub</a>&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::add_or_subtract_primary_children </td>
          <td>(</td>
          <td class="paramtype">ResultType &amp;&#160;</td>
          <td class="paramname"><em>result_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a1dfe3cdb5c78642134874671e5b000bc">num_tensor_indices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op1_multi_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a3347e9cb059d80268d7069dda9621596">num_tensor_indices_op2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op2_multi_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for evaluating the LHS Tensor's result component at this subtree by evaluating the two operand's subtrees separately and adding or subtracting them. </p>
<h3>Details</h3>
<p >The left and right operands' subtrees are evaluated successively with two separate assignments to the LHS result component. Since <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code> expression runtime scales poorly with increased number of operations, evaluating the two expression subtrees separately like this is beneficial when at least one of the subtrees contains a large number of operations. Instead of evaluating a larger expression with their combined total number of operations, we evaluate two smaller ones.</p>
<p >This function also differs from <code>add_or_subtract</code> in that it takes into account whether we have already computed part of the result component at a lower subtree. In recursively computing this sum/difference, the current result component will be substituted in for the most recent (highest) subtree below it that has already been evaluated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result_component</td><td>the LHS tensor component to evaluate </td></tr>
    <tr><td class="paramname">op1_multi_index</td><td>the multi-index of the component of the first operand of the sum or difference to evaluate </td></tr>
    <tr><td class="paramname">op2_multi_index</td><td>the multi-index of the component of the second operand of the sum or difference to evaluate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5907f82a47febea4c66120c352b9d0b" name="ac5907f82a47febea4c66120c352b9d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5907f82a47febea4c66120c352b9d0b">&#9670;&nbsp;</a></span>assert_lhs_tensorindices_same_in_rhs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , template&lt; typename... &gt; class ArgsList1, template&lt; typename... &gt; class ArgsList2, typename... Args1, typename... Args2, int Sign&gt; </div>
<div class="memtemplate">
template&lt;typename LhsTensorIndices , typename LhsTensor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structtenex_1_1AddSub.html">tenex::AddSub</a>&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::assert_lhs_tensorindices_same_in_rhs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; LhsTensor * &gt;&#160;</td>
          <td class="paramname"><em>lhs_tensor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assert that each instance of the LHS tensor in the RHS tensor expression uses the same generic index order that the LHS uses. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LhsTensorIndices</td><td>the list of generic <code><a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a></code>s of the LHS result <code>Tensor</code> being computed </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs_tensor</td><td>the LHS result <code>Tensor</code> being computed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf73234e98281f69907dffb6a15f1546" name="acf73234e98281f69907dffb6a15f1546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf73234e98281f69907dffb6a15f1546">&#9670;&nbsp;</a></span>evaluate_primary_children()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , template&lt; typename... &gt; class ArgsList1, template&lt; typename... &gt; class ArgsList2, typename... Args1, typename... Args2, int Sign&gt; </div>
<div class="memtemplate">
template&lt;typename ResultType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structtenex_1_1AddSub.html">tenex::AddSub</a>&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::evaluate_primary_children </td>
          <td>(</td>
          <td class="paramtype">ResultType &amp;&#160;</td>
          <td class="paramname"><em>result_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a1dfe3cdb5c78642134874671e5b000bc">num_tensor_indices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result_multi_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the LHS Tensor's result component at this subtree by evaluating the two operand's subtrees separately and adding or subtracting them. </p>
<h3>Details</h3>
<p >See <code>add_or_subtract_primary_children</code> for more details</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result_component</td><td>the LHS tensor component to evaluate </td></tr>
    <tr><td class="paramname">result_multi_index</td><td>the multi-index of the component of the result tensor to evaluate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fb095ad3c25d0bf277729990d46c6b9" name="a7fb095ad3c25d0bf277729990d46c6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb095ad3c25d0bf277729990d46c6b9">&#9670;&nbsp;</a></span>evaluate_primary_subtree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , template&lt; typename... &gt; class ArgsList1, template&lt; typename... &gt; class ArgsList2, typename... Args1, typename... Args2, int Sign&gt; </div>
<div class="memtemplate">
template&lt;typename ResultType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structtenex_1_1AddSub.html">tenex::AddSub</a>&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::evaluate_primary_subtree </td>
          <td>(</td>
          <td class="paramtype">ResultType &amp;&#160;</td>
          <td class="paramname"><em>result_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a1dfe3cdb5c78642134874671e5b000bc">num_tensor_indices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result_multi_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Successively evaluate the LHS Tensor's result component at each leg in this expression's subtree. </p>
<h3>Details</h3>
<p >This function takes into account whether we have already computed part of the result component at a lower subtree. In recursively computing this sum/difference, the current result component will be substituted in for the most recent (highest) subtree below it that has already been evaluated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result_component</td><td>the LHS tensor component to evaluate </td></tr>
    <tr><td class="paramname">result_multi_index</td><td>the multi-index of the component of the result tensor to evaluate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a692e81bebb4e5535485869ac6fef1dbe" name="a692e81bebb4e5535485869ac6fef1dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692e81bebb4e5535485869ac6fef1dbe">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , template&lt; typename... &gt; class ArgsList1, template&lt; typename... &gt; class ArgsList2, typename... Args1, typename... Args2, int Sign&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="structtenex_1_1AddSub.html">tenex::AddSub</a>&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a1dfe3cdb5c78642134874671e5b000bc">num_tensor_indices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result_multi_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of the component at the given multi-index of the tensor resulting from addition or subtraction. </p>
<h3>Details</h3>
<p >One important detail to note about the type of the <code><a class="el" href="structtenex_1_1AddSub.html" title="Defines the tensor expression representing the addition or subtraction of two tensor expressions.">AddSub</a></code> expression is that its two operands may have (i) different generic index orders, and/or (ii) different indices in their <code>index_list</code>s if where one operand uses a generic spatial index for a spacetime index, the other tensor may use that generic spatial index for a spatial index of the same dimension, valence, and frame. Therefore, there are four possible cases for an <code><a class="el" href="structtenex_1_1AddSub.html" title="Defines the tensor expression representing the addition or subtraction of two tensor expressions.">AddSub</a></code> expression that are considered in the implementation:</p><ul>
<li>same generic index order, spatial spacetime indices in expression</li>
<li>same generic index order, spatial spacetime indices not in expression</li>
<li>different generic index order, spatial spacetime indices in expression</li>
<li>different generic index order, spatial spacetime indices not in expression</li>
</ul>
<p >This means that for expressions where the generic index orders differ, a multi-index for a component of one operand is a (possible) rearrangement of the equivalent multi-index for a component in the other operand. This also means that for expressions where (at least once) a generic spatial index is used for a spacetime index, then, after accounting for potential reordering due to different generic index orders, a multi-index's values for a component of one operand are (possibly) shifted by one, compared to the multi-index's values for a component in the other operand.</p>
<p >For example, given \(R_{ij} + S_{ji}\), let \(R\)'s first index be a spacetime index, but \(R\)'s second index and both of \(S\)' indices be spatial indices. If \(i = 2\) and \(j = 0\), then when we compute \(R_{20} + S_{02}\), the multi-index for \(R_{20}\) is <code>{2 + 1, 0} = {3, 0}</code> (first value shifted because it is a spacetime index) and the multi-index for \(S_{02}\) is <code>[0, 2]</code>. Because the first operand of an <code><a class="el" href="structtenex_1_1AddSub.html" title="Defines the tensor expression representing the addition or subtraction of two tensor expressions.">AddSub</a></code> expresion propagates its generic index order and index list ( <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a>s) as the <code><a class="el" href="structtenex_1_1AddSub.html" title="Defines the tensor expression representing the addition or subtraction of two tensor expressions.">AddSub</a></code>'s own generic index order and index list, the <code>result_multi_index</code> is equivalent to the multi-index for the first operand. Thus, we need only compute the second operand's multi-index as a transformation of the first: reorder and shift the values of the first operand to compute the equivalent multi-index for the second operand.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result_multi_index</td><td>the multi-index of the component of the result tensor to retrieve </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the value of the component at <code>result_multi_index</code> in the result tensor </p>

</div>
</div>
<a id="ac63a521baa373a1259078105196a4f9d" name="ac63a521baa373a1259078105196a4f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63a521baa373a1259078105196a4f9d">&#9670;&nbsp;</a></span>get_op2_multi_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , template&lt; typename... &gt; class ArgsList1, template&lt; typename... &gt; class ArgsList2, typename... Args1, typename... Args2, int Sign&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a3347e9cb059d80268d7069dda9621596">num_tensor_indices_op2</a> &gt; <a class="el" href="structtenex_1_1AddSub.html">tenex::AddSub</a>&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::get_op2_multi_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a1dfe3cdb5c78642134874671e5b000bc">num_tensor_indices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op1_multi_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the second operand's multi-index given the first operand's multi-index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1_multi_index</td><td>the multi-index of the left operand </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the second operand's multi-index </p>

</div>
</div>
<a id="a76178279e85614d81e98f9726afa3a09" name="a76178279e85614d81e98f9726afa3a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76178279e85614d81e98f9726afa3a09">&#9670;&nbsp;</a></span>get_primary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , template&lt; typename... &gt; class ArgsList1, template&lt; typename... &gt; class ArgsList2, typename... Args1, typename... Args2, int Sign&gt; </div>
<div class="memtemplate">
template&lt;typename ResultType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="structtenex_1_1AddSub.html">tenex::AddSub</a>&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::get_primary </td>
          <td>(</td>
          <td class="paramtype">const ResultType &amp;&#160;</td>
          <td class="paramname"><em>result_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a1dfe3cdb5c78642134874671e5b000bc">num_tensor_indices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result_multi_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of the component at the given multi-index of the tensor resulting from addition or subtraction. </p>
<h3>Details</h3>
<p >This function differs from <code>get</code> in that it takes into account whether we have already computed part of the result component at a lower subtree. In recursively computing this sum/difference, the current result component will be substituted in for the most recent (highest) subtree below it that has already been evaluated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result_component</td><td>the LHS tensor component to evaluate </td></tr>
    <tr><td class="paramname">result_multi_index</td><td>the multi-index of the component of the result tensor to retrieve </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the value of the component at <code>result_multi_index</code> in the result tensor </p>

</div>
</div>
<a id="ad2306b3464d1d74633a6bd819889e235" name="ad2306b3464d1d74633a6bd819889e235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2306b3464d1d74633a6bd819889e235">&#9670;&nbsp;</a></span>get_rhs_tensor_component_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , template&lt; typename... &gt; class ArgsList1, template&lt; typename... &gt; class ArgsList2, typename... Args1, typename... Args2, int Sign&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structtenex_1_1AddSub.html">tenex::AddSub</a>&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::get_rhs_tensor_component_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of a component from a <code>Tensor</code> in this expression's subtree of the RHS <code>TensorExpression</code> </p>
<p ><em>Returns:</em> the size of a component from a <code>Tensor</code> in this expression's subtree of the RHS <code>TensorExpression</code> </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aad18f298352f710418d001f011bc2141" name="aad18f298352f710418d001f011bc2141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad18f298352f710418d001f011bc2141">&#9670;&nbsp;</a></span>evaluate_children_separately</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , template&lt; typename... &gt; class ArgsList1, template&lt; typename... &gt; class ArgsList2, typename... Args1, typename... Args2, int Sign&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structtenex_1_1AddSub.html">tenex::AddSub</a>&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::evaluate_children_separately</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      <a class="code hl_variable" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#aedaa6c82bd321f5925e801f43056fc05">is_primary_start</a> and (<a class="code hl_variable" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a21208e976121839b0f2c07b73b2dc722">num_ops_to_evaluate_primary_left_child</a> &gt;=</div>
<div class="line">                                detail::max_num_ops_in_sub_expression&lt;type&gt; or</div>
<div class="line">                            <a class="code hl_variable" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a49922d1efe2e0e067e3688bc5f592672">num_ops_to_evaluate_primary_right_child</a> &gt;=</div>
<div class="line">                                detail::max_num_ops_in_sub_expression&lt;type&gt;)</div>
<div class="ttc" id="astructtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4_html_a21208e976121839b0f2c07b73b2dc722"><div class="ttname"><a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a21208e976121839b0f2c07b73b2dc722">tenex::AddSub&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::num_ops_to_evaluate_primary_left_child</a></div><div class="ttdeci">static constexpr size_t num_ops_to_evaluate_primary_left_child</div><div class="ttdoc">If on the primary path, this is the remaining number of arithmetic tensor operations that need to be ...</div><div class="ttdef"><b>Definition:</b> AddSubtract.hpp:402</div></div>
<div class="ttc" id="astructtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4_html_a49922d1efe2e0e067e3688bc5f592672"><div class="ttname"><a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a49922d1efe2e0e067e3688bc5f592672">tenex::AddSub&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::num_ops_to_evaluate_primary_right_child</a></div><div class="ttdeci">static constexpr size_t num_ops_to_evaluate_primary_right_child</div><div class="ttdoc">If on the primary path, this is the remaining number of arithmetic tensor operations that need to be ...</div><div class="ttdef"><b>Definition:</b> AddSubtract.hpp:407</div></div>
<div class="ttc" id="astructtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4_html_aedaa6c82bd321f5925e801f43056fc05"><div class="ttname"><a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#aedaa6c82bd321f5925e801f43056fc05">tenex::AddSub&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::is_primary_start</a></div><div class="ttdeci">static constexpr bool is_primary_start</div><div class="ttdoc">If on the primary path, whether or not the expression is a starting point of a leg.</div><div class="ttdef"><b>Definition:</b> AddSubtract.hpp:418</div></div>
</div><!-- fragment -->
<p>When evaluating along a primary path, whether each operand's subtrees should be evaluated separately. Since <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code> expression runtime scales poorly with increased number of operations, evaluating the two expression subtrees separately like this is beneficial when at least one of the subtrees contains a large number of operations. </p>

</div>
</div>
<a id="a4fab2da63cdde5104425db92ff4a5b67" name="a4fab2da63cdde5104425db92ff4a5b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fab2da63cdde5104425db92ff4a5b67">&#9670;&nbsp;</a></span>height_relative_to_closest_tensor_leaf_in_subtree</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , template&lt; typename... &gt; class ArgsList1, template&lt; typename... &gt; class ArgsList2, typename... Args1, typename... Args2, int Sign&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="structtenex_1_1AddSub.html">tenex::AddSub</a>&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::height_relative_to_closest_tensor_leaf_in_subtree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      T2::height_relative_to_closest_tensor_leaf_in_subtree &lt;=</div>
<div class="line">              T1::height_relative_to_closest_tensor_leaf_in_subtree</div>
<div class="line">          ? (T2::height_relative_to_closest_tensor_leaf_in_subtree !=</div>
<div class="line">                     <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits/max.html">std::numeric_limits&lt;size_t&gt;::max</a>()</div>
<div class="line">                 ? T2::height_relative_to_closest_tensor_leaf_in_subtree + 1</div>
<div class="line">                 : T2::height_relative_to_closest_tensor_leaf_in_subtree)</div>
<div class="line">          : T1::height_relative_to_closest_tensor_leaf_in_subtree + 1</div>
<div class="ttc" id="amax_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/types/numeric_limits/max.html">std::numeric_limits::max</a></div><div class="ttdeci">T max(T... args)</div></div>
</div><!-- fragment -->
<p>The height of this expression's node in the expression tree relative to the closest <code><a class="el" href="structtenex_1_1TensorAsExpression.html" title="Defines an expression representing a Tensor.">TensorAsExpression</a></code> leaf in its subtree. </p>

</div>
</div>
<a id="aedaa6c82bd321f5925e801f43056fc05" name="aedaa6c82bd321f5925e801f43056fc05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedaa6c82bd321f5925e801f43056fc05">&#9670;&nbsp;</a></span>is_primary_start</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , template&lt; typename... &gt; class ArgsList1, template&lt; typename... &gt; class ArgsList2, typename... Args1, typename... Args2, int Sign&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structtenex_1_1AddSub.html">tenex::AddSub</a>&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::is_primary_start</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      <a class="code hl_variable" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a0022d3d8129f35a4b108f36119ac34bf">num_ops_to_evaluate_primary_subtree</a> &gt;=</div>
<div class="line">      detail::max_num_ops_in_sub_expression&lt;type&gt;</div>
<div class="ttc" id="astructtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4_html_a0022d3d8129f35a4b108f36119ac34bf"><div class="ttname"><a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a0022d3d8129f35a4b108f36119ac34bf">tenex::AddSub&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::num_ops_to_evaluate_primary_subtree</a></div><div class="ttdeci">static constexpr size_t num_ops_to_evaluate_primary_subtree</div><div class="ttdoc">If on the primary path, this is the remaining number of arithmetic tensor operations that need to be ...</div><div class="ttdef"><b>Definition:</b> AddSubtract.hpp:413</div></div>
</div><!-- fragment -->
<p>If on the primary path, whether or not the expression is a starting point of a leg. </p>

</div>
</div>
<a id="a107984e96b0a5a7b45d08e86071460e3" name="a107984e96b0a5a7b45d08e86071460e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a107984e96b0a5a7b45d08e86071460e3">&#9670;&nbsp;</a></span>num_ops_subtree</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , template&lt; typename... &gt; class ArgsList1, template&lt; typename... &gt; class ArgsList2, typename... Args1, typename... Args2, int Sign&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="structtenex_1_1AddSub.html">tenex::AddSub</a>&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::num_ops_subtree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      <a class="code hl_variable" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a22e3434e1f29ea6fd56df97cc5db1229">num_ops_left_child</a> + <a class="code hl_variable" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#aaf32f403573b543536d728f1787cf7e5">num_ops_right_child</a> + 1</div>
<div class="ttc" id="astructtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4_html_a22e3434e1f29ea6fd56df97cc5db1229"><div class="ttname"><a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a22e3434e1f29ea6fd56df97cc5db1229">tenex::AddSub&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::num_ops_left_child</a></div><div class="ttdeci">static constexpr size_t num_ops_left_child</div><div class="ttdoc">The number of arithmetic tensor operations done in the subtree for the left operand.</div><div class="ttdef"><b>Definition:</b> AddSubtract.hpp:366</div></div>
<div class="ttc" id="astructtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4_html_aaf32f403573b543536d728f1787cf7e5"><div class="ttname"><a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#aaf32f403573b543536d728f1787cf7e5">tenex::AddSub&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::num_ops_right_child</a></div><div class="ttdeci">static constexpr size_t num_ops_right_child</div><div class="ttdoc">The number of arithmetic tensor operations done in the subtree for the right operand.</div><div class="ttdef"><b>Definition:</b> AddSubtract.hpp:369</div></div>
</div><!-- fragment -->
<p>The total number of arithmetic tensor operations done in this expression's whole subtree. </p>

</div>
</div>
<a id="a21208e976121839b0f2c07b73b2dc722" name="a21208e976121839b0f2c07b73b2dc722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21208e976121839b0f2c07b73b2dc722">&#9670;&nbsp;</a></span>num_ops_to_evaluate_primary_left_child</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , template&lt; typename... &gt; class ArgsList1, template&lt; typename... &gt; class ArgsList2, typename... Args1, typename... Args2, int Sign&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="structtenex_1_1AddSub.html">tenex::AddSub</a>&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::num_ops_to_evaluate_primary_left_child</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      <a class="code hl_variable" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#ac5e5072efff9a24b3e617782ba2635f7">is_primary_end</a> ? 0 : T1::num_ops_to_evaluate_primary_subtree</div>
<div class="ttc" id="astructtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4_html_ac5e5072efff9a24b3e617782ba2635f7"><div class="ttname"><a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#ac5e5072efff9a24b3e617782ba2635f7">tenex::AddSub&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::is_primary_end</a></div><div class="ttdeci">static constexpr bool is_primary_end</div><div class="ttdoc">If on the primary path, whether or not the expression is an ending point of a leg.</div><div class="ttdef"><b>Definition:</b> AddSubtract.hpp:397</div></div>
</div><!-- fragment -->
<p>If on the primary path, this is the remaining number of arithmetic tensor operations that need to be done in the subtree of the child along the primary path, given that we will have already computed the whole subtree at the next lowest leg's starting point. </p>

</div>
</div>
<a id="a49922d1efe2e0e067e3688bc5f592672" name="a49922d1efe2e0e067e3688bc5f592672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49922d1efe2e0e067e3688bc5f592672">&#9670;&nbsp;</a></span>num_ops_to_evaluate_primary_right_child</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , template&lt; typename... &gt; class ArgsList1, template&lt; typename... &gt; class ArgsList2, typename... Args1, typename... Args2, int Sign&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="structtenex_1_1AddSub.html">tenex::AddSub</a>&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::num_ops_to_evaluate_primary_right_child</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      <a class="code hl_variable" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#aaf32f403573b543536d728f1787cf7e5">num_ops_right_child</a></div>
</div><!-- fragment -->
<p>If on the primary path, this is the remaining number of arithmetic tensor operations that need to be done in the right operand's subtree. No splitting is currently done, so this is just <code>num_ops_right_child</code>. </p>

</div>
</div>
<a id="a0022d3d8129f35a4b108f36119ac34bf" name="a0022d3d8129f35a4b108f36119ac34bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0022d3d8129f35a4b108f36119ac34bf">&#9670;&nbsp;</a></span>num_ops_to_evaluate_primary_subtree</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , template&lt; typename... &gt; class ArgsList1, template&lt; typename... &gt; class ArgsList2, typename... Args1, typename... Args2, int Sign&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="structtenex_1_1AddSub.html">tenex::AddSub</a>&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::num_ops_to_evaluate_primary_subtree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      <a class="code hl_variable" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a21208e976121839b0f2c07b73b2dc722">num_ops_to_evaluate_primary_left_child</a> +</div>
<div class="line">      <a class="code hl_variable" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a49922d1efe2e0e067e3688bc5f592672">num_ops_to_evaluate_primary_right_child</a> + 1</div>
</div><!-- fragment -->
<p>If on the primary path, this is the remaining number of arithmetic tensor operations that need to be done for this expression's subtree, given that we will have already computed the subtree at the next lowest leg's starting point. </p>

</div>
</div>
<a id="abe0c5bb7cdc859c408b83267d1b00795" name="abe0c5bb7cdc859c408b83267d1b00795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe0c5bb7cdc859c408b83267d1b00795">&#9670;&nbsp;</a></span>op1_spatial_spacetime_index_positions</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , template&lt; typename... &gt; class ArgsList1, template&lt; typename... &gt; class ArgsList2, typename... Args1, typename... Args2, int Sign&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structtenex_1_1AddSub.html">tenex::AddSub</a>&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::op1_spatial_spacetime_index_positions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      detail::get_spatial_spacetime_index_positions&lt;<span class="keyword">typename</span> T1::index_list,</div>
<div class="line">                                                    ArgsList1&lt;Args1...&gt;&gt;()</div>
</div><!-- fragment -->
<p>Positions of indices in first operand where generic spatial indices are used for spacetime indices. </p>

</div>
</div>
<a id="a0b270d2b9ca400f533c85f73fe9cc9a6" name="a0b270d2b9ca400f533c85f73fe9cc9a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b270d2b9ca400f533c85f73fe9cc9a6">&#9670;&nbsp;</a></span>op2_spatial_spacetime_index_positions</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , template&lt; typename... &gt; class ArgsList1, template&lt; typename... &gt; class ArgsList2, typename... Args1, typename... Args2, int Sign&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structtenex_1_1AddSub.html">tenex::AddSub</a>&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::op2_spatial_spacetime_index_positions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      detail::get_spatial_spacetime_index_positions&lt;<span class="keyword">typename</span> T2::index_list,</div>
<div class="line">                                                    ArgsList2&lt;Args2...&gt;&gt;()</div>
</div><!-- fragment -->
<p>Positions of indices in second operand where generic spatial indices are used for spacetime indices. </p>

</div>
</div>
<a id="adbe7c833629ba5d8afb7860daef8b387" name="adbe7c833629ba5d8afb7860daef8b387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe7c833629ba5d8afb7860daef8b387">&#9670;&nbsp;</a></span>operand_index_transformation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , template&lt; typename... &gt; class ArgsList1, template&lt; typename... &gt; class ArgsList2, typename... Args1, typename... Args2, int Sign&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;size_t, <a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a3347e9cb059d80268d7069dda9621596">num_tensor_indices_op2</a>&gt; <a class="el" href="structtenex_1_1AddSub.html">tenex::AddSub</a>&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::operand_index_transformation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">          <a class="code hl_function" href="namespacetenex.html#aeb5a8c04357e897b192841b9782f3cd8">compute_tensorindex_transformation</a>&lt;<a class="code hl_variable" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a1dfe3cdb5c78642134874671e5b000bc">num_tensor_indices</a>,</div>
<div class="line">                                             <a class="code hl_variable" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a3347e9cb059d80268d7069dda9621596">num_tensor_indices_op2</a>&gt;(</div>
<div class="line">              {{<a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">Args1::value</a>...}}, {{<a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">Args2::value</a>...}})</div>
<div class="ttc" id="agroup__UtilitiesGroup_html_ga4316f2ea7fb92cf4a3c5cf53bf36fb82"><div class="ttname"><a href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">value</a></div><div class="ttdeci">constexpr T &amp; value(T &amp;t)</div><div class="ttdoc">Returns t.value() if t is a std::optional otherwise returns t.</div><div class="ttdef"><b>Definition:</b> OptionalHelpers.hpp:32</div></div>
<div class="ttc" id="anamespacetenex_html_aeb5a8c04357e897b192841b9782f3cd8"><div class="ttname"><a href="namespacetenex.html#aeb5a8c04357e897b192841b9782f3cd8">tenex::compute_tensorindex_transformation</a></div><div class="ttdeci">constexpr std::array&lt; size_t, NumIndices2 &gt; compute_tensorindex_transformation(const std::array&lt; size_t, NumIndices1 &gt; &amp;tensorindices1, const std::array&lt; size_t, NumIndices2 &gt; &amp;tensorindices2)</div><div class="ttdoc">Computes a transformation from one generic tensor index order to another.</div><div class="ttdef"><b>Definition:</b> TensorIndexTransformation.hpp:79</div></div>
<div class="ttc" id="astructtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4_html_a1dfe3cdb5c78642134874671e5b000bc"><div class="ttname"><a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a1dfe3cdb5c78642134874671e5b000bc">tenex::AddSub&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::num_tensor_indices</a></div><div class="ttdeci">static constexpr auto num_tensor_indices</div><div class="ttdoc">The number of tensor indices in the result of the expression. This also doubles as the left operand's...</div><div class="ttdef"><b>Definition:</b> AddSubtract.hpp:336</div></div>
<div class="ttc" id="astructtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4_html_a3347e9cb059d80268d7069dda9621596"><div class="ttname"><a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a3347e9cb059d80268d7069dda9621596">tenex::AddSub&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::num_tensor_indices_op2</a></div><div class="ttdeci">static constexpr auto num_tensor_indices_op2</div><div class="ttdoc">The number of tensor indices in the right operand expression.</div><div class="ttdef"><b>Definition:</b> AddSubtract.hpp:338</div></div>
</div><!-- fragment -->
<p>Mapping from the left operand's index order to the right operand's index order. </p>

</div>
</div>
<a id="af80294cd08a338087105716a252b15c9" name="af80294cd08a338087105716a252b15c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80294cd08a338087105716a252b15c9">&#9670;&nbsp;</a></span>ops_have_generic_indices_at_same_positions</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , template&lt; typename... &gt; class ArgsList1, template&lt; typename... &gt; class ArgsList2, typename... Args1, typename... Args2, int Sign&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structtenex_1_1AddSub.html">tenex::AddSub</a>&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::ops_have_generic_indices_at_same_positions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      <a class="code hl_typedef" href="group__TensorExpressionsGroup.html#ga5c96f0cff493a34d1d2b674c105ae647">generic_indices_at_same_positions</a>&lt;tmpl::list&lt;Args1...&gt;,</div>
<div class="line">                                        tmpl::list&lt;Args2...&gt;&gt;<a class="code hl_function" href="group__UtilitiesGroup.html#ga4316f2ea7fb92cf4a3c5cf53bf36fb82">::value</a></div>
<div class="ttc" id="agroup__TensorExpressionsGroup_html_ga5c96f0cff493a34d1d2b674c105ae647"><div class="ttname"><a href="group__TensorExpressionsGroup.html#ga5c96f0cff493a34d1d2b674c105ae647">tenex::generic_indices_at_same_positions</a></div><div class="ttdeci">typename detail::generic_indices_at_same_positions_impl&lt; TensorIndexList1, TensorIndexList2, tmpl::size&lt; TensorIndexList1 &gt;::value==tmpl::size&lt; TensorIndexList2 &gt;::value &gt;::type generic_indices_at_same_positions</div><div class="ttdoc">Determine whether or not two lists of TensorIndexs contain the same generic indices at the same posit...</div><div class="ttdef"><b>Definition:</b> TensorIndex.hpp:323</div></div>
</div><!-- fragment -->
<p>Whether or not the two operands have the same <code><a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a></code>s in the same order (including concrete time indices) </p>

</div>
</div>
<a id="a8b2698b63b0777fc01df3e91100de330" name="a8b2698b63b0777fc01df3e91100de330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b2698b63b0777fc01df3e91100de330">&#9670;&nbsp;</a></span>primary_child_subtree_contains_primary_start</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , template&lt; typename... &gt; class ArgsList1, template&lt; typename... &gt; class ArgsList2, typename... Args1, typename... Args2, int Sign&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structtenex_1_1AddSub.html">tenex::AddSub</a>&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::primary_child_subtree_contains_primary_start</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      T1::primary_subtree_contains_primary_start</div>
</div><!-- fragment -->
<p>If on the primary path, whether or not the expression's child along the primary path is a subtree that contains a starting point of a leg along the primary path. </p>

</div>
</div>
<a id="a30619c0c1d379945b643b30d3191f48e" name="a30619c0c1d379945b643b30d3191f48e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30619c0c1d379945b643b30d3191f48e">&#9670;&nbsp;</a></span>primary_subtree_contains_primary_start</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , template&lt; typename... &gt; class ArgsList1, template&lt; typename... &gt; class ArgsList2, typename... Args1, typename... Args2, int Sign&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structtenex_1_1AddSub.html">tenex::AddSub</a>&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::primary_subtree_contains_primary_start</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      <a class="code hl_variable" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#aedaa6c82bd321f5925e801f43056fc05">is_primary_start</a> or <a class="code hl_variable" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a8b2698b63b0777fc01df3e91100de330">primary_child_subtree_contains_primary_start</a></div>
<div class="ttc" id="astructtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4_html_a8b2698b63b0777fc01df3e91100de330"><div class="ttname"><a href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html#a8b2698b63b0777fc01df3e91100de330">tenex::AddSub&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::primary_child_subtree_contains_primary_start</a></div><div class="ttdeci">static constexpr bool primary_child_subtree_contains_primary_start</div><div class="ttdoc">If on the primary path, whether or not the expression's child along the primary path is a subtree tha...</div><div class="ttdef"><b>Definition:</b> AddSubtract.hpp:434</div></div>
</div><!-- fragment -->
<p>If on the primary path, whether or not this subtree contains a starting point of a leg along the primary path. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>src/DataStructures/Tensor/Expressions/AddSubtract.hpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetenex.html">tenex</a></li><li class="navelem"><a class="el" href="structtenex_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_00_01Sign_01_4.html">AddSub&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
