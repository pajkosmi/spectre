<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: A Hitchhiker&#39;s Guide to Running SpECTRE</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('beginners_guide.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">A Hitchhiker's Guide to Running SpECTRE </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md28">Prerequisites</a></li>
<li class="level1"><a href="#autotoc_md29">Into the Container</a><ul><li class="level2"><a href="#with_terminal">With a Terminal</a></li>
<li class="level2"><a href="#autotoc_md30">With VSCode</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md31">Running ExportTimeDependentCoordinates3D</a></li>
<li class="level1"><a href="#autotoc_md32">Visualizing our BBH Coordinates</a><ul><li class="level2"><a href="#autotoc_md33">Attaching Paraview</a></li>
<li class="level2"><a href="#open_xmf">Open the XMF File in Paraview Client</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md34">Evolution of BBH Coordinates</a></li>
<li class="level1"><a href="#autotoc_md35">Exploring DG+FD</a><ul><li class="level2"><a href="#autotoc_md36">Description of DG+FD</a></li>
<li class="level2"><a href="#autotoc_md37">Running the Kuzmin Problem</a></li>
<li class="level2"><a href="#autotoc_md38">Changing the Default Input File</a></li>
<li class="level2"><a href="#autotoc_md39">Visualizing the Kuzmin Problem</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md40">Editing the Kuzmin System</a><ul><li class="level2"><a href="#autotoc_md41">Re-building SpECTRE</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md42">Conclusions</a></li>
</ul>
</div>
<div class="textblock"><p ><a class="anchor" id="md_docs_Tutorials_BeginnersTutorial"></a></p>
<p >SpECTRE can be a bit complicated to get started with, especially if you aren't familiar with our core concepts of task-based parallelism and Template Meta-Programming (TMP). However, <a href="https://en.wikipedia.org/wiki/Phrases_from_The_Hitchhiker%27s_Guide_to_the_Galaxy#Don&#39;t_Panic">Don't Panic</a>. This guide aims to get you introduced to running, visualizing, editing, and then rebuilding SpECTRE to give you a feel for what SpECTRE is all about, all on your own laptop! Hopefully by the end of this guide you'll feel comfortable enough to look at other executables and maybe even venture into the code itself!</p>
<h1><a class="anchor" id="autotoc_md28"></a>
Prerequisites</h1>
<p >To start off, you'll need to obtain an environment to build and run SpECTRE in. You could try and install all the dependencies yourself, but that is very tedious and very error prone. Instead, we provide a <a href="https://docs.docker.com/get-docker/">Docker</a> container with all the dependencies pre-installed for you to use. The container also has the SpECTRE repository cloned in it already so you don't have to worry about getting it yourself. To obtain the docker image, run</p>
<div class="fragment"><div class="line">docker pull sxscollaboration/spectre:demo</div>
</div><!-- fragment --><p >Another program you will need for this tutorial is <a href="https://www.paraview.org/download/">Paraview</a> for visualizing the output. You specifically will need version 5.10.1 for this tutorial.</p>
<p >If you'd like to use VSCode, the tutorial also has instructions for how to start in VSCode as well.</p>
<h1><a class="anchor" id="autotoc_md29"></a>
Into the Container</h1>
<p >For both a terminal and VSCode, create the container in a terminal and start it.</p>
<div class="fragment"><div class="line">docker create --rm --name spectre_demo -p 11111:11111 \</div>
<div class="line">    -i -t sxscollaboration/spectre:demo /bin/bash</div>
</div><!-- fragment --> <div class="fragment"><div class="line">docker start spectre_demo</div>
</div><!-- fragment --><p >We connect port <code>11111</code> on your local machine to port <code>11111</code> of the container so we can use Paraview. The <code>--rm</code> will delete the container when you stop it. This won't put you into the container, only start it in the background.</p>
<p >You can also run a <a href="https://jupyter.org/index.html">Jupyter</a> server for accessing the Python bindings (see <a class="el" href="spectre_using_python.html">Using SpECTRE's Python modules</a>) or running Jupyter notebooks. To do so, append another <code>-p</code> option with your specified port, e.g. <code>-p 8000:8000</code>. You can chain as many <code>-p</code> options as you want to expose more ports.</p>
<p >The SpECTRE repository is located at <code>/work/spectre</code> inside the container.</p>
<h2><a class="anchor" id="with_terminal"></a>
With a Terminal</h2>
<p >To hop in the container from a terminal, simply type</p>
<div class="fragment"><div class="line">docker attach spectre_demo</div>
</div><!-- fragment --><p >and now you're in the container!</p>
<h2><a class="anchor" id="autotoc_md30"></a>
With VSCode</h2>
<p >If you're using VSCode, you'll need the <code>Remote-Containers</code> extension to be able to access the container. Once you have it, open the <a href="https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette">command palette</a> and run the following commands.</p>
<ol type="1">
<li><code>Remote-Containers: Attach to Running Container</code> - you should see the container <code>spectre_demo</code> that's currently running. Select that.</li>
<li><code>File: Open Folder</code> - select <code>/work/spectre</code> which is where the repo is.</li>
</ol>
<p >Now you're in the container within VSCode! The terminal in VSCode will look identical to the one if you hadn't used VSCode.</p>
<dl class="section note"><dt>Note</dt><dd>Any changes you make inside <code>/work/spectre</code> will be lost once you stop the container. If you'd like your changes to persist, get rid of the <code>--rm</code> flag in the <code>docker create</code> command.</dd></dl>
<h1><a class="anchor" id="autotoc_md31"></a>
Running ExportTimeDependentCoordinates3D</h1>
<p >One of the pre-built executables inside the container is the <code>ExportTimeDependentCoordinates3D</code> executable. All executables are located in the <code>/work/spectre/build/bin</code> directory.</p>
<dl class="section note"><dt>Note</dt><dd>From here on out, all paths are assumed to be inside the container unless specified otherwise.</dd></dl>
<p>Make a directory where you will run everything.</p>
<div class="fragment"><div class="line">mkdir /work/runs</div>
</div><!-- fragment --><p >Copy over the input file <code>/work/spectre/tests/InputFiles/ExportCoordinates/InputTimeDependent3D.yaml</code> into your <code>/work/runs</code> directory. We will be visualizing the coordinates of a binary black hole domain. To run the executable, do</p>
<div class="fragment"><div class="line">ExportTimeDependentCoordinates3D --input-file InputTimeDependent3D.yaml</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The container already has the <code>/work/spectre/build/bin</code> directory added to the PATH environment variable, so no need to copy/link executables.</dd></dl>
<p>This will run it on one core. If you'd like to use more cores, add the <code>++ppn N</code> option where <code>N</code> is the number of cores. After this finishes you should see two <code>H5</code> files in your run directory:</p>
<ol type="1">
<li>ExportTimeDependentCoordinates3DVolume0</li>
<li>ExportTimeDependentCoordinates3DReductions</li>
</ol>
<p >The <code>Volume</code> file is where we store data from every element in our domain, like the coordinates or the metric. The <code>Reductions</code> file is for more global quantities like the minimum grid spacing over all the elements in our domain.</p>
<dl class="section note"><dt>Note</dt><dd>Next time you run the executable, you will have to either move or delete the existing <code>H5</code> files as SpECTRE will error if it detects that an output file already exists. This is to prevent you from accidentally overwriting data.</dd></dl>
<h1><a class="anchor" id="autotoc_md32"></a>
Visualizing our BBH Coordinates</h1>
<p >Now it's time to use Paraview to visualize the coordinates we use for our BBH evolutions! SpECTRE will actually export the physical frame coordinates for every executable we have because they are a really useful diagnostic to have. We are just using the ExportCoordinates executable here so that you don't have to run a BBH evolution on your laptop which probably wouldn't work because of memory requirements.</p>
<p >Before we get to Paraview, we have to tell paraview how to actually use the coordinates in the <code>Volume</code> <code>H5</code> file. To do this we have a tool called <code>generate-xdmf</code> in our Python command-line interface. Inside the <code>runs</code> directory where you have the <code>H5</code> files, run</p>
<div class="fragment"><div class="line">spectre generate-xdmf \</div>
<div class="line">  --subfile-name element_data --output BBH_Coords \</div>
<div class="line">  ExportTimeDependentCoordinates3DVolume*h5</div>
</div><!-- fragment --><p >We output volume data per node so we append the node number to each volume file we have. Since you're most likely running on a laptop, you'll only be running on one node so you should only get one output file for the volume. The <code>--subfile-name</code> argument is the group name inside the <code>H5</code> file where the data is stored (groups can be checked by <code>h5ls -r FILE_NAME</code>). <code>generate-xdmf</code> will generate a file called <code>BBH_Coords.xmf</code>. Make sure to keep this <code>.xmf</code> file next to the volume file it was generated from. It uses relative paths to find the volume file which means if you move it, you won't be able to visualize anything.</p>
<h2><a class="anchor" id="autotoc_md33"></a>
Attaching Paraview</h2>
<p >This is where we actually need Paraview. We have a headless (no GUI) vesion of paraview inside the container which we will refer to as the "server". To start the Paraview server, run</p>
<div class="fragment"><div class="line">pvserver &amp;</div>
</div><!-- fragment --><p >The <code>&amp;</code> is so that the server runs in the background. If you hit <code>Enter</code> a couple times you'll get back to being able to type commands. You should see some output similar to</p>
<div class="fragment"><div class="line">Waiting for client...</div>
<div class="line">Connection URL: cs://92bbb69f2af2:11111</div>
<div class="line">Accepting connection(s): 92bbb69f2af2:11111</div>
</div><!-- fragment --><p >This means it's waiting for you to connect some external Paraview session (the "client") to the server. Now, <em><b>outside</b></em> the container, start a session of Paraview 5.10.1. (Again, you must use this version otherwise it won't work properly.) Go to <code>File &gt; Connect</code>. Click <code>Add Server</code>. Name it whatever you want, but keep the Host as <code>localhost</code>, the Server Type as <code>Client/Server</code>, the Port as <code>11111</code> (remember the <code>-p 11111:11111</code> flag from the docker command?). Here's a snapshot of what it should look like before you configure.</p>
<div class="image">
<img src="paraview_server.png" alt=""/>
<div class="caption">
Paraview server settings</div></div>
<p >Hit <code>Configure</code>, then hit <code>Save</code> (we don't care about the launch configuration). Now you should see a list of your configured servers. Select the one you just created and hit <code>Connect</code>. It may take a minute or two to connect to the server, but once you do on the left you'll see something like</p>
<div class="image">
<img src="paraview_connect.png" alt=""/>
<div class="caption">
Successfully connected Paraview to a server</div></div>
<dl class="section note"><dt>Note</dt><dd>If you close your client, the server will stop and you won't be able to reconnect. You'll have to restart the server in the container.</dd></dl>
<h2><a class="anchor" id="open_xmf"></a>
Open the XMF File in Paraview Client</h2>
<p >Now that you have Paraview connected to the container, open the <code>BBH_Coords.xmf</code> file you just generated inside Paraview (the paths you'll see are the ones in the container, not your filesystem). You may be prompted to choose which XDMF reader to use. Choose the <code>XDMF Reader</code> option. The <code>Xdmf3</code> options won't work. Once you choose a reader, on the left, you'll see</p>
<div class="image">
<img src="beginners_paraview_left.png" alt=""/>
<div class="caption">
Paraview side-bar</div></div>
<p >You can uncheck all the boxes in the <code>Point Arrays</code> section as they aren't necessary for visualizing the coordinates. Then hit <code>Apply</code>. Now you should see a solid sphere. This isn't super helpful. In the top bar you should see a dropdown to change the style that the points are plotted in. Select <code>Surface With Edges</code> like so. (Note: Your top bar may look slightly different from this depending on what version of <code>Paraview</code> you have.)</p>
<div class="image">
<img src="beginners_paraview_top.png" alt=""/>
<div class="caption">
Paraview top-bar</div></div>
<p >Now you'll have a solid sphere with highlighted lines. To view the interior of the domain, you'll need to add a filter. To access the filters, navigate to <code>Filters</code> on the top menu bar, hover over <code>Alphabetical</code>, and search for your filter of choice. Probably the two most helpful filters for viewing the domain are the <code>Slice</code> and <code>Clip</code> filters. (Note that you'll have to choose the <code>Surface With Edges</code> option for each filter separately.)</p>
<p ><code>Slice</code> is fairly self explanatory in that it will show you a single plane through the domain. Experiment with different planes to see our whole domain structure!</p>
<p >The <code>Clip</code> filter will remove all points "above" a certain plane, where "above" is in the direction of the normal of that plane. If you combine two orthogonal <code>Clip</code>s, you can actually view a 3D wedge of our domain. Try moving the centers of the planes to view the domain around our excision surfaces! They have a lot of cool structure.</p>
<p >If you'd like to read more about our BBH domain, you can look at the documentation for <code><a class="el" href="classdomain_1_1creators_1_1BinaryCompactObject.html" title="A general domain for two compact objects.">domain::creators::BinaryCompactObject</a></code>.</p>
<h1><a class="anchor" id="autotoc_md34"></a>
Evolution of BBH Coordinates</h1>
<p >Now that you are able to export and visualize our BBH domain coordinates at a single time, let's make a small movie of the coordinates as they evolve! To do this, we'll need to edit the input file <code>InputTimeDependent3D.yaml</code>. If you aren't familiar with YAML, it's a file type that uses key-value pairs to create actual objects in our C++ code. Feel free to experiment with keys and values in our input files. If you're unsure about what a key or value should be, we offer an easy way to check the options in the input file without running a whole simulation. In your <code>/work/runs</code> directory, if you run</p>
<div class="fragment"><div class="line">ExportTimeDependentCoordinates3D \</div>
<div class="line">  --input-file InputTimeDependent3D.yaml --check-options</div>
</div><!-- fragment --><p >the <code>--check-options</code> will tell the executable to parse the input file and exit immediately after. If you made a typo, or added an incorrect key/value, a list of the available keys and their associated values will be printed.</p>
<p >To change the number of times we output the coordinates, we'll need to go to the <code>EventsAndTriggers:</code> block of the input file. This block is mainly where we specify which quantities we want to observe in a simulation or where we "Trigger" a specific "Event" to happen. (For more info on <code>EventsAndTriggers</code>, see the <a class="el" href="tutorial_events_and_triggers.html">Events and triggers</a> tutorial.) Currently in this input file we only have one Trigger/Event pair. The Trigger is <code>TimeCompares:</code> and the Event is <code>Completion</code>. To have the simulation run longer, change the <code>Value:</code> under <code>TimeCompares:</code> to something larger. If you look at the <code>Evolution:</code> block above the <code>EventsAndTriggers:</code> block, you'll see that the initial time step is <code>0.5</code>. The way this executable is set up, the coordinates will be exported every time step. So set the final time <code>Value:</code> under <code>TimeCompares:</code> to some larger multiple of <code>0.5</code> so that you'll have the coordinates at a bunch of different times (a final time of <code>20</code> is reasonable. Depending on how many cores you run on this should take a couple minutes).</p>
<p >Then, run the executable just like you did above (remember to move or delete the existing <code>H5</code> files), run <code>generate-xdmf</code>, and open it in Paraview and apply some filters of your choice. We recommend using a <code>Slice</code> filter with the normal pointing in the <code>-z</code> direction. This is because our BBH domain rotates about the <code>z</code> axis. Now, in the top bar of Paraview, you should see a "Play" button that looks like a sideways triangle (see the second image in the <a class="el" href="beginners_guide.html#open_xmf">Open the XMF File in Paraview Client</a> section). If you click this, Paraview will step through all the timesteps in the output files and you'll be able to see the domain rotate a bit!</p>
<p >Next, we encourage you to play with the other inputs that control how the domain evolves over time. These options are housed in the</p>
<div class="fragment"><div class="line">DomainCreator:</div>
<div class="line">  BinaryCompactObject:</div>
<div class="line">    ...</div>
<div class="line">    TimeDependentMaps:</div>
<div class="line">      ExpansionMap:</div>
<div class="line">        ...</div>
<div class="line">      RotationMap:</div>
<div class="line">        ...</div>
<div class="line">      SizeMapA:</div>
<div class="line">        ...</div>
<div class="line">      SizeMapB:</div>
<div class="line">        ...</div>
</div><!-- fragment --><p >block of the input file. Since this tutorial is more about running the code, we won't go into too much detail about each option. However, in general:</p>
<ol type="1">
<li><code>ExpansionMap</code> is a global map (all parts of the domain) that controls the separation between the excision surfaces</li>
<li><code>RotationMap</code> is a global map that controls how the excision spheres rotate about each other</li>
<li><code>SizeMap</code> is a local map only around the excision spheres (not in the wave zone) that control the compression of grid points.</li>
</ol>
<p >Play around with these values! You may get an error if you put something that's too unphysical, but this is a fairly consequence-free playground for you to explore so just try a different value.</p>
<p >Now you have a movie of how BBH coordinates evolve in a SpECTRE simulation!</p>
<h1><a class="anchor" id="autotoc_md35"></a>
Exploring DG+FD</h1>
<p >Now that you are able to run, and visualize SpECTRE, let's explore a feature that is fairly unique to SpECTRE and is really powerful for handling discontinuities and shocks in our simulations. We call this feature <code>DG+FD</code> (it's also sometimes referred to as just <code>subcell</code>).</p>
<h2><a class="anchor" id="autotoc_md36"></a>
Description of DG+FD</h2>
<p ><code>FD</code> is the usual finite difference you are used to. All of the BSSN codes use finite difference for solving Einstein's equations. FD is very good at capturing shocks and discontinuities and is a very robust method, making it well suited for hydro problems and other systems that have shocks and discontinuities.</p>
<p ><code>DG</code> stands for Discontinuous Galerkin. DG is a spectral method for representing a solution on a grid, meaning that instead of taking the difference between the function value at two points to get the derivative, it uses known basis functions to represent the solution. Then the derivative can be known analytically and you only need to supply the coefficients for the basis. DG works best for representing smooth solutions; ones with very few shocks and discontinuities (like GR in vacuum). This makes DG much faster than FD for smooth solutions.</p>
<p >In SpECTRE, we combine these two different methods into one system to take advantage of the strengths of each. When we have a solution that is smooth in some parts of the domain, but has shocks in other parts, using only one of these methods has disadvantages. If we only used DG, we wouldn't be able to resolve the shocks very well driving the errors up a lot. If we only used FD, we'd be able to represent the solution well, but it would be computationally inefficient. So we combine DG+FD so that we only do DG in the parts of the domain where the solution is smooth, and switch to FD in parts where there may be a shock or discontinuity. The algorithm for switching between DG and FD is explained in this image.</p>
<div class="image">
<img src="dg_fd_schematic.png" alt=""/>
<div class="caption">
Scheme for switching between DG and FD (credit: Nils Deppe)</div></div>
<p >If you'd like to learn more about how SpECTRE implements its DG+FD scheme, you can read <a href="https://arxiv.org/abs/2109.11645">the paper</a> on the ArXiv.</p>
<h2><a class="anchor" id="autotoc_md37"></a>
Running the Kuzmin Problem</h2>
<p >To demonstrate DG+FD, we will be evolving the <a class="el" href="classScalarAdvection_1_1Solutions_1_1Kuzmin.html">Kuzmin </a> problem using the <code>EvolveScalarAdvection2D</code> executable. This is a simple test problem that rotates a set of geometric shapes with uniform angular velocity, which can be used to evaluate how well a numerical code can handle discontinuities stably over time. Inside the container make a new directory <code>/work/runs2</code> where you will run it. Also copy the default input file in <code>/work/spectre/tests/InputFiles/ScalarAdvection/Kuzmin2D.yaml</code> to this new <code>/work/runs2</code> directory.</p>
<h2><a class="anchor" id="autotoc_md38"></a>
Changing the Default Input File</h2>
<p >The default input file has very low resolution so we'll need to crank that up a bit. The way to do this is to change the initial refinement levels and initial number of grid points which are located in</p>
<div class="fragment"><div class="line">DomainCreator:</div>
<div class="line">  Rectangle:</div>
<div class="line">    ...</div>
<div class="line">    InitialRefinement: [x, y]</div>
<div class="line">    InitialGridPoints: [x, y]</div>
</div><!-- fragment --><p ><code>InitialRefinement:</code> represents how many times we split a <code><a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a></code> in half in order to create <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code>s, which are the fundamental units of our domain. So an initial refinement of <code>[1, 1]</code> means we split a single <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> into 4 elements (split in half once in each direction). For an initial refinement of <code>[2, 2]</code> we first do 1 refinement like before, and then split each of the resulting 4 elements in half again in each direction, resulting in 16 total Elements. To determine the total number of Elements for a given refinement (same in all directions), just do \(2^{\mathrm{Dim * Refinement}}\). If you're confused by the terminology we use to describe the domain, we have a <a class="el" href="domain_concepts.html">Domain Concepts</a> guide that explains all terms related to our domain.</p>
<p ><code>InitialGridPoints</code> represents the number of grid points per dimension in each <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> after the final refinement has been applied. So if we had an initial refinement of <code>[2, 2]</code> like above and then initial grid points <code>[3, 3]</code> in each <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>, we'd have a total of 9x16=144 grid points.</p>
<p >As for actual numbers to use, you can experiment to see what gives good, well-resolved results. You'll definitely need more refinement than the default input file, but since refinement scales exponentially, this can become very expensive very quickly. On a laptop, you probably shouldn't go higher than refinement <code>[6, 6]</code>. As for grid points, this will depend on how much refinement you have. If you have a ton of small elements, you won't need too many grid points to resolve the solution; something like <code>[4, 4]</code> would work. If you don't have a lot of refinement, you may want more grid points if you still want to resolve your solution. For a DG scheme, increasing the number of grid points (p refinement) reduces the numerical error exponentially where the solution is smooth, so computational resources are used more effectively. However, to resolve shocks and discontinuities we have to refine the domain into more and smaller elements instead (h refinement). Striking the most effective balance between h and p refinement in different parts of the domain is the job of an adaptive mesh refinement (AMR) algorithm.</p>
<p >The default input file only runs for a few time steps so we'll want to make this run longer so we can actually see some evolution. From the documentation of the <a class="el" href="classScalarAdvection_1_1Solutions_1_1Kuzmin.html">Kuzmin </a> system, the solution will rotate with an angular velocity of <code>1.0</code> (in code units). Thus, to do a full orbit, it will take <code>6.28</code> code units of time. In the <code>EventsAndTriggers:</code> block of the input file, we see that the <code>Completion</code> event is triggered by the <code>Slabs</code> trigger. We could, in theory, calculate out how many slabs <code>6.28</code> code units is using the time step, but that's super tedious. Instead let's trigger completion using the <code>TimeCompares</code> trigger instead. We used this before when exporting the BBH coordinates, so just copy over the yaml block and change the <code>Value:</code>.</p>
<p >Your final <code>EventsAndTriggers:</code> block should look something like this:</p>
<div class="fragment"><div class="line">EventsAndTriggers:</div>
<div class="line">  ? TimeCompares:</div>
<div class="line">      Comparison: GreaterThanOrEqualTo</div>
<div class="line">      Value: 6.28</div>
<div class="line">  : - Completion</div>
<div class="line">  ...</div>
</div><!-- fragment --><p >Now you should be ready to run the executable and get some output. Here, you will almost definitely benefit by running this on many cores by adding the <code>++ppn N</code> flag to the command you use to run the executable. Since we use lots of smaller elements, we distribute these over the available resources via a <a class="el" href="structdomain_1_1BlockZCurveProcDistribution.html">space filling curve </a> to speed things up.</p>
<div class="fragment"><div class="line">EvolveScalarAdvection2D --input-file Kuzmin2D.yaml ++ppn 4</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md39"></a>
Visualizing the Kuzmin Problem</h2>
<p >Once your run finishes, extract the volume data with <code>generate-xdmf</code> using</p>
<div class="fragment"><div class="line">spectre generate-xdmf \</div>
<div class="line">  --file-prefix ScalarAdvectionKuzmin2DVolume \</div>
<div class="line">  --subfile-name VolumeData --output kuzmin_problem</div>
</div><!-- fragment --><p >(Note that the <code>subfile-name</code> is different than before because it was different in the input file) and load it into Paraview once again. We are only interested in the quantity <code>U</code> which is the scalar field we were evolving. You can uncheck any other boxes. So now, instead of coordinates on your screen, you should see a large square colored by the solution profile described in the <a class="el" href="classScalarAdvection_1_1Solutions_1_1Kuzmin.html">Kuzmin </a> system. You should also notice that there are smaller squares that don't touch each other in the middle of the domain and on the edges there are large sections that are continuous. These are the FD and DG grids, respectively. If you go to the top bar in Paraview and change how you view the grid to <code>Surface With Edges</code>, this will become even more apparent.</p>
<p >You will notice that the FD grid is mostly around where the interesting features are in the solution profile; the cylinder with a wedge cut out, the cone, and the hump. And then the DG grid is mostly where the solution should be zero towards the boundary of the domain (i.e. the very smooth part). So right from the start, you can see that we are saving computational effort by only doing the expensive, yet robust, method (FD) where it is necessary and the efficient method (DG) everywhere else where the solution is smooth.</p>
<p >Now hit the "Play" button in the top bar of Paraview and watch the solution evolve. You'll notice that the elements in the domain switch back and forth between FD and DG. They do so in such a way that the elements will switch to FD when an interesting feature enters the element and then switch back to DG once the feature leaves. In this way, we are able to actually track shocks and discontinuities in real time in our solution by where the code switches to using FD instead of DG. This is extremely useful for expensive GRMHD simulations where we only want to do FD at a shock boundary, yet that shock boundary is moving through the domain. We are able to dynamically track this shock and resolve it well with FD, then switch back to DG after the shock passes through and the solution has settled down again.</p>
<p >A pretty cool filter you can add is <code>Warp By Scalar</code>. In the left panel, choose the solution variable <code>U</code> as the scalar to use and hit <code>Apply</code>. In the viewing panel there should be a <code>2D</code> or <code>3D</code> button that you can toggle to make the view 3D. Once you do that you should be able to see that the height of the feature is your solution <code>U</code>. If you change the grid to <code>Surface With Edges</code> you can see the FD or DG grids warp with the solution. And if you hit "Play" it'll rotate around and you'll see the features moving in 3D! (Don't worry if you can't find this filter. Not all versions of Paraview may have it.)</p>
<p >We encourage you to play around with the refinement and grid points before the next section to get a feel for how each changes the runtime and accuracy of solution.</p>
<h1><a class="anchor" id="autotoc_md40"></a>
Editing the Kuzmin System</h1>
<p >Hopefully now you feel comfortable enough running SpECTRE that you can get the default input file for the pre-built executables, edit it, and run it. Now we are going to try our hand at actually editing some code in SpECTRE and then building SpECTRE. We're going to stick with the <a class="el" href="classScalarAdvection_1_1Solutions_1_1Kuzmin.html">Kuzmin </a> system and add a new feature to the solution profile!</p>
<p >You can find the files for the Kuzmin system at <code>/work/spectre/src/PointwiseFunctions/AnalyticSolutions/ScalarAdvection/ Kuzmin.?pp</code>. In the <code>hpp</code> file, you'll see a lot of Doxygen documentation and then the actual Kuzmin class. The only function that you will need to care about is</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</div>
<div class="line"><a class="code hl_class" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple&lt;ScalarAdvection::Tags::U&gt;</a> variables(</div>
<div class="line">    <span class="keyword">const</span> tnsr::I&lt;DataType, 2&gt;&amp; x, <span class="keywordtype">double</span> t,</div>
<div class="line">    tmpl::list&lt;ScalarAdvection::Tags::U&gt; <span class="comment">/*meta*/</span>) <span class="keyword">const</span>;</div>
<div class="ttc" id="aclasstuples_1_1TaggedTuple_html"><div class="ttname"><a href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a></div><div class="ttdoc">An associative container that is indexed by structs.</div><div class="ttdef"><b>Definition:</b> TaggedTuple.hpp:261</div></div>
</div><!-- fragment --><p >All of our analytic solutions have a function similar to this that will set the value corresponding to the tag in the return type. If you're unfamiliar with tags in SpECTRE, you can look at these sections for an explanation, <a class="el" href="databox_foundations.html#databox_a_taggedtuple_databox">A TaggedTuple DataBox</a> and <a class="el" href="databox_foundations.html#databox_a_proper_databox">SpECTRE's DataBox</a>. However, it's basically just a fancy way of doing a compile-time key/value pair. The tag is the key, and the value is whatever you want it to be. In our case, the value is a tensor, representing the solution.</p>
<p >The definition of this function in the <code>cpp</code> file is where you will be editing the actual Kuzmin solution. Towards the bottom of this function, there is a <code>for</code> loop that sets the solution at every grid point. This is where you will add in a new feature to the solution.</p>
<p >You can pick any feature you want to add, so long as it's inside the domain bounds of <code>[0,1]x[0,1]</code> and centered around <code>(0.75, 0.5)</code>. This is because of how the kuzmin solution is set up with existing features at <code>(0.25, 0.5); (0.5, 0.25); (0.5, 0.75)</code>. If you're having trouble thinking of a feature to add try one of the following features:</p>
<ul>
<li>Square centered at <code>(0.75, 0.5)</code> with solution value <code>1.0</code><ul>
<li>Side length <code>0.1</code> (any larger and it might interfere with the other features)</li>
<li>Circle of radius <code>0.045</code> centered on the square with value <code>0.0</code></li>
</ul>
</li>
<li>Triangle centered at <code>(0.75, 0.5)</code> with one corner facing in the <code>+x</code> direction with solution value <code>1.0</code></li>
<li>Square centered at <code>(0.75, 0.5)</code><ul>
<li>Side length <code>0.1</code> (any larger and it might interfere with the other features)</li>
<li>Left half of the square has value <code>1.0</code> and right half of the square has value <code>0.5</code></li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The more detailed you make your feature, the more resolution you will need to resolve it.</dd></dl>
<h2><a class="anchor" id="autotoc_md41"></a>
Re-building SpECTRE</h2>
<p >Once you have your feature coded up, go ahead and save your changes. Now we will build SpECTRE! Go to the <code>/work/spectre/build</code> directory. This is where you have to be in order to build SpECTRE. We use <a href="https://cmake.org/">CMake</a> to configure our build directory. However, since the executables are already pre-built, this means the build directory is already configured! So you don't have to worry about <code>CMake</code> for now. If you wanted to reconfigure, for example using a different compiler, then you'd have to run <code>CMake</code>. If you want to learn more about how we use <code>CMake</code>, take a look at the <a class="el" href="spectre_build_system.html#common_cmake_flags">Commonly Used CMake flags</a> developers guide.</p>
<p >To build the Kuzmin executable, run</p>
<div class="fragment"><div class="line">make EvolveScalarAdvection2D</div>
</div><!-- fragment --><p >This should be very fast because you only edited a <code>cpp</code> file. Congrats! You've just built SpECTRE!</p>
<p >Now re-run the executable in your <code>/work/runs2</code> directory. Hopefully everything works and you get some output. When you plot it in Paraview, it should look almost the same as before except your feature will be there too rotating with the others! How cool! You can also see if your feature needs FD or DG more by how much it switches back and forth.</p>
<p >Experiment some more with either different features or different resolution!</p>
<h1><a class="anchor" id="autotoc_md42"></a>
Conclusions</h1>
<p >Congrats! You've made it through the tutorial! If you only want to run our pre-built executables, you have all the tools necessary to run, visualize, and re-build them. If you want a full list of our executables, do <code>make list</code> in the build directory. This will also include our <code>Test_</code> executables which you can just ignore.</p>
<p >In an already configured build directory, all you have to do to build a new executable is</p>
<div class="fragment"><div class="line">make ExecutableName</div>
</div><!-- fragment --><p >and then you can copy the default input file from <code>/work/spectre/tests/InputFiles</code> and run it. Running an executable with the <code>--help</code> flag will give a description of what system is being evolved and the input options necessary. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">User Tutorials</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
