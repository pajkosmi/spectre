<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: LinearSolver::Serial::ExplicitInverse&lt; LinearSolverRegistrars &gt; Class Template Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classLinearSolver_1_1Serial_1_1ExplicitInverse.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classLinearSolver_1_1Serial_1_1ExplicitInverse-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">LinearSolver::Serial::ExplicitInverse&lt; LinearSolverRegistrars &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Linear solver that builds a matrix representation of the linear operator and inverts it directly.  
 <a href="classLinearSolver_1_1Serial_1_1ExplicitInverse.html#details">More...</a></p>

<p><code>#include &lt;ExplicitInverse.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4c72d6e30710266dda7552d3e59dcea9"><td class="memItemLeft" align="right" valign="top"><a id="a4c72d6e30710266dda7552d3e59dcea9" name="a4c72d6e30710266dda7552d3e59dcea9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>options</b> = tmpl::list&lt;&gt;</td></tr>
<tr class="separator:a4c72d6e30710266dda7552d3e59dcea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classLinearSolver_1_1Serial_1_1LinearSolver"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classLinearSolver_1_1Serial_1_1LinearSolver')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classLinearSolver_1_1Serial_1_1LinearSolver.html">LinearSolver::Serial::LinearSolver&lt; tmpl::list&lt; Registrars::ExplicitInverse &gt; &gt;</a></td></tr>
<tr class="memitem:a2e7539149853da200e304d0f98483871 inherit pub_types_classLinearSolver_1_1Serial_1_1LinearSolver"><td class="memItemLeft" align="right" valign="top"><a id="a2e7539149853da200e304d0f98483871" name="a2e7539149853da200e304d0f98483871"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>registrars</b> = tmpl::list&lt; <a class="el" href="namespaceLinearSolver_1_1Serial_1_1Registrars.html#ac037e64f431bb0b16b3535fdd0033a88">Registrars::ExplicitInverse</a> &gt;</td></tr>
<tr class="separator:a2e7539149853da200e304d0f98483871 inherit pub_types_classLinearSolver_1_1Serial_1_1LinearSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6b0c848b6cbdec48dddeb9cc367e82 inherit pub_types_classLinearSolver_1_1Serial_1_1LinearSolver"><td class="memItemLeft" align="right" valign="top"><a id="a4d6b0c848b6cbdec48dddeb9cc367e82" name="a4d6b0c848b6cbdec48dddeb9cc367e82"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>creatable_classes</b> = <a class="el" href="namespaceRegistration.html#abfd9ae1266be994041d2cfaa4199eed2">Registration::registrants</a>&lt; tmpl::list&lt; <a class="el" href="namespaceLinearSolver_1_1Serial_1_1Registrars.html#ac037e64f431bb0b16b3535fdd0033a88">Registrars::ExplicitInverse</a> &gt; &gt;</td></tr>
<tr class="separator:a4d6b0c848b6cbdec48dddeb9cc367e82 inherit pub_types_classLinearSolver_1_1Serial_1_1LinearSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae8f800f18854752d18ded43b3bd8d73a"><td class="memItemLeft" align="right" valign="top"><a id="ae8f800f18854752d18ded43b3bd8d73a" name="ae8f800f18854752d18ded43b3bd8d73a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ExplicitInverse</b> (const <a class="el" href="classLinearSolver_1_1Serial_1_1ExplicitInverse.html">ExplicitInverse</a> &amp;)=default</td></tr>
<tr class="separator:ae8f800f18854752d18ded43b3bd8d73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642af76031e76999a6e1f9c1975b4c73"><td class="memItemLeft" align="right" valign="top"><a id="a642af76031e76999a6e1f9c1975b4c73" name="a642af76031e76999a6e1f9c1975b4c73"></a>
<a class="el" href="classLinearSolver_1_1Serial_1_1ExplicitInverse.html">ExplicitInverse</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classLinearSolver_1_1Serial_1_1ExplicitInverse.html">ExplicitInverse</a> &amp;)=default</td></tr>
<tr class="separator:a642af76031e76999a6e1f9c1975b4c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25940e0df145fb6ec1a7806b45f0df33"><td class="memItemLeft" align="right" valign="top"><a id="a25940e0df145fb6ec1a7806b45f0df33" name="a25940e0df145fb6ec1a7806b45f0df33"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ExplicitInverse</b> (<a class="el" href="classLinearSolver_1_1Serial_1_1ExplicitInverse.html">ExplicitInverse</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a25940e0df145fb6ec1a7806b45f0df33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d64b7d7211922c62a8c998a68f0dcb9"><td class="memItemLeft" align="right" valign="top"><a id="a3d64b7d7211922c62a8c998a68f0dcb9" name="a3d64b7d7211922c62a8c998a68f0dcb9"></a>
<a class="el" href="classLinearSolver_1_1Serial_1_1ExplicitInverse.html">ExplicitInverse</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classLinearSolver_1_1Serial_1_1ExplicitInverse.html">ExplicitInverse</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a3d64b7d7211922c62a8c998a68f0dcb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad178e63ea77cd3f25ddd702e18a00e69"><td class="memTemplParams" colspan="2">template&lt;typename LinearOperator , typename VarsType , typename SourceType , typename... OperatorArgs&gt; </td></tr>
<tr class="memitem:ad178e63ea77cd3f25ddd702e18a00e69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structConvergence_1_1HasConverged.html">Convergence::HasConverged</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearSolver_1_1Serial_1_1ExplicitInverse.html#ad178e63ea77cd3f25ddd702e18a00e69">solve</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; VarsType * &gt; solution, const LinearOperator &amp;linear_operator, const SourceType &amp;source, const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; OperatorArgs... &gt; &amp;operator_args=<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>{}) const</td></tr>
<tr class="memdesc:ad178e63ea77cd3f25ddd702e18a00e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the equation \(Ax=b\) by explicitly constructing the operator matrix \(A\) and its inverse. The first solve is computationally expensive and successive solves are cheap.  <a href="classLinearSolver_1_1Serial_1_1ExplicitInverse.html#ad178e63ea77cd3f25ddd702e18a00e69">More...</a><br /></td></tr>
<tr class="separator:ad178e63ea77cd3f25ddd702e18a00e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f3881739f1794b8cfda78860338d63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearSolver_1_1Serial_1_1ExplicitInverse.html#ad8f3881739f1794b8cfda78860338d63">reset</a> () override</td></tr>
<tr class="memdesc:ad8f3881739f1794b8cfda78860338d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags the operator to require re-initialization. No memory is released. Call this function to rebuild the solver when the operator changed.  <a href="classLinearSolver_1_1Serial_1_1ExplicitInverse.html#ad8f3881739f1794b8cfda78860338d63">More...</a><br /></td></tr>
<tr class="separator:ad8f3881739f1794b8cfda78860338d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8f63889d03e8c5d5f2245165b370fb"><td class="memItemLeft" align="right" valign="top"><a id="adc8f63889d03e8c5d5f2245165b370fb" name="adc8f63889d03e8c5d5f2245165b370fb"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="memdesc:adc8f63889d03e8c5d5f2245165b370fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the operator. The stored matrix will have <code>size^2</code> entries. <br /></td></tr>
<tr class="separator:adc8f63889d03e8c5d5f2245165b370fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4852edab9d598c8d5f9737a9714f213"><td class="memItemLeft" align="right" valign="top"><a id="af4852edab9d598c8d5f9737a9714f213" name="af4852edab9d598c8d5f9737a9714f213"></a>
const blaze::DynamicMatrix&lt; double, blaze::columnMajor &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>matrix_representation</b> () const</td></tr>
<tr class="memdesc:af4852edab9d598c8d5f9737a9714f213"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix representation of the solver. This matrix approximates the inverse of the subdomain operator. <br /></td></tr>
<tr class="separator:af4852edab9d598c8d5f9737a9714f213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5585707c6477dd757bad007f21a3bf"><td class="memItemLeft" align="right" valign="top"><a id="a4d5585707c6477dd757bad007f21a3bf" name="a4d5585707c6477dd757bad007f21a3bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pup</b> (PUP::er &amp;p) override</td></tr>
<tr class="separator:a4d5585707c6477dd757bad007f21a3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831ef5bf75685e58a154b9e14c5c7703"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classLinearSolver_1_1Serial_1_1LinearSolver.html">Base</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearSolver_1_1Serial_1_1ExplicitInverse.html#a831ef5bf75685e58a154b9e14c5c7703">get_clone</a> () const override</td></tr>
<tr class="separator:a831ef5bf75685e58a154b9e14c5c7703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b31398e68be6716f917e1aa4bb04d8b"><td class="memTemplParams" colspan="2"><a id="a3b31398e68be6716f917e1aa4bb04d8b" name="a3b31398e68be6716f917e1aa4bb04d8b"></a>
template&lt;typename LinearOperator , typename VarsType , typename SourceType , typename... OperatorArgs&gt; </td></tr>
<tr class="memitem:a3b31398e68be6716f917e1aa4bb04d8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structConvergence_1_1HasConverged.html">Convergence::HasConverged</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>solve</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; VarsType * &gt; solution, const LinearOperator &amp;linear_operator, const SourceType &amp;source, const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; OperatorArgs... &gt; &amp;operator_args) const</td></tr>
<tr class="separator:a3b31398e68be6716f917e1aa4bb04d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classLinearSolver_1_1Serial_1_1LinearSolver"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classLinearSolver_1_1Serial_1_1LinearSolver')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classLinearSolver_1_1Serial_1_1LinearSolver.html">LinearSolver::Serial::LinearSolver&lt; tmpl::list&lt; Registrars::ExplicitInverse &gt; &gt;</a></td></tr>
<tr class="memitem:ad946777cfb39777f9d22efce31c9dcab inherit pub_methods_classLinearSolver_1_1Serial_1_1LinearSolver"><td class="memItemLeft" align="right" valign="top"><a id="ad946777cfb39777f9d22efce31c9dcab" name="ad946777cfb39777f9d22efce31c9dcab"></a>
virtual <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classLinearSolver_1_1Serial_1_1LinearSolver.html">LinearSolver</a>&lt; tmpl::list&lt; <a class="el" href="namespaceLinearSolver_1_1Serial_1_1Registrars.html#ac037e64f431bb0b16b3535fdd0033a88">Registrars::ExplicitInverse</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_clone</b> () const=0</td></tr>
<tr class="separator:ad946777cfb39777f9d22efce31c9dcab inherit pub_methods_classLinearSolver_1_1Serial_1_1LinearSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d50374a53f3015939fc456a3d98d59a inherit pub_methods_classLinearSolver_1_1Serial_1_1LinearSolver"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structConvergence_1_1HasConverged.html">Convergence::HasConverged</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearSolver_1_1Serial_1_1LinearSolver.html#a1d50374a53f3015939fc456a3d98d59a">solve</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; VarsType * &gt; initial_guess_in_solution_out, const LinearOperator &amp;linear_operator, const SourceType &amp;source, const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; OperatorArgs... &gt; &amp;operator_args, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:a1d50374a53f3015939fc456a3d98d59a inherit pub_methods_classLinearSolver_1_1Serial_1_1LinearSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the linear equation \(Ax=b\) where \(A\) is the <code>linear_operator</code> and \(b\) is the <code>source</code>.  <a href="classLinearSolver_1_1Serial_1_1LinearSolver.html#a1d50374a53f3015939fc456a3d98d59a">More...</a><br /></td></tr>
<tr class="separator:a1d50374a53f3015939fc456a3d98d59a inherit pub_methods_classLinearSolver_1_1Serial_1_1LinearSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0143dcebb27d53e1e955343cfb2bb0f inherit pub_methods_classLinearSolver_1_1Serial_1_1LinearSolver"><td class="memItemLeft" align="right" valign="top"><a id="ab0143dcebb27d53e1e955343cfb2bb0f" name="ab0143dcebb27d53e1e955343cfb2bb0f"></a>
<a class="el" href="structConvergence_1_1HasConverged.html">Convergence::HasConverged</a>&#160;</td><td class="memItemRight" valign="bottom"><b>solve</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; VarsType * &gt; initial_guess_in_solution_out, const LinearOperator &amp;linear_operator, const SourceType &amp;source, const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; OperatorArgs... &gt; &amp;operator_args, Args &amp;&amp;... args) const</td></tr>
<tr class="separator:ab0143dcebb27d53e1e955343cfb2bb0f inherit pub_methods_classLinearSolver_1_1Serial_1_1LinearSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61da7e4a83f906f9ee67e85fe57581b inherit pub_methods_classLinearSolver_1_1Serial_1_1LinearSolver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearSolver_1_1Serial_1_1LinearSolver.html#af61da7e4a83f906f9ee67e85fe57581b">reset</a> ()=0</td></tr>
<tr class="memdesc:af61da7e4a83f906f9ee67e85fe57581b inherit pub_methods_classLinearSolver_1_1Serial_1_1LinearSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discard caches from previous solves. Use before solving a different linear operator.  <a href="classLinearSolver_1_1Serial_1_1LinearSolver.html#af61da7e4a83f906f9ee67e85fe57581b">More...</a><br /></td></tr>
<tr class="separator:af61da7e4a83f906f9ee67e85fe57581b inherit pub_methods_classLinearSolver_1_1Serial_1_1LinearSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a9793a75b09047e2576650747dae2f853"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespaceOptions.html#aa61c7f41f21afa7646811456f673be89">Options::String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearSolver_1_1Serial_1_1ExplicitInverse.html#a9793a75b09047e2576650747dae2f853">help</a></td></tr>
<tr class="separator:a9793a75b09047e2576650747dae2f853"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename LinearSolverRegistrars = tmpl::list&lt;Registrars::ExplicitInverse&gt;&gt;<br />
class LinearSolver::Serial::ExplicitInverse&lt; LinearSolverRegistrars &gt;</div><p >Linear solver that builds a matrix representation of the linear operator and inverts it directly. </p>
<p >This solver first constructs an explicit matrix representation by "sniffing
out" the operator, i.e. feeding it with unit vectors, and then directly inverts the matrix. The result is an operator that solves the linear problem in a single step. This means that each element has a large initialization cost, but all successive solves converge immediately.</p>
<dl class="section user"><dt>Advice on using this linear solver:</dt><dd></dd></dl>
<ul>
<li>This solver is entirely agnostic to the structure of the linear operator. It is usually better to implement a linear solver that is specialized for your linear operator to take advantage of its properties. For example, if the operator has a tensor-product structure, the linear solver might take advantage of that. Only use this solver if no alternatives are available and if you have verified that it speeds up your solves.</li>
<li>Since this linear solver stores the full inverse operator matrix it can have significant memory demands. For example, an operator representing a 3D first-order <a class="el" href="namespaceElasticity.html" title="Items related to solving elasticity problems.">Elasticity</a> system (9 variables) discretized on 12 grid points per dimension requires ca. 2GB of memory (per element) to store the matrix, scaling quadratically with the number of variables and with a power of 6 with the number of grid points per dimension. Therefore, make sure to distribute the elements on a sufficient number of nodes to meet the memory requirements.</li>
<li>This linear solver can be <code><a class="el" href="classLinearSolver_1_1Serial_1_1ExplicitInverse.html#ad8f3881739f1794b8cfda78860338d63" title="Flags the operator to require re-initialization. No memory is released. Call this function to rebuild...">reset()</a></code> when the operator changes (e.g. in each nonlinear-solver iteration). However, when using this solver as preconditioner it can be advantageous to avoid the reset and the corresponding cost of re-building the matrix and its inverse if the operator only changes "a little". In that case the preconditioner solves subdomain problems only approximately, but possibly still sufficiently to provide effective preconditioning. </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a831ef5bf75685e58a154b9e14c5c7703" name="a831ef5bf75685e58a154b9e14c5c7703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831ef5bf75685e58a154b9e14c5c7703">&#9670;&nbsp;</a></span>get_clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LinearSolverRegistrars  = tmpl::list&lt;Registrars::ExplicitInverse&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classLinearSolver_1_1Serial_1_1LinearSolver.html">Base</a> &gt; <a class="el" href="classLinearSolver_1_1Serial_1_1ExplicitInverse.html">LinearSolver::Serial::ExplicitInverse</a>&lt; LinearSolverRegistrars &gt;::get_clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classLinearSolver_1_1Serial_1_1LinearSolver.html">LinearSolver::Serial::LinearSolver&lt; tmpl::list&lt; Registrars::ExplicitInverse &gt; &gt;</a>.</p>

</div>
</div>
<a id="ad8f3881739f1794b8cfda78860338d63" name="ad8f3881739f1794b8cfda78860338d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f3881739f1794b8cfda78860338d63">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LinearSolverRegistrars  = tmpl::list&lt;Registrars::ExplicitInverse&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearSolver_1_1Serial_1_1ExplicitInverse.html">LinearSolver::Serial::ExplicitInverse</a>&lt; LinearSolverRegistrars &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flags the operator to require re-initialization. No memory is released. Call this function to rebuild the solver when the operator changed. </p>

<p>Implements <a class="el" href="classLinearSolver_1_1Serial_1_1LinearSolver.html#af61da7e4a83f906f9ee67e85fe57581b">LinearSolver::Serial::LinearSolver&lt; tmpl::list&lt; Registrars::ExplicitInverse &gt; &gt;</a>.</p>

</div>
</div>
<a id="ad178e63ea77cd3f25ddd702e18a00e69" name="ad178e63ea77cd3f25ddd702e18a00e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad178e63ea77cd3f25ddd702e18a00e69">&#9670;&nbsp;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LinearSolverRegistrars  = tmpl::list&lt;Registrars::ExplicitInverse&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename LinearOperator , typename VarsType , typename SourceType , typename... OperatorArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structConvergence_1_1HasConverged.html">Convergence::HasConverged</a> <a class="el" href="classLinearSolver_1_1Serial_1_1ExplicitInverse.html">LinearSolver::Serial::ExplicitInverse</a>&lt; LinearSolverRegistrars &gt;::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; VarsType * &gt;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LinearOperator &amp;&#160;</td>
          <td class="paramname"><em>linear_operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; OperatorArgs... &gt; &amp;&#160;</td>
          <td class="paramname"><em>operator_args</em> = <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve the equation \(Ax=b\) by explicitly constructing the operator matrix \(A\) and its inverse. The first solve is computationally expensive and successive solves are cheap. </p>
<p >Building a matrix representation of the <code>linear_operator</code> requires iterating over the <code>SourceType</code> (which is also the type returned by the <code>linear_operator</code>) in a consistent way. This can be non-trivial for heterogeneous data structures because it requires they define a data ordering. Specifically, the <code>SourceType</code> must have a <code><a class="el" href="classLinearSolver_1_1Serial_1_1ExplicitInverse.html#adc8f63889d03e8c5d5f2245165b370fb" title="Size of the operator. The stored matrix will have size^2 entries.">size()</a></code> function as well as <code>begin()</code> and <code>end()</code> iterators that point into the data. If the iterators have a <code><a class="el" href="classLinearSolver_1_1Serial_1_1ExplicitInverse.html#ad8f3881739f1794b8cfda78860338d63" title="Flags the operator to require re-initialization. No memory is released. Call this function to rebuild...">reset()</a></code> function it is used to avoid repeatedly re-creating the <code>begin()</code> iterator. The <code><a class="el" href="classLinearSolver_1_1Serial_1_1ExplicitInverse.html#ad8f3881739f1794b8cfda78860338d63" title="Flags the operator to require re-initialization. No memory is released. Call this function to rebuild...">reset()</a></code> function must not invalidate the <code>end()</code> iterator. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9793a75b09047e2576650747dae2f853" name="a9793a75b09047e2576650747dae2f853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9793a75b09047e2576650747dae2f853">&#9670;&nbsp;</a></span>help</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LinearSolverRegistrars  = tmpl::list&lt;Registrars::ExplicitInverse&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceOptions.html#aa61c7f41f21afa7646811456f673be89">Options::String</a> <a class="el" href="classLinearSolver_1_1Serial_1_1ExplicitInverse.html">LinearSolver::Serial::ExplicitInverse</a>&lt; LinearSolverRegistrars &gt;::help</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      <span class="stringliteral">&quot;Build a matrix representation of the linear operator and invert it &quot;</span></div>
<div class="line">      <span class="stringliteral">&quot;directly. This means that the first solve has a large initialization &quot;</span></div>
<div class="line">      <span class="stringliteral">&quot;cost, but all subsequent solves converge immediately.&quot;</span></div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/NumericalAlgorithms/LinearSolver/ExplicitInverse.hpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceLinearSolver.html">LinearSolver</a></li><li class="navelem"><b>Serial</b></li><li class="navelem"><a class="el" href="classLinearSolver_1_1Serial_1_1ExplicitInverse.html">ExplicitInverse</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
