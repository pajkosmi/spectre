<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: domain::BlockZCurveProcDistribution&lt; Dim &gt; Struct Template Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
  </script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2023.06.19</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structdomain_1_1BlockZCurveProcDistribution.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structdomain_1_1BlockZCurveProcDistribution-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">domain::BlockZCurveProcDistribution&lt; Dim &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Distribution strategy for assigning elements to CPUs using a Morton ('Z-order') space-filling curve to determine placement within each block, where <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code>s are distributed across CPUs.  
 <a href="structdomain_1_1BlockZCurveProcDistribution.html#details">More...</a></p>

<p><code>#include &lt;ElementDistribution.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a31cd5c05d0ade6287b40f968e575f660"><td class="memItemLeft" align="right" valign="top"><a id="a31cd5c05d0ade6287b40f968e575f660" name="a31cd5c05d0ade6287b40f968e575f660"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BlockZCurveProcDistribution</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt;, double &gt; &amp;element_costs, size_t number_of_procs_with_elements, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classBlock.html">Block</a>&lt; Dim &gt; &gt; &amp;blocks, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, Dim &gt; &gt; &amp;initial_refinement_levels, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, Dim &gt; &gt; &amp;initial_extents, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; size_t &gt; &amp;global_procs_to_ignore={})</td></tr>
<tr class="memdesc:a31cd5c05d0ade6287b40f968e575f660"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>number_of_procs_with_elements</code> argument represents how many procs will have elements. This is not necessarily equal to the total number of procs because some global procs may be ignored by the sixth argument <code>global_procs_to_ignore</code>. <br /></td></tr>
<tr class="separator:a31cd5c05d0ade6287b40f968e575f660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d2b7cb2d96a103a17a80673a726021"><td class="memItemLeft" align="right" valign="top"><a id="aa8d2b7cb2d96a103a17a80673a726021" name="aa8d2b7cb2d96a103a17a80673a726021"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_proc_for_element</b> (const <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &amp;element_id) const</td></tr>
<tr class="memdesc:aa8d2b7cb2d96a103a17a80673a726021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the suggested processor number for a particular <code><a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a></code>, determined by the Morton curve weighted element assignment described in detail in the parent class documentation. <br /></td></tr>
<tr class="separator:aa8d2b7cb2d96a103a17a80673a726021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d09d5c6cfc125a65366a5d8ce885715"><td class="memItemLeft" align="right" valign="top"><a id="a5d09d5c6cfc125a65366a5d8ce885715" name="a5d09d5c6cfc125a65366a5d8ce885715"></a>
const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; size_t, size_t &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>block_element_distribution</b> () const</td></tr>
<tr class="separator:a5d09d5c6cfc125a65366a5d8ce885715"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;size_t Dim&gt;<br />
struct domain::BlockZCurveProcDistribution&lt; Dim &gt;</div><p >Distribution strategy for assigning elements to CPUs using a Morton ('Z-order') space-filling curve to determine placement within each block, where <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code>s are distributed across CPUs. </p>
<h3>Details</h3>
<p >The element distribution attempts to assign a balanced total computational cost to each processor that is allowed to have <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code>s. First, each <code><a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a></code>'s <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code>s are ordered by their Z-curve index (see more below). <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code>s are traversed in this order and assigned to CPUs in order, moving onto the next CPU once the target cost per CPU is met. The target cost per CPU is defined as the remaining cost to distribute divided by the remaining number of CPUs to distribute to. This is an important distinction from simply having one constant target cost per CPU defined as the total cost divided by the total number of CPUs with elements. Since the total cost of <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code>s on a processor will nearly never add up to be exactly the average cost per CPU, this means that we would either have to decide to overshoot or undershoot the average as we iterate over the CPUs and assign <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code>s. If we overshoot the average on each processor, the final processor could have a much lower cost than the rest of the processors and we run the risk of overshooting so much that one or more of the requested processors don't get assigned any <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code>s at all. If we undershoot the average on each processor, the final processor could have a much higher cost than the others due to remainder cost piling up. This algorithm avoids these risks by instead adjusting the target cost per CPU as we finish assigning cost to previous CPUs.</p>
<p >Morton curves are a simple and easily-computed space-filling curve that (unlike Hilbert curves) permit diagonal traversal. See, for instance, <a class="el" href="citelist.html#CITEREF_Borrell2018">[138]</a> for a discussion of mesh partitioning using space-filling curves. A concrete example of the use of a Morton curve in 2d is given below.</p>
<p >A sketch of a 2D block with 4x2 elements, with each element labeled according to the order on the Morton curve: </p><div class="fragment"><div class="line">        x--&gt;</div>
<div class="line">        0   1   2   3</div>
<div class="line">      ----------------</div>
<div class="line">y  0 |  0   2   4   6</div>
<div class="line">|    |  | / | / | / |</div>
<div class="line">v  1 |  1   3   5   7</div>
</div><!-- fragment --><p> (forming a zig-zag path, that under some rotation/reflection has a 'Z' shape).</p>
<p >The Morton curve method is a quick way of getting acceptable spatial locality &ndash; usually, for approximately even distributions, it will ensure that elements are assigned in large volume chunks, and the structure of the Morton curve ensures that for a given processor and block, the elements will be assigned in no more than two orthogonally connected clusters. In principle, a Hilbert curve could potentially improve upon the gains obtained by this class by guaranteeing that all elements within each block form a single orthogonally connected cluster.</p>
<p >The assignment of portions of blocks to processors may use partial blocks, and/or multiple blocks to ensure an even distribution of elements to processors. We currently make no distinction between dividing elements between processors within a node and dividing elements between processors across nodes. The current technique aims to have a simple method of reducing communication globally, though it would likely be more efficient to prioritize minimization of inter-node communication, because communication across interconnects is the primary cost of communication in charm++ runs.</p>
<dl class="section warning"><dt>Warning</dt><dd>The use of the Morton curve to generate a well-clustered element distribution currently assumes that the refinement is uniform over each block, with no internal structure that would be generated by, for instance AMR. This distribution method will need alteration to perform well for blocks with internal structure from h-refinement. Morton curves can be defined recursively, so a generalization of the present method is possible for blocks with internal refinement</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Dim</td><td>the number of spatial dimensions of the <code><a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a></code>s </td></tr>
  </table>
  </dd>
</dl>
</div><hr/>The documentation for this struct was generated from the following file:<ul>
<li>src/Domain/ElementDistribution.hpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedomain.html">domain</a></li><li class="navelem"><a class="el" href="structdomain_1_1BlockZCurveProcDistribution.html">BlockZCurveProcDistribution</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2023
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
